	TITLE	Z:\XashXTSRC\server\doors.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09ILCN@CBaseDoor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JMNH@m_bHealthValue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JIIB@healthvalue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MFAH@m_iMoveSnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HPHJ@movesnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LAAP@m_iStopSnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KHB@stopsnd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LGJC@m_iLockedSound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DKII@locked_sound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@NOBM@m_bLockedSentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJOH@locked_sentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HEFN@m_iUnlockedSound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@BKDI@unlocked_sound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@LOMA@m_bUnlockedSentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBHD@unlocked_sentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@OFG@m_iChainTarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GDMF@chaintarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@ICBK@m_bDoorGroup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PFID@DoorTouch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KCMH@DoorGoUp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NBIL@DoorGoDown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HDCA@DoorHitTop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HLMI@DoorHitBottom?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HMCI@func_door?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LCFM@func_water?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DLCL@WaveHeight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMFL@doors?1doormove1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMDE@doors?1doormove2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MBB@doors?1doormove3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GMOL@doors?1doormove4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MMMO@doors?1doormove5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CMKB@doors?1doormove6?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IMIE@doors?1doormove7?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@ONFE@doors?1doormove8?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@ENHB@doors?1doormove9?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@EEJ@doors?1doormove10?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGIG@doors?1doorstop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CGOJ@doors?1doorstop2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGMM@doors?1doorstop3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGDG@doors?1doorstop4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@EGBD@doors?1doorstop5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGHM@doors?1doorstop6?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GFJ@doors?1doorstop7?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GHIJ@doors?1doorstop8?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GHFJ@NA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GHJC@ND?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DCLM@NF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EMJD@NFIRE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PBNL@NCHEM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BCIH@NRAD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KCMG@NCON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JJHG@NH?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JICL@NG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02OJPC@EA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02OJDJ@ED?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02LMBH@EF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KNNG@EFIRE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BAJO@ECHEM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04FHOB@ERAD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OHKA@ECON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BHNN@EH?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@FOMB@door?5start?1end?5positions?5are?5equ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@BFEG@m_vecPosition1?5?$CB?$DN?5m_vecPosition2@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MJCP@c2a5e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04EAAN@?$CK103?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Spawn@CBaseDoor@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@GILE@Door?5group?5?$CFs?5has?5misaligned?5ori@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@FEHP@m_iState?5?$DN?$DN?5STATE_OFF?5?$HM?$HM?5m_iStat@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorGoUp@CBaseDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@NO@m_iState?5?$DN?$DN?5STATE_TURN_ON?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorHitTop@CBaseDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DC@DIAC@m_iState?5?$DN?$DN?5STATE_ON?5?$HM?$HM?5m_iState@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorGoDown@CBaseDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BL@KAOG@m_iState?5?$DN?$DN?5STATE_TURN_OFF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorHitBottom@CBaseDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@DIJK@func_door_rotating?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@FPJH@rotating?5door?5start?1end?5position@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@GFCE@m_vecAngle1?5?$CB?$DN?5m_vecAngle2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Spawn@CRotDoor@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@GFNB@momentary_door?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PNBF@CMomentaryDoor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JEAE@StopMoveSound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MGNF@func_traindoor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@CAAP@CBaseTrainDoor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MHPH@m_vecOldAngles?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EOHE@door_state?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CPLD@m_pTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GBDP@m_vecPosition1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JOIG@m_vecPosition2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@DEBB@m_vecPosition3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JEL@FindTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JKCM@DoorSlideUp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HKBE@DoorSlideDown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DMOF@DoorSlideWait?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CNO@ActivateTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HLPG@train?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@LPID@?$CGCBaseTrainDoor?5?3?3?5FindTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@IJPN@?$CGCBaseTrainDoor?3?3?5DoorGoDown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@HCHE@?$CGCBaseTrainDoor?3?3?5DoorSlideUp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MEKD@door_state?5?$DN?$DN?5TD_CLOSED?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@GJHF@?$CGCBaseTrainDoor?3?3?5DoorSlideWait?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorGoUp@CBaseTrainDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@CLFG@?$CGCBaseTrainDoor?3?3?5DoorHitTop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@LHGM@door_state?5?$DN?$DN?5TD_SLIDING_UP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorHitTop@CBaseTrainDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HHGP@door_state?5?$DN?$DN?5TD_OPENED?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorSlideDown@CBaseTrainDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@EKAB@door_state?5?$DN?$DN?5TD_SLIDING_DOWN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@COFI@?$CGCBaseTrainDoor?3?3?5DoorHitBottom?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorGoDown@CBaseTrainDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@BEEH@door_state?5?$DN?$DN?5TD_SHIFT_DOWN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??DoorHitBottom@CBaseTrainDoor@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Cross@Vector@@QBE?AV1@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProductAbs@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetChaining@CBaseEntity@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTrainDoor@CFuncTrackTrain@@QAEXPAVCBaseTrainDoor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseTrainDoor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDoorControl@CBaseTrainDoor@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseDoor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRotatingDoor@CBaseDoor@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDoor@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBaseDoor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBaseDoor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E25
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseDoor@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseDoor@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChainUse@CBaseDoor@@QAEXW4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChainTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorActivate@CBaseDoor@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorGoUp@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorHitTop@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorGoDown@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorHitBottom@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDoorMovementGroup@CBaseDoor@@QAEHQAPAV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseDoor@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRotatingDoor@CRotDoor@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CRotDoor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CRotDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CRotDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CRotDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CRotDoor@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CMomentaryDoor@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CMomentaryDoor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CMomentaryDoor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CMomentaryDoor@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CMomentaryDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CMomentaryDoor@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopMoveSound@CMomentaryDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBaseTrainDoor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBaseTrainDoor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseTrainDoor@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseTrainDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindTrain@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseTrainDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseTrainDoor@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseTrainDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseTrainDoor@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActivateTrain@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorSlideWait@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorGoUp@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorSlideUp@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorHitTop@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorSlideDown@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorGoDown@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoorHitBottom@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseTrainDoor@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCBaseDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCBaseDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCBaseDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCBaseDoor@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCRotDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCRotDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCRotDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCRotDoor@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCMomentaryDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCMomentaryDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCMomentaryDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCMomentaryDoor@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCBaseTrainDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCBaseTrainDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCBaseTrainDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCBaseTrainDoor@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDoor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRotDoor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMomentaryDoor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseTrainDoor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDoor@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CEntityFactory@VCBaseDoor@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseTrainDoor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCMomentaryDoor@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDoor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMomentaryDoor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRotDoor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCRotDoor@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCBaseTrainDoor@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A	; CMomentaryDoor::m_DataMap
PUBLIC	??_C@_0P@PNBF@CMomentaryDoor?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CMomentaryDoor_DataDescInit@@3PAUdatamap_s@@A ; CMomentaryDoor_DataDescInit::g_DataMapHolder
PUBLIC	?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A	; CBaseTrainDoor::m_DataMap
PUBLIC	??_C@_0P@CAAP@CBaseTrainDoor?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CBaseTrainDoor_DataDescInit@@3PAUdatamap_s@@A ; CBaseTrainDoor_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0P@MHPH@m_vecOldAngles?$AA@		; `string'
PUBLIC	??_C@_0L@EOHE@door_state?$AA@			; `string'
PUBLIC	??_C@_08CPLD@m_pTrain?$AA@			; `string'
PUBLIC	??_C@_0P@GBDP@m_vecPosition1?$AA@		; `string'
PUBLIC	??_C@_0P@JOIG@m_vecPosition2?$AA@		; `string'
PUBLIC	??_C@_0P@DEBB@m_vecPosition3?$AA@		; `string'
PUBLIC	?m_DataMap@CBaseDoor@@2Udatamap_s@@A		; CBaseDoor::m_DataMap
PUBLIC	??_C@_09ILCN@CBaseDoor?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CBaseDoor_DataDescInit@@3PAUdatamap_s@@A ; CBaseDoor_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0P@JMNH@m_bHealthValue?$AA@		; `string'
PUBLIC	??_C@_0M@JIIB@healthvalue?$AA@			; `string'
PUBLIC	??_C@_0L@MFAH@m_iMoveSnd?$AA@			; `string'
PUBLIC	??_C@_07HPHJ@movesnd?$AA@			; `string'
PUBLIC	??_C@_0L@LAAP@m_iStopSnd?$AA@			; `string'
PUBLIC	??_C@_07KHB@stopsnd?$AA@			; `string'
PUBLIC	??_C@_0P@LGJC@m_iLockedSound?$AA@		; `string'
PUBLIC	??_C@_0N@DKII@locked_sound?$AA@			; `string'
PUBLIC	??_C@_0BC@NOBM@m_bLockedSentence?$AA@		; `string'
PUBLIC	??_C@_0BA@BJOH@locked_sentence?$AA@		; `string'
PUBLIC	??_C@_0BB@HEFN@m_iUnlockedSound?$AA@		; `string'
PUBLIC	??_C@_0P@BKDI@unlocked_sound?$AA@		; `string'
PUBLIC	??_C@_0BE@LOMA@m_bUnlockedSentence?$AA@		; `string'
PUBLIC	??_C@_0BC@HBHD@unlocked_sentence?$AA@		; `string'
PUBLIC	??_C@_0P@OFG@m_iChainTarget?$AA@		; `string'
PUBLIC	??_C@_0M@GDMF@chaintarget?$AA@			; `string'
PUBLIC	??_C@_0N@ICBK@m_bDoorGroup?$AA@			; `string'
_BSS	SEGMENT
?g_DataMapHolder@CMomentaryDoor_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CMomentaryDoor_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CBaseTrainDoor_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBaseTrainDoor_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CBaseDoor_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBaseDoor_DataDescInit::g_DataMapHolder
_BSS	ENDS
_DATA	SEGMENT
?m_DataMap@CBaseDoor@@2Udatamap_s@@A DD 00H		; CBaseDoor::m_DataMap
	DD	00H
	DD	FLAT:??_C@_09ILCN@CBaseDoor?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S27	DD	FLAT:_$E26
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_0P@JMNH@m_bHealthValue?$AA@
	DD	07a4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@JIIB@healthvalue?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@MFAH@m_iMoveSnd?$AA@
	DD	07a8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07HPHJ@movesnd?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@LAAP@m_iStopSnd?$AA@
	DD	07acH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07KHB@stopsnd?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0P@LGJC@m_iLockedSound?$AA@
	DD	07d4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0N@DKII@locked_sound?$AA@
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_0BC@NOBM@m_bLockedSentence?$AA@
	DD	07d8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BA@BJOH@locked_sentence?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BB@HEFN@m_iUnlockedSound?$AA@
	DD	07dcH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0P@BKDI@unlocked_sound?$AA@
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_0BE@LOMA@m_bUnlockedSentence?$AA@
	DD	07e0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BC@HBHD@unlocked_sentence?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0P@OFG@m_iChainTarget?$AA@
	DD	07e4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@GDMF@chaintarget?$AA@
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0N@ICBK@m_bDoorGroup?$AA@
	DD	07e8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+116
_DATA	ENDS
CRT$XCU	SEGMENT
_$S32	DD	FLAT:_$E31
_$S35	DD	FLAT:_$E34
_$S38	DD	FLAT:_$E37
_$S42	DD	FLAT:_$E41
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A DD 00H	; CMomentaryDoor::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0P@PNBF@CMomentaryDoor?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S45	DD	FLAT:_$E44
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@MFAH@m_iMoveSnd?$AA@
	DD	07a4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07HPHJ@movesnd?$AA@
	DD	00H
	DD	012H
	ORG $+20
_DATA	ENDS
CRT$XCU	SEGMENT
_$S50	DD	FLAT:_$E49
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A DD 00H	; CBaseTrainDoor::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0P@CAAP@CBaseTrainDoor?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S53	DD	FLAT:_$E52
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@MFAH@m_iMoveSnd?$AA@
	DD	07a4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07HPHJ@movesnd?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@LAAP@m_iStopSnd?$AA@
	DD	07a8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07KHB@stopsnd?$AA@
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0P@MHPH@m_vecOldAngles?$AA@
	DD	07b0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_0L@EOHE@door_state?$AA@
	DD	07bcH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_08CPLD@m_pTrain?$AA@
	DD	07acH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0P@GBDP@m_vecPosition1?$AA@
	DD	0730H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0P@JOIG@m_vecPosition2?$AA@
	DD	073cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0P@DEBB@m_vecPosition3?$AA@
	DD	0748H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+212
_DATA	ENDS
;	COMDAT ??_C@_09ILCN@CBaseDoor?$AA@
CONST	SEGMENT
??_C@_09ILCN@CBaseDoor?$AA@ DB 'CBaseDoor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JMNH@m_bHealthValue?$AA@
CONST	SEGMENT
??_C@_0P@JMNH@m_bHealthValue?$AA@ DB 'm_bHealthValue', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JIIB@healthvalue?$AA@
CONST	SEGMENT
??_C@_0M@JIIB@healthvalue?$AA@ DB 'healthvalue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MFAH@m_iMoveSnd?$AA@
CONST	SEGMENT
??_C@_0L@MFAH@m_iMoveSnd?$AA@ DB 'm_iMoveSnd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HPHJ@movesnd?$AA@
CONST	SEGMENT
??_C@_07HPHJ@movesnd?$AA@ DB 'movesnd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LAAP@m_iStopSnd?$AA@
CONST	SEGMENT
??_C@_0L@LAAP@m_iStopSnd?$AA@ DB 'm_iStopSnd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KHB@stopsnd?$AA@
CONST	SEGMENT
??_C@_07KHB@stopsnd?$AA@ DB 'stopsnd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LGJC@m_iLockedSound?$AA@
CONST	SEGMENT
??_C@_0P@LGJC@m_iLockedSound?$AA@ DB 'm_iLockedSound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DKII@locked_sound?$AA@
CONST	SEGMENT
??_C@_0N@DKII@locked_sound?$AA@ DB 'locked_sound', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NOBM@m_bLockedSentence?$AA@
CONST	SEGMENT
??_C@_0BC@NOBM@m_bLockedSentence?$AA@ DB 'm_bLockedSentence', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJOH@locked_sentence?$AA@
CONST	SEGMENT
??_C@_0BA@BJOH@locked_sentence?$AA@ DB 'locked_sentence', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HEFN@m_iUnlockedSound?$AA@
CONST	SEGMENT
??_C@_0BB@HEFN@m_iUnlockedSound?$AA@ DB 'm_iUnlockedSound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BKDI@unlocked_sound?$AA@
CONST	SEGMENT
??_C@_0P@BKDI@unlocked_sound?$AA@ DB 'unlocked_sound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LOMA@m_bUnlockedSentence?$AA@
CONST	SEGMENT
??_C@_0BE@LOMA@m_bUnlockedSentence?$AA@ DB 'm_bUnlockedSentence', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBHD@unlocked_sentence?$AA@
CONST	SEGMENT
??_C@_0BC@HBHD@unlocked_sentence?$AA@ DB 'unlocked_sentence', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OFG@m_iChainTarget?$AA@
CONST	SEGMENT
??_C@_0P@OFG@m_iChainTarget?$AA@ DB 'm_iChainTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GDMF@chaintarget?$AA@
CONST	SEGMENT
??_C@_0M@GDMF@chaintarget?$AA@ DB 'chaintarget', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ICBK@m_bDoorGroup?$AA@
CONST	SEGMENT
??_C@_0N@ICBK@m_bDoorGroup?$AA@ DB 'm_bDoorGroup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PNBF@CMomentaryDoor?$AA@
CONST	SEGMENT
??_C@_0P@PNBF@CMomentaryDoor?$AA@ DB 'CMomentaryDoor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CAAP@CBaseTrainDoor?$AA@
CONST	SEGMENT
??_C@_0P@CAAP@CBaseTrainDoor?$AA@ DB 'CBaseTrainDoor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHPH@m_vecOldAngles?$AA@
CONST	SEGMENT
??_C@_0P@MHPH@m_vecOldAngles?$AA@ DB 'm_vecOldAngles', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EOHE@door_state?$AA@
CONST	SEGMENT
??_C@_0L@EOHE@door_state?$AA@ DB 'door_state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPLD@m_pTrain?$AA@
CONST	SEGMENT
??_C@_08CPLD@m_pTrain?$AA@ DB 'm_pTrain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GBDP@m_vecPosition1?$AA@
CONST	SEGMENT
??_C@_0P@GBDP@m_vecPosition1?$AA@ DB 'm_vecPosition1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JOIG@m_vecPosition2?$AA@
CONST	SEGMENT
??_C@_0P@JOIG@m_vecPosition2?$AA@ DB 'm_vecPosition2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DEBB@m_vecPosition3?$AA@
CONST	SEGMENT
??_C@_0P@DEBB@m_vecPosition3?$AA@ DB 'm_vecPosition3', 00H ; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBaseDoor@@UAEPAUdatamap_s@@XZ	; CBaseDoor::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBaseDoor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBaseDoor@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBaseDoor::GetDataDescMap, COMDAT

; 78   : BEGIN_DATADESC( CBaseDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseDoor@@2Udatamap_s@@A ; CBaseDoor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBaseDoor@@UAEPAUdatamap_s@@XZ ENDP	; CBaseDoor::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CBaseDoor@@SAPAUdatamap_s@@XZ	; CBaseDoor::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CBaseDoor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBaseDoor@@SAPAUdatamap_s@@XZ PROC NEAR	; CBaseDoor::GetBaseMap, COMDAT

; 78   : BEGIN_DATADESC( CBaseDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBaseDoor@@SAPAUdatamap_s@@XZ ENDP		; CBaseDoor::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT
_$E26	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E25
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E26	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z	; DataMapInit
;	COMDAT _$E25
_TEXT	SEGMENT
_$E25	PROC NEAR					; COMDAT

; 78   : BEGIN_DATADESC( CBaseDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBaseDoor_DataDescInit@@3PAUdatamap_s@@A, eax ; CBaseDoor_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E25	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	?DoorGoUp@CBaseDoor@@QAEXXZ			; CBaseDoor::DoorGoUp
PUBLIC	?DoorGoDown@CBaseDoor@@QAEXXZ			; CBaseDoor::DoorGoDown
PUBLIC	?DoorHitTop@CBaseDoor@@QAEXXZ			; CBaseDoor::DoorHitTop
PUBLIC	?DoorHitBottom@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorHitBottom
PUBLIC	?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z	; CBaseDoor::DoorTouch
PUBLIC	??_C@_09PFID@DoorTouch?$AA@			; `string'
PUBLIC	??_C@_08KCMH@DoorGoUp?$AA@			; `string'
PUBLIC	??_C@_0L@NBIL@DoorGoDown?$AA@			; `string'
PUBLIC	??_C@_0L@HDCA@DoorHitTop?$AA@			; `string'
PUBLIC	??_C@_0O@HLMI@DoorHitBottom?$AA@		; `string'
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09PFID@DoorTouch?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_09PFID@DoorTouch?$AA@ DB 'DoorTouch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KCMH@DoorGoUp?$AA@
CONST	SEGMENT
??_C@_08KCMH@DoorGoUp?$AA@ DB 'DoorGoUp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NBIL@DoorGoDown?$AA@
CONST	SEGMENT
??_C@_0L@NBIL@DoorGoDown?$AA@ DB 'DoorGoDown', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDCA@DoorHitTop?$AA@
CONST	SEGMENT
??_C@_0L@HDCA@DoorHitTop?$AA@ DB 'DoorHitTop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HLMI@DoorHitBottom?$AA@
CONST	SEGMENT
??_C@_0O@HLMI@DoorHitBottom?$AA@ DB 'DoorHitBottom', 00H ; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z PROC NEAR ; DataMapInit, COMDAT

; 78   : BEGIN_DATADESC( CBaseDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37335
	mov	cl, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_09ILCN@CBaseDoor?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E29
	call	_atexit
	add	esp, 4
$L37335:
	call	?GetBaseMap@CBaseDoor@@SAPAUdatamap_s@@XZ ; CBaseDoor::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBaseDoor@@2Udatamap_s@@A+12, eax

; 79   : 	DEFINE_KEYFIELD( m_bHealthValue, FIELD_CHARACTER, "healthvalue" ),
; 80   : 	DEFINE_KEYFIELD( m_iMoveSnd, FIELD_STRING, "movesnd" ),
; 81   : 	DEFINE_KEYFIELD( m_iStopSnd, FIELD_STRING, "stopsnd" ),
; 82   : 	DEFINE_KEYFIELD( m_iLockedSound, FIELD_STRING, "locked_sound" ),
; 83   : 	DEFINE_KEYFIELD( m_bLockedSentence, FIELD_CHARACTER, "locked_sentence" ),
; 84   : 	DEFINE_KEYFIELD( m_iUnlockedSound, FIELD_STRING, "unlocked_sound" ),	
; 85   : 	DEFINE_KEYFIELD( m_bUnlockedSentence, FIELD_CHARACTER, "unlocked_sentence" ),	
; 86   : 	DEFINE_KEYFIELD( m_iChainTarget, FIELD_STRING, "chaintarget" ),
; 87   : 	DEFINE_FIELD( m_bDoorGroup, FIELD_BOOLEAN ),
; 88   : 	DEFINE_FUNCTION( DoorTouch ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L37374
	mov	al, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_09PFID@DoorTouch?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+244, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+248, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+252, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+254, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+256, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+260, OFFSET FLAT:?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ; CBaseDoor::DoorTouch

; 89   : 	DEFINE_FUNCTION( DoorGoUp ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+264, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_08KCMH@DoorGoUp?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+268, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+272, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+276, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+278, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+280, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+284, OFFSET FLAT:?DoorGoUp@CBaseDoor@@QAEXXZ ; CBaseDoor::DoorGoUp

; 90   : 	DEFINE_FUNCTION( DoorGoDown ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+288, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0L@NBIL@DoorGoDown?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+292, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+296, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+300, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+302, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+304, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+308, OFFSET FLAT:?DoorGoDown@CBaseDoor@@QAEXXZ ; CBaseDoor::DoorGoDown

; 91   : 	DEFINE_FUNCTION( DoorHitTop ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+312, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0L@HDCA@DoorHitTop?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+316, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+320, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+324, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+326, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+328, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+332, OFFSET FLAT:?DoorHitTop@CBaseDoor@@QAEXXZ ; CBaseDoor::DoorHitTop

; 92   : 	DEFINE_FUNCTION( DoorHitBottom ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+336, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0O@HLMI@DoorHitBottom?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+340, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+344, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+348, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+350, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+352, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+356, OFFSET FLAT:?DoorHitBottom@CBaseDoor@@QAEXXZ ; CBaseDoor::DoorHitBottom
$L37374:

; 93   : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L37390
	mov	DWORD PTR ?m_DataMap@CBaseDoor@@2Udatamap_s@@A+4, 14 ; 0000000eH
	mov	DWORD PTR ?m_DataMap@CBaseDoor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37391
$L37390:
	mov	DWORD PTR ?m_DataMap@CBaseDoor@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBaseDoor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4PAUtypedescription_s@@A
$L37391:
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseDoor@@2Udatamap_s@@A ; CBaseDoor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
$T39292 = -12
_this$ = -4
_pBuf$ = -8
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39292[ebp], eax
	mov	ecx, DWORD PTR $T39292[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E29
_TEXT	SEGMENT
_$E29	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E29	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T39297 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T39297[ebp], edx
	mov	eax, DWORD PTR $T39297[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E31
_TEXT	SEGMENT
_$E31	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E30
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E31	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCBaseDoor@@@@QAE@PBD@Z	; CEntityFactory<CBaseDoor>::CEntityFactory<CBaseDoor>
PUBLIC	??_C@_09HMCI@func_door?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_func_door DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09HMCI@func_door?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_09HMCI@func_door?$AA@ DB 'func_door', 00H		; `string'
CONST	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT
_$E30	PROC NEAR					; COMDAT

; 95   : LINK_ENTITY_TO_CLASS( func_door, CBaseDoor );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_09HMCI@func_door?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_func_door
	call	??0?$CEntityFactory@VCBaseDoor@@@@QAE@PBD@Z ; CEntityFactory<CBaseDoor>::CEntityFactory<CBaseDoor>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E30	ENDP
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT
_$E34	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E33
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E34	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LCFM@func_water?$AA@			; `string'
_BSS	SEGMENT
_func_water DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@LCFM@func_water?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0L@LCFM@func_water?$AA@ DB 'func_water', 00H	; `string'
CONST	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT
_$E33	PROC NEAR					; COMDAT

; 96   : LINK_ENTITY_TO_CLASS( func_water, CBaseDoor );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0L@LCFM@func_water?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_water
	call	??0?$CEntityFactory@VCBaseDoor@@@@QAE@PBD@Z ; CEntityFactory<CBaseDoor>::CEntityFactory<CBaseDoor>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E33	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CBaseDoor@@UAEXPAUKeyValueData_s@@@Z	; CBaseDoor::KeyValue
PUBLIC	__real@4@3ffc8000000000000000
PUBLIC	??_C@_0L@DLCL@WaveHeight?$AA@			; `string'
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
EXTRN	?Q_atof@@YAMPBD@Z:NEAR				; Q_atof
EXTRN	__fltused:NEAR
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseToggle::KeyValue
;	COMDAT ??_C@_0L@DLCL@WaveHeight?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0L@DLCL@WaveHeight?$AA@ DB 'WaveHeight', 00H	; `string'
CONST	ENDS
;	COMDAT __real@4@3ffc8000000000000000
CONST	SEGMENT
__real@4@3ffc8000000000000000 DD 03e000000r	; 0.125
CONST	ENDS
;	COMDAT ?KeyValue@CBaseDoor@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CBaseDoor@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseDoor::KeyValue, COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 	if( FStrEq( pkvd->szKeyName, "movesnd" ))

	push	OFFSET FLAT:??_C@_07HPHJ@movesnd?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37429

; 102  : 		m_iMoveSnd = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1960], eax

; 103  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 105  : 	else if( FStrEq( pkvd->szKeyName, "stopsnd" ))

	jmp	$L37447
$L37429:
	push	OFFSET FLAT:??_C@_07KHB@stopsnd?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37431

; 107  : 		m_iStopSnd = ALLOC_STRING(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1964], eax

; 108  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 110  : 	else if( FStrEq( pkvd->szKeyName, "healthvalue" ))

	jmp	$L37447
$L37431:
	push	OFFSET FLAT:??_C@_0M@JIIB@healthvalue?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37433

; 112  : 		m_bHealthValue = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1956], al

; 113  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 115  : 	else if( FStrEq( pkvd->szKeyName, "locked_sound" ))

	jmp	$L37447
$L37433:
	push	OFFSET FLAT:??_C@_0N@DKII@locked_sound?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37435

; 117  : 		m_iLockedSound = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2004], eax

; 118  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 120  : 	else if( FStrEq( pkvd->szKeyName, "locked_sentence" ))

	jmp	$L37447
$L37435:
	push	OFFSET FLAT:??_C@_0BA@BJOH@locked_sentence?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37437

; 122  : 		m_bLockedSentence = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+2008], al

; 123  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 125  : 	else if( FStrEq( pkvd->szKeyName, "unlocked_sound" ))

	jmp	$L37447
$L37437:
	push	OFFSET FLAT:??_C@_0P@BKDI@unlocked_sound?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37439

; 127  : 		m_iUnlockedSound = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2012], eax

; 128  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 130  : 	else if( FStrEq( pkvd->szKeyName, "unlocked_sentence" ))

	jmp	$L37447
$L37439:
	push	OFFSET FLAT:??_C@_0BC@HBHD@unlocked_sentence?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37441

; 132  : 		m_bUnlockedSentence = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+2016], al

; 133  : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 135  : 	else if( FStrEq( pkvd->szKeyName, "WaveHeight" ))

	jmp	$L37447
$L37441:
	push	OFFSET FLAT:??_C@_0L@DLCL@WaveHeight?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37443

; 137  : 		pev->scale = Q_atof( pkvd->szValue ) * (1.0f / 8.0f);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atof@@YAMPBD@Z			; Q_atof
	add	esp, 4
	fmul	DWORD PTR __real@4@3ffc8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+324]

; 138  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 140  : 	else if( FStrEq( pkvd->szKeyName, "chaintarget" ))

	jmp	SHORT $L37447
$L37443:
	push	OFFSET FLAT:??_C@_0M@GDMF@chaintarget?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37446

; 142  : 		m_iChainTarget = ALLOC_STRING( pkvd->szValue );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2020], eax

; 143  : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 145  : 	else BaseClass :: KeyValue( pkvd );

	jmp	SHORT $L37447
$L37446:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z ; CBaseToggle::KeyValue
$L37447:

; 146  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseDoor@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseDoor::KeyValue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?Precache@CBaseDoor@@UAEXXZ			; CBaseDoor::Precache
PUBLIC	??_C@_0BE@EMFL@doors?1doormove1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@KMDE@doors?1doormove2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@MBB@doors?1doormove3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GMOL@doors?1doormove4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@MMMO@doors?1doormove5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@CMKB@doors?1doormove6?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IMIE@doors?1doormove7?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@ONFE@doors?1doormove8?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@ENHB@doors?1doormove9?4wav?$AA@	; `string'
PUBLIC	??_C@_0BF@EEJ@doors?1doormove10?4wav?$AA@	; `string'
PUBLIC	??_C@_0BA@LNFJ@common?1null?4wav?$AA@		; `string'
PUBLIC	??_C@_0BE@MGIG@doors?1doorstop1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@CGOJ@doors?1doorstop2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IGMM@doors?1doorstop3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@OGDG@doors?1doorstop4?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@EGBD@doors?1doorstop5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@KGHM@doors?1doorstop6?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GFJ@doors?1doorstop7?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@GHIJ@doors?1doorstop8?4wav?$AA@	; `string'
PUBLIC	??_C@_02GHFJ@NA?$AA@				; `string'
PUBLIC	??_C@_02GHJC@ND?$AA@				; `string'
PUBLIC	??_C@_02DCLM@NF?$AA@				; `string'
PUBLIC	??_C@_05EMJD@NFIRE?$AA@				; `string'
PUBLIC	??_C@_05PBNL@NCHEM?$AA@				; `string'
PUBLIC	??_C@_04BCIH@NRAD?$AA@				; `string'
PUBLIC	??_C@_04KCMG@NCON?$AA@				; `string'
PUBLIC	??_C@_02JJHG@NH?$AA@				; `string'
PUBLIC	??_C@_02JICL@NG?$AA@				; `string'
PUBLIC	??_C@_02OJPC@EA?$AA@				; `string'
PUBLIC	??_C@_02OJDJ@ED?$AA@				; `string'
PUBLIC	??_C@_02LMBH@EF?$AA@				; `string'
PUBLIC	??_C@_05KNNG@EFIRE?$AA@				; `string'
PUBLIC	??_C@_05BAJO@ECHEM?$AA@				; `string'
PUBLIC	??_C@_04FHOB@ERAD?$AA@				; `string'
PUBLIC	??_C@_04OHKA@ECON?$AA@				; `string'
PUBLIC	??_C@_02BHNN@EH?$AA@				; `string'
EXTRN	?UTIL_PrecacheSound@@YAHPBD@Z:NEAR		; UTIL_PrecacheSound
EXTRN	?UTIL_PrecacheSound@@YAHH@Z:NEAR		; UTIL_PrecacheSound
EXTRN	?UTIL_LoadSoundPreset@@YAHH@Z:NEAR		; UTIL_LoadSoundPreset
EXTRN	?UTIL_ButtonSound@@YAPBDH@Z:NEAR		; UTIL_ButtonSound
;	COMDAT ??_C@_0BE@EMFL@doors?1doormove1?4wav?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0BE@EMFL@doors?1doormove1?4wav?$AA@ DB 'doors/doormove1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMDE@doors?1doormove2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@KMDE@doors?1doormove2?4wav?$AA@ DB 'doors/doormove2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MBB@doors?1doormove3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MBB@doors?1doormove3?4wav?$AA@ DB 'doors/doormove3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GMOL@doors?1doormove4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GMOL@doors?1doormove4?4wav?$AA@ DB 'doors/doormove4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MMMO@doors?1doormove5?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MMMO@doors?1doormove5?4wav?$AA@ DB 'doors/doormove5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CMKB@doors?1doormove6?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@CMKB@doors?1doormove6?4wav?$AA@ DB 'doors/doormove6.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IMIE@doors?1doormove7?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IMIE@doors?1doormove7?4wav?$AA@ DB 'doors/doormove7.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ONFE@doors?1doormove8?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@ONFE@doors?1doormove8?4wav?$AA@ DB 'doors/doormove8.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ENHB@doors?1doormove9?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@ENHB@doors?1doormove9?4wav?$AA@ DB 'doors/doormove9.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EEJ@doors?1doormove10?4wav?$AA@
CONST	SEGMENT
??_C@_0BF@EEJ@doors?1doormove10?4wav?$AA@ DB 'doors/doormove10.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LNFJ@common?1null?4wav?$AA@
CONST	SEGMENT
??_C@_0BA@LNFJ@common?1null?4wav?$AA@ DB 'common/null.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGIG@doors?1doorstop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@MGIG@doors?1doorstop1?4wav?$AA@ DB 'doors/doorstop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CGOJ@doors?1doorstop2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@CGOJ@doors?1doorstop2?4wav?$AA@ DB 'doors/doorstop2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IGMM@doors?1doorstop3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IGMM@doors?1doorstop3?4wav?$AA@ DB 'doors/doorstop3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGDG@doors?1doorstop4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@OGDG@doors?1doorstop4?4wav?$AA@ DB 'doors/doorstop4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EGBD@doors?1doorstop5?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@EGBD@doors?1doorstop5?4wav?$AA@ DB 'doors/doorstop5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGHM@doors?1doorstop6?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@KGHM@doors?1doorstop6?4wav?$AA@ DB 'doors/doorstop6.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GFJ@doors?1doorstop7?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GFJ@doors?1doorstop7?4wav?$AA@ DB 'doors/doorstop7.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GHIJ@doors?1doorstop8?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@GHIJ@doors?1doorstop8?4wav?$AA@ DB 'doors/doorstop8.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GHFJ@NA?$AA@
CONST	SEGMENT
??_C@_02GHFJ@NA?$AA@ DB 'NA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GHJC@ND?$AA@
CONST	SEGMENT
??_C@_02GHJC@ND?$AA@ DB 'ND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCLM@NF?$AA@
CONST	SEGMENT
??_C@_02DCLM@NF?$AA@ DB 'NF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05EMJD@NFIRE?$AA@
CONST	SEGMENT
??_C@_05EMJD@NFIRE?$AA@ DB 'NFIRE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBNL@NCHEM?$AA@
CONST	SEGMENT
??_C@_05PBNL@NCHEM?$AA@ DB 'NCHEM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BCIH@NRAD?$AA@
CONST	SEGMENT
??_C@_04BCIH@NRAD?$AA@ DB 'NRAD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCMG@NCON?$AA@
CONST	SEGMENT
??_C@_04KCMG@NCON?$AA@ DB 'NCON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JJHG@NH?$AA@
CONST	SEGMENT
??_C@_02JJHG@NH?$AA@ DB 'NH', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JICL@NG?$AA@
CONST	SEGMENT
??_C@_02JICL@NG?$AA@ DB 'NG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OJPC@EA?$AA@
CONST	SEGMENT
??_C@_02OJPC@EA?$AA@ DB 'EA', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OJDJ@ED?$AA@
CONST	SEGMENT
??_C@_02OJDJ@ED?$AA@ DB 'ED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMBH@EF?$AA@
CONST	SEGMENT
??_C@_02LMBH@EF?$AA@ DB 'EF', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNNG@EFIRE?$AA@
CONST	SEGMENT
??_C@_05KNNG@EFIRE?$AA@ DB 'EFIRE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05BAJO@ECHEM?$AA@
CONST	SEGMENT
??_C@_05BAJO@ECHEM?$AA@ DB 'ECHEM', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FHOB@ERAD?$AA@
CONST	SEGMENT
??_C@_04FHOB@ERAD?$AA@ DB 'ERAD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHKA@ECON?$AA@
CONST	SEGMENT
??_C@_04OHKA@ECON?$AA@ DB 'ECON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BHNN@EH?$AA@
CONST	SEGMENT
??_C@_02BHNN@EH?$AA@ DB 'EH', 00H			; `string'
CONST	ENDS
;	COMDAT ?Precache@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pszSound$ = -8
_m_sound$ = -12
?Precache@CBaseDoor@@UAEXXZ PROC NEAR			; CBaseDoor::Precache, COMDAT

; 149  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 	const char *pszSound;
; 151  : 
; 152  : 	int m_sound = UTIL_LoadSoundPreset( m_iMoveSnd );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1960]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 156  : 	{

	mov	edx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	cmp	DWORD PTR -16+[ebp], 10			; 0000000aH
	ja	$L37480
	mov	eax, DWORD PTR -16+[ebp]
	jmp	DWORD PTR $L39326[eax*4]
$L37458:

; 157  : 	case 1:
; 158  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove1.wav" );

	push	OFFSET FLAT:??_C@_0BE@EMFL@doors?1doormove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 159  : 		break;

	jmp	$L37455
$L37460:

; 160  : 	case 2:
; 161  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove2.wav" );

	push	OFFSET FLAT:??_C@_0BE@KMDE@doors?1doormove2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 162  : 		break;

	jmp	$L37455
$L37462:

; 163  : 	case 3:
; 164  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove3.wav" );

	push	OFFSET FLAT:??_C@_0BE@MBB@doors?1doormove3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 165  : 		break;

	jmp	$L37455
$L37464:

; 166  : 	case 4:
; 167  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove4.wav" );

	push	OFFSET FLAT:??_C@_0BE@GMOL@doors?1doormove4?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 168  : 		break;

	jmp	$L37455
$L37466:

; 169  : 	case 5:
; 170  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove5.wav" );

	push	OFFSET FLAT:??_C@_0BE@MMMO@doors?1doormove5?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 171  : 		break;

	jmp	$L37455
$L37468:

; 172  : 	case 6:
; 173  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove6.wav" );

	push	OFFSET FLAT:??_C@_0BE@CMKB@doors?1doormove6?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 174  : 		break;

	jmp	$L37455
$L37470:

; 175  : 	case 7:
; 176  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove7.wav" );

	push	OFFSET FLAT:??_C@_0BE@IMIE@doors?1doormove7?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 177  : 		break;

	jmp	$L37455
$L37472:

; 178  : 	case 8:
; 179  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove8.wav" );

	push	OFFSET FLAT:??_C@_0BE@ONFE@doors?1doormove8?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 180  : 		break;

	jmp	SHORT $L37455
$L37474:

; 181  : 	case 9:
; 182  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove9.wav" );

	push	OFFSET FLAT:??_C@_0BE@ENHB@doors?1doormove9?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 183  : 		break;

	jmp	SHORT $L37455
$L37476:

; 184  : 	case 10:
; 185  : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove10.wav" );

	push	OFFSET FLAT:??_C@_0BF@EEJ@doors?1doormove10?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 186  : 		break;

	jmp	SHORT $L37455
$L37478:

; 187  : 	case 0:
; 188  : 		pev->noise1 = MAKE_STRING( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 189  : 		break;

	jmp	SHORT $L37455
$L37480:

; 190  : 	default:
; 191  : 		pev->noise1 = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax
$L37455:

; 194  : 
; 195  : 	m_sound = UTIL_LoadSoundPreset( m_iStopSnd );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1964]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 199  : 	{

	mov	edx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -20+[ebp], edx
	cmp	DWORD PTR -20+[ebp], 8
	ja	$L37502
	mov	eax, DWORD PTR -20+[ebp]
	jmp	DWORD PTR $L39327[eax*4]
$L37485:

; 200  : 	case 1:
; 201  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop1.wav" );

	push	OFFSET FLAT:??_C@_0BE@MGIG@doors?1doorstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 202  : 		break;

	jmp	$L37482
$L37487:

; 203  : 	case 2:
; 204  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop2.wav" );

	push	OFFSET FLAT:??_C@_0BE@CGOJ@doors?1doorstop2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 205  : 		break;

	jmp	$L37482
$L37489:

; 206  : 	case 3:
; 207  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop3.wav" );

	push	OFFSET FLAT:??_C@_0BE@IGMM@doors?1doorstop3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 208  : 		break;

	jmp	$L37482
$L37491:

; 209  : 	case 4:
; 210  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop4.wav" );

	push	OFFSET FLAT:??_C@_0BE@OGDG@doors?1doorstop4?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 211  : 		break;

	jmp	$L37482
$L37493:

; 212  : 	case 5:
; 213  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop5.wav" );

	push	OFFSET FLAT:??_C@_0BE@EGBD@doors?1doorstop5?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 214  : 		break;

	jmp	$L37482
$L37495:

; 215  : 	case 6:
; 216  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop6.wav" );

	push	OFFSET FLAT:??_C@_0BE@KGHM@doors?1doorstop6?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 217  : 		break;

	jmp	SHORT $L37482
$L37497:

; 218  : 	case 7:
; 219  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop7.wav" );

	push	OFFSET FLAT:??_C@_0BE@GFJ@doors?1doorstop7?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 220  : 		break;

	jmp	SHORT $L37482
$L37499:

; 221  : 	case 8:
; 222  : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop8.wav" );

	push	OFFSET FLAT:??_C@_0BE@GHIJ@doors?1doorstop8?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 223  : 		break;

	jmp	SHORT $L37482
$L37501:

; 224  : 	case 0:
; 225  : 		pev->noise2 = MAKE_STRING( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 226  : 		break;

	jmp	SHORT $L37482
$L37502:

; 227  : 	default:
; 228  : 		pev->noise2 = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax
$L37482:

; 231  : 
; 232  : 	// get door button sounds, for doors which are directly 'touched' to open
; 233  : 	if( m_iLockedSound )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2004], 0
	je	SHORT $L37503

; 235  : 		pszSound = UTIL_ButtonSound( m_iLockedSound );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2004]
	push	edx
	call	?UTIL_ButtonSound@@YAPBDH@Z		; UTIL_ButtonSound
	add	esp, 4
	mov	DWORD PTR _pszSound$[ebp], eax

; 236  : 		m_ls.sLockedSound = UTIL_PrecacheSound( pszSound );

	mov	eax, DWORD PTR _pszSound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1968], eax
$L37503:

; 238  : 
; 239  : 	if( m_iUnlockedSound )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2012], 0
	je	SHORT $L37504

; 241  : 		pszSound = UTIL_ButtonSound( m_iUnlockedSound );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2012]
	push	ecx
	call	?UTIL_ButtonSound@@YAPBDH@Z		; UTIL_ButtonSound
	add	esp, 4
	mov	DWORD PTR _pszSound$[ebp], eax

; 242  : 		m_ls.sUnlockedSound = UTIL_PrecacheSound( pszSound );

	mov	edx, DWORD PTR _pszSound$[ebp]
	push	edx
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1976], eax
$L37504:

; 249  : 	{

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2008]
	mov	DWORD PTR -24+[ebp], eax
	mov	ecx, DWORD PTR -24+[ebp]
	sub	ecx, 1
	mov	DWORD PTR -24+[ebp], ecx
	cmp	DWORD PTR -24+[ebp], 8
	ja	$L37527
	mov	edx, DWORD PTR -24+[ebp]
	jmp	DWORD PTR $L39328[edx*4]
$L37509:

; 250  : 	case 1: m_ls.sLockedSentence = MAKE_STRING( "NA" ); break; // access denied

	push	OFFSET FLAT:??_C@_02GHFJ@NA?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1972], eax
	jmp	$L37506
$L37511:

; 251  : 	case 2: m_ls.sLockedSentence = MAKE_STRING( "ND" ); break; // security lockout

	push	OFFSET FLAT:??_C@_02GHJC@ND?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1972], eax
	jmp	$L37506
$L37513:

; 252  : 	case 3: m_ls.sLockedSentence = MAKE_STRING( "NF" ); break; // blast door

	push	OFFSET FLAT:??_C@_02DCLM@NF?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1972], eax
	jmp	$L37506
$L37515:

; 253  : 	case 4: m_ls.sLockedSentence = MAKE_STRING( "NFIRE" ); break; // fire door

	push	OFFSET FLAT:??_C@_05EMJD@NFIRE?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1972], eax
	jmp	$L37506
$L37517:

; 254  : 	case 5: m_ls.sLockedSentence = MAKE_STRING( "NCHEM" ); break; // chemical door

	push	OFFSET FLAT:??_C@_05PBNL@NCHEM?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1972], eax
	jmp	SHORT $L37506
$L37519:

; 255  : 	case 6: m_ls.sLockedSentence = MAKE_STRING( "NRAD" ); break; // radiation door

	push	OFFSET FLAT:??_C@_04BCIH@NRAD?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1972], eax
	jmp	SHORT $L37506
$L37521:

; 256  : 	case 7: m_ls.sLockedSentence = MAKE_STRING( "NCON" ); break; // gen containment

	push	OFFSET FLAT:??_C@_04KCMG@NCON?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1972], eax
	jmp	SHORT $L37506
$L37523:

; 257  : 	case 8: m_ls.sLockedSentence = MAKE_STRING( "NH" ); break; // maintenance door

	push	OFFSET FLAT:??_C@_02JJHG@NH?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1972], eax
	jmp	SHORT $L37506
$L37525:

; 258  : 	case 9: m_ls.sLockedSentence = MAKE_STRING( "NG" ); break; // broken door

	push	OFFSET FLAT:??_C@_02JICL@NG?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1972], eax
	jmp	SHORT $L37506
$L37527:

; 259  : 	default: m_ls.sLockedSentence = 0; break;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1972], 0
$L37506:

; 263  : 	{

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+2016]
	mov	DWORD PTR -28+[ebp], ecx
	mov	edx, DWORD PTR -28+[ebp]
	sub	edx, 1
	mov	DWORD PTR -28+[ebp], edx
	cmp	DWORD PTR -28+[ebp], 7
	ja	$L37548
	mov	eax, DWORD PTR -28+[ebp]
	jmp	DWORD PTR $L39329[eax*4]
$L37532:

; 264  : 	case 1: m_ls.sUnlockedSentence = MAKE_STRING( "EA" ); break; // access granted

	push	OFFSET FLAT:??_C@_02OJPC@EA?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1980], eax
	jmp	$L37529
$L37534:

; 265  : 	case 2: m_ls.sUnlockedSentence = MAKE_STRING( "ED" ); break; // security door

	push	OFFSET FLAT:??_C@_02OJDJ@ED?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1980], eax
	jmp	$L37529
$L37536:

; 266  : 	case 3: m_ls.sUnlockedSentence = MAKE_STRING( "EF" ); break; // blast door

	push	OFFSET FLAT:??_C@_02LMBH@EF?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1980], eax
	jmp	$L37529
$L37538:

; 267  : 	case 4: m_ls.sUnlockedSentence = MAKE_STRING( "EFIRE" ); break; // fire door

	push	OFFSET FLAT:??_C@_05KNNG@EFIRE?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1980], eax
	jmp	SHORT $L37529
$L37540:

; 268  : 	case 5: m_ls.sUnlockedSentence = MAKE_STRING( "ECHEM" ); break; // chemical door

	push	OFFSET FLAT:??_C@_05BAJO@ECHEM?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1980], eax
	jmp	SHORT $L37529
$L37542:

; 269  : 	case 6: m_ls.sUnlockedSentence = MAKE_STRING( "ERAD" ); break; // radiation door

	push	OFFSET FLAT:??_C@_04FHOB@ERAD?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1980], eax
	jmp	SHORT $L37529
$L37544:

; 270  : 	case 7: m_ls.sUnlockedSentence = MAKE_STRING( "ECON" ); break; // gen containment

	push	OFFSET FLAT:??_C@_04OHKA@ECON?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1980], eax
	jmp	SHORT $L37529
$L37546:

; 271  : 	case 8: m_ls.sUnlockedSentence = MAKE_STRING( "EH" ); break; // maintenance door

	push	OFFSET FLAT:??_C@_02BHNN@EH?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1980], eax
	jmp	SHORT $L37529
$L37548:

; 272  : 	default: m_ls.sUnlockedSentence = 0; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1980], 0
$L37529:

; 274  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L39326:
	DD	$L37478
	DD	$L37458
	DD	$L37460
	DD	$L37462
	DD	$L37464
	DD	$L37466
	DD	$L37468
	DD	$L37470
	DD	$L37472
	DD	$L37474
	DD	$L37476
$L39327:
	DD	$L37501
	DD	$L37485
	DD	$L37487
	DD	$L37489
	DD	$L37491
	DD	$L37493
	DD	$L37495
	DD	$L37497
	DD	$L37499
$L39328:
	DD	$L37509
	DD	$L37511
	DD	$L37513
	DD	$L37515
	DD	$L37517
	DD	$L37519
	DD	$L37521
	DD	$L37523
	DD	$L37525
$L39329:
	DD	$L37532
	DD	$L37534
	DD	$L37536
	DD	$L37538
	DD	$L37540
	DD	$L37542
	DD	$L37544
	DD	$L37546
?Precache@CBaseDoor@@UAEXXZ ENDP			; CBaseDoor::Precache
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?Spawn@CBaseDoor@@UAEXXZ			; CBaseDoor::Spawn
PUBLIC	?DotProductAbs@@YAMABVVector@@0@Z		; DotProductAbs
PUBLIC	__real@4@00000000000000000000
PUBLIC	?GetModel@CBaseEntity@@QAEPBDXZ			; CBaseEntity::GetModel
PUBLIC	?__LINE__Var@?1??Spawn@CBaseDoor@@UAEXXZ@4FA	; `CBaseDoor::Spawn'::`2'::__LINE__Var
PUBLIC	??_C@_0CD@FOMB@door?5start?1end?5positions?5are?5equ@ ; `string'
PUBLIC	??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0CB@BFEG@m_vecPosition1?5?$CB?$DN?5m_vecPosition2@ ; `string'
PUBLIC	??_C@_05MJCP@c2a5e?$AA@				; `string'
PUBLIC	??_C@_04EAAN@?$CK103?$AA@			; `string'
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
PUBLIC	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalOrigin
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT ?__LINE__Var@?1??Spawn@CBaseDoor@@UAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??Spawn@CBaseDoor@@UAEXXZ@4FA DW 0115H	; `CBaseDoor::Spawn'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CD@FOMB@door?5start?1end?5positions?5are?5equ@
CONST	SEGMENT
??_C@_0CD@FOMB@door?5start?1end?5positions?5are?5equ@ DB 'door start/end '
	DB	'positions are equal', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@
CONST	SEGMENT
??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ DB 'z:\xashxtsrc\s'
	DB	'erver\doors.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BFEG@m_vecPosition1?5?$CB?$DN?5m_vecPosition2@
CONST	SEGMENT
??_C@_0CB@BFEG@m_vecPosition1?5?$CB?$DN?5m_vecPosition2@ DB 'm_vecPositio'
	DB	'n1 != m_vecPosition2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJCP@c2a5e?$AA@
CONST	SEGMENT
??_C@_05MJCP@c2a5e?$AA@ DB 'c2a5e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EAAN@?$CK103?$AA@
CONST	SEGMENT
??_C@_04EAAN@?$CK103?$AA@ DB '*103', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?Spawn@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT
$T39332 = -28
$T39333 = -40
$T39334 = -52
$T39335 = -64
$T39336 = -76
_this$ = -4
_vecSize$ = -16
?Spawn@CBaseDoor@@UAEXXZ PROC NEAR			; CBaseDoor::Spawn, COMDAT

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 278  : 	if( pev->skin == CONTENTS_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+272], 0
	jne	SHORT $L37553

; 280  : 		// normal door
; 281  : 		if( FBitSet( pev->spawnflags, SF_DOOR_PASSABLE ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L37554

; 282  : 			pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 283  : 		else

	jmp	SHORT $L37555
$L37554:

; 284  : 			pev->solid = SOLID_BSP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 4
$L37555:

; 286  : 	else

	jmp	SHORT $L37556
$L37553:

; 288  : 		SetBits( pev->spawnflags, SF_DOOR_SILENT );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	or	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx

; 289  : 		pev->solid = SOLID_NOT; // special contents

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0
$L37556:

; 291  : 
; 292  : 	Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 293  : 
; 294  : 	pev->movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7

; 295  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 296  : 
; 297  : 	// NOTE: original Half-Life was contain a bug in LinearMove function
; 298  : 	// while m_flWait was equal 0 then object has stopped forever. See code from quake:
; 299  : 	/*
; 300  : 		void LinearMove( Vector vecDest, float flSpeed )
; 301  : 		{
; 302  : 			...
; 303  : 			...
; 304  : 			...
; 305  : 			if( flTravelTime < 0.1f )
; 306  : 			{
; 307  : 				pev->velocity = g_vecZero;
; 308  : 				pev->nextthink = pev->ltime + 0.1f;
; 309  : 				return;
; 310  : 			}
; 311  : 		}
; 312  : 	*/
; 313  : 	// this block was removed from Half-Life and there no difference
; 314  : 	// between wait = 0 and wait = -1. But in Xash this bug was fixed
; 315  : 	// and level-designer errors is now actual. I'm set m_flWait to -1 for compatibility
; 316  : 	if( m_flWait == 0.0f )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1764]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37557

; 317  : 		m_flWait = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], -1082130432	; bf800000H
$L37557:

; 318  : 
; 319  : 	if( pev->speed == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37558

; 320  : 		pev->speed = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+504], 1120403456		; 42c80000H
$L37558:

; 321  : 
; 322  : 	if( pev->movedir == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37559

; 323  : 		pev->movedir = Vector( 1.0f, 0.0f, 0.0f );

	push	0
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T39332[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L37559:

; 324  : 
; 325  : 	m_vecPosition1 = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 326  : 
; 327  : 	// Subtract 2 from size because the engine expands bboxes by 1 in all directions making the size too big
; 328  : 	Vector vecSize = pev->size - Vector( 2, 2, 2 );

	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR $T39333[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T39334[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecSize$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 329  : 	m_vecPosition2 = m_vecPosition1 + (pev->movedir * (DotProductAbs( pev->movedir, vecSize ) - m_flLip));

	lea	eax, DWORD PTR _vecSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	push	edx
	call	?DotProductAbs@@YAMABVVector@@0@Z	; DotProductAbs
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+1828]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39335[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T39336[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 330  : 
; 331  : 	ASSERTSZ( m_vecPosition1 != m_vecPosition2, "door start/end positions are equal" );

	push	OFFSET FLAT:??_C@_0CD@FOMB@door?5start?1end?5positions?5are?5equ@ ; `string'
	movsx	ecx, WORD PTR ?__LINE__Var@?1??Spawn@CBaseDoor@@UAEXXZ@4FA ; `CBaseDoor::Spawn'::`2'::__LINE__Var
	add	ecx, 54					; 00000036H
	push	ecx
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0CB@BFEG@m_vecPosition1?5?$CB?$DN?5m_vecPosition2@ ; `string'
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1852				; 0000073cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 332  : 
; 333  : 	if( FBitSet( pev->spawnflags, SF_DOOR_START_OPEN ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L37570

; 335  : 		UTIL_SetOrigin( this, m_vecPosition2 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1852				; 0000073cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 336  : 		m_vecPosition2 = m_vecPosition1;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1840				; 00000730H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1852				; 0000073cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx

; 337  : 		m_vecPosition1 = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 339  : 	else

	jmp	SHORT $L37571
$L37570:

; 341  : 		UTIL_SetOrigin( this, m_vecPosition1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8
$L37571:

; 343  : 
; 344  : 	// another hack: PhysX 2.8.4.0 crashed while trying to created kinematic body from this brush-model
; 345  : 	if ( FStrEq( STRING( gpGlobals->mapname ), "c2a5e" ) && FStrEq( STRING( pev->model ), "*103" ));

	push	OFFSET FLAT:??_C@_05MJCP@c2a5e?$AA@	; `string'
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37572
	push	OFFSET FLAT:??_C@_04EAAN@?$CK103?$AA@	; `string'
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37572

; 346  : 	else m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	jmp	SHORT $L37575
$L37572:
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax
$L37575:

; 347  : 	m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 348  : 
; 349  : 	// if the door is flagged for USE button activation only, use NULL touch function
; 350  : 	if( FBitSet( pev->spawnflags, SF_DOOR_USE_ONLY ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L37576

; 352  : 		SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 354  : 	else

	jmp	SHORT $L37580
$L37576:

; 356  : 		// touchable button
; 357  : 		SetTouch( DoorTouch );

	push	OFFSET FLAT:??_C@_09PFID@DoorTouch?$AA@	; `string'
	push	OFFSET FLAT:?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ; CBaseDoor::DoorTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
$L37580:

; 359  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseDoor@@UAEXXZ ENDP				; CBaseDoor::Spawn
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39345
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39345
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39345
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39346
$L39345:
	mov	DWORD PTR -8+[ebp], 0
$L39346:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39351 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39351[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39354 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39354[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39357 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39357[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
EXTRN	_fabs:NEAR
;	COMDAT ?DotProductAbs@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProductAbs@@YAMABVVector@@0@Z PROC NEAR		; DotProductAbs, COMDAT

; 290  : inline float DotProductAbs( const Vector& a, const Vector& b ) { return( fabs( a.x * b.x ) + fabs( a.y * b.y ) + fabs( a.z * b.z )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -8+[ebp]
	add	esp, 8
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	QWORD PTR -8+[ebp]
	fstp	QWORD PTR -16+[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	QWORD PTR -16+[ebp]
	fst	DWORD PTR -20+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProductAbs@@YAMABVVector@@0@Z ENDP			; DotProductAbs
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetModel@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetModel, COMDAT

; 288  : 	const char*	GetModel() { return STRING( pev->model ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetModel
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z PROC NEAR ; CBaseEntity::TouchSet, COMDAT

; 567  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 568  : 		m_pfnTouch = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1748], ecx

; 569  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnTouch)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1748]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 570  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 571  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ENDP ; CBaseEntity::TouchSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABV0@@Z			; matrix4x4::matrix4x4
PUBLIC	?OnChangeParent@CBaseDoor@@UAEXXZ		; CBaseDoor::OnChangeParent
EXTRN	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorITransform
EXTRN	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ:NEAR ; CBaseEntity::GetParentToWorldTransform
;	COMDAT ?OnChangeParent@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT
$T39374 = -132
$T39375 = -144
$T39376 = -156
_this$ = -4
_parent$ = -68
?OnChangeParent@CBaseDoor@@UAEXXZ PROC NEAR		; CBaseDoor::OnChangeParent, COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 363  : 	matrix4x4 parent = GetParentToWorldTransform();

	lea	eax, DWORD PTR $T39374[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _parent$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 364  : 	m_vecPosition1 = parent.VectorITransform( m_vecPosition1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	lea	edx, DWORD PTR $T39375[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 365  : 	m_vecPosition2 = parent.VectorITransform( m_vecPosition2 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	lea	edx, DWORD PTR $T39376[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 366  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseDoor@@UAEXXZ ENDP			; CBaseDoor::OnChangeParent
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@ABV0@@Z			; Vector4D::Vector4D
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S7$ = -8
_$S8$ = -12
_$S9$ = -16
??0matrix4x4@@QAE@ABV0@@Z PROC NEAR			; matrix4x4::matrix4x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S7$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S9$[ebp], ecx
$L26032:
	mov	edx, DWORD PTR _$S9$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S8$[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D
	mov	eax, DWORD PTR _$S8$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR _$S9$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _$S9$[ebp], ecx
	mov	edx, DWORD PTR _$S7$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S7$[ebp], edx
	cmp	DWORD PTR _$S7$[ebp], 0
	ja	SHORT $L26032
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABV0@@Z ENDP				; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector4D@@QAE@ABV0@@Z PROC NEAR			; Vector4D::Vector4D, COMDAT

; 313  : 	inline Vector4D( const Vector4D& v ) { x = v.x; y = v.y; z = v.z, w = v.w; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABV0@@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	?OnClearParent@CBaseDoor@@UAEXXZ		; CBaseDoor::OnClearParent
EXTRN	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorTransform
;	COMDAT ?OnClearParent@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT
$T39383 = -132
$T39384 = -144
$T39385 = -156
_this$ = -4
_parent$ = -68
?OnClearParent@CBaseDoor@@UAEXXZ PROC NEAR		; CBaseDoor::OnClearParent, COMDAT

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 	matrix4x4 parent = GetParentToWorldTransform();

	lea	eax, DWORD PTR $T39383[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _parent$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 371  : 	m_vecPosition1 = parent.VectorTransform( m_vecPosition1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	lea	edx, DWORD PTR $T39384[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 372  : 	m_vecPosition2 = parent.VectorTransform( m_vecPosition2 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	lea	edx, DWORD PTR $T39385[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 373  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseDoor@@UAEXXZ ENDP			; CBaseDoor::OnClearParent
_TEXT	ENDS
PUBLIC	?SetToggleState@CBaseDoor@@UAEXH@Z		; CBaseDoor::SetToggleState
;	COMDAT ?SetToggleState@CBaseDoor@@UAEXH@Z
_TEXT	SEGMENT
_state$ = 8
_this$ = -4
?SetToggleState@CBaseDoor@@UAEXH@Z PROC NEAR		; CBaseDoor::SetToggleState, COMDAT

; 376  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 	if( (STATE)state == STATE_ON )

	cmp	DWORD PTR _state$[ebp], 1
	jne	SHORT $L37604

; 378  : 		UTIL_SetOrigin( this, m_vecPosition2 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1852				; 0000073cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 379  : 	else UTIL_SetOrigin( this, m_vecPosition1 );

	jmp	SHORT $L37605
$L37604:
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1840				; 00000730H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8
$L37605:

; 380  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseDoor@@UAEXH@Z ENDP			; CBaseDoor::SetToggleState
_TEXT	ENDS
PUBLIC	?GetDoorMovementGroup@CBaseDoor@@QAEHQAPAV1@H@Z	; CBaseDoor::GetDoorMovementGroup
PUBLIC	?Activate@CBaseDoor@@UAEXXZ			; CBaseDoor::Activate
PUBLIC	?GetTargetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTargetname
PUBLIC	??_C@_0CG@GILE@Door?5group?5?$CFs?5has?5misaligned?5ori@ ; `string'
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
;	COMDAT ??_C@_0CG@GILE@Door?5group?5?$CFs?5has?5misaligned?5ori@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0CG@GILE@Door?5group?5?$CFs?5has?5misaligned?5ori@ DB 'Door group %'
	DB	's has misaligned origin!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?Activate@CBaseDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pDoorList$ = -260
_doorCount$ = -264
_i$ = -268
_error$37617 = -272
?Activate@CBaseDoor@@UAEXXZ PROC NEAR			; CBaseDoor::Activate, COMDAT

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 384  : 	CBaseDoor	*pDoorList[64];
; 385  : 	m_bDoorGroup = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2024], 1

; 386  : 
; 387  : 	// force movement groups to sync!!!
; 388  : 	int doorCount = GetDoorMovementGroup( pDoorList, ARRAYSIZE( pDoorList ));

	push	64					; 00000040H
	lea	ecx, DWORD PTR _pDoorList$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDoorMovementGroup@CBaseDoor@@QAEHQAPAV1@H@Z ; CBaseDoor::GetDoorMovementGroup
	mov	DWORD PTR _doorCount$[ebp], eax

; 389  : 
; 390  : 	for( int i = 0; i < doorCount; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37613
$L37614:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L37613:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _doorCount$[ebp]
	jge	$L37615

; 392  : 		if( pDoorList[i]->pev->movedir == pev->movedir )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pDoorList$[ebp+eax*4]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	$L37620

; 394  : 			bool error = false;

	mov	BYTE PTR _error$37617[ebp], 0

; 395  : 
; 396  : 			if( pDoorList[i]->IsRotatingDoor() )

	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pDoorList$[ebp+edx*4]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pDoorList$[ebp+eax*4]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+344]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L37618

; 398  : 				error = ( pDoorList[i]->GetLocalAngles() != GetLocalAngles()) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pDoorList$[ebp+ecx*4]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	setne	dl
	mov	BYTE PTR _error$37617[ebp], dl

; 400  : 			else 

	jmp	SHORT $L37619
$L37618:

; 402  : 				error = ( pDoorList[i]->GetLocalOrigin() != GetLocalOrigin()) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pDoorList$[ebp+eax*4]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	setne	cl
	mov	BYTE PTR _error$37617[ebp], cl
$L37619:

; 404  : 
; 405  : 			if( error )

	mov	edx, DWORD PTR _error$37617[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L37620

; 407  : 				// don't do group blocking
; 408  : 				m_bDoorGroup = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2024], 0

; 409  : 
; 410  : 				// UNDONE: This should probably fixup m_vecPosition1 & m_vecPosition2
; 411  : 				ALERT( at_aiconsole, "Door group %s has misaligned origin!\n", GetTargetname( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET FLAT:??_C@_0CG@GILE@Door?5group?5?$CFs?5has?5misaligned?5ori@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L37620:

; 414  : 	}

	jmp	$L37614
$L37615:

; 415  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseDoor@@UAEXXZ ENDP			; CBaseDoor::Activate
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetTargetname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetTargetname, COMDAT

; 284  : 	const char*	GetTargetname() { return STRING( pev->targetname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTargetname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetTargetname
_TEXT	ENDS
PUBLIC	?ChainUse@CBaseDoor@@QAEXW4USE_TYPE@@M@Z	; CBaseDoor::ChainUse
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	?SetChaining@CBaseEntity@@QAEX_N@Z		; CBaseEntity::SetChaining
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByTargetname
;	COMDAT ?ChainUse@CBaseDoor@@QAEXW4USE_TYPE@@M@Z
_TEXT	SEGMENT
_useType$ = 8
_value$ = 12
_this$ = -4
_pEnt$ = -8
_pDoor$37633 = -12
?ChainUse@CBaseDoor@@QAEXW4USE_TYPE@@M@Z PROC NEAR	; CBaseDoor::ChainUse, COMDAT

; 418  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 419  : 	// to prevent recursion
; 420  : 	if( m_isChaining ) return;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	je	SHORT $L37627
	jmp	$L37626
$L37627:

; 421  : 
; 422  : 	CBaseEntity *pEnt = NULL;

	mov	DWORD PTR _pEnt$[ebp], 0
$L37630:

; 423  : 
; 424  : 	while(( pEnt = UTIL_FindEntityByTargetname( pEnt, STRING( m_iChainTarget ))) != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2020]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	push	ecx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax
	cmp	DWORD PTR _pEnt$[ebp], 0
	je	SHORT $L37631

; 426  : 		if( pEnt == this ) continue;

	mov	edx, DWORD PTR _pEnt$[ebp]
	cmp	edx, DWORD PTR _this$[ebp]
	jne	SHORT $L37632
	jmp	SHORT $L37630
$L37632:

; 427  : 
; 428  : 		CBaseDoor *pDoor = (CBaseDoor *)pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	DWORD PTR _pDoor$37633[ebp], eax

; 429  : 
; 430  : 		if( pDoor )

	cmp	DWORD PTR _pDoor$37633[ebp], 0
	je	SHORT $L37635

; 432  : 			pDoor->SetChaining( true );

	push	1
	mov	ecx, DWORD PTR _pDoor$37633[ebp]
	call	?SetChaining@CBaseEntity@@QAEX_N@Z	; CBaseEntity::SetChaining

; 433  : 			pDoor->Use( m_hActivator, this, useType, value );

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _pDoor$37633[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pDoor$37633[ebp]
	call	DWORD PTR [edx+276]

; 434  : 			pDoor->SetChaining( false );

	push	0
	mov	ecx, DWORD PTR _pDoor$37633[ebp]
	call	?SetChaining@CBaseEntity@@QAEX_N@Z	; CBaseEntity::SetChaining
$L37635:

; 436  : 	}

	jmp	SHORT $L37630
$L37631:
$L37626:

; 437  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ChainUse@CBaseDoor@@QAEXW4USE_TYPE@@M@Z ENDP		; CBaseDoor::ChainUse
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ?SetChaining@CBaseEntity@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4
_chaining$ = 8
?SetChaining@CBaseEntity@@QAEX_N@Z PROC NEAR		; CBaseEntity::SetChaining, COMDAT

; 279  : 	void		SetChaining( bool chaining ) { m_isChaining = chaining; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _chaining$[ebp]
	mov	BYTE PTR [eax+1628], cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetChaining@CBaseEntity@@QAEX_N@Z ENDP			; CBaseEntity::SetChaining
_TEXT	ENDS
PUBLIC	?ChainTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z	; CBaseDoor::ChainTouch
;	COMDAT ?ChainTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
_pEnt$ = -8
_pDoor$37646 = -12
?ChainTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z PROC NEAR	; CBaseDoor::ChainTouch, COMDAT

; 440  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 441  : 	// to prevent recursion
; 442  : 	if( m_isChaining ) return;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	je	SHORT $L37640
	jmp	SHORT $L37639
$L37640:

; 443  : 
; 444  : 	CBaseEntity *pEnt = NULL;

	mov	DWORD PTR _pEnt$[ebp], 0
$L37643:

; 445  : 
; 446  : 	while(( pEnt = UTIL_FindEntityByTargetname( pEnt, STRING( m_iChainTarget ))) != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2020]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	push	ecx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax
	cmp	DWORD PTR _pEnt$[ebp], 0
	je	SHORT $L37644

; 448  : 		if( pEnt == this ) continue;

	mov	edx, DWORD PTR _pEnt$[ebp]
	cmp	edx, DWORD PTR _this$[ebp]
	jne	SHORT $L37645
	jmp	SHORT $L37643
$L37645:

; 449  : 
; 450  : 		CBaseDoor *pDoor = (CBaseDoor *)pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	DWORD PTR _pDoor$37646[ebp], eax

; 451  : 
; 452  : 		if( pDoor )

	cmp	DWORD PTR _pDoor$37646[ebp], 0
	je	SHORT $L37648

; 454  : 			pDoor->SetChaining( true );

	push	1
	mov	ecx, DWORD PTR _pDoor$37646[ebp]
	call	?SetChaining@CBaseEntity@@QAEX_N@Z	; CBaseEntity::SetChaining

; 455  : 			pDoor->Touch( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDoor$37646[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pDoor$37646[ebp]
	call	DWORD PTR [eax+280]

; 456  : 			pDoor->SetChaining( false );

	push	0
	mov	ecx, DWORD PTR _pDoor$37646[ebp]
	call	?SetChaining@CBaseEntity@@QAEX_N@Z	; CBaseEntity::SetChaining
$L37648:

; 458  : 	}

	jmp	SHORT $L37643
$L37644:
$L37639:

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ChainTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ENDP	; CBaseDoor::ChainTouch
_TEXT	ENDS
PUBLIC	?DoorActivate@CBaseDoor@@QAEHXZ			; CBaseDoor::DoorActivate
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
EXTRN	?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z:NEAR ; PlayLockSounds
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHXZ:NEAR	; CBaseDelay::IsLockedByMaster
;	COMDAT ?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z PROC NEAR	; CBaseDoor::DoorTouch, COMDAT

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 	if( !FStringNull( m_iChainTarget ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2020]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37653

; 464  : 		ChainTouch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChainTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ; CBaseDoor::ChainTouch
$L37653:

; 465  : 
; 466  : 	m_bDoorTouched = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2025], 1

; 467  : 
; 468  : 	// ignore touches by anything but players and pushables
; 469  : 	if( !pOther->IsPlayer() && !pOther->IsPushable()) return;

	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L37654
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+236]
	test	eax, eax
	jne	SHORT $L37654
	jmp	$L37652
$L37654:

; 470  : 
; 471  : 	m_hActivator = pOther; // remember who activated the door

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 472  : 
; 473  : 	// If door has master, and it's not ready to trigger, 
; 474  : 	// play 'locked' sound
; 475  : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37655

; 476  : 		PlayLockSounds( pev, &m_ls, TRUE, FALSE );

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z ; PlayLockSounds
	add	esp, 16					; 00000010H
$L37655:

; 477  : 	
; 478  : 	// If door is somebody's target, then touching does nothing.
; 479  : 	// You have to activate the owner (e.g. button).
; 480  : 	// g-cont. but allow touch for chain doors
; 481  : 	if( !FStringNull( pev->targetname ) && FStringNull( m_iChainTarget ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+460]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37656
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2020]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L37656

; 483  : 		// play locked sound
; 484  : 		PlayLockSounds( pev, &m_ls, TRUE, FALSE );

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1968				; 000007b0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z ; PlayLockSounds
	add	esp, 16					; 00000010H

; 485  : 		return; 

	jmp	SHORT $L37652
$L37656:

; 487  : 
; 488  : 	if( DoorActivate( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorActivate@CBaseDoor@@QAEHXZ		; CBaseDoor::DoorActivate
	test	eax, eax
	je	SHORT $L37657

; 490  : 		// temporarily disable the touch function, until movement is finished.
; 491  : 		SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
$L37657:
$L37652:

; 493  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ENDP	; CBaseDoor::DoorTouch
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?Use@CBaseDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CBaseDoor::Use
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
;	COMDAT ?Use@CBaseDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_value$ = 20
_this$ = -4
?Use@CBaseDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CBaseDoor::Use, COMDAT

; 496  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 498  : 
; 499  : 	if( !FStringNull( m_iChainTarget ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2020]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37667

; 500  : 		ChainUse( useType, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChainUse@CBaseDoor@@QAEXW4USE_TYPE@@M@Z ; CBaseDoor::ChainUse
$L37667:

; 501  : 
; 502  : 	m_bDoorTouched = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+2025], 0

; 503  : 
; 504  : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37668

; 506  : 		PlayLockSounds( pev, &m_ls, TRUE, FALSE );

	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1968				; 000007b0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z ; PlayLockSounds
	add	esp, 16					; 00000010H

; 507  : 		return;

	jmp	$L37666
$L37668:

; 509  : 
; 510  : 	if( FBitSet( pev->spawnflags, SF_DOOR_ONOFF_MODE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 4
	test	edx, edx
	je	$L37677

; 512  : 		if( useType == USE_ON )

	cmp	DWORD PTR _useType$[ebp], 1
	jne	$L37670

; 514  : 			if( m_iState == STATE_OFF )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 0
	jne	$L37671

; 516  : 				// door should open
; 517  : 				if( m_hActivator != NULL && m_hActivator->IsPlayer( ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37672
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L37672

; 518  : 					m_hActivator->TakeHealth( m_bHealthValue, DMG_GENERIC );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1956]
	mov	DWORD PTR -12+[ebp], ecx
	fild	DWORD PTR -12+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -16+[ebp], eax
	mov	edx, DWORD PTR -16+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -16+[ebp]
	call	DWORD PTR [eax+100]
$L37672:

; 519  : 
; 520  : 		 		PlayLockSounds( pev, &m_ls, FALSE, FALSE );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z ; PlayLockSounds
	add	esp, 16					; 00000010H

; 521  : 		 		DoorGoUp();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoUp@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoUp
$L37671:

; 523  : 			return;

	jmp	$L37666
$L37670:

; 525  : 		else if( useType == USE_OFF )

	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L37674

; 527  : 			if( m_iState == STATE_ON )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 1
	jne	SHORT $L37675

; 529  : 		         		DoorGoDown();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoDown@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoDown
$L37675:

; 531  : 	         		return;

	jmp	SHORT $L37666
$L37674:

; 533  : 		else if( useType == USE_SET )

	cmp	DWORD PTR _useType$[ebp], 2
	jne	SHORT $L37677

; 535  : 			// change texture
; 536  : 			pev->frame = !pev->frame;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+304]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39412
	mov	DWORD PTR -20+[ebp], 1
	jmp	SHORT $L39413
$L39412:
	mov	DWORD PTR -20+[ebp], 0
$L39413:
	fild	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+304]

; 537  : 			return;

	jmp	SHORT $L37666
$L37677:

; 540  : 
; 541  : 	// if not ready to be used, ignore "use" command.
; 542  : 	if( m_iState == STATE_OFF || FBitSet( pev->spawnflags, SF_DOOR_NO_AUTO_RETURN ) && m_iState == STATE_ON )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 0
	je	SHORT $L37679
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L37678
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 1
	jne	SHORT $L37678
$L37679:

; 543  : 		DoorActivate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorActivate@CBaseDoor@@QAEHXZ		; CBaseDoor::DoorActivate
$L37678:
$L37666:

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CBaseDoor::Use
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?DoorActivate@CBaseDoor@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?DoorActivate@CBaseDoor@@QAEHXZ PROC NEAR		; CBaseDoor::DoorActivate, COMDAT

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 548  : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L37684

; 549  : 		return 0;

	xor	eax, eax
	jmp	$L37683
$L37684:

; 550  : 
; 551  : 	if( FBitSet(pev->spawnflags, SF_DOOR_NO_AUTO_RETURN ) && m_iState == STATE_ON )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L37685
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 1
	jne	SHORT $L37685

; 553  : 		// door should close
; 554  : 		DoorGoDown();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoDown@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoDown

; 556  : 	else

	jmp	$L37686
$L37685:

; 558  : 		// door should open
; 559  : 		if( m_hActivator != NULL && m_hActivator->IsPlayer( ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37687
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L37687

; 560  : 			m_hActivator->TakeHealth( m_bHealthValue, DMG_GENERIC );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1956]
	mov	DWORD PTR -12+[ebp], ecx
	fild	DWORD PTR -12+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -16+[ebp], eax
	mov	edx, DWORD PTR -16+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -16+[ebp]
	call	DWORD PTR [eax+100]
$L37687:

; 561  : 
; 562  : 		// play door unlock sounds
; 563  : 		PlayLockSounds( pev, &m_ls, FALSE, FALSE );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?PlayLockSounds@@YAXPAUentvars_s@@PAUlocksounds@@HH@Z ; PlayLockSounds
	add	esp, 16					; 00000010H

; 564  : 		DoorGoUp();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoUp@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoUp
$L37686:

; 566  : 	return 1;

	mov	eax, 1
$L37683:

; 567  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorActivate@CBaseDoor@@QAEHXZ ENDP			; CBaseDoor::DoorActivate
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	?Cross@Vector@@QBE?AV1@ABV1@@Z			; Vector::Cross
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	?__LINE__Var@?1??DoorGoUp@CBaseDoor@@QAEXXZ@4FA	; `CBaseDoor::DoorGoUp'::`2'::__LINE__Var
PUBLIC	??_C@_0DE@FEHP@m_iState?5?$DN?$DN?5STATE_OFF?5?$HM?$HM?5m_iStat@ ; `string'
PUBLIC	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z:NEAR ; CBaseToggle::LinearMove
EXTRN	?AngularMove@CBaseToggle@@QAEXABVVector@@M@Z:NEAR ; CBaseToggle::AngularMove
EXTRN	?CalcNearestPoint@CBaseEntity@@QBEXABVVector@@PAV2@@Z:NEAR ; CBaseEntity::CalcNearestPoint
;	COMDAT ?__LINE__Var@?1??DoorGoUp@CBaseDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorGoUp@CBaseDoor@@QAEXXZ@4FA DW 023aH ; `CBaseDoor::DoorGoUp'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DE@FEHP@m_iState?5?$DN?$DN?5STATE_OFF?5?$HM?$HM?5m_iStat@
CONST	SEGMENT
??_C@_0DE@FEHP@m_iState?5?$DN?$DN?5STATE_OFF?5?$HM?$HM?5m_iStat@ DB 'm_iS'
	DB	'tate == STATE_OFF || m_iState == STATE_TURN_OFF', 00H ; `string'
CONST	ENDS
;	COMDAT ?DoorGoUp@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT
$T39424 = -72
$T39425 = -84
$T39426 = -96
$T39427 = -108
_this$ = -4
_pevActivator$ = -8
_sign$37700 = -12
_nearestPoint$37703 = -24
_activatorToNearestPoint$37704 = -36
_activatorToOrigin$37706 = -48
_cross$37708 = -60
?DoorGoUp@CBaseDoor@@QAEXXZ PROC NEAR			; CBaseDoor::DoorGoUp, COMDAT

; 570  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 571  : 	entvars_t	*pevActivator;
; 572  : 
; 573  : 	// It could be going-down, if blocked.
; 574  : 	ASSERT( m_iState == STATE_OFF || m_iState == STATE_TURN_OFF );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 0
	je	SHORT $L39422
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 3
	je	SHORT $L39422
	mov	DWORD PTR -112+[ebp], 0
	jmp	SHORT $L39423
$L39422:
	mov	DWORD PTR -112+[ebp], 1
$L39423:
	push	0
	movsx	edx, WORD PTR ?__LINE__Var@?1??DoorGoUp@CBaseDoor@@QAEXXZ@4FA ; `CBaseDoor::DoorGoUp'::`2'::__LINE__Var
	add	edx, 4
	push	edx
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DE@FEHP@m_iState?5?$DN?$DN?5STATE_OFF?5?$HM?$HM?5m_iStat@ ; `string'
	mov	eax, DWORD PTR -112+[ebp]
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 575  : 
; 576  : 	// emit door moving and stop sounds on CHAN_STATIC so that the multicast doesn't
; 577  : 	// filter them out and leave a client stuck with looping door sounds!
; 578  : 	if( !FBitSet( pev->spawnflags, SF_DOOR_SILENT ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	jne	SHORT $L37695

; 579  : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+492]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37695:

; 580  : 
; 581  : 	m_iState = STATE_TURN_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 2

; 582  : 	SetMoveDone( DoorHitTop );

	push	OFFSET FLAT:??_C@_0L@HDCA@DoorHitTop?$AA@ ; `string'
	push	OFFSET FLAT:?DoorHitTop@CBaseDoor@@QAEXXZ ; CBaseDoor::DoorHitTop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 583  : 
; 584  : 	if( IsRotatingDoor( ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+344]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L37699

; 586  : 		float sign = 1.0;

	mov	DWORD PTR _sign$37700[ebp], 1065353216	; 3f800000H

; 587  : 
; 588  : 		// !!! BUGBUG Triggered doors don't work with this yet
; 589  : 		if( m_hActivator != NULL && m_bDoorTouched )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	$L37710
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+2025]
	test	edx, edx
	je	$L37710

; 591  : 			pevActivator = m_hActivator->pev;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _pevActivator$[ebp], eax

; 592  : 
; 593  : 			// Y axis rotation, move away from the player			
; 594  : 			if( !FBitSet( pev->spawnflags, SF_DOOR_ONEWAY ) && pev->movedir.y )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 16					; 00000010H
	test	eax, eax
	jne	$L37710
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+72]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L37710

; 596  : 				// Positive is CCW, negative is CW, so make 'sign' 1 or -1 based on which way we want to open.
; 597  : 				// Important note:  All doors face East at all times, and twist their local angle to open.
; 598  : 				// So you can't look at the door's facing to determine which way to open.
; 599  : 
; 600  : 				Vector nearestPoint;

	lea	ecx, DWORD PTR _nearestPoint$37703[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 601  : 
; 602  : 				CalcNearestPoint( m_hActivator->GetAbsOrigin(), &nearestPoint );

	lea	eax, DWORD PTR _nearestPoint$37703[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcNearestPoint@CBaseEntity@@QBEXABVVector@@PAV2@@Z ; CBaseEntity::CalcNearestPoint

; 603  : 				Vector activatorToNearestPoint = nearestPoint - m_hActivator->GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T39424[ebp]
	push	ecx
	lea	ecx, DWORD PTR _nearestPoint$37703[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _activatorToNearestPoint$37704[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 604  : 				activatorToNearestPoint.z = 0;

	mov	DWORD PTR _activatorToNearestPoint$37704[ebp+8], 0

; 605  : 
; 606  : 				Vector activatorToOrigin = GetAbsOrigin() - m_hActivator->GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T39425[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _activatorToOrigin$37706[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 607  : 				activatorToOrigin.z = 0;

	mov	DWORD PTR _activatorToOrigin$37706[ebp+8], 0

; 608  : 
; 609  : 				// Point right hand at door hinge, curl hand towards closest spot on door, if thumb
; 610  : 				// is up, open door CW. -- Department of Basic Cross Product Understanding for Noobs
; 611  : 				// g-cont. MWA-HA-HA!
; 612  : 				Vector cross = activatorToOrigin.Cross( activatorToNearestPoint );

	lea	eax, DWORD PTR _activatorToNearestPoint$37704[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39426[ebp]
	push	ecx
	lea	ecx, DWORD PTR _activatorToOrigin$37706[ebp]
	call	?Cross@Vector@@QBE?AV1@ABV1@@Z		; Vector::Cross
	push	eax
	lea	ecx, DWORD PTR _cross$37708[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 613  : 				if( cross.z > 0.0f ) sign = -1.0f;	

	fld	DWORD PTR _cross$37708[ebp+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37710
	mov	DWORD PTR _sign$37700[ebp], -1082130432	; bf800000H
$L37710:

; 616  : 
; 617  : 		AngularMove( m_vecAngle2 * sign, pev->speed );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+504]
	push	ecx
	mov	edx, DWORD PTR _sign$37700[ebp]
	push	edx
	lea	eax, DWORD PTR $T39427[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AngularMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::AngularMove

; 619  : 	else

	jmp	SHORT $L37712
$L37699:

; 621  : 		LinearMove( m_vecPosition2, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove
$L37712:

; 623  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorGoUp@CBaseDoor@@QAEXXZ ENDP			; CBaseDoor::DoorGoUp
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ?Cross@Vector@@QBE?AV1@ABV1@@Z
_TEXT	SEGMENT
_vOther$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T39432 = -16
?Cross@Vector@@QBE?AV1@ABV1@@Z PROC NEAR		; Vector::Cross, COMDAT

; 263  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 		return Vector(y*vOther.z - z*vOther.y, z*vOther.x - x*vOther.z, x*vOther.y - y*vOther.x);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vOther$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vOther$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vOther$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vOther$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vOther$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vOther$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+4]
	fsubp	ST(1), ST(0)
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T39432[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 265  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Cross@Vector@@QBE?AV1@ABV1@@Z ENDP			; Vector::Cross
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
;	COMDAT ?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::MoveDoneSet, COMDAT

; 588  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 589  : 		m_pfnMoveDone = func;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1760], ecx

; 590  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnMoveDone)), name );

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1760]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 591  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 592  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP ; CBaseEntity::MoveDoneSet
_TEXT	ENDS
PUBLIC	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z		; STOP_SOUND
PUBLIC	__real@4@bfff8000000000000000
PUBLIC	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z		; CBaseEntity::SetMoveDoneTime
PUBLIC	?__LINE__Var@?1??DoorHitTop@CBaseDoor@@QAEXXZ@4FA ; `CBaseDoor::DoorHitTop'::`2'::__LINE__Var
PUBLIC	??_C@_0BK@NO@m_iState?5?$DN?$DN?5STATE_TURN_ON?$AA@ ; `string'
EXTRN	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z:NEAR ; CBaseDelay::SUB_UseTargets
EXTRN	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ?__LINE__Var@?1??DoorHitTop@CBaseDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorHitTop@CBaseDoor@@QAEXXZ@4FA DW 0272H ; `CBaseDoor::DoorHitTop'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BK@NO@m_iState?5?$DN?$DN?5STATE_TURN_ON?$AA@
CONST	SEGMENT
??_C@_0BK@NO@m_iState?5?$DN?$DN?5STATE_TURN_ON?$AA@ DB 'm_iState == STATE'
	DB	'_TURN_ON', 00H				; `string'
CONST	ENDS
;	COMDAT __real@4@bfff8000000000000000
CONST	SEGMENT
__real@4@bfff8000000000000000 DD 0bf800000r	; -1
CONST	ENDS
;	COMDAT ?DoorHitTop@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorHitTop@CBaseDoor@@QAEXXZ PROC NEAR			; CBaseDoor::DoorHitTop, COMDAT

; 626  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 	if( !FBitSet( pev->spawnflags, SF_DOOR_SILENT ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, -2147483648			; 80000000H
	test	edx, edx
	jne	SHORT $L37717

; 629  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 630  : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise2 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+496]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37717:

; 632  : 
; 633  : 	ASSERT( m_iState == STATE_TURN_ON );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??DoorHitTop@CBaseDoor@@QAEXXZ@4FA ; `CBaseDoor::DoorHitTop'::`2'::__LINE__Var
	add	eax, 7
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BK@NO@m_iState?5?$DN?$DN?5STATE_TURN_ON?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1788], 2
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 634  : 	m_iState = STATE_ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 1

; 635  : 	
; 636  : 	// toggle-doors don't come down automatically, they wait for refire.
; 637  : 	if( FBitSet( pev->spawnflags, SF_DOOR_NO_AUTO_RETURN ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	SHORT $L37721

; 639  : 		// re-instate touch method, movement is complete
; 640  : 		if( !FBitSet( pev->spawnflags, SF_DOOR_USE_ONLY ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	SHORT $L37722

; 641  : 			SetTouch( DoorTouch );

	push	OFFSET FLAT:??_C@_09PFID@DoorTouch?$AA@	; `string'
	push	OFFSET FLAT:?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ; CBaseDoor::DoorTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
$L37722:

; 643  : 	else

	jmp	SHORT $L37728
$L37721:

; 645  : 		// in flWait seconds, DoorGoDown will fire, unless wait is -1, then door stays open
; 646  : 		SetMoveDoneTime( m_flWait );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1764]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMoveDoneTime@CBaseEntity@@QAEXM@Z	; CBaseEntity::SetMoveDoneTime

; 647  : 		SetMoveDone( DoorGoDown );

	push	OFFSET FLAT:??_C@_0L@NBIL@DoorGoDown?$AA@ ; `string'
	push	OFFSET FLAT:?DoorGoDown@CBaseDoor@@QAEXXZ ; CBaseDoor::DoorGoDown
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 648  : 
; 649  : 		if( m_flWait == -1 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	fcomp	DWORD PTR __real@4@bfff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37728

; 651  : 			SetNextThink( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L37728:

; 654  : 
; 655  : 	// fire the close target (if startopen is set, then "top" is closed) - netname is the close target
; 656  : 	if( FBitSet( pev->spawnflags, SF_DOOR_START_OPEN ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	test	edx, edx
	je	SHORT $L37729

; 658  : 		UTIL_FireTargets( pev->netname, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 660  : 	else

	jmp	SHORT $L37730
$L37729:

; 662  : 		UTIL_FireTargets( pev->message, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+468]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L37730:

; 664  : 
; 665  : 	if( FBitSet( pev->spawnflags, SF_DOOR_ONOFF_MODE ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L37731

; 666  : 		SUB_UseTargets( m_hActivator, USE_OFF, 0 ); 

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets

; 667  : 	else SUB_UseTargets( m_hActivator, USE_TOGGLE, 0 ); // this isn't finished

	jmp	SHORT $L37732
$L37731:
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L37732:

; 668  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorHitTop@CBaseDoor@@QAEXXZ ENDP			; CBaseDoor::DoorHitTop
_TEXT	ENDS
;	COMDAT ?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z PROC NEAR		; STOP_SOUND, COMDAT

; 614  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 615  : 	EMIT_SOUND_DYN( entity, channel, sample, 0, 0, SND_STOP, PITCH_NORM );

	push	100					; 00000064H
	push	32					; 00000020H
	push	0
	push	0
	mov	eax, DWORD PTR _sample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _channel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entity$[ebp]
	push	edx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 616  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z ENDP			; STOP_SOUND
_TEXT	ENDS
PUBLIC	?GetLocalTime@CBaseEntity@@QBEMXZ		; CBaseEntity::GetLocalTime
;	COMDAT ?SetMoveDoneTime@CBaseEntity@@QAEXM@Z
_TEXT	SEGMENT
_flDelay$ = 8
_this$ = -4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z PROC NEAR		; CBaseEntity::SetMoveDoneTime, COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 799  : 	if( flDelay >= 0 )

	fld	DWORD PTR _flDelay$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L35183

; 800  : 		m_flMoveDoneTime = GetLocalTime() + flDelay;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalTime@CBaseEntity@@QBEMXZ	; CBaseEntity::GetLocalTime
	fadd	DWORD PTR _flDelay$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+44]

; 801  : 	else m_flMoveDoneTime = -1;

	jmp	SHORT $L35184
$L35183:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], -1082130432		; bf800000H
$L35184:

; 802  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMoveDoneTime@CBaseEntity@@QAEXM@Z ENDP		; CBaseEntity::SetMoveDoneTime
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalTime@CBaseEntity@@QBEMXZ PROC NEAR		; CBaseEntity::GetLocalTime, COMDAT

; 788  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 789  : 	return pev->ltime; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+256]

; 790  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalTime@CBaseEntity@@QBEMXZ ENDP			; CBaseEntity::GetLocalTime
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DoorGoDown@CBaseDoor@@QAEXXZ@4FA ; `CBaseDoor::DoorGoDown'::`2'::__LINE__Var
PUBLIC	??_C@_0DC@DIAC@m_iState?5?$DN?$DN?5STATE_ON?5?$HM?$HM?5m_iState@ ; `string'
;	COMDAT ?__LINE__Var@?1??DoorGoDown@CBaseDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorGoDown@CBaseDoor@@QAEXXZ@4FA DW 029fH ; `CBaseDoor::DoorGoDown'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DC@DIAC@m_iState?5?$DN?$DN?5STATE_ON?5?$HM?$HM?5m_iState@
CONST	SEGMENT
??_C@_0DC@DIAC@m_iState?5?$DN?$DN?5STATE_ON?5?$HM?$HM?5m_iState@ DB 'm_iS'
	DB	'tate == STATE_ON || m_iState == STATE_TURN_ON', 00H ; `string'
CONST	ENDS
;	COMDAT ?DoorGoDown@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorGoDown@CBaseDoor@@QAEXXZ PROC NEAR			; CBaseDoor::DoorGoDown, COMDAT

; 671  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 672  : 	if( !FBitSet( pev->spawnflags, SF_DOOR_SILENT ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, -2147483648			; 80000000H
	test	edx, edx
	jne	SHORT $L37737

; 673  : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37737:

; 674  : 	
; 675  : 	ASSERT( m_iState == STATE_ON || m_iState == STATE_TURN_ON );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1788], 1
	je	SHORT $L39449
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 2
	je	SHORT $L39449
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L39450
$L39449:
	mov	DWORD PTR -8+[ebp], 1
$L39450:
	push	0
	movsx	edx, WORD PTR ?__LINE__Var@?1??DoorGoDown@CBaseDoor@@QAEXXZ@4FA ; `CBaseDoor::DoorGoDown'::`2'::__LINE__Var
	add	edx, 4
	push	edx
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0DC@DIAC@m_iState?5?$DN?$DN?5STATE_ON?5?$HM?$HM?5m_iState@ ; `string'
	mov	eax, DWORD PTR -8+[ebp]
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 676  : 	m_iState = STATE_TURN_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 3

; 677  : 
; 678  : 	SetMoveDone( DoorHitBottom );

	push	OFFSET FLAT:??_C@_0O@HLMI@DoorHitBottom?$AA@ ; `string'
	push	OFFSET FLAT:?DoorHitBottom@CBaseDoor@@QAEXXZ ; CBaseDoor::DoorHitBottom
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 679  : 
; 680  : 	if( IsRotatingDoor( ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+344]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L37743

; 681  : 		AngularMove( m_vecAngle1, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AngularMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::AngularMove

; 682  : 	else LinearMove( m_vecPosition1, pev->speed );

	jmp	SHORT $L37744
$L37743:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+504]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1840				; 00000730H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove
$L37744:

; 683  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorGoDown@CBaseDoor@@QAEXXZ ENDP			; CBaseDoor::DoorGoDown
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DoorHitBottom@CBaseDoor@@QAEXXZ@4FA ; `CBaseDoor::DoorHitBottom'::`2'::__LINE__Var
PUBLIC	??_C@_0BL@KAOG@m_iState?5?$DN?$DN?5STATE_TURN_OFF?$AA@ ; `string'
;	COMDAT ?__LINE__Var@?1??DoorHitBottom@CBaseDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorHitBottom@CBaseDoor@@QAEXXZ@4FA DW 02aeH ; `CBaseDoor::DoorHitBottom'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BL@KAOG@m_iState?5?$DN?$DN?5STATE_TURN_OFF?$AA@
CONST	SEGMENT
??_C@_0BL@KAOG@m_iState?5?$DN?$DN?5STATE_TURN_OFF?$AA@ DB 'm_iState == ST'
	DB	'ATE_TURN_OFF', 00H				; `string'
CONST	ENDS
;	COMDAT ?DoorHitBottom@CBaseDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorHitBottom@CBaseDoor@@QAEXXZ PROC NEAR		; CBaseDoor::DoorHitBottom, COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 687  : 	if( !FBitSet( pev->spawnflags, SF_DOOR_SILENT ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, -2147483648			; 80000000H
	test	edx, edx
	jne	SHORT $L37749

; 689  : 		STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 690  : 		EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise2 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+496]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L37749:

; 692  : 
; 693  : 	ASSERT( m_iState == STATE_TURN_OFF );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??DoorHitBottom@CBaseDoor@@QAEXXZ@4FA ; `CBaseDoor::DoorHitBottom'::`2'::__LINE__Var
	add	eax, 7
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BL@KAOG@m_iState?5?$DN?$DN?5STATE_TURN_OFF?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1788], 3
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 694  : 	m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 695  : 
; 696  : 	// re-instate touch method, cycle is complete
; 697  : 	if( FBitSet( pev->spawnflags, SF_DOOR_USE_ONLY ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L37753

; 699  : 		// use only door
; 700  : 		SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 702  : 	else

	jmp	SHORT $L37756
$L37753:

; 704  : 		// touchable door
; 705  : 		SetTouch( DoorTouch );

	push	OFFSET FLAT:??_C@_09PFID@DoorTouch?$AA@	; `string'
	push	OFFSET FLAT:?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ; CBaseDoor::DoorTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
$L37756:

; 707  : 
; 708  : 	// fire the close target (if startopen is set, then "top" is closed) - netname is the close target
; 709  : 	if( !FBitSet( pev->spawnflags, SF_DOOR_START_OPEN ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37759

; 711  : 		UTIL_FireTargets( pev->netname, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 713  : 	else

	jmp	SHORT $L37760
$L37759:

; 715  : 		UTIL_FireTargets( pev->message, m_hActivator, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L37760:

; 717  : 
; 718  : 	if( FBitSet( pev->spawnflags, SF_DOOR_ONOFF_MODE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 4
	test	edx, edx
	je	SHORT $L37761

; 719  : 		SUB_UseTargets( m_hActivator, USE_ON, 0 );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets

; 720  : 	else SUB_UseTargets( m_hActivator, USE_TOGGLE, 0 );

	jmp	SHORT $L37762
$L37761:
	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L37762:

; 721  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorHitBottom@CBaseDoor@@QAEXXZ ENDP			; CBaseDoor::DoorHitBottom
_TEXT	ENDS
EXTRN	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z:NEAR	; FClassnameIs
;	COMDAT ?GetDoorMovementGroup@CBaseDoor@@QAEHQAPAV1@H@Z
_TEXT	SEGMENT
_pDoorList$ = 8
_listMax$ = 12
_this$ = -4
_pTarget$ = -8
_count$ = -12
_pDoor$37775 = -16
?GetDoorMovementGroup@CBaseDoor@@QAEHQAPAV1@H@Z PROC NEAR ; CBaseDoor::GetDoorMovementGroup, COMDAT

; 725  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 	CBaseEntity *pTarget = NULL;

	mov	DWORD PTR _pTarget$[ebp], 0

; 727  : 	int count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 728  : 
; 729  : 	// block all door pieces with the same targetname here.
; 730  : 	if( !FStringNull( pev->targetname ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L37773
$L37772:

; 732  : 		while(( pTarget = UTIL_FindEntityByTargetname( pTarget, STRING( pev->targetname ))) != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax
	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L37773

; 734  : 			if( pTarget != this && FClassnameIs( pTarget, GetClassname() ))

	mov	ecx, DWORD PTR _pTarget$[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $L37777
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L37777

; 736  : 				CBaseDoor *pDoor = (CBaseDoor *)pTarget;

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	DWORD PTR _pDoor$37775[ebp], eax

; 737  : 
; 738  : 				if( pDoor && count < listMax )

	cmp	DWORD PTR _pDoor$37775[ebp], 0
	je	SHORT $L37777
	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _listMax$[ebp]
	jge	SHORT $L37777

; 740  : 					pDoorList[count] = pDoor;

	mov	edx, DWORD PTR _count$[ebp]
	mov	eax, DWORD PTR _pDoorList$[ebp]
	mov	ecx, DWORD PTR _pDoor$37775[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 741  : 					count++;

	mov	edx, DWORD PTR _count$[ebp]
	add	edx, 1
	mov	DWORD PTR _count$[ebp], edx
$L37777:

; 744  : 		}

	jmp	SHORT $L37772
$L37773:

; 746  : 
; 747  : 	return count;

	mov	eax, DWORD PTR _count$[ebp]

; 748  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetDoorMovementGroup@CBaseDoor@@QAEHQAPAV1@H@Z ENDP	; CBaseDoor::GetDoorMovementGroup
_TEXT	ENDS
PUBLIC	?Blocked@CBaseDoor@@UAEXPAVCBaseEntity@@@Z	; CBaseDoor::Blocked
EXTRN	?g_ulFrameCount@@3KA:DWORD			; g_ulFrameCount
EXTRN	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalOrigin
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
EXTRN	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAvelocity
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT ?Blocked@CBaseDoor@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
_pDoorList$37788 = -260
_doorCount$37789 = -264
_i$37790 = -268
_pDoor$37794 = -272
?Blocked@CBaseDoor@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CBaseDoor::Blocked, COMDAT

; 751  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 752  : 	// hurt the blocker a little.
; 753  : 	if( pev->dmg ) pOther->TakeDamage( pev, pev, pev->dmg, DMG_CRUSH );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L37782
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+480]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]
$L37782:

; 754  : 
; 755  : 	// if a door has a negative wait, it would never come back if blocked,
; 756  : 	// so let it just squash the object to death real fast
; 757  : 	if( m_flWait >= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37786

; 759  : 		if( !FBitSet( pev->spawnflags, SF_DOOR_SILENT ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, -2147483648			; 80000000H
	test	eax, eax
	jne	SHORT $L37784

; 760  : 			STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+492]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH
$L37784:

; 761  : 
; 762  : 		if( m_iState == STATE_TURN_OFF )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 3
	jne	SHORT $L37785

; 764  : 			DoorGoUp();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoUp@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoUp

; 766  : 		else

	jmp	SHORT $L37786
$L37785:

; 768  : 			DoorGoDown();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoDown@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoDown
$L37786:

; 771  : 
; 772  : 	// block all door pieces with the same targetname here.
; 773  : 	if( !FStringNull( pev->targetname ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+460]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	$L37793

; 775  : 		CBaseDoor *pDoorList[64];
; 776  : 		int doorCount = GetDoorMovementGroup( pDoorList, ARRAYSIZE( pDoorList ));

	push	64					; 00000040H
	lea	edx, DWORD PTR _pDoorList$37788[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetDoorMovementGroup@CBaseDoor@@QAEHQAPAV1@H@Z ; CBaseDoor::GetDoorMovementGroup
	mov	DWORD PTR _doorCount$37789[ebp], eax

; 777  : 
; 778  : 		for( int i = 0; i < doorCount; i++ )

	mov	DWORD PTR _i$37790[ebp], 0
	jmp	SHORT $L37791
$L37792:
	mov	eax, DWORD PTR _i$37790[ebp]
	add	eax, 1
	mov	DWORD PTR _i$37790[ebp], eax
$L37791:
	mov	ecx, DWORD PTR _i$37790[ebp]
	cmp	ecx, DWORD PTR _doorCount$37789[ebp]
	jge	$L37793

; 780  : 			CBaseDoor *pDoor = pDoorList[i];

	mov	edx, DWORD PTR _i$37790[ebp]
	mov	eax, DWORD PTR _pDoorList$37788[ebp+edx*4]
	mov	DWORD PTR _pDoor$37794[ebp], eax

; 781  : 
; 782  : 			if( pDoor->m_flWait >= 0)

	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	fld	DWORD PTR [ecx+1764]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L37800

; 784  : 				if( m_bDoorGroup && pDoor->pev->movedir == pev->movedir && pDoor->GetAbsVelocity() == GetAbsVelocity() && pDoor->GetLocalAvelocity() == GetLocalAvelocity( ))

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2024]
	test	eax, eax
	je	$L37798
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _pDoor$37794[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	$L37798
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	$L37798
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L37798

; 786  : 					pDoor->m_iPhysicsFrame = g_ulFrameCount; // don't run physics this frame if you haven't run yet

	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	mov	edx, DWORD PTR ?g_ulFrameCount@@3KA	; g_ulFrameCount
	mov	DWORD PTR [ecx+52], edx

; 787  : 
; 788  : 					// this is the most hacked, evil, bastardized thing I've ever seen. kjb
; 789  : 					if( !pDoor->IsRotatingDoor( ))

	mov	eax, DWORD PTR _pDoor$37794[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	DWORD PTR [edx+344]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L37797

; 791  : 						// set origin to realign normal doors
; 792  : 						pDoor->SetLocalOrigin( GetLocalOrigin( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 793  : 						pDoor->SetAbsVelocity( g_vecZero ); // stop!

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 796  : 					else

	jmp	SHORT $L37798
$L37797:

; 798  : 						// set angles to realign rotating doors
; 799  : 						pDoor->SetLocalAngles( GetLocalAngles( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 800  : 						pDoor->SetLocalAvelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity
$L37798:

; 803  : 			
; 804  : 				if( pDoor->m_iState == STATE_TURN_OFF )

	mov	eax, DWORD PTR _pDoor$37794[ebp]
	cmp	DWORD PTR [eax+1788], 3
	jne	SHORT $L37799

; 805  : 					pDoor->DoorGoUp();

	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?DoorGoUp@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoUp

; 806  : 				else pDoor->DoorGoDown();

	jmp	SHORT $L37800
$L37799:
	mov	ecx, DWORD PTR _pDoor$37794[ebp]
	call	?DoorGoDown@CBaseDoor@@QAEXXZ		; CBaseDoor::DoorGoDown
$L37800:

; 808  : 		}

	jmp	$L37792
$L37793:

; 810  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseDoor@@UAEXPAVCBaseEntity@@@Z ENDP		; CBaseDoor::Blocked
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT
_$E37	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E36
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E37	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCRotDoor@@@@QAE@PBD@Z	; CEntityFactory<CRotDoor>::CEntityFactory<CRotDoor>
PUBLIC	??_C@_0BD@DIJK@func_door_rotating?$AA@		; `string'
_BSS	SEGMENT
_func_door_rotating DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@DIJK@func_door_rotating?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0BD@DIJK@func_door_rotating?$AA@ DB 'func_door_rotating', 00H ; `string'
CONST	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT
_$E36	PROC NEAR					; COMDAT

; 826  : LINK_ENTITY_TO_CLASS( func_door_rotating, CRotDoor );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BD@DIJK@func_door_rotating?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_door_rotating
	call	??0?$CEntityFactory@VCRotDoor@@@@QAE@PBD@Z ; CEntityFactory<CRotDoor>::CEntityFactory<CRotDoor>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E36	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CRotDoor@@UAEXXZ				; CRotDoor::Spawn
PUBLIC	?__LINE__Var@?1??Spawn@CRotDoor@@UAEXXZ@4FA	; `CRotDoor::Spawn'::`2'::__LINE__Var
PUBLIC	??_C@_0CM@FPJH@rotating?5door?5start?1end?5position@ ; `string'
PUBLIC	??_C@_0BL@GFCE@m_vecAngle1?5?$CB?$DN?5m_vecAngle2?$AA@ ; `string'
EXTRN	?AxisDir@CBaseToggle@@SAXPAUentvars_s@@@Z:NEAR	; CBaseToggle::AxisDir
EXTRN	?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z:NEAR	; CBaseEntity::Teleport
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT ?__LINE__Var@?1??Spawn@CRotDoor@@UAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??Spawn@CRotDoor@@UAEXXZ@4FA DW 033dH	; `CRotDoor::Spawn'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CM@FPJH@rotating?5door?5start?1end?5position@
CONST	SEGMENT
??_C@_0CM@FPJH@rotating?5door?5start?1end?5position@ DB 'rotating door st'
	DB	'art/end positions are equal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GFCE@m_vecAngle1?5?$CB?$DN?5m_vecAngle2?$AA@
CONST	SEGMENT
??_C@_0BL@GFCE@m_vecAngle1?5?$CB?$DN?5m_vecAngle2?$AA@ DB 'm_vecAngle1 !='
	DB	' m_vecAngle2', 00H				; `string'
CONST	ENDS
;	COMDAT ?Spawn@CRotDoor@@UAEXXZ
_TEXT	SEGMENT
$T39463 = -28
$T39464 = -40
$T39465 = -52
$T39466 = -64
_this$ = -4
_vecNewAngles$37873 = -16
?Spawn@CRotDoor@@UAEXXZ PROC NEAR			; CRotDoor::Spawn, COMDAT

; 829  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 830  : 	// set the axis of rotation
; 831  : 	AxisDir( pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?AxisDir@CBaseToggle@@SAXPAUentvars_s@@@Z ; CBaseToggle::AxisDir
	add	esp, 4

; 832  : 
; 833  : 	if( FBitSet( pev->spawnflags, SF_DOOR_PASSABLE ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L37861

; 834  : 		pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 835  : 	else pev->solid = SOLID_BSP;

	jmp	SHORT $L37862
$L37861:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 4
$L37862:

; 836  : 
; 837  : 	Precache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 838  : 
; 839  : 	// check for clockwise rotation
; 840  : 	if( FBitSet( pev->spawnflags, SF_DOOR_ROTATE_BACKWARDS ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L37863

; 841  : 		pev->movedir = pev->movedir * -1;

	push	-1082130432				; bf800000H
	lea	eax, DWORD PTR $T39463[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L37863:

; 842  : 	
; 843  : 	m_vecAngle1 = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 844  : 	m_vecAngle2 = GetLocalAngles() + pev->movedir * m_flMoveDistance;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1824]
	push	edx
	lea	eax, DWORD PTR $T39464[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T39465[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 845  : 
; 846  : 	ASSERTSZ( m_vecAngle1 != m_vecAngle2, "rotating door start/end positions are equal" );

	push	OFFSET FLAT:??_C@_0CM@FPJH@rotating?5door?5start?1end?5position@ ; `string'
	movsx	ecx, WORD PTR ?__LINE__Var@?1??Spawn@CRotDoor@@UAEXXZ@4FA ; `CRotDoor::Spawn'::`2'::__LINE__Var
	add	ecx, 17					; 00000011H
	push	ecx
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BL@GFCE@m_vecAngle1?5?$CB?$DN?5m_vecAngle2?$AA@ ; `string'
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1888				; 00000760H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 847  : 
; 848  : 	pev->movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7

; 849  : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 850  : 
; 851  : 	// NOTE: original Half-Life was contain a bug in AngularMove function
; 852  : 	// while m_flWait was equal 0 then object has stopped forever. See code from quake:
; 853  : 	/*
; 854  : 		void AngularMove( Vector vecDest, float flSpeed )
; 855  : 		{
; 856  : 			...
; 857  : 			...
; 858  : 			...
; 859  : 			if( flTravelTime < 0.1f )
; 860  : 			{
; 861  : 				pev->avelocity = g_vecZero;
; 862  : 				pev->nextthink = pev->ltime + 0.1f;
; 863  : 				return;
; 864  : 			}
; 865  : 		}
; 866  : 	*/
; 867  : 	// this block was removed from Half-Life and there no difference
; 868  : 	// between wait = 0 and wait = -1. But in Xash this bug was fixed
; 869  : 	// and level-designer errors is now actual. I'm set m_flWait to -1 for compatibility
; 870  : 	if( m_flWait == 0.0f )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+1764]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37870

; 871  : 		m_flWait = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1764], -1082130432	; bf800000H
$L37870:

; 872  : 
; 873  : 	if( pev->speed == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37871

; 874  : 		pev->speed = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+504], 1120403456		; 42c80000H
$L37871:

; 875  : 	
; 876  : 	// DOOR_START_OPEN is to allow an entity to be lighted in the closed position
; 877  : 	// but spawn in the open position
; 878  : 	if( FBitSet( pev->spawnflags, SF_DOOR_START_OPEN ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	$L37872

; 880  : 		// swap pos1 and pos2, put door at pos2, invert movement direction
; 881  : 		Vector vecNewAngles = m_vecAngle2;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1888				; 00000760H
	push	edx
	lea	ecx, DWORD PTR _vecNewAngles$37873[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 882  : 		m_vecAngle2 = m_vecAngle1;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1876				; 00000754H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 883  : 		m_vecAngle1 = vecNewAngles;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	mov	edx, DWORD PTR _vecNewAngles$37873[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _vecNewAngles$37873[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _vecNewAngles$37873[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 884  : 		pev->movedir = pev->movedir * -1;

	push	-1082130432				; bf800000H
	lea	eax, DWORD PTR $T39466[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 885  : 
; 886  : 		// We've already had our physics setup in BaseClass::Spawn, so teleport to our
; 887  : 		// current position. If we don't do this, our vphysics shadow will not update.
; 888  : 		Teleport( NULL, &m_vecAngle1, NULL );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z ; CBaseEntity::Teleport

; 890  : 	else

	jmp	SHORT $L37875
$L37872:

; 892  : 		SetLocalAngles( m_vecAngle1 );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1876				; 00000754H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles
$L37875:

; 894  : 
; 895  : 	m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 896  : 	RelinkEntity();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 897  : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 898  : 
; 899  : 	if( FBitSet( pev->spawnflags, SF_DOOR_USE_ONLY ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L37876

; 901  : 		SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 903  : 	else

	jmp	SHORT $L37879
$L37876:

; 905  : 		// touchable button
; 906  : 		SetTouch( DoorTouch );

	push	OFFSET FLAT:??_C@_09PFID@DoorTouch?$AA@	; `string'
	push	OFFSET FLAT:?DoorTouch@CBaseDoor@@QAEXPAVCBaseEntity@@@Z ; CBaseDoor::DoorTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
$L37879:

; 908  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CRotDoor@@UAEXXZ ENDP				; CRotDoor::Spawn
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABVVector@@0M@Z		; matrix4x4::matrix4x4
PUBLIC	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z		; matrix4x4::GetAngles
PUBLIC	?OnChangeParent@CRotDoor@@UAEXXZ		; CRotDoor::OnChangeParent
EXTRN	?Invert@matrix4x4@@QBE?AV1@XZ:NEAR		; matrix4x4::Invert
EXTRN	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z:NEAR	; matrix4x4::ConcatTransforms
;	COMDAT ?OnChangeParent@CRotDoor@@UAEXXZ
_TEXT	SEGMENT
_angle1$ = -132
$T39469 = -196
$T39470 = -260
$T39472 = -328
$T39473 = -392
$T39474 = -404
$T39475 = -416
_this$ = -4
_iparent$ = -68
?OnChangeParent@CRotDoor@@UAEXXZ PROC NEAR		; CRotDoor::OnChangeParent, COMDAT

; 911  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 912  : 	matrix4x4 iparent = GetParentToWorldTransform().Invert();

	lea	eax, DWORD PTR $T39470[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39469[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	mov	ecx, eax
	call	?Invert@matrix4x4@@QBE?AV1@XZ		; matrix4x4::Invert
	push	eax
	lea	ecx, DWORD PTR _iparent$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 913  : 	matrix4x4 angle1 = iparent.ConcatTransforms( matrix4x4( g_vecZero, m_vecAngle1 ));

	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1876				; 00000754H
	push	edx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR $T39472[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	push	eax
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T39473[ebp]
	push	eax
	lea	ecx, DWORD PTR _iparent$[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _angle1$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 914  : 
; 915  : 	angle1.GetAngles( m_vecAngle1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	push	ecx
	lea	ecx, DWORD PTR _angle1$[ebp]
	call	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetAngles

; 916  : 
; 917  : 	// just recalc angle2 without transforms
; 918  : 	m_vecAngle2 = m_vecAngle1 + pev->movedir * m_flMoveDistance;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1824]
	push	eax
	lea	ecx, DWORD PTR $T39474[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T39475[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 919  : 
; 920  : 	// update angles if needed
; 921  : 	if( GetState() == STATE_ON )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	cmp	eax, 1
	jne	SHORT $L37895

; 922  : 		SetLocalAngles( m_vecAngle2 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1888				; 00000760H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 923  : 	else if( GetState() == STATE_OFF )

	jmp	SHORT $L37897
$L37895:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	test	eax, eax
	jne	SHORT $L37897

; 924  : 		SetLocalAngles( m_vecAngle1 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1876				; 00000754H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles
$L37897:

; 925  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CRotDoor@@UAEXXZ ENDP			; CRotDoor::OnChangeParent
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
PUBLIC	__real@8@3ff98efa351294e9c800
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_origin$ = 8
_angles$ = 12
_scale$ = 16
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix4x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 701  : 	_forceinline matrix4x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 702  : 	{
; 703  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 704  : 
; 705  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25873

; 707  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 708  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 709  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 710  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 711  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 712  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 713  : 
; 714  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 715  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 716  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 717  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 718  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 719  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 720  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 721  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 722  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 723  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 724  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 725  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 726  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 727  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 728  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 729  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 731  : 		else if( angles[PITCH] )

	jmp	$L25878
$L25873:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25875

; 733  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 734  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 735  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 736  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 737  : 
; 738  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 739  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 741  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 742  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 743  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 744  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 745  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 746  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 747  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 748  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 749  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 750  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 751  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 752  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 753  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 755  : 		else if( angles[YAW] )

	jmp	$L25878
$L25875:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25877

; 757  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 758  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 759  : 
; 760  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 761  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 762  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 763  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 764  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 765  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 766  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 767  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 768  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 769  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 770  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 771  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 772  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 773  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 774  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 775  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 777  : 		else

	jmp	$L25878
$L25877:

; 779  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 780  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 781  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 782  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 783  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 784  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 785  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 786  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 787  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 788  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 789  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 790  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 791  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 792  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 793  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 794  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
$L25878:

; 796  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix4x4@@QAE@ABVVector@@0M@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QAEPAMXZ PROC NEAR				; Vector4D::operator float *, COMDAT

; 325  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
PUBLIC	?GetAngles@matrix4x4@@QAE?AVVector@@XZ		; matrix4x4::GetAngles
;	COMDAT ?GetAngles@matrix4x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT
_angles$ = 8
_this$ = -4
$T39490 = -16
?GetAngles@matrix4x4@@QAEXAAVVector@@@Z PROC NEAR	; matrix4x4::GetAngles, COMDAT

; 1014 : 	void	GetAngles( Vector &angles ) { angles = GetAngles(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T39490[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAngles@matrix4x4@@QAE?AVVector@@XZ	; matrix4x4::GetAngles
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix4x4@@QAEXAAVVector@@@Z ENDP		; matrix4x4::GetAngles
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	__real@4@3ff583126f0000000000
PUBLIC	__real@4@4004e52ee10000000000
EXTRN	_atan2:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT __real@4@3ff583126f0000000000
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@4@3ff583126f0000000000 DD 03a83126fr	; 0.001
CONST	ENDS
;	COMDAT __real@4@4004e52ee10000000000
CONST	SEGMENT
__real@4@4004e52ee10000000000 DD 042652ee1r	; 57.2958
CONST	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_xyDist$ = -8
_angles$ = -20
?GetAngles@matrix4x4@@QAE?AVVector@@XZ PROC NEAR	; matrix4x4::GetAngles, COMDAT

; 993  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 994  : 		float xyDist = sqrt( mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -24+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _xyDist$[ebp]

; 995  : 		Vector angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 996  : 
; 997  : 		// enough here to get angles?
; 998  : 		if( xyDist > 0.001f )

	fld	DWORD PTR _xyDist$[ebp]
	fcomp	DWORD PTR __real@4@3ff583126f0000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L25975

; 1000 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -28+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -32+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax], ecx

; 1001 : 			angles[1] = RAD2DEG( atan2( mat[0][1], mat[0][0] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -36+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -40+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+4], edx

; 1002 : 			angles[2] = RAD2DEG( atan2( mat[1][2], mat[2][2] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -44+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -48+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1004 : 		else	// forward is mostly Z, gimbal lock

	jmp	$L25982
$L25975:

; 1006 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -52+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -56+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax], edx

; 1007 : 			angles[1] = RAD2DEG( atan2( -mat[1][0], mat[1][1] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -60+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -64+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1008 : 			angles[2] = 0;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0
$L25982:

; 1010 : 
; 1011 : 		return angles;

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1012 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix4x4@@QAE?AVVector@@XZ ENDP		; matrix4x4::GetAngles
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
PUBLIC	?OnClearParent@CRotDoor@@UAEXXZ			; CRotDoor::OnClearParent
EXTRN	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsAngles
;	COMDAT ?OnClearParent@CRotDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_parent$ = -68
_angle1$ = -132
$T39501 = -196
$T39503 = -264
$T39504 = -328
$T39505 = -340
$T39506 = -352
?OnClearParent@CRotDoor@@UAEXXZ PROC NEAR		; CRotDoor::OnClearParent, COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 929  : 	matrix4x4 parent = GetParentToWorldTransform();

	lea	eax, DWORD PTR $T39501[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _parent$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 930  : 	matrix4x4 angle1 = parent.ConcatTransforms( matrix4x4( g_vecZero, m_vecAngle1 ));

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	push	ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR $T39503[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	push	eax
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	edx, DWORD PTR $T39504[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _angle1$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 931  : 
; 932  : 	angle1.GetAngles( m_vecAngle1 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1876				; 00000754H
	push	eax
	lea	ecx, DWORD PTR _angle1$[ebp]
	call	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetAngles

; 933  : 
; 934  : 	// just recalc angle2 without transforms
; 935  : 	m_vecAngle2 = m_vecAngle1 + pev->movedir * m_flMoveDistance;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1824]
	push	edx
	lea	eax, DWORD PTR $T39505[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T39506[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 936  : 
; 937  : 	// update angles if needed
; 938  : 	if( GetState() == STATE_ON )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	cmp	eax, 1
	jne	SHORT $L37910

; 939  : 		SetAbsAngles( m_vecAngle2 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1888				; 00000760H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 940  : 	else if( GetState() == STATE_OFF )

	jmp	SHORT $L37912
$L37910:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	test	eax, eax
	jne	SHORT $L37912

; 941  : 		SetAbsAngles( m_vecAngle1 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1876				; 00000754H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles
$L37912:

; 942  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CRotDoor@@UAEXXZ ENDP			; CRotDoor::OnClearParent
_TEXT	ENDS
PUBLIC	?SetToggleState@CRotDoor@@UAEXH@Z		; CRotDoor::SetToggleState
;	COMDAT ?SetToggleState@CRotDoor@@UAEXH@Z
_TEXT	SEGMENT
_state$ = 8
_this$ = -4
?SetToggleState@CRotDoor@@UAEXH@Z PROC NEAR		; CRotDoor::SetToggleState, COMDAT

; 945  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 946  : 	if( (STATE)state == STATE_ON )

	cmp	DWORD PTR _state$[ebp], 1
	jne	SHORT $L37918

; 947  : 		SetLocalAngles( m_vecAngle2 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1888				; 00000760H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 948  : 	else SetLocalAngles( m_vecAngle1 );

	jmp	SHORT $L37919
$L37918:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles
$L37919:

; 949  : 
; 950  : 	RelinkEntity( TRUE );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 951  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CRotDoor@@UAEXH@Z ENDP			; CRotDoor::SetToggleState
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT
_$E41	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E40
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E41	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCMomentaryDoor@@@@QAE@PBD@Z ; CEntityFactory<CMomentaryDoor>::CEntityFactory<CMomentaryDoor>
PUBLIC	??_C@_0P@GFNB@momentary_door?$AA@		; `string'
_BSS	SEGMENT
_momentary_door DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0P@GFNB@momentary_door?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0P@GFNB@momentary_door?$AA@ DB 'momentary_door', 00H ; `string'
CONST	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT
_$E40	PROC NEAR					; COMDAT

; 978  : LINK_ENTITY_TO_CLASS( momentary_door, CMomentaryDoor );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0P@GFNB@momentary_door?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_momentary_door
	call	??0?$CEntityFactory@VCMomentaryDoor@@@@QAE@PBD@Z ; CEntityFactory<CMomentaryDoor>::CEntityFactory<CMomentaryDoor>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E40	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CMomentaryDoor@@UAEPAUdatamap_s@@XZ ; CMomentaryDoor::GetDataDescMap
;	COMDAT ?GetDataDescMap@CMomentaryDoor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CMomentaryDoor@@UAEPAUdatamap_s@@XZ PROC NEAR ; CMomentaryDoor::GetDataDescMap, COMDAT

; 980  : BEGIN_DATADESC( CMomentaryDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A ; CMomentaryDoor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CMomentaryDoor@@UAEPAUdatamap_s@@XZ ENDP ; CMomentaryDoor::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CMomentaryDoor@@SAPAUdatamap_s@@XZ	; CMomentaryDoor::GetBaseMap
;	COMDAT ?GetBaseMap@CMomentaryDoor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CMomentaryDoor@@SAPAUdatamap_s@@XZ PROC NEAR ; CMomentaryDoor::GetBaseMap, COMDAT

; 980  : BEGIN_DATADESC( CMomentaryDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CMomentaryDoor@@SAPAUdatamap_s@@XZ ENDP	; CMomentaryDoor::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT
_$E44	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E43
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E44	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z ; DataMapInit
;	COMDAT _$E43
_TEXT	SEGMENT
_$E43	PROC NEAR					; COMDAT

; 980  : BEGIN_DATADESC( CMomentaryDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CMomentaryDoor_DataDescInit@@3PAUdatamap_s@@A, eax ; CMomentaryDoor_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E43	ENDP
_TEXT	ENDS
PUBLIC	?StopMoveSound@CMomentaryDoor@@QAEXXZ		; CMomentaryDoor::StopMoveSound
PUBLIC	??_C@_0O@JEAE@StopMoveSound?$AA@		; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0O@JEAE@StopMoveSound?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0O@JEAE@StopMoveSound?$AA@ DB 'StopMoveSound', 00H ; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z PROC NEAR ; DataMapInit, COMDAT

; 980  : BEGIN_DATADESC( CMomentaryDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38038
	mov	cl, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0P@PNBF@CMomentaryDoor?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E47
	call	_atexit
	add	esp, 4
$L38038:
	call	?GetBaseMap@CMomentaryDoor@@SAPAUdatamap_s@@XZ ; CMomentaryDoor::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A+12, eax

; 981  : 	DEFINE_KEYFIELD( m_iMoveSnd, FIELD_STRING, "movesnd" ),
; 982  : 	DEFINE_FUNCTION( StopMoveSound ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L38044
	mov	al, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0O@JEAE@StopMoveSound?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A+52, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A+56, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A+60, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A+62, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A+64, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A+68, OFFSET FLAT:?StopMoveSound@CMomentaryDoor@@QAEXXZ ; CMomentaryDoor::StopMoveSound
$L38044:

; 983  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38048
	mov	DWORD PTR ?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A+4, 2
	mov	DWORD PTR ?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38049
$L38048:
	mov	DWORD PTR ?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4PAUtypedescription_s@@A
$L38049:
	mov	eax, OFFSET FLAT:?m_DataMap@CMomentaryDoor@@2Udatamap_s@@A ; CMomentaryDoor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCMomentaryDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E47	ENDP
_TEXT	ENDS
PUBLIC	?Precache@CMomentaryDoor@@UAEXXZ		; CMomentaryDoor::Precache
;	COMDAT ?Precache@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_m_sound$ = -8
?Precache@CMomentaryDoor@@UAEXXZ PROC NEAR		; CMomentaryDoor::Precache, COMDAT

; 986  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 	int m_sound = UTIL_LoadSoundPreset( m_iMoveSnd );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 991  : 	{

	mov	edx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 8
	ja	$L38069
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L39527[eax*4]
$L38060:

; 992  : 	case 1:
; 993  : 		pev->noise = UTIL_PrecacheSound( "doors/doormove1.wav" );

	push	OFFSET FLAT:??_C@_0BE@EMFL@doors?1doormove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 994  : 		break;

	jmp	$L38057
$L38061:

; 995  : 	case 2:
; 996  : 		pev->noise = UTIL_PrecacheSound( "doors/doormove2.wav" );

	push	OFFSET FLAT:??_C@_0BE@KMDE@doors?1doormove2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 997  : 		break;

	jmp	$L38057
$L38062:

; 998  : 	case 3:
; 999  : 		pev->noise = UTIL_PrecacheSound( "doors/doormove3.wav" );

	push	OFFSET FLAT:??_C@_0BE@MBB@doors?1doormove3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 1000 : 		break;

	jmp	$L38057
$L38063:

; 1001 : 	case 4:
; 1002 : 		pev->noise = UTIL_PrecacheSound( "doors/doormove4.wav" );

	push	OFFSET FLAT:??_C@_0BE@GMOL@doors?1doormove4?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 1003 : 		break;

	jmp	$L38057
$L38064:

; 1004 : 	case 5:
; 1005 : 		pev->noise = UTIL_PrecacheSound( "doors/doormove5.wav" );

	push	OFFSET FLAT:??_C@_0BE@MMMO@doors?1doormove5?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 1006 : 		break;

	jmp	$L38057
$L38065:

; 1007 : 	case 6:
; 1008 : 		pev->noise = UTIL_PrecacheSound( "doors/doormove6.wav" );

	push	OFFSET FLAT:??_C@_0BE@CMKB@doors?1doormove6?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 1009 : 		break;

	jmp	SHORT $L38057
$L38066:

; 1010 : 	case 7:
; 1011 : 		pev->noise = UTIL_PrecacheSound( "doors/doormove7.wav" );

	push	OFFSET FLAT:??_C@_0BE@IMIE@doors?1doormove7?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 1012 : 		break;

	jmp	SHORT $L38057
$L38067:

; 1013 : 	case 8:
; 1014 : 		pev->noise = UTIL_PrecacheSound( "doors/doormove8.wav" );

	push	OFFSET FLAT:??_C@_0BE@ONFE@doors?1doormove8?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 1015 : 		break;

	jmp	SHORT $L38057
$L38068:

; 1016 : 	case 0:
; 1017 : 		pev->noise = MAKE_STRING( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax

; 1018 : 		break;

	jmp	SHORT $L38057
$L38069:

; 1019 : 	default:
; 1020 : 		pev->noise = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+488], eax
$L38057:

; 1023 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L39527:
	DD	$L38068
	DD	$L38060
	DD	$L38061
	DD	$L38062
	DD	$L38063
	DD	$L38064
	DD	$L38065
	DD	$L38066
	DD	$L38067
?Precache@CMomentaryDoor@@UAEXXZ ENDP			; CMomentaryDoor::Precache
_TEXT	ENDS
PUBLIC	?KeyValue@CMomentaryDoor@@UAEXPAUKeyValueData_s@@@Z ; CMomentaryDoor::KeyValue
;	COMDAT ?KeyValue@CMomentaryDoor@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CMomentaryDoor@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CMomentaryDoor::KeyValue, COMDAT

; 1026 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1027 : 	if( FStrEq( pkvd->szKeyName, "movesnd" ))

	push	OFFSET FLAT:??_C@_07HPHJ@movesnd?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38074

; 1029 : 		m_iMoveSnd = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1956], eax

; 1030 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1032 : 	else BaseClass::KeyValue( pkvd );

	jmp	SHORT $L38075
$L38074:
	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z ; CBaseToggle::KeyValue
$L38075:

; 1033 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CMomentaryDoor@@UAEXPAUKeyValueData_s@@@Z ENDP ; CMomentaryDoor::KeyValue
_TEXT	ENDS
PUBLIC	?Spawn@CMomentaryDoor@@UAEXXZ			; CMomentaryDoor::Spawn
;	COMDAT ?Spawn@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecSize$38088 = -16
$T39532 = -28
$T39533 = -40
$T39534 = -52
$T39535 = -64
$T39536 = -76
?Spawn@CMomentaryDoor@@UAEXXZ PROC NEAR			; CMomentaryDoor::Spawn, COMDAT

; 1036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1037 : 	if( FBitSet( pev->spawnflags, SF_DOOR_PASSABLE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 8
	test	edx, edx
	je	SHORT $L38080

; 1038 : 		pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 1039 : 	else

	jmp	SHORT $L38081
$L38080:

; 1040 : 		pev->solid = SOLID_BSP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 4
$L38081:

; 1041 : 
; 1042 : 	pev->movetype = MOVETYPE_PUSH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 7

; 1043 : 
; 1044 : 	if( pev->speed <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38082

; 1045 : 		pev->speed = 100;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+504], 1120403456		; 42c80000H
$L38082:

; 1046 : 
; 1047 : 	if( pev->movedir == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L38083

; 1048 : 		pev->movedir = Vector( 1.0f, 0.0f, 0.0f );

	push	0
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T39532[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L38083:

; 1049 : 
; 1050 : 	Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 1051 : 	SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1052 : 
; 1053 : 	SET_MODEL( edict(), GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1054 : 
; 1055 : 	// if move distance is set to zero, use with width of the 
; 1056 : 	// brush to determine the size of the move distance
; 1057 : 	if( m_flMoveDistance <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1824]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L38087

; 1059 : 		Vector vecSize = pev->size - Vector( 2, 2, 2 );

	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR $T39533[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T39534[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecSize$38088[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1060 : 		m_flMoveDistance = DotProductAbs( pev->movedir, vecSize ) - m_flLip;

	lea	eax, DWORD PTR _vecSize$38088[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	push	edx
	call	?DotProductAbs@@YAMABVVector@@0@Z	; DotProductAbs
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [eax+1828]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1824]
$L38087:

; 1062 : 
; 1063 : 	m_vecPosition1 = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1840				; 00000730H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1064 : 	m_vecPosition2 = m_vecPosition1 + (pev->movedir * m_flMoveDistance);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1824]
	push	edx
	lea	eax, DWORD PTR $T39535[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T39536[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1065 : 
; 1066 : 	if( FBitSet( pev->spawnflags, SF_DOOR_START_OPEN ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $L38093

; 1068 : 		UTIL_SetOrigin( this, m_vecPosition2 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1069 : 
; 1070 : 		// NOTE: momentary door doesn't have absolute positions
; 1071 : 		// so we need swap it here for right movement
; 1072 : 		m_vecPosition2 = m_vecPosition1;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1840				; 00000730H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1073 : 		m_vecPosition1 = GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1075 : 	else

	jmp	SHORT $L38094
$L38093:

; 1077 : 		UTIL_SetOrigin( this, m_vecPosition1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8
$L38094:

; 1079 : 
; 1080 : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 1081 : 	m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 1082 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CMomentaryDoor@@UAEXXZ ENDP			; CMomentaryDoor::Spawn
_TEXT	ENDS
PUBLIC	?OnChangeParent@CMomentaryDoor@@UAEXXZ		; CMomentaryDoor::OnChangeParent
;	COMDAT ?OnChangeParent@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_parent$ = -68
$T39539 = -132
$T39540 = -144
$T39541 = -156
?OnChangeParent@CMomentaryDoor@@UAEXXZ PROC NEAR	; CMomentaryDoor::OnChangeParent, COMDAT

; 1085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 	matrix4x4 parent = GetParentToWorldTransform();

	lea	eax, DWORD PTR $T39539[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _parent$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 1087 : 	m_vecPosition1 = parent.VectorITransform( m_vecPosition1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	lea	edx, DWORD PTR $T39540[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1088 : 	m_vecPosition2 = parent.VectorITransform( m_vecPosition2 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	lea	edx, DWORD PTR $T39541[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1089 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CMomentaryDoor@@UAEXXZ ENDP		; CMomentaryDoor::OnChangeParent
_TEXT	ENDS
PUBLIC	?OnClearParent@CMomentaryDoor@@UAEXXZ		; CMomentaryDoor::OnClearParent
;	COMDAT ?OnClearParent@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_parent$ = -68
$T39544 = -132
$T39545 = -144
$T39546 = -156
?OnClearParent@CMomentaryDoor@@UAEXXZ PROC NEAR		; CMomentaryDoor::OnClearParent, COMDAT

; 1092 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1093 : 	matrix4x4 parent = GetParentToWorldTransform();

	lea	eax, DWORD PTR $T39544[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _parent$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 1094 : 	m_vecPosition1 = parent.VectorTransform( m_vecPosition1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	lea	edx, DWORD PTR $T39545[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1095 : 	m_vecPosition2 = parent.VectorTransform( m_vecPosition2 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	lea	edx, DWORD PTR $T39546[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1096 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CMomentaryDoor@@UAEXXZ ENDP		; CMomentaryDoor::OnClearParent
_TEXT	ENDS
PUBLIC	?Use@CMomentaryDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CMomentaryDoor::Use
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@4002a000000000000000
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z:NEAR ; CBaseDelay::IsLockedByMaster
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@4002a000000000000000
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT ?Use@CMomentaryDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_value$ = 20
_this$ = -4
_speed$ = -8
_move$ = -20
_delta$38132 = -32
$T39553 = -44
$T39554 = -56
$T39555 = -68
$T39556 = -80
?Use@CMomentaryDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CMomentaryDoor::Use, COMDAT

; 1099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1100 : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1101 : 
; 1102 : 	if( IsLockedByMaster( pActivator ))

	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L38118

; 1103 : 		return;

	jmp	$L38117
$L38118:

; 1104 : 
; 1105 : 	if( useType == USE_RESET )

	cmp	DWORD PTR _useType$[ebp], 4
	jne	SHORT $L38119

; 1107 : 		// stop moving immediately
; 1108 : 		MoveDone();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+288]

; 1109 : 		return;

	jmp	$L38117
$L38119:

; 1111 : 
; 1112 : 	float speed = 0.0f;

	mov	DWORD PTR _speed$[ebp], 0

; 1113 : 
; 1114 : 	// allow on-off mode that simulate standard door
; 1115 : 	if( FBitSet( pev->spawnflags, SF_DOOR_ONOFF_MODE ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 4
	test	eax, eax
	je	SHORT $L38124

; 1117 : 		if( useType == USE_ON )

	cmp	DWORD PTR _useType$[ebp], 1
	jne	SHORT $L38122

; 1119 : 			useType = USE_SET;

	mov	DWORD PTR _useType$[ebp], 2

; 1120 : 			value = 1.0f;

	mov	DWORD PTR _value$[ebp], 1065353216	; 3f800000H

; 1122 : 		else if( useType == USE_OFF )

	jmp	SHORT $L38124
$L38122:
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L38124

; 1124 : 			useType = USE_SET;

	mov	DWORD PTR _useType$[ebp], 2

; 1125 : 			value = 0.0f;

	mov	DWORD PTR _value$[ebp], 0
$L38124:

; 1128 : 
; 1129 : 	// momentary buttons will pass down a float in here
; 1130 : 	if( useType != USE_SET ) return;

	cmp	DWORD PTR _useType$[ebp], 2
	je	SHORT $L38125
	jmp	$L38117
$L38125:

; 1131 : 
; 1132 : 	value = bound( 0.0f, value, 1.0f );

	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39551
	fld	DWORD PTR _value$[ebp]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39549
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR -84+[ebp], ecx
	jmp	SHORT $L39550
$L39549:
	mov	DWORD PTR -84+[ebp], 1065353216		; 3f800000H
$L39550:
	mov	edx, DWORD PTR -84+[ebp]
	mov	DWORD PTR -88+[ebp], edx
	jmp	SHORT $L39552
$L39551:
	mov	DWORD PTR -88+[ebp], 0
$L39552:
	mov	eax, DWORD PTR -88+[ebp]
	mov	DWORD PTR _value$[ebp], eax

; 1133 : 	Vector move = m_vecPosition1 + (value * ( m_vecPosition2 - m_vecPosition1 ));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	lea	edx, DWORD PTR $T39553[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39554[ebp]
	push	ecx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T39555[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _move$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1134 : 
; 1135 : 	// NOTE: historically momentary_door is completely ignore pev->speed
; 1136 : 	// and get local speed that based on distance between new and current position
; 1137 : 	// with interval 0.1 secs. This flag is allow constant speed like for func_door
; 1138 : 	if( FBitSet( pev->spawnflags, SF_DOOR_CONSTANT_SPEED ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	je	SHORT $L38130

; 1140 : 		speed = pev->speed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+504]
	mov	DWORD PTR _speed$[ebp], edx

; 1142 : 	else

	jmp	SHORT $L38131
$L38130:

; 1144 : 		// classic Valve method to determine speed
; 1145 : 		Vector delta = move - GetLocalOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	eax, DWORD PTR $T39556[ebp]
	push	eax
	lea	ecx, DWORD PTR _move$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _delta$38132[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1146 : 		speed = delta.Length() * 10;

	lea	ecx, DWORD PTR _delta$38132[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fmul	DWORD PTR __real@4@4002a000000000000000
	fstp	DWORD PTR _speed$[ebp]
$L38131:

; 1148 : 
; 1149 : 	if( move != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _move$[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38134

; 1151 : 		// This entity only thinks when it moves, so if it's thinking, it's in the process of moving
; 1152 : 		// play the sound when it starts moving
; 1153 : 		if( m_iState == STATE_OFF ) EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ), 1, ATTN_NORM );

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1788], 0
	jne	SHORT $L38135
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+488]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L38135:

; 1154 : 
; 1155 : 		m_iState = STATE_ON; // we are "in-moving"

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 1

; 1156 : 
; 1157 : 		// clear think (that stops sounds)
; 1158 : 		SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1159 : 
; 1160 : 		LinearMove( move, speed );

	mov	eax, DWORD PTR _speed$[ebp]
	push	eax
	lea	ecx, DWORD PTR _move$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove
$L38134:
$L38117:

; 1162 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CMomentaryDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CMomentaryDoor::Use
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
$T39565 = -12
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T39565[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	?Blocked@CMomentaryDoor@@UAEXPAVCBaseEntity@@@Z	; CMomentaryDoor::Blocked
;	COMDAT ?Blocked@CMomentaryDoor@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?Blocked@CMomentaryDoor@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CMomentaryDoor::Blocked, COMDAT

; 1165 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1166 : 	// hurt the blocker a little.
; 1167 : 	if( pev->dmg ) pOther->TakeDamage( pev, pev, pev->dmg, DMG_CRUSH );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+480]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38143
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+480]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+96]
$L38143:

; 1168 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CMomentaryDoor@@UAEXPAVCBaseEntity@@@Z ENDP	; CMomentaryDoor::Blocked
_TEXT	ENDS
PUBLIC	?MoveDone@CMomentaryDoor@@UAEXXZ		; CMomentaryDoor::MoveDone
EXTRN	?MoveDone@CBaseToggle@@UAEXXZ:NEAR		; CBaseToggle::MoveDone
;	COMDAT ?MoveDone@CMomentaryDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CMomentaryDoor@@UAEXXZ PROC NEAR		; CMomentaryDoor::MoveDone, COMDAT

; 1171 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1172 : 	// stop sounds at the next think, rather than here as another
; 1173 : 	// SetPosition call might immediately follow the end of this move
; 1174 : 	SetThink( StopMoveSound );

	push	OFFSET FLAT:??_C@_0O@JEAE@StopMoveSound?$AA@ ; `string'
	push	OFFSET FLAT:?StopMoveSound@CMomentaryDoor@@QAEXXZ ; CMomentaryDoor::StopMoveSound
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1175 : 	SetNextThink( 0.1f );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1176 : 
; 1177 : 	CBaseToggle::MoveDone();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDone@CBaseToggle@@UAEXXZ		; CBaseToggle::MoveDone

; 1178 : 
; 1179 : 	if( GetLocalOrigin() == m_vecPosition2 )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1852				; 0000073cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L38150

; 1181 : 		SUB_UseTargets( m_hActivator, USE_ON, 0 );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets

; 1183 : 	else if( GetLocalOrigin() == m_vecPosition1 )

	jmp	SHORT $L38152
$L38150:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L38152

; 1185 : 		SUB_UseTargets( m_hActivator, USE_OFF, 0 );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L38152:

; 1187 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CMomentaryDoor@@UAEXXZ ENDP			; CMomentaryDoor::MoveDone
_TEXT	ENDS
;	COMDAT ?StopMoveSound@CMomentaryDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopMoveSound@CMomentaryDoor@@QAEXXZ PROC NEAR		; CMomentaryDoor::StopMoveSound, COMDAT

; 1190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1191 : 	STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+488]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 1192 : 	m_iState = STATE_OFF; // really off

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 1193 : 	SetNextThink( -1 );

	push	-1082130432				; bf800000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1194 : 	SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1195 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopMoveSound@CMomentaryDoor@@QAEXXZ ENDP		; CMomentaryDoor::StopMoveSound
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT
_$E49	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E48
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E49	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCBaseTrainDoor@@@@QAE@PBD@Z ; CEntityFactory<CBaseTrainDoor>::CEntityFactory<CBaseTrainDoor>
PUBLIC	??_C@_0P@MGNF@func_traindoor?$AA@		; `string'
_BSS	SEGMENT
	ALIGN	4

_func_traindoor DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0P@MGNF@func_traindoor?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0P@MGNF@func_traindoor?$AA@ DB 'func_traindoor', 00H ; `string'
CONST	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT

; 1199 : LINK_ENTITY_TO_CLASS( func_traindoor, CBaseTrainDoor );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0P@MGNF@func_traindoor?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_func_traindoor
	call	??0?$CEntityFactory@VCBaseTrainDoor@@@@QAE@PBD@Z ; CEntityFactory<CBaseTrainDoor>::CEntityFactory<CBaseTrainDoor>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBaseTrainDoor@@UAEPAUdatamap_s@@XZ ; CBaseTrainDoor::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBaseTrainDoor@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBaseTrainDoor@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBaseTrainDoor::GetDataDescMap, COMDAT

; 1201 : BEGIN_DATADESC( CBaseTrainDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A ; CBaseTrainDoor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBaseTrainDoor@@UAEPAUdatamap_s@@XZ ENDP ; CBaseTrainDoor::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CBaseTrainDoor@@SAPAUdatamap_s@@XZ	; CBaseTrainDoor::GetBaseMap
;	COMDAT ?GetBaseMap@CBaseTrainDoor@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBaseTrainDoor@@SAPAUdatamap_s@@XZ PROC NEAR ; CBaseTrainDoor::GetBaseMap, COMDAT

; 1201 : BEGIN_DATADESC( CBaseTrainDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBaseTrainDoor@@SAPAUdatamap_s@@XZ ENDP	; CBaseTrainDoor::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT
_$E52	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E51
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E52	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z ; DataMapInit
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT

; 1201 : BEGIN_DATADESC( CBaseTrainDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBaseTrainDoor_DataDescInit@@3PAUdatamap_s@@A, eax ; CBaseTrainDoor_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	?FindTrain@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::FindTrain
PUBLIC	?DoorGoUp@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::DoorGoUp
PUBLIC	?DoorGoDown@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::DoorGoDown
PUBLIC	?DoorHitTop@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::DoorHitTop
PUBLIC	?DoorSlideUp@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::DoorSlideUp
PUBLIC	?DoorSlideDown@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::DoorSlideDown
PUBLIC	?DoorSlideWait@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::DoorSlideWait
PUBLIC	?DoorHitBottom@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::DoorHitBottom
PUBLIC	?ActivateTrain@CBaseTrainDoor@@QAEXXZ		; CBaseTrainDoor::ActivateTrain
PUBLIC	??_C@_09JEL@FindTrain?$AA@			; `string'
PUBLIC	??_C@_0M@JKCM@DoorSlideUp?$AA@			; `string'
PUBLIC	??_C@_0O@HKBE@DoorSlideDown?$AA@		; `string'
PUBLIC	??_C@_0O@DMOF@DoorSlideWait?$AA@		; `string'
PUBLIC	??_C@_0O@CNO@ActivateTrain?$AA@			; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_09JEL@FindTrain?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_09JEL@FindTrain?$AA@ DB 'FindTrain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JKCM@DoorSlideUp?$AA@
CONST	SEGMENT
??_C@_0M@JKCM@DoorSlideUp?$AA@ DB 'DoorSlideUp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HKBE@DoorSlideDown?$AA@
CONST	SEGMENT
??_C@_0O@HKBE@DoorSlideDown?$AA@ DB 'DoorSlideDown', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMOF@DoorSlideWait?$AA@
CONST	SEGMENT
??_C@_0O@DMOF@DoorSlideWait?$AA@ DB 'DoorSlideWait', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CNO@ActivateTrain?$AA@
CONST	SEGMENT
??_C@_0O@CNO@ActivateTrain?$AA@ DB 'ActivateTrain', 00H	; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1201 : BEGIN_DATADESC( CBaseTrainDoor )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L38222
	mov	cl, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0P@CAAP@CBaseTrainDoor?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E55
	call	_atexit
	add	esp, 4
$L38222:
	call	?GetBaseMap@CBaseTrainDoor@@SAPAUdatamap_s@@XZ ; CBaseTrainDoor::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A+12, eax

; 1202 : 	DEFINE_KEYFIELD( m_iMoveSnd, FIELD_STRING, "movesnd" ),
; 1203 : 	DEFINE_KEYFIELD( m_iStopSnd, FIELD_STRING, "stopsnd" ),
; 1204 : 	DEFINE_FIELD( m_vecOldAngles, FIELD_VECTOR ),
; 1205 : 	DEFINE_FIELD( door_state, FIELD_CHARACTER ),
; 1206 : 	DEFINE_FIELD( m_pTrain, FIELD_CLASSPTR ),
; 1207 : 	DEFINE_FIELD( m_vecPosition1, FIELD_VECTOR ), // all traindoor positions are local
; 1208 : 	DEFINE_FIELD( m_vecPosition2, FIELD_VECTOR ),
; 1209 : 	DEFINE_FIELD( m_vecPosition3, FIELD_VECTOR ),
; 1210 : 	DEFINE_FUNCTION( FindTrain ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L38248
	mov	al, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_09JEL@FindTrain?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+220, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+224, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+228, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+230, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+232, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+236, OFFSET FLAT:?FindTrain@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::FindTrain

; 1211 : 	DEFINE_FUNCTION( DoorGoUp ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+240, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_08KCMH@DoorGoUp?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+244, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+248, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+252, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+254, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+256, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+260, OFFSET FLAT:?DoorGoUp@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorGoUp

; 1212 : 	DEFINE_FUNCTION( DoorGoDown ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+264, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0L@NBIL@DoorGoDown?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+268, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+272, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+276, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+278, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+280, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+284, OFFSET FLAT:?DoorGoDown@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorGoDown

; 1213 : 	DEFINE_FUNCTION( DoorHitTop ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+288, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0L@HDCA@DoorHitTop?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+292, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+296, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+300, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+302, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+304, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+308, OFFSET FLAT:?DoorHitTop@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorHitTop

; 1214 : 	DEFINE_FUNCTION( DoorSlideUp ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+312, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0M@JKCM@DoorSlideUp?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+316, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+320, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+324, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+326, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+328, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+332, OFFSET FLAT:?DoorSlideUp@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorSlideUp

; 1215 : 	DEFINE_FUNCTION( DoorSlideDown ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+336, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0O@HKBE@DoorSlideDown?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+340, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+344, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+348, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+350, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+352, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+356, OFFSET FLAT:?DoorSlideDown@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorSlideDown

; 1216 : 	DEFINE_FUNCTION( DoorSlideWait ),		// wait before sliding

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+360, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0O@DMOF@DoorSlideWait?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+364, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+368, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+372, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+374, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+376, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+380, OFFSET FLAT:?DoorSlideWait@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorSlideWait

; 1217 : 	DEFINE_FUNCTION( DoorHitBottom ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+384, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0O@HLMI@DoorHitBottom?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+388, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+392, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+396, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+398, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+400, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+404, OFFSET FLAT:?DoorHitBottom@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorHitBottom

; 1218 : 	DEFINE_FUNCTION( ActivateTrain ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+408, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0O@CNO@ActivateTrain?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+412, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+416, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+420, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+422, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+424, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+428, OFFSET FLAT:?ActivateTrain@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::ActivateTrain
$L38248:

; 1219 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L38272
	mov	DWORD PTR ?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A+4, 17 ; 00000011H
	mov	DWORD PTR ?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L38273
$L38272:
	mov	DWORD PTR ?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4PAUtypedescription_s@@A
$L38273:
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseTrainDoor@@2Udatamap_s@@A ; CBaseTrainDoor::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT
_$E55	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseTrainDoor@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E55	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CBaseTrainDoor@@UAEXPAUKeyValueData_s@@@Z ; CBaseTrainDoor::KeyValue
PUBLIC	??_C@_05HLPG@train?$AA@				; `string'
;	COMDAT ??_C@_05HLPG@train?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_05HLPG@train?$AA@ DB 'train', 00H			; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseTrainDoor@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CBaseTrainDoor@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseTrainDoor::KeyValue, COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1223 : 	if( FStrEq( pkvd->szKeyName, "movesnd" ))

	push	OFFSET FLAT:??_C@_07HPHJ@movesnd?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38279

; 1225 : 		m_iMoveSnd = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1956], eax

; 1226 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1228 : 	else if( FStrEq( pkvd->szKeyName, "stopsnd" ))

	jmp	$L38285
$L38279:
	push	OFFSET FLAT:??_C@_07KHB@stopsnd?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38281

; 1230 : 		m_iStopSnd = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1960], eax

; 1231 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1233 : 	else if( FStrEq( pkvd->szKeyName, "train" ))

	jmp	SHORT $L38285
$L38281:
	push	OFFSET FLAT:??_C@_05HLPG@train?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L38283

; 1235 : 		// g-cont. just a replace movewith name
; 1236 : 		m_iParent = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 1237 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1239 : 	else

	jmp	SHORT $L38285
$L38283:

; 1240 : 		BaseClass::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z ; CBaseToggle::KeyValue
$L38285:

; 1241 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseTrainDoor@@UAEXPAUKeyValueData_s@@@Z ENDP ; CBaseTrainDoor::KeyValue
_TEXT	ENDS
PUBLIC	?Spawn@CBaseTrainDoor@@UAEXXZ			; CBaseTrainDoor::Spawn
PUBLIC	??_C@_0BN@LPID@?$CGCBaseTrainDoor?5?3?3?5FindTrain?$AA@ ; `string'
;	COMDAT ??_C@_0BN@LPID@?$CGCBaseTrainDoor?5?3?3?5FindTrain?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0BN@LPID@?$CGCBaseTrainDoor?5?3?3?5FindTrain?$AA@ DB '&CBaseTrainDo'
	DB	'or :: FindTrain', 00H			; `string'
CONST	ENDS
;	COMDAT ?Spawn@CBaseTrainDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
$T39594 = -16
?Spawn@CBaseTrainDoor@@UAEXXZ PROC NEAR			; CBaseTrainDoor::Spawn, COMDAT

; 1244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1245 : 	Precache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 1246 : 
; 1247 : 	pev->movetype = MOVETYPE_PUSH;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 7

; 1248 : 	pev->solid = SOLID_BSP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 4

; 1249 : 
; 1250 : 	SET_MODEL( edict(), GetModel( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1251 : 
; 1252 : 	// is mapper forget set angles?
; 1253 : 	if( pev->movedir == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 68					; 00000044H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L38290

; 1255 : 		pev->movedir = Vector( 1, 0, 0 );

	push	0
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T39594[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1256 : 		SetLocalAngles( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles
$L38290:

; 1258 : 
; 1259 : 	// save initial angles
; 1260 : 	m_vecOldAngles = GetLocalAngles();	// ???

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1261 : 	m_vecPosition1 = GetLocalOrigin();	// member the initial position

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1262 : 
; 1263 : 	if( !pev->speed )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38292

; 1264 : 		pev->speed = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+504], 1120403456		; 42c80000H
$L38292:

; 1265 : 
; 1266 : 	m_pUserData = WorldPhysic->CreateKinematicBodyFromEntity( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 1267 : 	door_state = TD_CLOSED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1980], 0

; 1268 : 	SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1269 : 
; 1270 : 	SetThink( &CBaseTrainDoor :: FindTrain );

	push	OFFSET FLAT:??_C@_0BN@LPID@?$CGCBaseTrainDoor?5?3?3?5FindTrain?$AA@ ; `string'
	push	OFFSET FLAT:?FindTrain@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::FindTrain
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1271 : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 1272 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseTrainDoor@@UAEXXZ ENDP			; CBaseTrainDoor::Spawn
_TEXT	ENDS
PUBLIC	?SetTrainDoor@CFuncTrackTrain@@QAEXPAVCBaseTrainDoor@@@Z ; CFuncTrackTrain::SetTrainDoor
PUBLIC	??_C@_0BA@KOLE@func_tracktrain?$AA@		; `string'
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0BA@KOLE@func_tracktrain?$AA@ DB 'func_tracktrain', 00H ; `string'
CONST	ENDS
;	COMDAT ?FindTrain@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = -8
?FindTrain@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::FindTrain, COMDAT

; 1275 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1276 : 	CBaseEntity *pEntity = NULL;

	mov	DWORD PTR _pEntity$[ebp], 0
$L38304:

; 1277 : 
; 1278 : 	while(( pEntity = UTIL_FindEntityByTargetname( pEntity, STRING( m_iParent ))) != NULL )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax
	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L38305

; 1280 : 		// found the tracktrain
; 1281 : 		if( FClassnameIs( pEntity->pev, "func_tracktrain" ) )

	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L38306

; 1283 : 			m_pTrain = (CFuncTrackTrain *)pEntity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [edx+1964], eax

; 1284 : 			m_pTrain->SetTrainDoor( this ); // tell train about door

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1964]
	call	?SetTrainDoor@CFuncTrackTrain@@QAEXPAVCBaseTrainDoor@@@Z ; CFuncTrackTrain::SetTrainDoor

; 1285 : 			break;

	jmp	SHORT $L38305
$L38306:

; 1287 : 	}

	jmp	SHORT $L38304
$L38305:

; 1288 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FindTrain@CBaseTrainDoor@@QAEXXZ ENDP			; CBaseTrainDoor::FindTrain
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L39601
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39601
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L39602
$L39601:
	mov	DWORD PTR -4+[ebp], 1
$L39602:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
;	COMDAT ?SetTrainDoor@CFuncTrackTrain@@QAEXPAVCBaseTrainDoor@@@Z
_TEXT	SEGMENT
_pDoor$ = 8
_this$ = -4
?SetTrainDoor@CFuncTrackTrain@@QAEXPAVCBaseTrainDoor@@@Z PROC NEAR ; CFuncTrackTrain::SetTrainDoor, COMDAT

; 137  : 	void SetTrainDoor( CBaseTrainDoor *pDoor ) { m_pDoor = pDoor; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pDoor$[ebp]
	mov	DWORD PTR [eax+1792], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetTrainDoor@CFuncTrackTrain@@QAEXPAVCBaseTrainDoor@@@Z ENDP ; CFuncTrackTrain::SetTrainDoor
_TEXT	ENDS
PUBLIC	?OverrideReset@CBaseTrainDoor@@UAEXXZ		; CBaseTrainDoor::OverrideReset
;	COMDAT ?OverrideReset@CBaseTrainDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseTrainDoor@@UAEXXZ PROC NEAR		; CBaseTrainDoor::OverrideReset, COMDAT

; 1291 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1292 : 	FindTrain( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindTrain@CBaseTrainDoor@@QAEXXZ	; CBaseTrainDoor::FindTrain

; 1293 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseTrainDoor@@UAEXXZ ENDP		; CBaseTrainDoor::OverrideReset
_TEXT	ENDS
PUBLIC	?Precache@CBaseTrainDoor@@UAEXXZ		; CBaseTrainDoor::Precache
;	COMDAT ?Precache@CBaseTrainDoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_m_sound$ = -8
?Precache@CBaseTrainDoor@@UAEXXZ PROC NEAR		; CBaseTrainDoor::Precache, COMDAT

; 1296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1297 : 	int m_sound = UTIL_LoadSoundPreset( m_iMoveSnd );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 1301 : 	{

	mov	edx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -12+[ebp], edx
	cmp	DWORD PTR -12+[ebp], 10			; 0000000aH
	ja	$L38333
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L39615[eax*4]
$L38322:

; 1302 : 	case 1:
; 1303 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove1.wav" );

	push	OFFSET FLAT:??_C@_0BE@EMFL@doors?1doormove1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1304 : 		break;

	jmp	$L38319
$L38323:

; 1305 : 	case 2:
; 1306 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove2.wav" );

	push	OFFSET FLAT:??_C@_0BE@KMDE@doors?1doormove2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1307 : 		break;

	jmp	$L38319
$L38324:

; 1308 : 	case 3:
; 1309 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove3.wav" );

	push	OFFSET FLAT:??_C@_0BE@MBB@doors?1doormove3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1310 : 		break;

	jmp	$L38319
$L38325:

; 1311 : 	case 4:
; 1312 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove4.wav" );

	push	OFFSET FLAT:??_C@_0BE@GMOL@doors?1doormove4?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1313 : 		break;

	jmp	$L38319
$L38326:

; 1314 : 	case 5:
; 1315 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove5.wav" );

	push	OFFSET FLAT:??_C@_0BE@MMMO@doors?1doormove5?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1316 : 		break;

	jmp	$L38319
$L38327:

; 1317 : 	case 6:
; 1318 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove6.wav" );

	push	OFFSET FLAT:??_C@_0BE@CMKB@doors?1doormove6?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1319 : 		break;

	jmp	$L38319
$L38328:

; 1320 : 	case 7:
; 1321 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove7.wav" );

	push	OFFSET FLAT:??_C@_0BE@IMIE@doors?1doormove7?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1322 : 		break;

	jmp	$L38319
$L38329:

; 1323 : 	case 8:
; 1324 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove8.wav" );

	push	OFFSET FLAT:??_C@_0BE@ONFE@doors?1doormove8?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1325 : 		break;

	jmp	SHORT $L38319
$L38330:

; 1326 : 	case 9:
; 1327 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove9.wav" );

	push	OFFSET FLAT:??_C@_0BE@ENHB@doors?1doormove9?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1328 : 		break;

	jmp	SHORT $L38319
$L38331:

; 1329 : 	case 10:
; 1330 : 		pev->noise1 = UTIL_PrecacheSound( "doors/doormove10.wav" );

	push	OFFSET FLAT:??_C@_0BF@EEJ@doors?1doormove10?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1331 : 		break;

	jmp	SHORT $L38319
$L38332:

; 1332 : 	case 0:
; 1333 : 		pev->noise1 = MAKE_STRING( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax

; 1334 : 		break;

	jmp	SHORT $L38319
$L38333:

; 1335 : 	default:
; 1336 : 		pev->noise1 = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+492], eax
$L38319:

; 1339 : 
; 1340 : 	m_sound = UTIL_LoadSoundPreset( m_iStopSnd );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1960]
	push	ecx
	call	?UTIL_LoadSoundPreset@@YAHH@Z		; UTIL_LoadSoundPreset
	add	esp, 4
	mov	DWORD PTR _m_sound$[ebp], eax

; 1344 : 	{

	mov	edx, DWORD PTR _m_sound$[ebp]
	mov	DWORD PTR -16+[ebp], edx
	cmp	DWORD PTR -16+[ebp], 8
	ja	$L38347
	mov	eax, DWORD PTR -16+[ebp]
	jmp	DWORD PTR $L39616[eax*4]
$L38338:

; 1345 : 	case 1:
; 1346 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop1.wav" );

	push	OFFSET FLAT:??_C@_0BE@MGIG@doors?1doorstop1?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1347 : 		break;

	jmp	$L38335
$L38339:

; 1348 : 	case 2:
; 1349 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop2.wav" );

	push	OFFSET FLAT:??_C@_0BE@CGOJ@doors?1doorstop2?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1350 : 		break;

	jmp	$L38335
$L38340:

; 1351 : 	case 3:
; 1352 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop3.wav" );

	push	OFFSET FLAT:??_C@_0BE@IGMM@doors?1doorstop3?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1353 : 		break;

	jmp	$L38335
$L38341:

; 1354 : 	case 4:
; 1355 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop4.wav" );

	push	OFFSET FLAT:??_C@_0BE@OGDG@doors?1doorstop4?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1356 : 		break;

	jmp	$L38335
$L38342:

; 1357 : 	case 5:
; 1358 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop5.wav" );

	push	OFFSET FLAT:??_C@_0BE@EGBD@doors?1doorstop5?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1359 : 		break;

	jmp	$L38335
$L38343:

; 1360 : 	case 6:
; 1361 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop6.wav" );

	push	OFFSET FLAT:??_C@_0BE@KGHM@doors?1doorstop6?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1362 : 		break;

	jmp	SHORT $L38335
$L38344:

; 1363 : 	case 7:
; 1364 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop7.wav" );

	push	OFFSET FLAT:??_C@_0BE@GFJ@doors?1doorstop7?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1365 : 		break;

	jmp	SHORT $L38335
$L38345:

; 1366 : 	case 8:
; 1367 : 		pev->noise2 = UTIL_PrecacheSound( "doors/doorstop8.wav" );

	push	OFFSET FLAT:??_C@_0BE@GHIJ@doors?1doorstop8?4wav?$AA@ ; `string'
	call	?UTIL_PrecacheSound@@YAHPBD@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1368 : 		break;

	jmp	SHORT $L38335
$L38346:

; 1369 : 	case 0:
; 1370 : 		pev->noise2 = MAKE_STRING( "common/null.wav" );

	push	OFFSET FLAT:??_C@_0BA@LNFJ@common?1null?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax

; 1371 : 		break;

	jmp	SHORT $L38335
$L38347:

; 1372 : 	default:
; 1373 : 		pev->noise2 = UTIL_PrecacheSound( m_sound );

	mov	eax, DWORD PTR _m_sound$[ebp]
	push	eax
	call	?UTIL_PrecacheSound@@YAHH@Z		; UTIL_PrecacheSound
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+496], eax
$L38335:

; 1376 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L39615:
	DD	$L38332
	DD	$L38322
	DD	$L38323
	DD	$L38324
	DD	$L38325
	DD	$L38326
	DD	$L38327
	DD	$L38328
	DD	$L38329
	DD	$L38330
	DD	$L38331
$L39616:
	DD	$L38346
	DD	$L38338
	DD	$L38339
	DD	$L38340
	DD	$L38341
	DD	$L38342
	DD	$L38343
	DD	$L38344
	DD	$L38345
?Precache@CBaseTrainDoor@@UAEXXZ ENDP			; CBaseTrainDoor::Precache
_TEXT	ENDS
PUBLIC	?Use@CBaseTrainDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CBaseTrainDoor::Use
EXTRN	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalVelocity
;	COMDAT ?Use@CBaseTrainDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_value$ = 20
_this$ = -4
?Use@CBaseTrainDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CBaseTrainDoor::Use, COMDAT

; 1379 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1380 : 	m_hActivator = pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1381 : 
; 1382 : 	if( IsLockedByMaster( ))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHXZ	; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L38355

; 1383 : 		return;

	jmp	$L38354
$L38355:

; 1384 : 
; 1385 : 	if( m_pTrain )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1964], 0
	je	SHORT $L38359

; 1387 : 		if( m_pTrain->GetLocalVelocity() != g_vecZero || m_pTrain->GetLocalAvelocity() != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1964]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	jne	SHORT $L38358
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1964]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38359
$L38358:

; 1389 : 			if( !FBitSet( pev->spawnflags, SF_TRAINDOOR_OPEN_IN_MOVING ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	jne	SHORT $L38359

; 1391 : 				// very dangerous open the doors while train is moving :-)
; 1392 : 				return;

	jmp	$L38354
$L38359:

; 1396 : 
; 1397 : 	if( !FBitSet( pev->spawnflags, SF_TRAINDOOR_OPEN_IN_MOVING ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	jne	SHORT $L38364

; 1399 : 		if( useType == USE_SET )

	cmp	DWORD PTR _useType$[ebp], 2
	jne	SHORT $L38364

; 1401 : 			if( value == 2.0f )

	cmp	DWORD PTR _value$[ebp], 1073741824	; 40000000H
	jne	SHORT $L38362

; 1403 : 				// start train after door is closing 
; 1404 : 				pev->impulse = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+388], 1

; 1406 : 			else if( value == 3.0f )

	jmp	SHORT $L38364
$L38362:
	cmp	DWORD PTR _value$[ebp], 1077936128	; 40400000H
	jne	SHORT $L38364

; 1408 : 				// start train after door is closing 
; 1409 : 				pev->impulse = 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+388], 2
$L38364:

; 1413 : 
; 1414 : 	if( FBitSet( pev->spawnflags, SF_TRAINDOOR_ONOFF_MODE ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L38370

; 1416 : 		if( useType == USE_ON )

	cmp	DWORD PTR _useType$[ebp], 1
	jne	SHORT $L38366

; 1418 : 			if( door_state != TD_CLOSED )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1980], 0
	je	SHORT $L38367

; 1419 : 				return;

	jmp	SHORT $L38354
$L38367:

; 1421 : 		else if( useType == USE_OFF )

	jmp	SHORT $L38370
$L38366:
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L38370

; 1423 : 			if( door_state != TD_OPENED )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1980], 3
	je	SHORT $L38370

; 1424 : 				return;

	jmp	SHORT $L38354
$L38370:

; 1427 : 
; 1428 : 	if( door_state == TD_OPENED )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1980], 3
	jne	SHORT $L38371

; 1430 : 		// door should close
; 1431 : 		DoorSlideDown();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorSlideDown@CBaseTrainDoor@@QAEXXZ	; CBaseTrainDoor::DoorSlideDown

; 1433 : 	else if( door_state == TD_CLOSED )

	jmp	SHORT $L38373
$L38371:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1980], 0
	jne	SHORT $L38373

; 1435 : 		// door should open
; 1436 : 		DoorGoUp();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoUp@CBaseTrainDoor@@QAEXXZ	; CBaseTrainDoor::DoorGoUp
$L38373:
$L38354:

; 1438 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseTrainDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CBaseTrainDoor::Use
_TEXT	ENDS
PUBLIC	?GetState@CBaseTrainDoor@@UAE?AW4STATE@@XZ	; CBaseTrainDoor::GetState
;	COMDAT ?GetState@CBaseTrainDoor@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseTrainDoor@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseTrainDoor::GetState, COMDAT

; 1441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1443 : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1980]
	mov	DWORD PTR -8+[ebp], ecx
	cmp	DWORD PTR -8+[ebp], 5
	ja	SHORT $L38386
	mov	edx, DWORD PTR -8+[ebp]
	jmp	DWORD PTR $L39621[edx*4]
$L38382:

; 1444 : 	case TD_OPENED:
; 1445 : 		return STATE_ON;

	mov	eax, 1
	jmp	SHORT $L38379
$L38383:

; 1446 : 	case TD_CLOSED:
; 1447 : 		return STATE_OFF;

	xor	eax, eax
	jmp	SHORT $L38379
$L38384:

; 1448 : 	case TD_SHIFT_UP:
; 1449 : 	case TD_SLIDING_UP:
; 1450 : 		 return STATE_TURN_ON;

	mov	eax, 2
	jmp	SHORT $L38379
$L38385:

; 1451 : 	case TD_SLIDING_DOWN:
; 1452 : 	case TD_SHIFT_DOWN:
; 1453 : 		return STATE_TURN_OFF;

	mov	eax, 3
	jmp	SHORT $L38379
$L38386:

; 1454 : 	default: return STATE_OFF; // This should never happen.

	xor	eax, eax
$L38379:

; 1456 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L39621:
	DD	$L38383
	DD	$L38384
	DD	$L38384
	DD	$L38382
	DD	$L38385
	DD	$L38385
?GetState@CBaseTrainDoor@@UAE?AW4STATE@@XZ ENDP		; CBaseTrainDoor::GetState
_TEXT	ENDS
PUBLIC	?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ		; CFuncTrackTrain::GetMaxSpeed
EXTRN	?Next@CFuncTrackTrain@@QAEXXZ:NEAR		; CFuncTrackTrain::Next
;	COMDAT ?ActivateTrain@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ActivateTrain@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::ActivateTrain, COMDAT

; 1459 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1461 : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR -8+[ebp], edx
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L38395
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L38397
	jmp	SHORT $L38392
$L38395:

; 1462 : 	case 1:	// activate train
; 1463 : 		if( m_pTrain )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1964], 0
	je	SHORT $L38396

; 1465 : 			m_pTrain->pev->speed = m_pTrain->GetMaxSpeed();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1964]
	call	?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ	; CFuncTrackTrain::GetMaxSpeed
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1964]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+504]

; 1466 : 			m_pTrain->Next();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1964]
	call	?Next@CFuncTrackTrain@@QAEXXZ		; CFuncTrackTrain::Next
$L38396:

; 1468 : 		break;

	jmp	SHORT $L38392
$L38397:

; 1469 : 	case 2:	// activate trackchange
; 1470 : 		if( m_hActivator )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L38398

; 1471 : 			m_hActivator->Use( this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -12+[ebp], eax
	mov	edx, DWORD PTR -12+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -12+[ebp]
	call	DWORD PTR [eax+276]
$L38398:
$L38392:

; 1474 : 
; 1475 : 	SetThink( &CBaseTrainDoor :: FindTrain );

	push	OFFSET FLAT:??_C@_0BN@LPID@?$CGCBaseTrainDoor?5?3?3?5FindTrain?$AA@ ; `string'
	push	OFFSET FLAT:?FindTrain@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::FindTrain
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1476 : 	pev->impulse = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+388], 0

; 1477 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ActivateTrain@CBaseTrainDoor@@QAEXXZ ENDP		; CBaseTrainDoor::ActivateTrain
_TEXT	ENDS
;	COMDAT ?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ PROC NEAR		; CFuncTrackTrain::GetMaxSpeed, COMDAT

; 153  : 	float GetMaxSpeed( void ) { return m_maxSpeed; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1812]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ ENDP		; CFuncTrackTrain::GetMaxSpeed
_TEXT	ENDS
PUBLIC	??_C@_0BN@IJPN@?$CGCBaseTrainDoor?3?3?5DoorGoDown?$AA@ ; `string'
PUBLIC	??_C@_0BO@HCHE@?$CGCBaseTrainDoor?3?3?5DoorSlideUp?$AA@ ; `string'
;	COMDAT ??_C@_0BN@IJPN@?$CGCBaseTrainDoor?3?3?5DoorGoDown?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0BN@IJPN@?$CGCBaseTrainDoor?3?3?5DoorGoDown?$AA@ DB '&CBaseTrainDoo'
	DB	'r:: DoorGoDown', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@HCHE@?$CGCBaseTrainDoor?3?3?5DoorSlideUp?$AA@
CONST	SEGMENT
??_C@_0BO@HCHE@?$CGCBaseTrainDoor?3?3?5DoorSlideUp?$AA@ DB '&CBaseTrainDo'
	DB	'or:: DoorSlideUp', 00H			; `string'
CONST	ENDS
;	COMDAT ?DoorSlideWait@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorSlideWait@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::DoorSlideWait, COMDAT

; 1483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1484 : 	if( door_state == TD_SLIDING_DOWN )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1980], 4
	jne	SHORT $L38405

; 1486 : 		// okay. we are in poisition. Wait for 0.5 secs
; 1487 : 		SetThink( &CBaseTrainDoor:: DoorGoDown );

	push	OFFSET FLAT:??_C@_0BN@IJPN@?$CGCBaseTrainDoor?3?3?5DoorGoDown?$AA@ ; `string'
	push	OFFSET FLAT:?DoorGoDown@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorGoDown
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1489 : 	else if( door_state == TD_SHIFT_UP )

	jmp	SHORT $L38410
$L38405:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1980], 1
	jne	SHORT $L38410

; 1491 : 		// okay. we are in poisition. Wait for 0.5 secs
; 1492 : 		SetThink( &CBaseTrainDoor:: DoorSlideUp );

	push	OFFSET FLAT:??_C@_0BO@HCHE@?$CGCBaseTrainDoor?3?3?5DoorSlideUp?$AA@ ; `string'
	push	OFFSET FLAT:?DoorSlideUp@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorSlideUp
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
$L38410:

; 1494 : 
; 1495 : 	SetNextThink( 0.5 );

	push	1056964608				; 3f000000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 1496 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorSlideWait@CBaseTrainDoor@@QAEXXZ ENDP		; CBaseTrainDoor::DoorSlideWait
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DoorGoUp@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorGoUp'::`2'::__LINE__Var
PUBLIC	??_C@_0BI@MEKD@door_state?5?$DN?$DN?5TD_CLOSED?$AA@ ; `string'
PUBLIC	??_C@_0CA@GJHF@?$CGCBaseTrainDoor?3?3?5DoorSlideWait?$AA@ ; `string'
EXTRN	?VectorMatrix@@YAXAAVVector@@00@Z:NEAR		; VectorMatrix
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeVectors
;	COMDAT ?__LINE__Var@?1??DoorGoUp@CBaseTrainDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorGoUp@CBaseTrainDoor@@QAEXXZ@4FA DW 05deH ; `CBaseTrainDoor::DoorGoUp'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@MEKD@door_state?5?$DN?$DN?5TD_CLOSED?$AA@
CONST	SEGMENT
??_C@_0BI@MEKD@door_state?5?$DN?$DN?5TD_CLOSED?$AA@ DB 'door_state == TD_'
	DB	'CLOSED', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GJHF@?$CGCBaseTrainDoor?3?3?5DoorSlideWait?$AA@
CONST	SEGMENT
??_C@_0CA@GJHF@?$CGCBaseTrainDoor?3?3?5DoorSlideWait?$AA@ DB '&CBaseTrain'
	DB	'Door:: DoorSlideWait', 00H			; `string'
CONST	ENDS
;	COMDAT ?DoorGoUp@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecSize$ = -16
_depth$ = -20
$T39630 = -32
$T39631 = -44
$T39632 = -56
$T39633 = -68
?DoorGoUp@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::DoorGoUp, COMDAT

; 1502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1503 : 	// It could be going-down, if blocked.
; 1504 : 	ASSERT( door_state == TD_CLOSED );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??DoorGoUp@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorGoUp'::`2'::__LINE__Var
	add	eax, 2
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@MEKD@door_state?5?$DN?$DN?5TD_CLOSED?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1980], 0
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1505 : 
; 1506 : 	door_state = TD_SHIFT_UP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1980], 1

; 1507 : 
; 1508 : 	UTIL_MakeVectors( m_vecOldAngles );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	push	ecx
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1509 : 
; 1510 : 	STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+492]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 1511 : 	EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise2 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+496]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1512 : 
; 1513 : 	// Subtract 2 from size because the engine expands bboxes by 1 in all directions making the size too big
; 1514 : 	Vector vecSize = pev->size - Vector( 2, 2, 2 );

	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR $T39630[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T39631[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecSize$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1515 : 	float depth = (fabs( gpGlobals->v_right.x * vecSize.x ) + fabs( gpGlobals->v_right.y * vecSize.y ) + fabs( gpGlobals->v_right.z * vecSize.z ) - m_flLip);

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _vecSize$[ebp]
	fmul	DWORD PTR [ecx+64]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -76+[ebp]
	add	esp, 8
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _vecSize$[ebp+4]
	fmul	DWORD PTR [edx+68]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	QWORD PTR -76+[ebp]
	fstp	QWORD PTR -84+[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _vecSize$[ebp+8]
	fmul	DWORD PTR [eax+72]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	QWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fsub	DWORD PTR [ecx+1828]
	fstp	DWORD PTR _depth$[ebp]

; 1516 : 
; 1517 : 	if( pev->spawnflags & SF_TRAINDOOR_INVERSE )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L38425

; 1518 : 		depth = -depth;

	fld	DWORD PTR _depth$[ebp]
	fchs
	fstp	DWORD PTR _depth$[ebp]
$L38425:

; 1519 : 
; 1520 : 	VectorMatrix( pev->movedir, gpGlobals->v_right, gpGlobals->v_up );

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 52					; 00000034H
	push	edx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 68					; 00000044H
	push	edx
	call	?VectorMatrix@@YAXAAVVector@@00@Z	; VectorMatrix
	add	esp, 12					; 0000000cH

; 1521 : 	m_vecPosition3 = m_vecPosition1 + gpGlobals->v_right * -depth;

	fld	DWORD PTR _depth$[ebp]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T39632[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 64					; 00000040H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39633[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1864				; 00000748H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1522 : 
; 1523 : 	SetMoveDone( &CBaseTrainDoor:: DoorSlideWait );

	push	OFFSET FLAT:??_C@_0CA@GJHF@?$CGCBaseTrainDoor?3?3?5DoorSlideWait?$AA@ ; `string'
	push	OFFSET FLAT:?DoorSlideWait@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorSlideWait
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1524 : 	LinearMove( m_vecPosition3, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove

; 1525 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorGoUp@CBaseTrainDoor@@QAEXXZ ENDP			; CBaseTrainDoor::DoorGoUp
_TEXT	ENDS
PUBLIC	??_C@_0BN@CLFG@?$CGCBaseTrainDoor?3?3?5DoorHitTop?$AA@ ; `string'
;	COMDAT ??_C@_0BN@CLFG@?$CGCBaseTrainDoor?3?3?5DoorHitTop?$AA@
; File z:\xashxtsrc\server\doors.cpp
CONST	SEGMENT
??_C@_0BN@CLFG@?$CGCBaseTrainDoor?3?3?5DoorHitTop?$AA@ DB '&CBaseTrainDoo'
	DB	'r:: DoorHitTop', 00H			; `string'
CONST	ENDS
;	COMDAT ?DoorSlideUp@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecSize$ = -16
_width$ = -20
$T39636 = -32
$T39637 = -44
$T39638 = -56
$T39639 = -68
?DoorSlideUp@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::DoorSlideUp, COMDAT

; 1531 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 	// emit door moving and stop sounds on CHAN_STATIC so that the multicast doesn't
; 1533 : 	// filter them out and leave a client stuck with looping door sounds!
; 1534 : 	EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1535 : 
; 1536 : 	UTIL_MakeVectors( m_vecOldAngles );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1968				; 000007b0H
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1537 : 
; 1538 : 	// Subtract 2 from size because the engine expands bboxes by 1 in all directions making the size too big
; 1539 : 	Vector vecSize = pev->size - Vector( 2, 2, 2 );

	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR $T39636[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T39637[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecSize$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1540 : 	float width = (fabs( gpGlobals->v_forward.x * vecSize.x ) + fabs( gpGlobals->v_forward.y * vecSize.y ) + fabs( gpGlobals->v_forward.z * vecSize.z ));

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _vecSize$[ebp]
	fmul	DWORD PTR [eax+40]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -76+[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _vecSize$[ebp+4]
	fmul	DWORD PTR [ecx+44]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	QWORD PTR -76+[ebp]
	fstp	QWORD PTR -84+[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _vecSize$[ebp+8]
	fmul	DWORD PTR [edx+48]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	QWORD PTR -84+[ebp]
	fstp	DWORD PTR _width$[ebp]

; 1541 : 
; 1542 : 	door_state = TD_SLIDING_UP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1980], 2

; 1543 : 
; 1544 : 	m_vecPosition2 = m_vecPosition3 + pev->movedir * width;

	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T39638[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 68					; 00000044H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T39639[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1852				; 0000073cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1545 : 
; 1546 : 	SetMoveDone( &CBaseTrainDoor:: DoorHitTop );

	push	OFFSET FLAT:??_C@_0BN@CLFG@?$CGCBaseTrainDoor?3?3?5DoorHitTop?$AA@ ; `string'
	push	OFFSET FLAT:?DoorHitTop@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorHitTop
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1547 : 	LinearMove( m_vecPosition2, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove

; 1548 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorSlideUp@CBaseTrainDoor@@QAEXXZ ENDP		; CBaseTrainDoor::DoorSlideUp
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DoorHitTop@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorHitTop'::`2'::__LINE__Var
PUBLIC	??_C@_0BM@LHGM@door_state?5?$DN?$DN?5TD_SLIDING_UP?$AA@ ; `string'
;	COMDAT ?__LINE__Var@?1??DoorHitTop@CBaseTrainDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorHitTop@CBaseTrainDoor@@QAEXXZ@4FA DW 0612H ; `CBaseTrainDoor::DoorHitTop'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@LHGM@door_state?5?$DN?$DN?5TD_SLIDING_UP?$AA@
CONST	SEGMENT
??_C@_0BM@LHGM@door_state?5?$DN?$DN?5TD_SLIDING_UP?$AA@ DB 'door_state =='
	DB	' TD_SLIDING_UP', 00H			; `string'
CONST	ENDS
;	COMDAT ?DoorHitTop@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorHitTop@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::DoorHitTop, COMDAT

; 1554 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1555 : //	STOP_SOUND( edict(), CHAN_STATIC, pev->noise1 );
; 1556 : 
; 1557 : 	ASSERT( door_state == TD_SLIDING_UP );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??DoorHitTop@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorHitTop'::`2'::__LINE__Var
	add	eax, 3
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BM@LHGM@door_state?5?$DN?$DN?5TD_SLIDING_UP?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1980], 2
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1558 : 	door_state = TD_OPENED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1980], 3

; 1559 : 
; 1560 : 	if( pev->impulse )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+388], 0
	je	SHORT $L38451

; 1563 : 		{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR -8+[ebp], edx
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L38456
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L38458
	jmp	SHORT $L38453
$L38456:

; 1564 : 		case 1:	// deactivate train
; 1565 : 			if( m_pTrain )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1964], 0
	je	SHORT $L38457

; 1566 : 				m_pTrain->pev->speed = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1964]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+504], 0
$L38457:

; 1567 : 			break;

	jmp	SHORT $L38453
$L38458:

; 1568 : 		case 2:	// cancel trackchange
; 1569 : 			m_hActivator = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L38453:

; 1572 : 		
; 1573 : 		pev->impulse = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+388], 0
$L38451:

; 1575 : 	
; 1576 : 	SUB_UseTargets( m_hActivator, USE_TOGGLE, 0 );

	push	0
	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets

; 1577 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorHitTop@CBaseTrainDoor@@QAEXXZ ENDP			; CBaseTrainDoor::DoorHitTop
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DoorSlideDown@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorSlideDown'::`2'::__LINE__Var
PUBLIC	??_C@_0BI@HHGP@door_state?5?$DN?$DN?5TD_OPENED?$AA@ ; `string'
;	COMDAT ?__LINE__Var@?1??DoorSlideDown@CBaseTrainDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorSlideDown@CBaseTrainDoor@@QAEXXZ@4FA DW 062cH ; `CBaseTrainDoor::DoorSlideDown'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BI@HHGP@door_state?5?$DN?$DN?5TD_OPENED?$AA@
CONST	SEGMENT
??_C@_0BI@HHGP@door_state?5?$DN?$DN?5TD_OPENED?$AA@ DB 'door_state == TD_'
	DB	'OPENED', 00H				; `string'
CONST	ENDS
;	COMDAT ?DoorSlideDown@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorSlideDown@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::DoorSlideDown, COMDAT

; 1580 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1581 : 	EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1582 : 	
; 1583 : 	ASSERT( door_state == TD_OPENED );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??DoorSlideDown@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorSlideDown'::`2'::__LINE__Var
	add	eax, 3
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BI@HHGP@door_state?5?$DN?$DN?5TD_OPENED?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1980], 3
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1584 : 	door_state = TD_SLIDING_DOWN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1980], 4

; 1585 : 
; 1586 : 	SetMoveDone( &CBaseTrainDoor:: DoorSlideWait );

	push	OFFSET FLAT:??_C@_0CA@GJHF@?$CGCBaseTrainDoor?3?3?5DoorSlideWait?$AA@ ; `string'
	push	OFFSET FLAT:?DoorSlideWait@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorSlideWait
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1587 : 	LinearMove( m_vecPosition3, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove

; 1588 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorSlideDown@CBaseTrainDoor@@QAEXXZ ENDP		; CBaseTrainDoor::DoorSlideDown
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DoorGoDown@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorGoDown'::`2'::__LINE__Var
PUBLIC	??_C@_0BO@EKAB@door_state?5?$DN?$DN?5TD_SLIDING_DOWN?$AA@ ; `string'
PUBLIC	??_C@_0CA@COFI@?$CGCBaseTrainDoor?3?3?5DoorHitBottom?$AA@ ; `string'
;	COMDAT ?__LINE__Var@?1??DoorGoDown@CBaseTrainDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorGoDown@CBaseTrainDoor@@QAEXXZ@4FA DW 063aH ; `CBaseTrainDoor::DoorGoDown'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BO@EKAB@door_state?5?$DN?$DN?5TD_SLIDING_DOWN?$AA@
CONST	SEGMENT
??_C@_0BO@EKAB@door_state?5?$DN?$DN?5TD_SLIDING_DOWN?$AA@ DB 'door_state '
	DB	'== TD_SLIDING_DOWN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@COFI@?$CGCBaseTrainDoor?3?3?5DoorHitBottom?$AA@
CONST	SEGMENT
??_C@_0CA@COFI@?$CGCBaseTrainDoor?3?3?5DoorHitBottom?$AA@ DB '&CBaseTrain'
	DB	'Door:: DoorHitBottom', 00H			; `string'
CONST	ENDS
;	COMDAT ?DoorGoDown@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorGoDown@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::DoorGoDown, COMDAT

; 1594 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1595 : 	ASSERT( door_state == TD_SLIDING_DOWN );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??DoorGoDown@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorGoDown'::`2'::__LINE__Var
	add	eax, 1
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BO@EKAB@door_state?5?$DN?$DN?5TD_SLIDING_DOWN?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1980], 4
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1596 : 	door_state = TD_SHIFT_DOWN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1980], 5

; 1597 : 
; 1598 : 	SetMoveDone( &CBaseTrainDoor:: DoorHitBottom );

	push	OFFSET FLAT:??_C@_0CA@COFI@?$CGCBaseTrainDoor?3?3?5DoorHitBottom?$AA@ ; `string'
	push	OFFSET FLAT:?DoorHitBottom@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::DoorHitBottom
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveDoneSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::MoveDoneSet

; 1599 : 	LinearMove( m_vecPosition1, pev->speed );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+504]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinearMove@CBaseToggle@@QAEXABVVector@@M@Z ; CBaseToggle::LinearMove

; 1600 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorGoDown@CBaseTrainDoor@@QAEXXZ ENDP			; CBaseTrainDoor::DoorGoDown
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??DoorHitBottom@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorHitBottom'::`2'::__LINE__Var
PUBLIC	??_C@_0BM@BEEH@door_state?5?$DN?$DN?5TD_SHIFT_DOWN?$AA@ ; `string'
;	COMDAT ?__LINE__Var@?1??DoorHitBottom@CBaseTrainDoor@@QAEXXZ@4FA
; File z:\xashxtsrc\server\doors.cpp
_DATA	SEGMENT
?__LINE__Var@?1??DoorHitBottom@CBaseTrainDoor@@QAEXXZ@4FA DW 0646H ; `CBaseTrainDoor::DoorHitBottom'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BM@BEEH@door_state?5?$DN?$DN?5TD_SHIFT_DOWN?$AA@
CONST	SEGMENT
??_C@_0BM@BEEH@door_state?5?$DN?$DN?5TD_SHIFT_DOWN?$AA@ DB 'door_state =='
	DB	' TD_SHIFT_DOWN', 00H			; `string'
CONST	ENDS
;	COMDAT ?DoorHitBottom@CBaseTrainDoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DoorHitBottom@CBaseTrainDoor@@QAEXXZ PROC NEAR		; CBaseTrainDoor::DoorHitBottom, COMDAT

; 1606 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1607 : 	STOP_SOUND( edict(), CHAN_STATIC, STRING( pev->noise1 ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+492]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?STOP_SOUND@@YAXPAUedict_s@@HPBD@Z	; STOP_SOUND
	add	esp, 12					; 0000000cH

; 1608 : 	EMIT_SOUND( edict(), CHAN_STATIC, STRING( pev->noise2 ), 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+496]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1609 : 
; 1610 : 	ASSERT( door_state == TD_SHIFT_DOWN );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??DoorHitBottom@CBaseTrainDoor@@QAEXXZ@4FA ; `CBaseTrainDoor::DoorHitBottom'::`2'::__LINE__Var
	add	eax, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BO@MCPF@z?3?2xashxtsrc?2server?2doors?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BM@BEEH@door_state?5?$DN?$DN?5TD_SHIFT_DOWN?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+1980], 5
	sete	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1611 : 	door_state = TD_CLOSED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1980], 0

; 1612 : 
; 1613 : 	if( pev->impulse )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+388], 0
	je	SHORT $L38484

; 1615 : 		SetThink( ActivateTrain );

	push	OFFSET FLAT:??_C@_0O@CNO@ActivateTrain?$AA@ ; `string'
	push	OFFSET FLAT:?ActivateTrain@CBaseTrainDoor@@QAEXXZ ; CBaseTrainDoor::ActivateTrain
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1616 : 		SetNextThink( 1.0 );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]
$L38484:

; 1618 : 
; 1619 : 	SUB_UseTargets( m_hActivator, USE_ON, 0 );

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1780				; 000006f4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets

; 1620 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DoorHitBottom@CBaseTrainDoor@@QAEXXZ ENDP		; CBaseTrainDoor::DoorHitBottom
_TEXT	ENDS
PUBLIC	?Blocked@CBaseTrainDoor@@UAEXPAVCBaseEntity@@@Z	; CBaseTrainDoor::Blocked
;	COMDAT ?Blocked@CBaseTrainDoor@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?Blocked@CBaseTrainDoor@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CBaseTrainDoor::Blocked, COMDAT

; 1623 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1624 : 	if( door_state == TD_SHIFT_UP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1980], 1
	jne	SHORT $L38491

; 1626 : 		DoorGoDown( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoDown@CBaseTrainDoor@@QAEXXZ	; CBaseTrainDoor::DoorGoDown

; 1628 : 	else if( door_state == TD_SHIFT_DOWN )

	jmp	SHORT $L38497
$L38491:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1980], 5
	jne	SHORT $L38493

; 1630 : 		DoorGoUp( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorGoUp@CBaseTrainDoor@@QAEXXZ	; CBaseTrainDoor::DoorGoUp

; 1632 : 	else if( door_state == TD_SLIDING_UP )

	jmp	SHORT $L38497
$L38493:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1980], 2
	jne	SHORT $L38495

; 1634 : 		DoorSlideDown( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorSlideDown@CBaseTrainDoor@@QAEXXZ	; CBaseTrainDoor::DoorSlideDown

; 1636 : 	else if( door_state == TD_SLIDING_DOWN )

	jmp	SHORT $L38497
$L38495:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1980], 4
	jne	SHORT $L38497

; 1638 : 		DoorSlideUp( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoorSlideUp@CBaseTrainDoor@@QAEXXZ	; CBaseTrainDoor::DoorSlideUp
$L38497:

; 1640 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseTrainDoor@@UAEXPAVCBaseEntity@@@Z ENDP	; CBaseTrainDoor::Blocked
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCBaseDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CBaseDoor>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCBaseDoor@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CBaseDoor>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCBaseDoor@@@@UAEIXZ ; CEntityFactory<CBaseDoor>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCBaseDoor@@@@6B@		; CEntityFactory<CBaseDoor>::`vftable'
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCBaseDoor@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCBaseDoor@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCBaseDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CBaseDoor>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCBaseDoor@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCBaseDoor@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCBaseDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCBaseDoor@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CBaseDoor>::CEntityFactory<CBaseDoor>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCBaseDoor@@@@6B@ ; CEntityFactory<CBaseDoor>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCBaseDoor@@@@QAE@PBD@Z ENDP	; CEntityFactory<CBaseDoor>::CEntityFactory<CBaseDoor>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCBaseDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCBaseDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CBaseDoor>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCBaseDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CBaseDoor>::Create
_TEXT	ENDS
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ?Destroy@?$CEntityFactory@VCBaseDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCBaseDoor@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CBaseDoor>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCBaseDoor@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CBaseDoor>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCBaseDoor@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCBaseDoor@@@@UAEIXZ PROC NEAR ; CEntityFactory<CBaseDoor>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2028				; 000007ecH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCBaseDoor@@@@UAEIXZ ENDP ; CEntityFactory<CBaseDoor>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCRotDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CRotDoor>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCRotDoor@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CRotDoor>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCRotDoor@@@@UAEIXZ ; CEntityFactory<CRotDoor>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCRotDoor@@@@6B@		; CEntityFactory<CRotDoor>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCRotDoor@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCRotDoor@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCRotDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CRotDoor>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCRotDoor@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCRotDoor@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCRotDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCRotDoor@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CRotDoor>::CEntityFactory<CRotDoor>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCRotDoor@@@@6B@ ; CEntityFactory<CRotDoor>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCRotDoor@@@@QAE@PBD@Z ENDP		; CEntityFactory<CRotDoor>::CEntityFactory<CRotDoor>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z		; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCRotDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCRotDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CRotDoor>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z	; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCRotDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CRotDoor>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCRotDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCRotDoor@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CRotDoor>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCRotDoor@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CRotDoor>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCRotDoor@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCRotDoor@@@@UAEIXZ PROC NEAR ; CEntityFactory<CRotDoor>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2028				; 000007ecH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCRotDoor@@@@UAEIXZ ENDP ; CEntityFactory<CRotDoor>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCMomentaryDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CMomentaryDoor>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCMomentaryDoor@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CMomentaryDoor>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCMomentaryDoor@@@@UAEIXZ ; CEntityFactory<CMomentaryDoor>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCMomentaryDoor@@@@6B@	; CEntityFactory<CMomentaryDoor>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCMomentaryDoor@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCMomentaryDoor@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCMomentaryDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CMomentaryDoor>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCMomentaryDoor@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCMomentaryDoor@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCMomentaryDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCMomentaryDoor@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CMomentaryDoor>::CEntityFactory<CMomentaryDoor>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCMomentaryDoor@@@@6B@ ; CEntityFactory<CMomentaryDoor>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCMomentaryDoor@@@@QAE@PBD@Z ENDP	; CEntityFactory<CMomentaryDoor>::CEntityFactory<CMomentaryDoor>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCMomentaryDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCMomentaryDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CMomentaryDoor>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCMomentaryDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CMomentaryDoor>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCMomentaryDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCMomentaryDoor@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CMomentaryDoor>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCMomentaryDoor@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CMomentaryDoor>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCMomentaryDoor@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCMomentaryDoor@@@@UAEIXZ PROC NEAR ; CEntityFactory<CMomentaryDoor>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1960				; 000007a8H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCMomentaryDoor@@@@UAEIXZ ENDP ; CEntityFactory<CMomentaryDoor>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCBaseTrainDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CBaseTrainDoor>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCBaseTrainDoor@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CBaseTrainDoor>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCBaseTrainDoor@@@@UAEIXZ ; CEntityFactory<CBaseTrainDoor>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCBaseTrainDoor@@@@6B@	; CEntityFactory<CBaseTrainDoor>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCBaseTrainDoor@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCBaseTrainDoor@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCBaseTrainDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CBaseTrainDoor>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCBaseTrainDoor@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCBaseTrainDoor@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCBaseTrainDoor@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCBaseTrainDoor@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CBaseTrainDoor>::CEntityFactory<CBaseTrainDoor>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCBaseTrainDoor@@@@6B@ ; CEntityFactory<CBaseTrainDoor>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCBaseTrainDoor@@@@QAE@PBD@Z ENDP	; CEntityFactory<CBaseTrainDoor>::CEntityFactory<CBaseTrainDoor>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCBaseTrainDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCBaseTrainDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CBaseTrainDoor>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCBaseTrainDoor@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CBaseTrainDoor>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCBaseTrainDoor@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCBaseTrainDoor@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CBaseTrainDoor>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCBaseTrainDoor@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CBaseTrainDoor>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCBaseTrainDoor@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCBaseTrainDoor@@@@UAEIXZ PROC NEAR ; CEntityFactory<CBaseTrainDoor>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1984				; 000007c0H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCBaseTrainDoor@@@@UAEIXZ ENDP ; CEntityFactory<CBaseTrainDoor>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
_growSize$ = 8
_initSize$ = 12
_this$ = -16
__$EHRec$ = -12
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L39708
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L39708
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L39708
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L39708:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseToggle@@2Udatamap_s@@A:BYTE	; CBaseToggle::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseToggle@@2Udatamap_s@@A ; CBaseToggle::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseToggle@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CBaseDoor@@QAE@XZ				; CBaseDoor::CBaseDoor
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T39713 = -20
$T39714 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38590

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38590:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38592

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2028					; 000007ecH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T39714[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T39714[ebp], 0
	je	SHORT $L39715
	mov	ecx, DWORD PTR $T39714[ebp]
	call	??0CBaseDoor@@QAE@XZ			; CBaseDoor::CBaseDoor
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L39716
$L39715:
	mov	DWORD PTR -28+[ebp], 0
$L39716:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T39713[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T39713[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38592:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T39714[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCBaseDoor@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CRotDoor@@QAE@XZ				; CRotDoor::CRotDoor
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T39734 = -20
$T39735 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38601

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38601:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38603

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2028					; 000007ecH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T39735[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T39735[ebp], 0
	je	SHORT $L39736
	mov	ecx, DWORD PTR $T39735[ebp]
	call	??0CRotDoor@@QAE@XZ			; CRotDoor::CRotDoor
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L39737
$L39736:
	mov	DWORD PTR -28+[ebp], 0
$L39737:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T39734[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T39734[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38603:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T39735[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCRotDoor@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	??0CMomentaryDoor@@QAE@XZ			; CMomentaryDoor::CMomentaryDoor
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T39747 = -20
$T39748 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38612

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38612:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38614

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1960					; 000007a8H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T39748[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T39748[ebp], 0
	je	SHORT $L39749
	mov	ecx, DWORD PTR $T39748[ebp]
	call	??0CMomentaryDoor@@QAE@XZ		; CMomentaryDoor::CMomentaryDoor
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L39750
$L39749:
	mov	DWORD PTR -28+[ebp], 0
$L39750:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T39747[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T39747[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38614:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T39748[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCMomentaryDoor@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CBaseTrainDoor@@QAE@XZ			; CBaseTrainDoor::CBaseTrainDoor
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T39760 = -20
$T39761 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L38623

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L38623:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L38625

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1984					; 000007c0H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T39761[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T39761[ebp], 0
	je	SHORT $L39762
	mov	ecx, DWORD PTR $T39761[ebp]
	call	??0CBaseTrainDoor@@QAE@XZ		; CBaseTrainDoor::CBaseTrainDoor
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L39763
$L39762:
	mov	DWORD PTR -28+[ebp], 0
$L39763:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T39760[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T39760[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L38625:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T39761[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCBaseTrainDoor@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	?ObjectCaps@CBaseDoor@@UAEHXZ			; CBaseDoor::ObjectCaps
PUBLIC	?IsRotatingDoor@CBaseDoor@@UAE_NXZ		; CBaseDoor::IsRotatingDoor
PUBLIC	?GetState@CBaseDoor@@UAE?AW4STATE@@XZ		; CBaseDoor::GetState
PUBLIC	??_7CBaseDoor@@6B@				; CBaseDoor::`vftable'
PUBLIC	?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ; CBaseAnimating::HandleAnimEvent
PUBLIC	?GetToggleState@CBaseToggle@@UAEHXZ		; CBaseToggle::GetToggleState
PUBLIC	?GetDelay@CBaseToggle@@UAEMXZ			; CBaseToggle::GetDelay
PUBLIC	??0CBaseToggle@@QAE@XZ				; CBaseToggle::CBaseToggle
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z:NEAR	; CBaseToggle::Restore
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CBaseDoor@@6B@
CONST	SEGMENT
??_7CBaseDoor@@6B@ DD FLAT:?GetDataDescMap@CBaseDoor@@UAEPAUdatamap_s@@XZ ; CBaseDoor::`vftable'
	DD	FLAT:?Spawn@CBaseDoor@@UAEXXZ
	DD	FLAT:?Precache@CBaseDoor@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDoor@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseDoor@@UAEHXZ
	DD	FLAT:?Activate@CBaseDoor@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseDoor@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseDoor@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDoor@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseDoor@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseDoor@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsRotatingDoor@CBaseDoor@@UAE_NXZ
CONST	ENDS
;	COMDAT ??0CBaseDoor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDoor@@QAE@XZ PROC NEAR				; CBaseDoor::CBaseDoor, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDoor@@6B@ ; CBaseDoor::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDoor@@QAE@XZ ENDP				; CBaseDoor::CBaseDoor
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L39830
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39830
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39831
$L39830:
	mov	DWORD PTR -8+[ebp], 0
$L39831:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L39838
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L39839
$L39838:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39839
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39840
$L39839:
	mov	DWORD PTR -8+[ebp], 0
$L39840:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39877 = -16
$T39878 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T39878[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T39877[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39881 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T39881[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39884 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T39884[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T39887 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T39887[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_this$ = -4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CBaseAnimating::HandleAnimEvent, COMDAT

; 909  : 	virtual void HandleAnimEvent( MonsterEvent_t *pEvent ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CBaseAnimating::HandleAnimEvent
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseToggle@@UAEHXZ PROC NEAR		; CBaseToggle::GetToggleState, COMDAT

; 978  : 	virtual int GetToggleState( void ) { return m_toggle_state; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1816]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseToggle@@UAEHXZ ENDP		; CBaseToggle::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseToggle@@UAEMXZ PROC NEAR			; CBaseToggle::GetDelay, COMDAT

; 979  : 	virtual float GetDelay( void ) { return m_flWait; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseToggle@@UAEMXZ ENDP			; CBaseToggle::GetDelay
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ?ObjectCaps@CBaseDoor@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseDoor@@UAEHXZ PROC NEAR			; CBaseDoor::ObjectCaps, COMDAT

; 41   : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 42   : 		if( FBitSet( pev->spawnflags, SF_DOOR_USE_ONLY ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L37286

; 43   : 			return (BaseClass::ObjectCaps() & (~FCAP_ACROSS_TRANSITION)) | FCAP_IMPULSE_USE | FCAP_SET_MOVEDIR;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 8
	or	al, 1
	jmp	SHORT $L37285
$L37286:

; 44   : 		return (BaseClass::ObjectCaps() & (~FCAP_ACROSS_TRANSITION)) | FCAP_SET_MOVEDIR;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 1
$L37285:

; 45   : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseDoor@@UAEHXZ ENDP			; CBaseDoor::ObjectCaps
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
;	COMDAT ?IsRotatingDoor@CBaseDoor@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsRotatingDoor@CBaseDoor@@UAE_NXZ PROC NEAR		; CBaseDoor::IsRotatingDoor, COMDAT

; 50   : 	virtual bool IsRotatingDoor() { return false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	al, al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRotatingDoor@CBaseDoor@@UAE_NXZ ENDP			; CBaseDoor::IsRotatingDoor
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDoor@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDoor@@UAE?AW4STATE@@XZ PROC NEAR		; CBaseDoor::GetState, COMDAT

; 51   : 	virtual STATE GetState ( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDoor@@UAE?AW4STATE@@XZ ENDP		; CBaseDoor::GetState
_TEXT	ENDS
PUBLIC	?IsRotatingDoor@CRotDoor@@UAE_NXZ		; CRotDoor::IsRotatingDoor
PUBLIC	?ObjectCaps@CRotDoor@@UAEHXZ			; CRotDoor::ObjectCaps
PUBLIC	??_7CRotDoor@@6B@				; CRotDoor::`vftable'
;	COMDAT ??_7CRotDoor@@6B@
CONST	SEGMENT
??_7CRotDoor@@6B@ DD FLAT:?GetDataDescMap@CBaseDoor@@UAEPAUdatamap_s@@XZ ; CRotDoor::`vftable'
	DD	FLAT:?Spawn@CRotDoor@@UAEXXZ
	DD	FLAT:?Precache@CBaseDoor@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDoor@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CRotDoor@@UAEHXZ
	DD	FLAT:?Activate@CBaseDoor@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CRotDoor@@UAEXXZ
	DD	FLAT:?OnClearParent@CRotDoor@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDoor@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CRotDoor@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseDoor@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsRotatingDoor@CRotDoor@@UAE_NXZ
CONST	ENDS
;	COMDAT ??0CRotDoor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CRotDoor@@QAE@XZ PROC NEAR				; CRotDoor::CRotDoor, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDoor@@QAE@XZ			; CBaseDoor::CBaseDoor
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CRotDoor@@6B@ ; CRotDoor::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CRotDoor@@QAE@XZ ENDP				; CRotDoor::CRotDoor
_TEXT	ENDS
;	COMDAT ?IsRotatingDoor@CRotDoor@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsRotatingDoor@CRotDoor@@UAE_NXZ PROC NEAR		; CRotDoor::IsRotatingDoor, COMDAT

; 820  : 	virtual bool IsRotatingDoor() { return true; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRotatingDoor@CRotDoor@@UAE_NXZ ENDP			; CRotDoor::IsRotatingDoor
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CRotDoor@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CRotDoor@@UAEHXZ PROC NEAR			; CRotDoor::ObjectCaps, COMDAT

; 821  : 	virtual int ObjectCaps( void ) { return BaseClass::ObjectCaps() & ~FCAP_SET_MOVEDIR; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseDoor@@UAEHXZ		; CBaseDoor::ObjectCaps
	and	al, -2					; fffffffeH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CRotDoor@@UAEHXZ ENDP			; CRotDoor::ObjectCaps
_TEXT	ENDS
PUBLIC	?ObjectCaps@CMomentaryDoor@@UAEHXZ		; CMomentaryDoor::ObjectCaps
PUBLIC	??_7CMomentaryDoor@@6B@				; CMomentaryDoor::`vftable'
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
EXTRN	?GetState@CBaseToggle@@UAE?AW4STATE@@XZ:NEAR	; CBaseToggle::GetState
;	COMDAT ??_7CMomentaryDoor@@6B@
CONST	SEGMENT
??_7CMomentaryDoor@@6B@ DD FLAT:?GetDataDescMap@CMomentaryDoor@@UAEPAUdatamap_s@@XZ ; CMomentaryDoor::`vftable'
	DD	FLAT:?Spawn@CMomentaryDoor@@UAEXXZ
	DD	FLAT:?Precache@CMomentaryDoor@@UAEXXZ
	DD	FLAT:?KeyValue@CMomentaryDoor@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CMomentaryDoor@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CMomentaryDoor@@UAEXXZ
	DD	FLAT:?OnClearParent@CMomentaryDoor@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CMomentaryDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CMomentaryDoor@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CMomentaryDoor@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT ??0CMomentaryDoor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CMomentaryDoor@@QAE@XZ PROC NEAR			; CMomentaryDoor::CMomentaryDoor, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CMomentaryDoor@@6B@ ; CMomentaryDoor::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CMomentaryDoor@@QAE@XZ ENDP				; CMomentaryDoor::CMomentaryDoor
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CMomentaryDoor@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CMomentaryDoor@@UAEHXZ PROC NEAR		; CMomentaryDoor::ObjectCaps, COMDAT

; 965  : 	virtual int ObjectCaps( void ) { return (BaseClass::ObjectCaps() & (~FCAP_ACROSS_TRANSITION)) | FCAP_SET_MOVEDIR; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CMomentaryDoor@@UAEHXZ ENDP			; CMomentaryDoor::ObjectCaps
_TEXT	ENDS
PUBLIC	?ObjectCaps@CBaseTrainDoor@@UAEHXZ		; CBaseTrainDoor::ObjectCaps
PUBLIC	?IsDoorControl@CBaseTrainDoor@@UAE_NXZ		; CBaseTrainDoor::IsDoorControl
PUBLIC	??_7CBaseTrainDoor@@6B@				; CBaseTrainDoor::`vftable'
PUBLIC	??1CBaseToggle@@QAE@XZ				; CBaseToggle::~CBaseToggle
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
;	COMDAT ??_7CBaseTrainDoor@@6B@
CONST	SEGMENT
??_7CBaseTrainDoor@@6B@ DD FLAT:?GetDataDescMap@CBaseTrainDoor@@UAEPAUdatamap_s@@XZ ; CBaseTrainDoor::`vftable'
	DD	FLAT:?Spawn@CBaseTrainDoor@@UAEXXZ
	DD	FLAT:?Precache@CBaseTrainDoor@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseTrainDoor@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseTrainDoor@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseTrainDoor@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseTrainDoor@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseTrainDoor@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseTrainDoor@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?IsDoorControl@CBaseTrainDoor@@UAE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseTrainDoor@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseTrainDoor@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseTrainDoor@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseTrainDoor@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseTrainDoor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseTrainDoor@@QAE@XZ PROC NEAR			; CBaseTrainDoor::CBaseTrainDoor, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseTrainDoor@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseTrainDoor@@6B@ ; CBaseTrainDoor::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseTrainDoor@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	ret	0
__ehhandler$??0CBaseTrainDoor@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseTrainDoor@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseTrainDoor@@QAE@XZ ENDP				; CBaseTrainDoor::CBaseTrainDoor
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseTrainDoor@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseTrainDoor@@UAEHXZ PROC NEAR		; CBaseTrainDoor::ObjectCaps, COMDAT

; 216  : 	virtual int ObjectCaps( void ) { return ((CBaseToggle::ObjectCaps() & ~FCAP_ACROSS_TRANSITION)) | FCAP_SET_MOVEDIR; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	or	al, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseTrainDoor@@UAEHXZ ENDP			; CBaseTrainDoor::ObjectCaps
_TEXT	ENDS
;	COMDAT ?IsDoorControl@CBaseTrainDoor@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsDoorControl@CBaseTrainDoor@@UAE_NXZ PROC NEAR	; CBaseTrainDoor::IsDoorControl, COMDAT

; 217  : 	virtual bool IsDoorControl( void ) { return !FBitSet( pev->spawnflags, SF_TRAINDOOR_OPEN_IN_MOVING ) && GetState() != STATE_OFF; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	test	edx, edx
	jne	SHORT $L39939
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	test	eax, eax
	je	SHORT $L39939
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39940
$L39939:
	mov	DWORD PTR -8+[ebp], 0
$L39940:
	mov	al, BYTE PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDoorControl@CBaseTrainDoor@@UAE_NXZ ENDP		; CBaseTrainDoor::IsDoorControl
_TEXT	ENDS
PUBLIC	??0CBaseAnimating@@QAE@XZ			; CBaseAnimating::CBaseAnimating
PUBLIC	??1CBaseAnimating@@QAE@XZ			; CBaseAnimating::~CBaseAnimating
PUBLIC	??_7CBaseToggle@@6B@				; CBaseToggle::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
EXTRN	?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseToggle::GetDataDescMap
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT
??_7CBaseToggle@@6B@ DD FLAT:?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ ; CBaseToggle::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseToggle@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseToggle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseToggle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseToggle@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseToggle@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseAnimating@@QAE@XZ		; CBaseAnimating::CBaseAnimating
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1912				; 00000778H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1924				; 00000784H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1936				; 00000790H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseToggle@@6B@ ; CBaseToggle::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseToggle@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	ret	0
__ehhandler$??0CBaseToggle@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseToggle@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::CBaseToggle
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::~CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::~CBaseToggle
_TEXT	ENDS
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	??_7CBaseAnimating@@6B@				; CBaseAnimating::`vftable'
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
EXTRN	?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseAnimating::GetDataDescMap
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT
??_7CBaseAnimating@@6B@ DD FLAT:?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ ; CBaseAnimating::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseAnimating@@6B@ ; CBaseAnimating::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::CBaseAnimating
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::~CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::~CBaseAnimating
_TEXT	ENDS
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	_atoi:NEAR
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L40003
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L40003
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L40003
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40003:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L40004
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40004
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40004:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L40009
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40009:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L38685

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L38685:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40014
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40014:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40015
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40015:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40018
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40018:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40025
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L40025
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40026
$L40025:
	mov	DWORD PTR -8+[ebp], 0
$L40026:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L38718:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L38719

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L38718
$L38719:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L38728

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L38728:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40033
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L40033
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L40033
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40033:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L38737
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L38737

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L38737:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
$T40036 = -4
_pMemory$ = 8
_src$ = 12
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T40036[ebp], eax
	cmp	DWORD PTR $T40036[ebp], 0
	je	SHORT $L40037
	mov	ecx, DWORD PTR $T40036[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T40036[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L40038
$L40037:
	mov	DWORD PTR -8+[ebp], 0
$L40038:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40043
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L40043
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40044
$L40043:
	mov	DWORD PTR -8+[ebp], 0
$L40044:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38751

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L38752

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L38752:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L38751:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L40053
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40053:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38766

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L40054
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40054:

; 567  : 		return;

	jmp	$L38763
$L38766:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L38786

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L38778
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L38778

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L38786
$L38778:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L38782

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L40055
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40055:

; 589  : 				return;

	jmp	$L38763
$L38782:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L38786

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L38782
$L38786:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L38789

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L40056
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40056:

; 603  : 	else

	jmp	SHORT $L40057
$L38789:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L40057
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L40057:
$L38763:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
