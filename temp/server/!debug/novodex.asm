	TITLE	Z:\XashXTSRC\server\novodex.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@MOJB@z?3?2xashxtsrc?2phys_shared?2nxvec3?4@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOLO@index?$DO?$DN0?5?$CG?$CG?5index?$DM?$DN2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@KONG@z?3?2xashxtsrc?2phys_shared?2nxconta@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KLKJ@shapeIndex?$DM?$DN1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@LKMM@z?3?2xashxtsrc?2server?2physics?2nxus@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@LMKO@invalid?5parameter?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@FBLK@invalid?5operation?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DFDP@out?5of?5memory?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HHKO@?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JFAD@unknown?5error?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@MCFO@access?5violation?5?3?5?$CFs?5?$CI?$CFs?5line?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@EIOC@NxCreatePhysicsSDK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEEP@NxReleasePhysicsSDK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FME@NxGetCookingLib?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FCEP@NxGetUtilLib?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@NOCF@InitPhysic?3?5physics?5already?5init@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@OFMN@InitPhysic?3?5PhysX?5support?5is?5dis@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HBBH@PhysXLoader?4dll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@END@?$CKPhysXLoader?4dll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FK@GABD@InitPhysic?3?5failed?5to?5loading?5Nx@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@KMH@InitPhysic?3?5failed?5to?5initalize?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@HODF@InitPhysic?3?5failed?5to?5initalize?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@BG@InitPhysic?3?5failed?5to?5initalize?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PIGM@sv_maxspeed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GIJ@sv_gravity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@HBPI@gravity?5changed?5from?5?$CFg?5to?5?$CFg?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@BFOI@?$CF3i?5active?5bodies?0?5?$CF3i?5actors?6?$CF3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EA@ECJ@ConvexMeshFromBmodel?3?5can?8t?5crea@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@CMIM@ConvexMeshFromBmodel?3?5unbale?5to?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@PGMH@ConvexMeshFromBmodel?3?5?$CFs?5has?5no?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@EBNF@TriangleMeshFromBmodel?3?5can?8t?5cr@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@HFFC@TriangleMeshFromBmodel?3?5unable?5t@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@CJEP@TriangleMeshFromBmodel?3?5?$CFs?5has?5n@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MDAM@CollisionFromStudio?3?5not?5a?5studi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@GKBK@CollisionFromStudio?3?5bad?5model?5h@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@MOEN@Convex?5mesh?5for?5?$CFs?5is?5corrupted?4@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@FJAP@Convex?5mesh?5for?5?$CFs?5is?5out?5of?5Dat@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DF@JAPI@CollisionFromStudio?3?5bad?5sequenc@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@MCNP@TriangleMeshFromStudio?3?5not?5a?5st@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@DKKI@TriangleMeshFromStudio?3?5bad?5mode@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@OOBA@Triangle?5mesh?5for?5?$CFs?5is?5corrupte@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@IGIH@Triangle?5mesh?5for?5?$CFs?5is?5out?5of?5D@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DI@GABK@TriangleMeshFromStudio?3?5bad?5sequ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@FBM@ConvexMeshFromEntity?3?5entity?5?$CFs?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DA@BLIM@ConvexMeshFromEntity?3?5?$CFi?5has?5mis@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@CFEB@TriangleMeshFromEntity?3?5entity?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@KHDF@TriangleMeshFromEntity?3?5?$CFs?5has?5m@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@HLHI@failed?5to?5create?5rigidbody?5from?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@FINK@failed?5to?5create?5kinematic?5from?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@GEAK@failed?5to?5create?5static?5from?5ent@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@HPGI@SaveBody?3?5physic?5entity?5?$CFi?5misse@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@LIJA@RestoreBody?3?5invalid?5actor?5type?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@PPLN@RestoreBody?3?5unbale?5to?5create?5ac@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GOLK@cache?1maps?1?$CFs?4bin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@JDKP@?4BIN?5file?5will?5be?5updated?6?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KPOE@models?1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNAO@cache?1?$CFs?1?$CFs?4hull?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DCDF@cache?1?$CFs?4hull?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FIIK@cache?1?$CFs?1?$CFs?4mesh?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@LHLB@cache?1?$CFs?4mesh?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@GILB@BuildCollisionTree?3?5unbale?5to?5fe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CL@OMND@Tree?5Collision?5out?5of?5Date?4?5Rebu@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@OAD@z?3?2xashxtsrc?2server?2novodex?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@BNBF@totalElems?5?$DN?$DN?5numElems?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@HNGO@?$CKcollision?5tree?5not?5ready?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@IPEB@SetupWorld?3?5unbale?5to?5fetch?5worl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PNBN@width?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@NGDC@failed?5to?5build?5mesh?5from?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LLLA@ElemType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@HHAN@z?3?2xashxtsrc?2phys_shared?2nxarray@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VectorLerp@@YAXABVVector@@M0AAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bmatrix3x3@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@PAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyToArray@matrix4x4@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHeadNode@CMeshDesc@@QAEPAUareanode_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMesh@CMeshDesc@@QAEPAUmmesh_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equals@NxMath@@SA_NMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?abs@NxMath@@SAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?abs@NxMath@@SANN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max@NxMath@@SAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?min@NxMath@@SAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sqrt@NxMath@@SAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isFinite@NxMath@@SA_NM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?degToRad@NxMath@@SAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?radToDeg@NxMath@@SAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sin@NxMath@@SAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?cos@NxMath@@SAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sinCos@NxMath@@SAXMAAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?acos@NxMath@@SAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?atan2@NxMath@@SAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rand@NxMath@@SAMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isZero@NxVec3@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4NxVec3@@QAEABV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4NxVec3@@QAEABV0@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ANxVec3@@QBEMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@NxVec3@@QAEXMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?zero@NxVec3@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max@NxVec3@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?min@NxVec3@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add@NxVec3@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?subtract@NxVec3@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?normalize@NxVec3@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setMagnitude@NxVec3@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isFinite@NxVec3@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dot@NxVec3@@QBEMABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?magnitude@NxVec3@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?magnitudeSquared@NxVec3@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?distance@NxVec3@@QBEMABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?distanceSquared@NxVec3@@QBEMABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?cross@NxVec3@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GNxVec3@@QBE?AV0@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HNxVec3@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GNxVec3@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DNxVec3@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YNxVec3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ZNxVec3@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??XNxVec3@@QAEAAV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?cross@NxVec3@@QBE?AV1@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??TNxVec3@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??UNxVec3@@QBEMABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVNxVec3@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxQuat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxQuat@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fromAngleAxis@NxQuat@@QAEXMABVNxVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?magnitudeSquared@NxQuat@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?dot@NxQuat@@QBEMABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?normalize@NxQuat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiply@NxQuat@@QAEXABV1@ABVNxVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4NxQuat@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxQuat@@AAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rot@NxQuat@@QBE?BVNxVec3@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?invRot@NxQuat@@QBE?BVNxVec3@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxMat33@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxMat33@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxMat33@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4NxMat33@@QAEABV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setRowMajor@NxMat33@@QAEXPBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setRowMajorStride4@NxMat33@@QAEXPBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setRowMajorStride4@NxMat33@@QAEXQAY03$$CBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setColumnMajorStride4@NxMat33@@QAEXPBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setColumnMajorStride4@NxMat33@@QAEXQAY03$$CBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getRowMajorStride4@NxMat33@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getRowMajorStride4@NxMat33@@QBEXQAY03M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getColumnMajorStride4@NxMat33@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getColumnMajorStride4@NxMat33@@QBEXQAY03M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RNxMat33@@QBEABMHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isIdentity@NxMat33@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isFinite@NxMat33@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?zero@NxMat33@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?id@NxMat33@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fromQuat@NxMat33@@QAEXABVNxQuat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?toQuat@NxMat33@@QBEXAAVNxQuat@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setTransposed@NxMat33@@QAEXABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiplyByTranspose@NxMat33@@QBEXABVNxVec3@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?add@NxMat33@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?subtract@NxMat33@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiply@NxMat33@@QAEXMABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiply@NxMat33@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiplyTransposeLeft@NxMat33@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiplyTransposeRight@NxMat33@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??LNxMat33@@QBE?AVNxVec3@@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DNxMat33@@QBE?AVNxVec3@@ABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getInverse@NxMat33@@QBE_NAAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxMat34@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxMat34@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxMat34@@QAE@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?id@NxMat34@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isFinite@NxMat34@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiply@NxMat34@@QBEXABVNxVec3@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiplyByInverseRT@NxMat34@@QBEXABVNxVec3@@AAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?multiply@NxMat34@@QAEXABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setColumnMajor44@NxMat34@@QAEXPBM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getColumnMajor44@NxMat34@@QBEXPAM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxGroupsMask@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxGroupsMask@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxInterface@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxInterface@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?mallocDEBUG@NxUserAllocator@@UAEPAXIPBDH0W4NxMemoryType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?malloc@NxUserAllocator@@UAEPAXIW4NxMemoryType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?checkDEBUG@NxUserAllocator@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserAllocator@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserAllocator@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxPhysicsSDKDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxPhysicsSDKDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxPhysicsSDK@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxPhysicsSDK@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxShape@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxShape@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserContactReport@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserContactReport@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserTriggerReport@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserTriggerReport@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserContactModify@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserContactModify@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserWheelContactModify@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserWheelContactModify@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserActorPairFiltering@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserActorPairFiltering@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserOutputStream@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserOutputStream@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUserRaycastReport@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUserRaycastReport@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxSceneQueryReport@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxSceneQueryReport@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSceneQueryDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxSceneQuery@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxSceneQuery@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxSceneDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSceneDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NxIsPowerOfTwo@@YA_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxSceneStats@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reset@NxSceneStats@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?mallocDEBUG@NxAllocatorDefault@@QAEPAXIPBDH0W4NxMemoryType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?free@NxAllocatorDefault@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxFoundationSDK@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxFoundationSDK@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxBounds3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxBounds3@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setEmpty@NxBounds3@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@NxBounds3@@QAEXMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?boundsOfOBB@NxBounds3@@QAEXABVNxMat33@@ABVNxVec3@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getCenter@NxBounds3@@QBEXAAVNxVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getExtents@NxBounds3@@QBEXAAVNxVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setCenterExtents@NxBounds3@@QAEXABVNxVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxMeshData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxMeshData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxMeshData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxMeshData@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxParticleData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxParticleData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxParticleData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxParticleData@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxParticleIdData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxParticleIdData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxParticleIdData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxParticleIdData@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxParticleUpdateData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxFluidPacketData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxFluidPacketData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxFluidPacketData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxFluidPacketData@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxFluidEmitter@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxFluidEmitter@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxFluidEmitterDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxFluidEmitterDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxFluidEmitterDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxFluidEmitterDesc@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxPlane@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxPlane@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@NxPlane@@QAEAAV1@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@NxPlane@@QAEAAV1@ABVNxVec3@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@NxPlane@@QAEAAV1@ABVNxVec3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set@NxPlane@@QAEAAV1@ABVNxVec3@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?distance@NxPlane@@QBEMABVNxVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxFluidDescBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxFluidDescBase@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxFluidDescBase@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxFluidDescBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxFluidDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxFluidDesc@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxFluid@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxFluid@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxClothSplitPairData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxClothSplitPairData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxClothSplitPairData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxClothSplitPairData@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxClothDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxCloth@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxCloth@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxSimpleTriangleMesh@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSimpleTriangleMesh@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxSimpleTriangleMesh@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxClothMeshDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxClothMesh@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxClothMesh@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxSoftBodySplitPairData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxSoftBodySplitPairData@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSoftBodySplitPairData@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxSoftBodySplitPairData@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSoftBodyDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxSoftBody@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxSoftBody@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSoftBodyMeshDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxSoftBodyMesh@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxSoftBodyMesh@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxProfileData@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxProfileData@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxScene@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxScene@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxBodyDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxBodyDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxBodyDesc@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxShapeDesc@@IAE@W4NxShapeType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxShapeDesc@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxShapeDesc@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxShapeDesc@@UBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxActorDescBase@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxActorDescBase@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxActorDescBase@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValidInternal@NxActorDescBase@@IBE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxActorDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxActorDescBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxActorDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxSweepCache@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxSweepCache@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxActor@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxActor@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxStream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxStream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reportError@NxErrorStream@@UAEXW4NxErrorCode@@PBD1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reportAssertViolation@NxErrorStream@@UAE?AW4NxAssertResponse@@PBD0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?print@NxErrorStream@@UAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?hideWarning@NxErrorStream@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxTriangleMesh@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxTriangleMesh@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxTriangleMeshDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxTriangleMeshDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxTriangleMeshShapeDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxTriangleMeshShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxTriangleMeshShapeDesc@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxTriangleMeshShapeDesc@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxTriangleMeshShapeDesc@@UBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxForceFieldKernel@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxForceFieldKernel@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxForceFieldShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxForceFieldShapeDesc@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxForceFieldShapeDesc@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxForceFieldShapeDesc@@UBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxForceFieldDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxForceFieldDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxForceFieldLinearKernelDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxForceFieldLinearKernelDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxForceFieldLinearKernel@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxForceFieldLinearKernel@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxForceFieldKernel@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxBoxForceFieldShapeDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxBoxForceFieldShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxBoxForceFieldShapeDesc@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxBoxForceFieldShapeDesc@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxBoxForceFieldShapeDesc@@UBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxBox@@QAE@ABVNxVec3@@0ABVNxMat33@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getNbPoints@NxDebugRenderable@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getPoints@NxDebugRenderable@@QBEPBUNxDebugPoint@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getNbLines@NxDebugRenderable@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getLines@NxDebugRenderable@@QBEPBUNxDebugLine@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getNbTriangles@NxDebugRenderable@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getTriangles@NxDebugRenderable@@QBEPBUNxDebugTriangle@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxConvexShapeDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxConvexShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxConvexShapeDesc@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxConvexShapeDesc@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxConvexShapeDesc@@UBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxConvexMesh@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxConvexMesh@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxConvexMeshDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxConvexMeshDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxBoxShapeDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxBoxShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxBoxShapeDesc@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxBoxShapeDesc@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValid@NxBoxShapeDesc@@UBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSpringDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxMaterialDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setToDefault@NxMaterialDesc@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxMaterial@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxMaterial@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxCookingInterface@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxCookingInterface@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?center@NxTriangle@@QBEXAAVNxVec3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0FlagRef@NxBitField@@QAE@AAV1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setFlag@NxBitField@@QAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?raiseFlag@NxBitField@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lowerFlag@NxBitField@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getFlag@NxBitField@@QBEII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?raiseFlagMask@NxBitField@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lowerFlagMask@NxBitField@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clearField@NxBitField@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxSegment@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxSegment@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxSegment@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?onConnect@NxRemoteDebuggerEventListener@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?onDisconnect@NxRemoteDebuggerEventListener@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?beforeMaskChange@NxRemoteDebuggerEventListener@@UAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?afterMaskChange@NxRemoteDebuggerEventListener@@UAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxRemoteDebuggerEventListener@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxRemoteDebuggerEventListener@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxRemoteDebugger@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxRemoteDebugger@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxUtilLib@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxUtilLib@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Initialized@CPhysicNovodex@@UAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCookingInterface@CPhysicNovodex@@UAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPhysicInterface@CPhysicNovodex@@UAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TraceMesh@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1TraceMesh@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTraceMesh@TraceMesh@@QAEXPAUmmesh_t@@PAUareanode_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E19
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E21
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E22
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPhysicNovodex@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPhysicNovodex@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxErrorStream@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IPhysicLayer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxErrorStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxErrorStream@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxUserOutputStream@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setupColor@DebugRenderer@@QBEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?renderData@DebugRenderer@@QBEXABVNxDebugRenderable@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?onContactNotify@ContactReport@@UAEXAAVNxContactPair@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E25
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ContactReport@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ContactReport@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GContactReport@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxUserContactReport@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitPhysic@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreePhysic@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUtilLibrary@CPhysicNovodex@@UAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Update@CPhysicNovodex@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndFrame@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveBody@CPhysicNovodex@@UAEXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioCalcBoneQuaterion@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector4D@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StudioCalcBonePosition@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvexMeshFromEntity@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityFromActor@CPhysicNovodex@@AAEPAVCBaseEntity@@PAVNxActor@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxBodyDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxActorDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4NxMat34@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateVehicle@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateVehicle@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBodySleeping@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetOrigin@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAvelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLinearMomentum@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddImpulse@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddForce@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxForceFieldLinearKernelDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1NxForceFieldDesc@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FLoadTree@CPhysicNovodex@@UAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckBINFile@CPhysicNovodex@@UAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HullNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MeshNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckFileTimes@CPhysicNovodex@@AAEHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetupWorld@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DebugDraw@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?P_SpeedsMessage@CPhysicNovodex@@AAE_NPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawPSpeeds@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeAllBodies@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeleportCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableCollision@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4NxBox@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NxSweepQueryHit@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pushBack@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QAEXABVNxFluidEmitterDesc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QBEABVNxFluidEmitterDesc@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEABQAVNxShapeDesc@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEABQAVNxForceFieldShapeDesc@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4NxFluidEmitterDesc@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reserve@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QAEPAVNxFluidEmitterDesc@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QAEPAVNxFluidEmitterDesc@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@AAEXPAVNxFluidEmitterDesc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@AAEXPAVNxFluidEmitterDesc@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reserve@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pushBack@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GNxFluidEmitterDesc@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@AAEPAVNxFluidEmitterDesc@@PBV2@0PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$NxArray@VNxFluidEmitterDesc@@VNxAllocatorDefault@@@@AAEPAVNxFluidEmitterDesc@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@PBQAV2@0PAPAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reserve@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@PBQAV2@0PAPAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NX_Swap@@YAXAAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7NxBoxForceFieldShapeDesc@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxSceneQuery@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxScene@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxForceFieldShapeDesc@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxForceFieldLinearKernel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxCookingInterface@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxSoftBodyMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxConvexShapeDesc@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxClothMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxShape@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IPhysicLayer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxRemoteDebuggerEventListener@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxTriangleMeshShapeDesc@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ContactReport@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserActorPairFiltering@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserOutputStream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxSceneQueryReport@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxBoxShapeDesc@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxFluid@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxInterface@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxActor@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxRemoteDebugger@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxFoundationSDK@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserRaycastReport@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserTriggerReport@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserContactModify@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserWheelContactModify@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxCloth@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserAllocator@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxSweepCache@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxMaterial@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUtilLib@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxStream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxForceFieldKernel@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxConvexMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxFluidEmitter@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxTriangleMesh@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxPhysicsSDK@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxProfileData@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxUserContactReport@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxShapeDesc@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxErrorStream@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPhysicNovodex@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7NxSoftBody@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?gContactReport@@3VContactReport@@A		; gContactReport
PUBLIC	?WorldPhysic@@3PAVIPhysicLayer@@A		; WorldPhysic
PUBLIC	?NovodexPhysic@@3VCPhysicNovodex@@A		; NovodexPhysic
PUBLIC	??_C@_0BD@EIOC@NxCreatePhysicsSDK?$AA@		; `string'
PUBLIC	??_C@_0BE@CEEP@NxReleasePhysicsSDK?$AA@		; `string'
PUBLIC	??_C@_0BA@FME@NxGetCookingLib?$AA@		; `string'
PUBLIC	??_C@_0N@FCEP@NxGetUtilLib?$AA@			; `string'
PUBLIC	?gDebugRenderer@@3VDebugRenderer@@A		; gDebugRenderer
_BSS	SEGMENT
?gContactReport@@3VContactReport@@A DD 01H DUP (?)	; gContactReport
?NovodexPhysic@@3VCPhysicNovodex@@A DB 0554H DUP (?)	; NovodexPhysic
_pNxCreatePhysicsSDK DD 01H DUP (?)
_pNxGetCookingLib DD 01H DUP (?)
_pNxReleasePhysicsSDK DD 01H DUP (?)
_pNxGetUtilLib DD 01H DUP (?)
_hPhysics DD	01H DUP (?)
?gDebugRenderer@@3VDebugRenderer@@A DB 01H DUP (?)	; gDebugRenderer
_BSS	ENDS
CONST	SEGMENT
_NxPiF64 DQ	0400921fb54442d18r		; 3.14159
_NxHalfPiF64 DQ	03ff921fb54442d18r		; 1.5708
_NxPiF32 DD	040490fdbr			; 3.14159
_NxHalfPiF32 DD	03fc90fdbr			; 1.5708
CONST	ENDS
CRT$XCU	SEGMENT
_$S23	DD	FLAT:_$E22
CRT$XCU	ENDS
_DATA	SEGMENT
?WorldPhysic@@3PAVIPhysicLayer@@A DD FLAT:?NovodexPhysic@@3VCPhysicNovodex@@A ; WorldPhysic
	ORG $+4
_NxPhysics DD	FLAT:??_C@_0BD@EIOC@NxCreatePhysicsSDK?$AA@
	DD	FLAT:_pNxCreatePhysicsSDK
	DD	FLAT:??_C@_0BE@CEEP@NxReleasePhysicsSDK?$AA@
	DD	FLAT:_pNxReleasePhysicsSDK
	DD	FLAT:??_C@_0BA@FME@NxGetCookingLib?$AA@
	DD	FLAT:_pNxGetCookingLib
	DD	FLAT:??_C@_0N@FCEP@NxGetUtilLib?$AA@
	DD	FLAT:_pNxGetUtilLib
	DD	00H
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S28	DD	FLAT:_$E27
CRT$XCU	ENDS
;	COMDAT ??_C@_0BD@EIOC@NxCreatePhysicsSDK?$AA@
CONST	SEGMENT
??_C@_0BD@EIOC@NxCreatePhysicsSDK?$AA@ DB 'NxCreatePhysicsSDK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CEEP@NxReleasePhysicsSDK?$AA@
CONST	SEGMENT
??_C@_0BE@CEEP@NxReleasePhysicsSDK?$AA@ DB 'NxReleasePhysicsSDK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FME@NxGetCookingLib?$AA@
CONST	SEGMENT
??_C@_0BA@FME@NxGetCookingLib?$AA@ DB 'NxGetCookingLib', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FCEP@NxGetUtilLib?$AA@
CONST	SEGMENT
??_C@_0N@FCEP@NxGetUtilLib?$AA@ DB 'NxGetUtilLib', 00H	; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25519:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25520
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25519
$L25520:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT _$E22
_TEXT	SEGMENT
_$E22	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E19
	call	_$E21
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E22	ENDP
_TEXT	ENDS
PUBLIC	??0CPhysicNovodex@@QAE@XZ			; CPhysicNovodex::CPhysicNovodex
;	COMDAT _$E19
_TEXT	SEGMENT
_$E19	PROC NEAR					; COMDAT

; 40   : CPhysicNovodex	NovodexPhysic;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?NovodexPhysic@@3VCPhysicNovodex@@A
	call	??0CPhysicNovodex@@QAE@XZ		; CPhysicNovodex::CPhysicNovodex
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E19	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
;	COMDAT _$E21
_TEXT	SEGMENT
_$E21	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:_$E20
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E21	ENDP
_TEXT	ENDS
PUBLIC	??1CPhysicNovodex@@QAE@XZ			; CPhysicNovodex::~CPhysicNovodex
;	COMDAT _$E20
_TEXT	SEGMENT
_$E20	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?NovodexPhysic@@3VCPhysicNovodex@@A
	call	??1CPhysicNovodex@@QAE@XZ		; CPhysicNovodex::~CPhysicNovodex
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E20	ENDP
_TEXT	ENDS
PUBLIC	??1NxBounds3@@QAE@XZ				; NxBounds3::~NxBounds3
PUBLIC	??1NxErrorStream@@UAE@XZ			; NxErrorStream::~NxErrorStream
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CPhysicNovodex@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CPhysicNovodex@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CPhysicNovodex@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CPhysicNovodex@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CPhysicNovodex@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1CPhysicNovodex@@QAE@XZ PROC NEAR			; CPhysicNovodex::~CPhysicNovodex, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CPhysicNovodex@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??1NxErrorStream@@UAE@XZ		; NxErrorStream::~NxErrorStream
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CPhysicNovodex@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	ret	0
__ehhandler$??1CPhysicNovodex@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CPhysicNovodex@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CPhysicNovodex@@QAE@XZ ENDP				; CPhysicNovodex::~CPhysicNovodex
;	COMDAT ??1NxBounds3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxBounds3@@QAE@XZ PROC NEAR				; NxBounds3::~NxBounds3, COMDAT

; 179  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 	//nothing
; 181  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxBounds3@@QAE@XZ ENDP				; NxBounds3::~NxBounds3
_TEXT	ENDS
PUBLIC	?InitPhysic@CPhysicNovodex@@UAEXXZ		; CPhysicNovodex::InitPhysic
PUBLIC	?FreePhysic@CPhysicNovodex@@UAEXXZ		; CPhysicNovodex::FreePhysic
PUBLIC	?GetUtilLibrary@CPhysicNovodex@@UAEPAXXZ	; CPhysicNovodex::GetUtilLibrary
PUBLIC	?Update@CPhysicNovodex@@UAEXM@Z			; CPhysicNovodex::Update
PUBLIC	?EndFrame@CPhysicNovodex@@UAEXXZ		; CPhysicNovodex::EndFrame
PUBLIC	?RemoveBody@CPhysicNovodex@@UAEXPAUedict_s@@@Z	; CPhysicNovodex::RemoveBody
PUBLIC	?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ; CPhysicNovodex::CreateBodyFromEntity
PUBLIC	?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ; CPhysicNovodex::CreateBoxFromEntity
PUBLIC	?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ; CPhysicNovodex::CreateKinematicBodyFromEntity
PUBLIC	?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ; CPhysicNovodex::CreateStaticBodyFromEntity
PUBLIC	?CreateVehicle@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@H@Z ; CPhysicNovodex::CreateVehicle
PUBLIC	?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ; CPhysicNovodex::RestoreBody
PUBLIC	?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ; CPhysicNovodex::SaveBody
PUBLIC	?Initialized@CPhysicNovodex@@UAE_NXZ		; CPhysicNovodex::Initialized
PUBLIC	?SetOrigin@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::SetOrigin
PUBLIC	?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::SetAngles
PUBLIC	?SetVelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::SetVelocity
PUBLIC	?SetAvelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::SetAvelocity
PUBLIC	?MoveObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::MoveObject
PUBLIC	?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::RotateObject
PUBLIC	?SetLinearMomentum@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::SetLinearMomentum
PUBLIC	?AddImpulse@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1M@Z ; CPhysicNovodex::AddImpulse
PUBLIC	?AddForce@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::AddForce
PUBLIC	?EnableCollision@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z ; CPhysicNovodex::EnableCollision
PUBLIC	?MakeKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z ; CPhysicNovodex::MakeKinematic
PUBLIC	?UpdateVehicle@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ; CPhysicNovodex::UpdateVehicle
PUBLIC	?FLoadTree@CPhysicNovodex@@UAEHPAD@Z		; CPhysicNovodex::FLoadTree
PUBLIC	?CheckBINFile@CPhysicNovodex@@UAEHPAD@Z		; CPhysicNovodex::CheckBINFile
PUBLIC	?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z	; CPhysicNovodex::BuildCollisionTree
PUBLIC	?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z ; CPhysicNovodex::UpdateEntityPos
PUBLIC	?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ; CPhysicNovodex::UpdateEntityAABB
PUBLIC	?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z ; CPhysicNovodex::UpdateActorPos
PUBLIC	?SetupWorld@CPhysicNovodex@@UAEXXZ		; CPhysicNovodex::SetupWorld
PUBLIC	?DebugDraw@CPhysicNovodex@@UAEXXZ		; CPhysicNovodex::DebugDraw
PUBLIC	?DrawPSpeeds@CPhysicNovodex@@UAEXXZ		; CPhysicNovodex::DrawPSpeeds
PUBLIC	?FreeAllBodies@CPhysicNovodex@@UAEXXZ		; CPhysicNovodex::FreeAllBodies
PUBLIC	?TeleportCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ; CPhysicNovodex::TeleportCharacter
PUBLIC	?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ; CPhysicNovodex::TeleportActor
PUBLIC	?MoveCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ; CPhysicNovodex::MoveCharacter
PUBLIC	?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ; CPhysicNovodex::MoveKinematic
PUBLIC	?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z ; CPhysicNovodex::SweepTest
PUBLIC	?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z ; CPhysicNovodex::SweepEntity
PUBLIC	?IsBodySleeping@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z ; CPhysicNovodex::IsBodySleeping
PUBLIC	?GetCookingInterface@CPhysicNovodex@@UAEPAXXZ	; CPhysicNovodex::GetCookingInterface
PUBLIC	?GetPhysicInterface@CPhysicNovodex@@UAEPAXXZ	; CPhysicNovodex::GetPhysicInterface
PUBLIC	??0IPhysicLayer@@QAE@XZ				; IPhysicLayer::IPhysicLayer
PUBLIC	??_7CPhysicNovodex@@6B@				; CPhysicNovodex::`vftable'
PUBLIC	??0NxBounds3@@QAE@XZ				; NxBounds3::NxBounds3
PUBLIC	??0NxErrorStream@@QAE@XZ			; NxErrorStream::NxErrorStream
;	COMDAT ??_7CPhysicNovodex@@6B@
CONST	SEGMENT
??_7CPhysicNovodex@@6B@ DD FLAT:?InitPhysic@CPhysicNovodex@@UAEXXZ ; CPhysicNovodex::`vftable'
	DD	FLAT:?FreePhysic@CPhysicNovodex@@UAEXXZ
	DD	FLAT:?Update@CPhysicNovodex@@UAEXM@Z
	DD	FLAT:?EndFrame@CPhysicNovodex@@UAEXXZ
	DD	FLAT:?GetUtilLibrary@CPhysicNovodex@@UAEPAXXZ
	DD	FLAT:?Initialized@CPhysicNovodex@@UAE_NXZ
	DD	FLAT:?RemoveBody@CPhysicNovodex@@UAEXPAUedict_s@@@Z
	DD	FLAT:?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	FLAT:?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	FLAT:?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	FLAT:?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	FLAT:?CreateVehicle@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@H@Z
	DD	FLAT:?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	FLAT:?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?SetOrigin@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?SetVelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?SetAvelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?MoveObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?SetLinearMomentum@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?AddImpulse@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1M@Z
	DD	FLAT:?AddForce@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	FLAT:?EnableCollision@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z
	DD	FLAT:?MakeKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z
	DD	FLAT:?UpdateVehicle@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?FLoadTree@CPhysicNovodex@@UAEHPAD@Z
	DD	FLAT:?CheckBINFile@CPhysicNovodex@@UAEHPAD@Z
	DD	FLAT:?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z
	DD	FLAT:?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	DD	FLAT:?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	DD	FLAT:?SetupWorld@CPhysicNovodex@@UAEXXZ
	DD	FLAT:?DebugDraw@CPhysicNovodex@@UAEXXZ
	DD	FLAT:?DrawPSpeeds@CPhysicNovodex@@UAEXXZ
	DD	FLAT:?FreeAllBodies@CPhysicNovodex@@UAEXXZ
	DD	FLAT:?TeleportCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z
	DD	FLAT:?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
	DD	FLAT:?IsBodySleeping@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	DD	FLAT:?GetCookingInterface@CPhysicNovodex@@UAEPAXXZ
	DD	FLAT:?GetPhysicInterface@CPhysicNovodex@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CPhysicNovodex@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CPhysicNovodex@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CPhysicNovodex@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CPhysicNovodex@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CPhysicNovodex@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CPhysicNovodex@@QAE@XZ PROC NEAR			; CPhysicNovodex::CPhysicNovodex, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CPhysicNovodex@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IPhysicLayer@@QAE@XZ			; IPhysicLayer::IPhysicLayer
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??0NxBounds3@@QAE@XZ			; NxBounds3::NxBounds3
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	??0NxErrorStream@@QAE@XZ		; NxErrorStream::NxErrorStream
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPhysicNovodex@@6B@ ; CPhysicNovodex::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CPhysicNovodex@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	ret	0
__ehhandler$??0CPhysicNovodex@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CPhysicNovodex@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CPhysicNovodex@@QAE@XZ ENDP				; CPhysicNovodex::CPhysicNovodex
PUBLIC	?setEmpty@NxBounds3@@QAEXXZ			; NxBounds3::setEmpty
PUBLIC	??0NxVec3@@QAE@XZ				; NxVec3::NxVec3
;	COMDAT ??0NxBounds3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxBounds3@@QAE@XZ PROC NEAR				; NxBounds3::NxBounds3, COMDAT

; 172  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 173  : 	// Default to empty boxes for compatibility TODO: PT: remove this if useless
; 174  : 	setEmpty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setEmpty@NxBounds3@@QAEXXZ		; NxBounds3::setEmpty

; 175  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxBounds3@@QAE@XZ ENDP				; NxBounds3::NxBounds3
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxVec3@@QAE@XZ PROC NEAR				; NxVec3::NxVec3, COMDAT

; 424  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 425  : 	//default constructor leaves data uninitialized.
; 426  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxVec3@@QAE@XZ ENDP					; NxVec3::NxVec3
_TEXT	ENDS
PUBLIC	?set@NxBounds3@@QAEXMMMMMM@Z			; NxBounds3::set
EXTRN	__fltused:NEAR
;	COMDAT ?setEmpty@NxBounds3@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setEmpty@NxBounds3@@QAEXXZ PROC NEAR			; NxBounds3::setEmpty, COMDAT

; 185  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 186  : 	// We know use this particular pattern for empty boxes
; 187  : 	set(NX_MAX_REAL, NX_MAX_REAL, NX_MAX_REAL,
; 188  : 		NX_MIN_REAL, NX_MIN_REAL, NX_MIN_REAL);

	push	-8388609				; ff7fffffH
	push	-8388609				; ff7fffffH
	push	-8388609				; ff7fffffH
	push	2139095039				; 7f7fffffH
	push	2139095039				; 7f7fffffH
	push	2139095039				; 7f7fffffH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set@NxBounds3@@QAEXMMMMMM@Z		; NxBounds3::set

; 189  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setEmpty@NxBounds3@@QAEXXZ ENDP			; NxBounds3::setEmpty
_TEXT	ENDS
PUBLIC	?set@NxVec3@@QAEXMMM@Z				; NxVec3::set
;	COMDAT ?set@NxBounds3@@QAEXMMMMMM@Z
_TEXT	SEGMENT
_minx$ = 8
_miny$ = 12
_minz$ = 16
_maxx$ = 20
_maxy$ = 24
_maxz$ = 28
_this$ = -4
?set@NxBounds3@@QAEXMMMMMM@Z PROC NEAR			; NxBounds3::set, COMDAT

; 198  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 	min.set(minx, miny, minz);

	mov	eax, DWORD PTR _minz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _miny$[ebp]
	push	ecx
	mov	edx, DWORD PTR _minx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?set@NxVec3@@QAEXMMM@Z			; NxVec3::set

; 200  : 	max.set(maxx, maxy, maxz);

	mov	eax, DWORD PTR _maxz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxy$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxx$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?set@NxVec3@@QAEXMMM@Z			; NxVec3::set

; 201  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?set@NxBounds3@@QAEXMMMMMM@Z ENDP			; NxBounds3::set
_TEXT	ENDS
;	COMDAT ?set@NxVec3@@QAEXMMM@Z
_TEXT	SEGMENT
__x$ = 8
__y$ = 12
__z$ = 16
_this$ = -4
?set@NxVec3@@QAEXMMM@Z PROC NEAR			; NxVec3::set, COMDAT

; 578  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 579  : 	this->x = _x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __x$[ebp]
	mov	DWORD PTR [eax], ecx

; 580  : 	this->y = _y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __y$[ebp]
	mov	DWORD PTR [edx+4], eax

; 581  : 	this->z = _z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __z$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 582  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?set@NxVec3@@QAEXMMM@Z ENDP				; NxVec3::set
_TEXT	ENDS
;	COMDAT ?Initialized@CPhysicNovodex@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4
?Initialized@CPhysicNovodex@@UAE_NXZ PROC NEAR		; CPhysicNovodex::Initialized, COMDAT

; 82   : 	bool		Initialized( void ) { return (m_pPhysics != NULL); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+4], 0
	setne	cl
	mov	al, cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Initialized@CPhysicNovodex@@UAE_NXZ ENDP		; CPhysicNovodex::Initialized
_TEXT	ENDS
;	COMDAT ?GetCookingInterface@CPhysicNovodex@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4
?GetCookingInterface@CPhysicNovodex@@UAEPAXXZ PROC NEAR	; CPhysicNovodex::GetCookingInterface, COMDAT

; 113  : 	void		*GetCookingInterface( void ) { return m_pCooking; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1352]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCookingInterface@CPhysicNovodex@@UAEPAXXZ ENDP	; CPhysicNovodex::GetCookingInterface
_TEXT	ENDS
;	COMDAT ?GetPhysicInterface@CPhysicNovodex@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4
?GetPhysicInterface@CPhysicNovodex@@UAEPAXXZ PROC NEAR	; CPhysicNovodex::GetPhysicInterface, COMDAT

; 114  : 	void		*GetPhysicInterface( void ) { return m_pPhysics; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPhysicInterface@CPhysicNovodex@@UAEPAXXZ ENDP	; CPhysicNovodex::GetPhysicInterface
_TEXT	ENDS
PUBLIC	??1NxUserOutputStream@@MAE@XZ			; NxUserOutputStream::~NxUserOutputStream
;	COMDAT ??1NxErrorStream@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxErrorStream@@UAE@XZ PROC NEAR			; NxErrorStream::~NxErrorStream, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxUserOutputStream@@MAE@XZ		; NxUserOutputStream::~NxUserOutputStream
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxErrorStream@@UAE@XZ ENDP				; NxErrorStream::~NxErrorStream
_TEXT	ENDS
PUBLIC	??_7NxUserOutputStream@@6B@			; NxUserOutputStream::`vftable'
PUBLIC	??_GNxUserOutputStream@@MAEPAXI@Z		; NxUserOutputStream::`scalar deleting destructor'
PUBLIC	??_ENxUserOutputStream@@MAEPAXI@Z		; NxUserOutputStream::`vector deleting destructor'
EXTRN	__purecall:NEAR
;	COMDAT ??_7NxUserOutputStream@@6B@
; File z:\xashxtsrc\phys_shared\nxuseroutputstream.h
CONST	SEGMENT
??_7NxUserOutputStream@@6B@ DD FLAT:__purecall		; NxUserOutputStream::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_ENxUserOutputStream@@MAEPAXI@Z
CONST	ENDS
;	COMDAT ??1NxUserOutputStream@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxUserOutputStream@@MAE@XZ PROC NEAR			; NxUserOutputStream::~NxUserOutputStream, COMDAT

; 60   : 	virtual ~NxUserOutputStream(){};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxUserOutputStream@@6B@ ; NxUserOutputStream::`vftable'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxUserOutputStream@@MAE@XZ ENDP			; NxUserOutputStream::~NxUserOutputStream
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GNxUserOutputStream@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxUserOutputStream@@MAEPAXI@Z PROC NEAR		; NxUserOutputStream::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxUserOutputStream@@MAE@XZ		; NxUserOutputStream::~NxUserOutputStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L41697
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L41697:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxUserOutputStream@@MAEPAXI@Z ENDP			; NxUserOutputStream::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7IPhysicLayer@@6B@				; IPhysicLayer::`vftable'
;	COMDAT ??_7IPhysicLayer@@6B@
CONST	SEGMENT
??_7IPhysicLayer@@6B@ DD FLAT:__purecall		; IPhysicLayer::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IPhysicLayer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IPhysicLayer@@QAE@XZ PROC NEAR			; IPhysicLayer::IPhysicLayer, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IPhysicLayer@@6B@ ; IPhysicLayer::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IPhysicLayer@@QAE@XZ ENDP				; IPhysicLayer::IPhysicLayer
_TEXT	ENDS
PUBLIC	??0NxUserOutputStream@@QAE@XZ			; NxUserOutputStream::NxUserOutputStream
PUBLIC	?reportError@NxErrorStream@@UAEXW4NxErrorCode@@PBD1H@Z ; NxErrorStream::reportError
PUBLIC	?reportAssertViolation@NxErrorStream@@UAE?AW4NxAssertResponse@@PBD0H@Z ; NxErrorStream::reportAssertViolation
PUBLIC	?print@NxErrorStream@@UAEXPBD@Z			; NxErrorStream::print
PUBLIC	??_7NxErrorStream@@6B@				; NxErrorStream::`vftable'
PUBLIC	??_GNxErrorStream@@UAEPAXI@Z			; NxErrorStream::`scalar deleting destructor'
PUBLIC	??_ENxErrorStream@@UAEPAXI@Z			; NxErrorStream::`vector deleting destructor'
;	COMDAT ??_7NxErrorStream@@6B@
CONST	SEGMENT
??_7NxErrorStream@@6B@ DD FLAT:?reportError@NxErrorStream@@UAEXW4NxErrorCode@@PBD1H@Z ; NxErrorStream::`vftable'
	DD	FLAT:?reportAssertViolation@NxErrorStream@@UAE?AW4NxAssertResponse@@PBD0H@Z
	DD	FLAT:?print@NxErrorStream@@UAEXPBD@Z
	DD	FLAT:??_ENxErrorStream@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??0NxErrorStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxErrorStream@@QAE@XZ PROC NEAR			; NxErrorStream::NxErrorStream, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxUserOutputStream@@QAE@XZ		; NxUserOutputStream::NxUserOutputStream
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxErrorStream@@6B@ ; NxErrorStream::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxErrorStream@@QAE@XZ ENDP				; NxErrorStream::NxErrorStream
_TEXT	ENDS
PUBLIC	??_C@_0BH@LMKO@invalid?5parameter?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@FBLK@invalid?5operation?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@DFDP@out?5of?5memory?3?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_03HHKO@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0BD@JFAD@unknown?5error?3?5?$CFs?6?$AA@	; `string'
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
;	COMDAT ??_C@_0BH@LMKO@invalid?5parameter?3?5?$CFs?6?$AA@
; File z:\xashxtsrc\server\physics\nxerrorstream.h
CONST	SEGMENT
??_C@_0BH@LMKO@invalid?5parameter?3?5?$CFs?6?$AA@ DB 'invalid parameter: '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FBLK@invalid?5operation?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@FBLK@invalid?5operation?3?5?$CFs?6?$AA@ DB 'invalid operation: '
	DB	'%s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DFDP@out?5of?5memory?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@DFDP@out?5of?5memory?3?5?$CFs?6?$AA@ DB 'out of memory: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHKO@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03HHKO@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JFAD@unknown?5error?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@JFAD@unknown?5error?3?5?$CFs?6?$AA@ DB 'unknown error: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?reportError@NxErrorStream@@UAEXW4NxErrorCode@@PBD1H@Z
_TEXT	SEGMENT
_e$ = 8
_message$ = 12
_this$ = -4
?reportError@NxErrorStream@@UAEXW4NxErrorCode@@PBD1H@Z PROC NEAR ; NxErrorStream::reportError, COMDAT

; 24   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 		{

	mov	eax, DWORD PTR _e$[ebp]
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	sub	ecx, 1
	mov	DWORD PTR -8+[ebp], ecx
	cmp	DWORD PTR -8+[ebp], 205			; 000000cdH
	ja	$L45918
	mov	eax, DWORD PTR -8+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L51692[eax]
	jmp	DWORD PTR $L51693[edx*4]
$L45908:

; 27   : 		case NXE_INVALID_PARAMETER:
; 28   : 			ALERT( at_error, "invalid parameter: %s\n", message );

	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BH@LMKO@invalid?5parameter?3?5?$CFs?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 29   : 			break;

	jmp	SHORT $L45905
$L45910:

; 30   : 		case NXE_INVALID_OPERATION:
; 31   : 			ALERT( at_error, "invalid operation: %s\n", message );

	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BH@FBLK@invalid?5operation?3?5?$CFs?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 32   : 			break;

	jmp	SHORT $L45905
$L45912:

; 33   : 		case NXE_OUT_OF_MEMORY:
; 34   : 			ALERT( at_error, "out of memory: %s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BD@DFDP@out?5of?5memory?3?5?$CFs?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 35   : 			break;

	jmp	SHORT $L45905
$L45914:

; 36   : 		case NXE_DB_INFO:
; 37   : 			ALERT( at_console, "%s\n", message );

	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_03HHKO@?$CFs?6?$AA@	; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 38   : 			break;

	jmp	SHORT $L45905
$L45916:

; 39   : 		case NXE_DB_WARNING:
; 40   : 			if( !m_fHideWarning )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+4]
	test	eax, eax
	jne	SHORT $L45917

; 41   : 				ALERT( at_warning, "%s\n", message );

	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_03HHKO@?$CFs?6?$AA@	; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L45917:

; 42   : 			break;

	jmp	SHORT $L45905
$L45918:

; 43   : 		default:
; 44   : 			ALERT( at_error, "unknown error: %s\n", message );

	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BD@JFAD@unknown?5error?3?5?$CFs?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L45905:

; 47   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L51693:
	DD	$L45908
	DD	$L45910
	DD	$L45912
	DD	$L45914
	DD	$L45916
	DD	$L45918
$L51692:
	DB	0
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
?reportError@NxErrorStream@@UAEXW4NxErrorCode@@PBD1H@Z ENDP ; NxErrorStream::reportError
_TEXT	ENDS
PUBLIC	??_C@_0CE@MCFO@access?5violation?5?3?5?$CFs?5?$CI?$CFs?5line?5?$CF@ ; `string'
;	COMDAT ??_C@_0CE@MCFO@access?5violation?5?3?5?$CFs?5?$CI?$CFs?5line?5?$CF@
; File z:\xashxtsrc\server\physics\nxerrorstream.h
CONST	SEGMENT
??_C@_0CE@MCFO@access?5violation?5?3?5?$CFs?5?$CI?$CFs?5line?5?$CF@ DB 'a'
	DB	'ccess violation : %s (%s line %d)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?reportAssertViolation@NxErrorStream@@UAE?AW4NxAssertResponse@@PBD0H@Z
_TEXT	SEGMENT
_message$ = 8
_file$ = 12
_line$ = 16
_this$ = -4
?reportAssertViolation@NxErrorStream@@UAE?AW4NxAssertResponse@@PBD0H@Z PROC NEAR ; NxErrorStream::reportAssertViolation, COMDAT

; 50   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		ALERT( at_aiconsole, "access violation : %s (%s line %d)\n", message, file, line );

	mov	eax, DWORD PTR _line$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CE@MCFO@access?5violation?5?3?5?$CFs?5?$CI?$CFs?5line?5?$CF@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H

; 52   : 		return NX_AR_BREAKPOINT;		

	mov	eax, 2

; 53   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?reportAssertViolation@NxErrorStream@@UAE?AW4NxAssertResponse@@PBD0H@Z ENDP ; NxErrorStream::reportAssertViolation
_TEXT	ENDS
;	COMDAT ?print@NxErrorStream@@UAEXPBD@Z
_TEXT	SEGMENT
_message$ = 8
_this$ = -4
?print@NxErrorStream@@UAEXPBD@Z PROC NEAR		; NxErrorStream::print, COMDAT

; 56   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 		ALERT( at_console, "%s\n", message );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_03HHKO@?$CFs?6?$AA@	; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 58   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?print@NxErrorStream@@UAEXPBD@Z ENDP			; NxErrorStream::print
_TEXT	ENDS
;	COMDAT ??_GNxErrorStream@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxErrorStream@@UAEPAXI@Z PROC NEAR			; NxErrorStream::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxErrorStream@@UAE@XZ		; NxErrorStream::~NxErrorStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L49069
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L49069:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxErrorStream@@UAEPAXI@Z ENDP			; NxErrorStream::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??0NxUserOutputStream@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxUserOutputStream@@QAE@XZ PROC NEAR			; NxUserOutputStream::NxUserOutputStream, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxUserOutputStream@@6B@ ; NxUserOutputStream::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxUserOutputStream@@QAE@XZ ENDP			; NxUserOutputStream::NxUserOutputStream
_TEXT	ENDS
;	COMDAT _$E27
_TEXT	SEGMENT
_$E27	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E24
	call	_$E26
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E27	ENDP
_TEXT	ENDS
PUBLIC	??0ContactReport@@QAE@XZ			; ContactReport::ContactReport
;	COMDAT _$E24
_TEXT	SEGMENT
_$E24	PROC NEAR					; COMDAT

; 155  : } gContactReport;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?gContactReport@@3VContactReport@@A ; gContactReport
	call	??0ContactReport@@QAE@XZ		; ContactReport::ContactReport
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E24	ENDP
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT
_$E26	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:_$E25
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E26	ENDP
_TEXT	ENDS
PUBLIC	??1ContactReport@@UAE@XZ			; ContactReport::~ContactReport
;	COMDAT _$E25
_TEXT	SEGMENT
_$E25	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:?gContactReport@@3VContactReport@@A ; gContactReport
	call	??1ContactReport@@UAE@XZ		; ContactReport::~ContactReport
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E25	ENDP
_TEXT	ENDS
PUBLIC	??1NxUserContactReport@@MAE@XZ			; NxUserContactReport::~NxUserContactReport
;	COMDAT ??1ContactReport@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1ContactReport@@UAE@XZ PROC NEAR			; ContactReport::~ContactReport, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxUserContactReport@@MAE@XZ		; NxUserContactReport::~NxUserContactReport
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1ContactReport@@UAE@XZ ENDP				; ContactReport::~ContactReport
_TEXT	ENDS
PUBLIC	??_7NxUserContactReport@@6B@			; NxUserContactReport::`vftable'
PUBLIC	??_GNxUserContactReport@@MAEPAXI@Z		; NxUserContactReport::`scalar deleting destructor'
PUBLIC	??_ENxUserContactReport@@MAEPAXI@Z		; NxUserContactReport::`vector deleting destructor'
;	COMDAT ??_7NxUserContactReport@@6B@
; File z:\xashxtsrc\phys_shared\nxusercontactreport.h
CONST	SEGMENT
??_7NxUserContactReport@@6B@ DD FLAT:__purecall		; NxUserContactReport::`vftable'
	DD	FLAT:??_ENxUserContactReport@@MAEPAXI@Z
CONST	ENDS
;	COMDAT ??1NxUserContactReport@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxUserContactReport@@MAE@XZ PROC NEAR		; NxUserContactReport::~NxUserContactReport, COMDAT

; 170  : 	virtual ~NxUserContactReport(){};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxUserContactReport@@6B@ ; NxUserContactReport::`vftable'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxUserContactReport@@MAE@XZ ENDP			; NxUserContactReport::~NxUserContactReport
_TEXT	ENDS
;	COMDAT ??_GNxUserContactReport@@MAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxUserContactReport@@MAEPAXI@Z PROC NEAR		; NxUserContactReport::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxUserContactReport@@MAE@XZ		; NxUserContactReport::~NxUserContactReport
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L41501
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L41501:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxUserContactReport@@MAEPAXI@Z ENDP			; NxUserContactReport::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_EContactReport@@UAEPAXI@Z			; ContactReport::`vector deleting destructor'
PUBLIC	??0NxUserContactReport@@QAE@XZ			; NxUserContactReport::NxUserContactReport
PUBLIC	?onContactNotify@ContactReport@@UAEXAAVNxContactPair@@I@Z ; ContactReport::onContactNotify
PUBLIC	??_7ContactReport@@6B@				; ContactReport::`vftable'
PUBLIC	??_GContactReport@@UAEPAXI@Z			; ContactReport::`scalar deleting destructor'
;	COMDAT ??_7ContactReport@@6B@
CONST	SEGMENT
??_7ContactReport@@6B@ DD FLAT:?onContactNotify@ContactReport@@UAEXAAVNxContactPair@@I@Z ; ContactReport::`vftable'
	DD	FLAT:??_EContactReport@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??0ContactReport@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0ContactReport@@QAE@XZ PROC NEAR			; ContactReport::ContactReport, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxUserContactReport@@QAE@XZ		; NxUserContactReport::NxUserContactReport
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7ContactReport@@6B@ ; ContactReport::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0ContactReport@@QAE@XZ ENDP				; ContactReport::ContactReport
_TEXT	ENDS
PUBLIC	??0NxVec3@@QAE@ABVVector@@@Z			; NxVec3::NxVec3
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@3ffe8000000000000000
EXTRN	?DispatchTouch@@YAXPAUedict_s@@0@Z:NEAR		; DispatchTouch
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@3ffe8000000000000000
CONST	SEGMENT
__real@4@3ffe8000000000000000 DD 03f000000r	; 0.5
CONST	ENDS
;	COMDAT ?onContactNotify@ContactReport@@UAEXAAVNxContactPair@@I@Z
_TEXT	SEGMENT
_this$ = -4
_e1$ = -8
_e2$ = -12
_basevelocity$49167 = -24
_basevelocity$49172 = -36
$T51722 = -48
$T51723 = -60
$T51724 = -72
$T51725 = -84
$T51726 = -96
$T51727 = -108
_pair$ = 8
_events$ = 12
?onContactNotify@ContactReport@@UAEXAAVNxContactPair@@I@Z PROC NEAR ; ContactReport::onContactNotify, COMDAT

; 122  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		if( !FBitSet( events, NX_NOTIFY_ON_TOUCH ))

	mov	eax, DWORD PTR _events$[ebp]
	and	eax, 8
	test	eax, eax
	jne	SHORT $L49159

; 124  : 			return;

	jmp	$L49158
$L49159:

; 125  : 
; 126  : 		edict_t *e1 = (edict_t *)pair.actors[0]->userData;

	mov	ecx, DWORD PTR _pair$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _e1$[ebp], eax

; 127  : 		edict_t *e2 = (edict_t *)pair.actors[1]->userData;

	mov	ecx, DWORD PTR _pair$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _e2$[ebp], eax

; 128  : 
; 129  : 		if( !e1 || !e2 ) return;

	cmp	DWORD PTR _e1$[ebp], 0
	je	SHORT $L49165
	cmp	DWORD PTR _e2$[ebp], 0
	jne	SHORT $L49164
$L49165:
	jmp	$L49158
$L49164:

; 130  : 
; 131  : 		if( e1->v.flags & FL_CONVEYOR )

	mov	ecx, DWORD PTR _e1$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	and	edx, 4
	test	edx, edx
	je	SHORT $L49166

; 133  : 			Vector basevelocity = e1->v.movedir * e1->v.speed * CONVEYOR_SCALE_FACTOR;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR [eax+4]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T51723[ebp]
	push	ecx
	mov	edx, DWORD PTR _e1$[ebp]
	mov	eax, DWORD PTR [edx+632]
	push	eax
	lea	ecx, DWORD PTR $T51722[ebp]
	push	ecx
	mov	ecx, DWORD PTR _e1$[ebp]
	add	ecx, 196				; 000000c4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _basevelocity$49167[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 134  : 			pair.actors[1]->setLinearMomentum( basevelocity );

	lea	edx, DWORD PTR _basevelocity$49167[ebp]
	push	edx
	lea	ecx, DWORD PTR $T51724[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T51724[ebp]
	push	eax
	mov	ecx, DWORD PTR _pair$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _pair$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+256]
$L49166:

; 136  : 
; 137  : 		if( e2->v.flags & FL_CONVEYOR )

	mov	eax, DWORD PTR _e2$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L49171

; 139  : 			Vector basevelocity = e2->v.movedir * e2->v.speed * CONVEYOR_SCALE_FACTOR;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR [edx+4]
	fmul	DWORD PTR __real@4@3ffe8000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T51726[ebp]
	push	eax
	mov	ecx, DWORD PTR _e2$[ebp]
	mov	edx, DWORD PTR [ecx+632]
	push	edx
	lea	eax, DWORD PTR $T51725[ebp]
	push	eax
	mov	ecx, DWORD PTR _e2$[ebp]
	add	ecx, 196				; 000000c4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _basevelocity$49172[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 140  : 			pair.actors[0]->setLinearMomentum( basevelocity );

	lea	ecx, DWORD PTR _basevelocity$49172[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T51727[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T51727[ebp]
	push	edx
	mov	eax, DWORD PTR _pair$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pair$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+256]
$L49171:

; 142  : 
; 143  : 		if( e1 && e1->v.solid != SOLID_NOT )

	cmp	DWORD PTR _e1$[ebp], 0
	je	SHORT $L49176
	mov	eax, DWORD PTR _e1$[ebp]
	cmp	DWORD PTR [eax+396], 0
	je	SHORT $L49176

; 145  : 			// FIXME: build trace info
; 146  : 			DispatchTouch( e1, e2 );

	mov	ecx, DWORD PTR _e2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e1$[ebp]
	push	edx
	call	?DispatchTouch@@YAXPAUedict_s@@0@Z	; DispatchTouch
	add	esp, 8
$L49176:

; 148  : 
; 149  : 		if( e2 && e2->v.solid != SOLID_NOT )

	cmp	DWORD PTR _e2$[ebp], 0
	je	SHORT $L49177
	mov	eax, DWORD PTR _e2$[ebp]
	cmp	DWORD PTR [eax+396], 0
	je	SHORT $L49177

; 151  : 			// FIXME: build trace info
; 152  : 			DispatchTouch( e1, e2 );

	mov	ecx, DWORD PTR _e2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _e1$[ebp]
	push	edx
	call	?DispatchTouch@@YAXPAUedict_s@@0@Z	; DispatchTouch
	add	esp, 8
$L49177:
$L49158:

; 154  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?onContactNotify@ContactReport@@UAEXAAVNxContactPair@@I@Z ENDP ; ContactReport::onContactNotify
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T51736 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T51736[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@ABVVector@@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0NxVec3@@QAE@ABVVector@@@Z PROC NEAR			; NxVec3::NxVec3, COMDAT

; 420  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 421  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0NxVec3@@QAE@ABVVector@@@Z ENDP			; NxVec3::NxVec3
_TEXT	ENDS
;	COMDAT ??_GContactReport@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GContactReport@@UAEPAXI@Z PROC NEAR			; ContactReport::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ContactReport@@UAE@XZ		; ContactReport::~ContactReport
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L49192
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L49192:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GContactReport@@UAEPAXI@Z ENDP			; ContactReport::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??0NxUserContactReport@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxUserContactReport@@QAE@XZ PROC NEAR		; NxUserContactReport::NxUserContactReport, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxUserContactReport@@6B@ ; NxUserContactReport::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxUserContactReport@@QAE@XZ ENDP			; NxUserContactReport::NxUserContactReport
_TEXT	ENDS
PUBLIC	??0NxVec3@@QAE@MMM@Z				; NxVec3::NxVec3
PUBLIC	??4NxVec3@@QAEABV0@ABV0@@Z			; NxVec3::operator=
PUBLIC	??_C@_0CI@NOCF@InitPhysic?3?5physics?5already?5init@ ; `string'
PUBLIC	??_C@_0DA@OFMN@InitPhysic?3?5PhysX?5support?5is?5dis@ ; `string'
PUBLIC	??_C@_0BA@HBBH@PhysXLoader?4dll?$AA@		; `string'
PUBLIC	??_C@_0BB@END@?$CKPhysXLoader?4dll?$AA@		; `string'
PUBLIC	??_C@_0FK@GABD@InitPhysic?3?5failed?5to?5loading?5Nx@ ; `string'
PUBLIC	??0NxPhysicsSDKDesc@@QAE@XZ			; NxPhysicsSDKDesc::NxPhysicsSDKDesc
PUBLIC	??_C@_0DA@KMH@InitPhysic?3?5failed?5to?5initalize?5@ ; `string'
PUBLIC	??_C@_0DB@HODF@InitPhysic?3?5failed?5to?5initalize?5@ ; `string'
PUBLIC	??_C@_0CO@BG@InitPhysic?3?5failed?5to?5initalize?5@ ; `string'
PUBLIC	??0NxSceneDesc@@QAE@XZ				; NxSceneDesc::NxSceneDesc
PUBLIC	??_C@_0M@PIGM@sv_maxspeed?$AA@			; `string'
PUBLIC	__real@4@00000000000000000000
PUBLIC	??0NxMaterialDesc@@QAE@XZ			; NxMaterialDesc::NxMaterialDesc
EXTRN	?GameInitNullPhysics@@YAXXZ:NEAR		; GameInitNullPhysics
EXTRN	?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z:NEAR ; Sys_LoadLibrary
EXTRN	?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z:NEAR	; Sys_FreeLibrary
EXTRN	?g_allow_physx@@3PAUcvar_s@@A:DWORD		; g_allow_physx
;	COMDAT ??_C@_0CI@NOCF@InitPhysic?3?5physics?5already?5init@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CI@NOCF@InitPhysic?3?5physics?5already?5init@ DB 'InitPhysic: phys'
	DB	'ics already initalized', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OFMN@InitPhysic?3?5PhysX?5support?5is?5dis@
CONST	SEGMENT
??_C@_0DA@OFMN@InitPhysic?3?5PhysX?5support?5is?5dis@ DB 'InitPhysic: Phy'
	DB	'sX support is disabled by user.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HBBH@PhysXLoader?4dll?$AA@
CONST	SEGMENT
??_C@_0BA@HBBH@PhysXLoader?4dll?$AA@ DB 'PhysXLoader.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@END@?$CKPhysXLoader?4dll?$AA@
CONST	SEGMENT
??_C@_0BB@END@?$CKPhysXLoader?4dll?$AA@ DB '*PhysXLoader.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@GABD@InitPhysic?3?5failed?5to?5loading?5Nx@
CONST	SEGMENT
??_C@_0FK@GABD@InitPhysic?3?5failed?5to?5loading?5Nx@ DB 'InitPhysic: fai'
	DB	'led to loading NxPhysics.dll.', 0aH, 'Physics abstraction lay'
	DB	'er will be disabled.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KMH@InitPhysic?3?5failed?5to?5initalize?5@
CONST	SEGMENT
??_C@_0DA@KMH@InitPhysic?3?5failed?5to?5initalize?5@ DB 'InitPhysic: fail'
	DB	'ed to initalize physics engine', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HODF@InitPhysic?3?5failed?5to?5initalize?5@
CONST	SEGMENT
??_C@_0DB@HODF@InitPhysic?3?5failed?5to?5initalize?5@ DB 'InitPhysic: fai'
	DB	'led to initalize cooking library', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BG@InitPhysic?3?5failed?5to?5initalize?5@
CONST	SEGMENT
??_C@_0CO@BG@InitPhysic?3?5failed?5to?5initalize?5@ DB 'InitPhysic: faile'
	DB	'd to initalize util library', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PIGM@sv_maxspeed?$AA@
CONST	SEGMENT
??_C@_0M@PIGM@sv_maxspeed?$AA@ DB 'sv_maxspeed', 00H	; `string'
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?InitPhysic@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_maxSpeed$ = -8
_sceneDesc$ = -172
_defaultMaterial$ = -176
_conveyorMat$ = -224
_conveyorMaterial$ = -228
$T51747 = -256
$T51748 = -268
$T51749 = -280
$T51750 = -292
$T51751 = -304
?InitPhysic@CPhysicNovodex@@UAEXXZ PROC NEAR		; CPhysicNovodex::InitPhysic, COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	if( m_pPhysics )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L49199

; 161  : 		ALERT( at_error, "InitPhysic: physics already initalized\n" );

	push	OFFSET FLAT:??_C@_0CI@NOCF@InitPhysic?3?5physics?5already?5init@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 162  : 		return;

	jmp	$L49198
$L49199:

; 164  : 
; 165  : 	if( g_allow_physx != NULL && g_allow_physx->value == 0.0f )

	cmp	DWORD PTR ?g_allow_physx@@3PAUcvar_s@@A, 0 ; g_allow_physx
	je	SHORT $L49201
	mov	ecx, DWORD PTR ?g_allow_physx@@3PAUcvar_s@@A ; g_allow_physx
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L49201

; 167  : 		ALERT( at_console, "InitPhysic: PhysX support is disabled by user.\n" );

	push	OFFSET FLAT:??_C@_0DA@OFMN@InitPhysic?3?5PhysX?5support?5is?5dis@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 168  : 		GameInitNullPhysics ();

	call	?GameInitNullPhysics@@YAXXZ		; GameInitNullPhysics

; 169  : 		return;

	jmp	$L49198
$L49201:

; 171  : 
; 172  : 	// trying to load dlls from mod-folder
; 173  : 	if( !Sys_LoadLibrary( "PhysXLoader.dll", &hPhysics, NxPhysics ))

	push	OFFSET FLAT:_NxPhysics
	push	OFFSET FLAT:_hPhysics
	push	OFFSET FLAT:??_C@_0BA@HBBH@PhysXLoader?4dll?$AA@ ; `string'
	call	?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z ; Sys_LoadLibrary
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L49205

; 175  : 		// NOTE: using '*' symbol to force loading dll from system path not game folder (Nvidia PhysX drivers)
; 176  : 		if( !Sys_LoadLibrary( "*PhysXLoader.dll", &hPhysics, NxPhysics ))

	push	OFFSET FLAT:_NxPhysics
	push	OFFSET FLAT:_hPhysics
	push	OFFSET FLAT:??_C@_0BB@END@?$CKPhysXLoader?4dll?$AA@ ; `string'
	call	?Sys_LoadLibrary@@YA_NPBDPAPAUHINSTANCE__@@PBUdllfunc_s@@@Z ; Sys_LoadLibrary
	add	esp, 12					; 0000000cH
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L49205

; 178  : 			ALERT( at_error, "InitPhysic: failed to loading NxPhysics.dll.\nPhysics abstraction layer will be disabled.\n" );

	push	OFFSET FLAT:??_C@_0FK@GABD@InitPhysic?3?5failed?5to?5loading?5Nx@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 179  : 			GameInitNullPhysics ();

	call	?GameInitNullPhysics@@YAXXZ		; GameInitNullPhysics

; 180  : 			return;

	jmp	$L49198
$L49205:

; 183  : 
; 184  : 	m_pPhysics = pNxCreatePhysicsSDK( NX_PHYSICS_SDK_VERSION, NULL, &m_ErrorStream );

	push	0
	lea	ecx, DWORD PTR $T51747[ebp]
	call	??0NxPhysicsSDKDesc@@QAE@XZ		; NxPhysicsSDKDesc::NxPhysicsSDKDesc
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1344				; 00000540H
	push	edx
	push	0
	push	34079488				; 02080300H
	call	DWORD PTR _pNxCreatePhysicsSDK
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 185  : 
; 186  : 	if( !m_pPhysics )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L49209

; 188  : 		ALERT( at_error, "InitPhysic: failed to initalize physics engine\n" );

	push	OFFSET FLAT:??_C@_0DA@KMH@InitPhysic?3?5failed?5to?5initalize?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 189  : 		Sys_FreeLibrary( &hPhysics );

	push	OFFSET FLAT:_hPhysics
	call	?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z ; Sys_FreeLibrary
	add	esp, 4

; 190  : 		GameInitNullPhysics ();

	call	?GameInitNullPhysics@@YAXXZ		; GameInitNullPhysics

; 191  : 		return;

	jmp	$L49198
$L49209:

; 193  : 
; 194  : 	m_pCooking = pNxGetCookingLib( NX_PHYSICS_SDK_VERSION );

	push	34079488				; 02080300H
	call	DWORD PTR _pNxGetCookingLib
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1352], eax

; 195  : 
; 196  : 	if( !m_pCooking )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1352], 0
	jne	SHORT $L49211

; 198  : 		ALERT( at_warning, "InitPhysic: failed to initalize cooking library\n" );

	push	OFFSET FLAT:??_C@_0DB@HODF@InitPhysic?3?5failed?5to?5initalize?5@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L49211:

; 200  : 
; 201  : 	m_pUtils = pNxGetUtilLib();

	call	DWORD PTR _pNxGetUtilLib
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1356], eax

; 202  : 
; 203  : 	if( !m_pUtils )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1356], 0
	jne	SHORT $L49213

; 205  : 		ALERT( at_warning, "InitPhysic: failed to initalize util library\n" );

	push	OFFSET FLAT:??_C@_0CO@BG@InitPhysic?3?5failed?5to?5initalize?5@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L49213:

; 207  : 
; 208  : 	float maxSpeed = CVAR_GET_FLOAT( "sv_maxspeed" );

	push	OFFSET FLAT:??_C@_0M@PIGM@sv_maxspeed?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	fstp	DWORD PTR _maxSpeed$[ebp]

; 209  : 
; 210  : 	m_pPhysics->setParameter( NX_SKIN_WIDTH, 0.25f );

	push	1048576000				; 3e800000H
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 211  : 
; 212  : 	m_pPhysics->setParameter( NX_VISUALIZATION_SCALE, 1.0f );

	push	1065353216				; 3f800000H
	push	9
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 213  : 	m_pPhysics->setParameter( NX_VISUALIZE_COLLISION_SHAPES, 1 );

	push	1065353216				; 3f800000H
	push	39					; 00000027H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 214  : 	m_pPhysics->setParameter( NX_VISUALIZE_CONTACT_POINT, 1 );

	push	1065353216				; 3f800000H
	push	33					; 00000021H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 215  : 	m_pPhysics->setParameter( NX_VISUALIZE_CONTACT_NORMAL, 1 );

	push	1065353216				; 3f800000H
	push	34					; 00000022H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 216  : 	m_pPhysics->setParameter( NX_MAX_ANGULAR_VELOCITY, maxSpeed );

	mov	eax, DWORD PTR _maxSpeed$[ebp]
	push	eax
	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 217  : 	m_pPhysics->setParameter( NX_CONTINUOUS_CD, 1 );

	push	1065353216				; 3f800000H
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 218  : 	m_pPhysics->setParameter( NX_VISUALIZE_BODY_AXES, 1 );

	push	1065353216				; 3f800000H
	push	11					; 0000000bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 219  : 	m_pPhysics->setParameter( NX_DEFAULT_SLEEP_LIN_VEL_SQUARED, 5.0f );

	push	1084227584				; 40a00000H
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 220  : 	m_pPhysics->setParameter( NX_DEFAULT_SLEEP_ANG_VEL_SQUARED, 5.0f );

	push	1084227584				; 40a00000H
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 221  : 	m_pPhysics->setParameter( NX_VISUALIZE_FORCE_FIELDS, 1.0f );

	push	1065353216				; 3f800000H
	push	91					; 0000005bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 222  : 	m_pPhysics->setParameter( NX_ADAPTIVE_FORCE, 0.0f );

	push	0
	push	68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]

; 223  : 
; 224  : 	// create a scene
; 225  : 	NxSceneDesc sceneDesc;

	lea	ecx, DWORD PTR _sceneDesc$[ebp]
	call	??0NxSceneDesc@@QAE@XZ			; NxSceneDesc::NxSceneDesc

; 226  : 
; 227  : 	sceneDesc.userContactReport = &gContactReport;

	mov	DWORD PTR _sceneDesc$[ebp+36], OFFSET FLAT:?gContactReport@@3VContactReport@@A ; gContactReport

; 228  : 	sceneDesc.gravity = NxVec3( 0.0f, 0.0f, -800.0f );

	push	-1001914368				; c4480000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T51748[ebp]
	call	??0NxVec3@@QAE@MMM@Z			; NxVec3::NxVec3
	push	eax
	lea	ecx, DWORD PTR _sceneDesc$[ebp]
	call	??4NxVec3@@QAEABV0@ABV0@@Z		; NxVec3::operator=

; 229  : 	sceneDesc.maxTimestep = (1.0f / 150.0f);

	mov	DWORD PTR _sceneDesc$[ebp+44], 1004172302 ; 3bda740eH

; 230  : 	sceneDesc.bpType = NX_BP_TYPE_SAP_MULTI;

	mov	DWORD PTR _sceneDesc$[ebp+148], 1

; 231  : 	sceneDesc.maxIter = SOLVER_ITERATION_COUNT;

	mov	DWORD PTR _sceneDesc$[ebp+48], 16	; 00000010H

; 232  : 	sceneDesc.dynamicStructure = NX_PRUNING_DYNAMIC_AABB_TREE;

	mov	DWORD PTR _sceneDesc$[ebp+136], 3

; 233  : 
; 234  : 	worldBounds.min = NxVec3( -32768, -32768, -32768 );

	push	-956301312				; c7000000H
	push	-956301312				; c7000000H
	push	-956301312				; c7000000H
	lea	ecx, DWORD PTR $T51749[ebp]
	call	??0NxVec3@@QAE@MMM@Z			; NxVec3::NxVec3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??4NxVec3@@QAEABV0@ABV0@@Z		; NxVec3::operator=

; 235  : 	worldBounds.max = NxVec3(  32768,  32768,  32768 );

	push	1191182336				; 47000000H
	push	1191182336				; 47000000H
	push	1191182336				; 47000000H
	lea	ecx, DWORD PTR $T51750[ebp]
	call	??0NxVec3@@QAE@MMM@Z			; NxVec3::NxVec3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	call	??4NxVec3@@QAEABV0@ABV0@@Z		; NxVec3::operator=

; 236  : 	sceneDesc.maxBounds = &worldBounds;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 296				; 00000128H
	mov	DWORD PTR _sceneDesc$[ebp+56], eax

; 237  : 	sceneDesc.nbGridCellsX = 8;

	mov	DWORD PTR _sceneDesc$[ebp+152], 8

; 238  : 	sceneDesc.nbGridCellsY = 8;

	mov	DWORD PTR _sceneDesc$[ebp+156], 8

; 239  : 	sceneDesc.upAxis = 2;

	mov	DWORD PTR _sceneDesc$[ebp+124], 2

; 240  : 
; 241  : 	m_pScene = m_pPhysics->createScene( sceneDesc );

	lea	ecx, DWORD PTR _sceneDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 242  : 
; 243  : 	// notify on all contacts:
; 244  : 	m_pScene->setActorGroupPairFlags( 0, 0, NX_NOTIFY_ON_TOUCH );

	push	8
	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+204]

; 245  : 
; 246  : 	NxMaterial *defaultMaterial = m_pScene->getMaterialFromIndex( 0 ); 

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+320]
	mov	DWORD PTR _defaultMaterial$[ebp], eax

; 247  : 	defaultMaterial->setStaticFriction( 0.5f );

	push	1056964608				; 3f000000H
	mov	eax, DWORD PTR _defaultMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _defaultMaterial$[ebp]
	call	DWORD PTR [edx+28]

; 248  : 	defaultMaterial->setDynamicFriction( 0.5f );

	push	1056964608				; 3f000000H
	mov	eax, DWORD PTR _defaultMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _defaultMaterial$[ebp]
	call	DWORD PTR [edx+20]

; 249  : 	defaultMaterial->setRestitution( 0.0f );

	push	0
	mov	eax, DWORD PTR _defaultMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _defaultMaterial$[ebp]
	call	DWORD PTR [edx+36]

; 250  : 
; 251  : 	NxMaterialDesc conveyorMat;

	lea	ecx, DWORD PTR _conveyorMat$[ebp]
	call	??0NxMaterialDesc@@QAE@XZ		; NxMaterialDesc::NxMaterialDesc

; 252  : 	NxMaterial *conveyorMaterial = m_pScene->createMaterial( conveyorMat ); 

	lea	eax, DWORD PTR _conveyorMat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+144]
	mov	DWORD PTR _conveyorMaterial$[ebp], eax

; 253  : 	conveyorMaterial->setStaticFriction( 1.0f );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _conveyorMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _conveyorMaterial$[ebp]
	call	DWORD PTR [edx+28]

; 254  : 	conveyorMaterial->setDynamicFriction( 1.0f );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _conveyorMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _conveyorMaterial$[ebp]
	call	DWORD PTR [edx+20]

; 255  : 	conveyorMaterial->setRestitution( 0.0f );

	push	0
	mov	eax, DWORD PTR _conveyorMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _conveyorMaterial$[ebp]
	call	DWORD PTR [edx+36]

; 256  : 	conveyorMaterial->setDirOfAnisotropy( NxVec3( 0, 0, 1 ));

	push	1065353216				; 3f800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T51751[ebp]
	call	??0NxVec3@@QAE@MMM@Z			; NxVec3::NxVec3
	push	eax
	mov	eax, DWORD PTR _conveyorMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _conveyorMaterial$[ebp]
	call	DWORD PTR [edx+60]

; 257  : 	conveyorMaterial->setFlags( NX_MF_ANISOTROPIC );

	push	1
	mov	eax, DWORD PTR _conveyorMaterial$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _conveyorMaterial$[ebp]
	call	DWORD PTR [edx+68]

; 258  : 
; 259  : 	m_fNeedFetchResults = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+284], 0
$L49198:

; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitPhysic@CPhysicNovodex@@UAEXXZ ENDP			; CPhysicNovodex::InitPhysic
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@MMM@Z
_TEXT	SEGMENT
__x$ = 8
__y$ = 12
__z$ = 16
_this$ = -4
??0NxVec3@@QAE@MMM@Z PROC NEAR				; NxVec3::NxVec3, COMDAT

; 403  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __x$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __z$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 404  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0NxVec3@@QAE@MMM@Z ENDP				; NxVec3::NxVec3
_TEXT	ENDS
;	COMDAT ??4NxVec3@@QAEABV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??4NxVec3@@QAEABV0@ABV0@@Z PROC NEAR			; NxVec3::operator=, COMDAT

; 430  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 	x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 432  : 	y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 433  : 	z = v.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 434  : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 435  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4NxVec3@@QAEABV0@ABV0@@Z ENDP				; NxVec3::operator=
_TEXT	ENDS
PUBLIC	?setToDefault@NxPhysicsSDKDesc@@QAEXXZ		; NxPhysicsSDKDesc::setToDefault
;	COMDAT ??0NxPhysicsSDKDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxPhysicsSDKDesc@@QAE@XZ PROC NEAR			; NxPhysicsSDKDesc::NxPhysicsSDKDesc, COMDAT

; 187  : 	NxPhysicsSDKDesc()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 188  : 		{
; 189  : 		setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxPhysicsSDKDesc@@QAEXXZ	; NxPhysicsSDKDesc::setToDefault

; 190  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxPhysicsSDKDesc@@QAE@XZ ENDP			; NxPhysicsSDKDesc::NxPhysicsSDKDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxPhysicsSDKDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxPhysicsSDKDesc@@QAEXXZ PROC NEAR	; NxPhysicsSDKDesc::setToDefault, COMDAT

; 157  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 		hwPageSize = 65536;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 65536			; 00010000H

; 159  : 		hwConvexMax = 2048;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 2048			; 00000800H

; 160  : 		hwPageMax = 256;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 256			; 00000100H

; 161  : 		flags = (NxU32) NX_SDKF_EXTENDED_DESCRIPTOR;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], -2147483648		; 80000000H

; 162  : 		cookerThreadMask = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 163  : 		gpuHeapSize = 4; // g-cont. changed this from 128 to 4

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 4

; 164  : 		meshCacheSize = 0xffffffff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], -1

; 165  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxPhysicsSDKDesc@@QAEXXZ ENDP		; NxPhysicsSDKDesc::setToDefault
_TEXT	ENDS
PUBLIC	?setToDefault@NxSceneDesc@@QAEXXZ		; NxSceneDesc::setToDefault
;	COMDAT ??0NxSceneDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxSceneDesc@@QAE@XZ PROC NEAR			; NxSceneDesc::NxSceneDesc, COMDAT

; 1068 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 1069 : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxSceneDesc@@QAEXXZ	; NxSceneDesc::setToDefault

; 1070 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxSceneDesc@@QAE@XZ ENDP				; NxSceneDesc::NxSceneDesc
_TEXT	ENDS
PUBLIC	?zero@NxVec3@@QAEXXZ				; NxVec3::zero
;	COMDAT ?setToDefault@NxSceneDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxSceneDesc@@QAEXXZ PROC NEAR		; NxSceneDesc::setToDefault, COMDAT

; 1073 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1074 : 	gravity.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 1075 : 	userNotify				= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1076 : 	fluidUserNotify			= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1077 : 	clothUserNotify			= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1078 : 	softBodyUserNotify		= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1079 : 	userTriggerReport		= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 1080 : 	userContactReport		= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 1081 : 	userContactModify		= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1082 : 	userActorPairFiltering	= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 1083 : 
; 1084 : 	maxTimestep				= 1.0f/60.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 1015580809		; 3c888889H

; 1085 : 	maxIter					= 8;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 8

; 1086 : 	timeStepMethod			= NX_TIMESTEP_FIXED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 1087 : 
; 1088 : 	maxBounds				= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 1089 : 	limits					= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 1090 : 	simType					= NX_SIMULATION_SW;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 1091 : 	groundPlane				= false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 1092 : 	boundsPlanes			= false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 1093 : 	userData				= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], 0

; 1094 : #ifdef __CELLOS_LV2__
; 1095 : 	flags				= NX_SF_SIMULATE_SEPARATE_THREAD | NX_SF_SEQUENTIAL_PRIMARY;
; 1096 : #else
; 1097 : 	flags					= NX_SF_SIMULATE_SEPARATE_THREAD | NX_SF_DISABLE_SCENE_MUTEX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 68			; 00000044H

; 1098 : #endif
; 1099 : 	upAxis					= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 0

; 1100 : 	subdivisionLevel		= 5;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 5

; 1101 : 	staticStructure			= NX_PRUNING_STATIC_AABB_TREE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 4

; 1102 : 	dynamicStructure		= NX_PRUNING_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+136], 0

; 1103 : 	dynamicTreeRebuildRateHint = 100;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 100		; 00000064H

; 1104 : 
; 1105 : 	internalThreadCount		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0

; 1106 : 	backgroundThreadCount	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0

; 1107 : 	customScheduler			= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 0

; 1108 : 
; 1109 : 	simThreadStackSize		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 0

; 1110 : 	simThreadPriority		= NX_TP_NORMAL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 2

; 1111 : 
; 1112 : 	workerThreadStackSize	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 1113 : 	workerThreadPriority	= NX_TP_NORMAL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 2

; 1114 : 	backgroundThreadPriority= NX_TP_NORMAL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 2

; 1115 : 
; 1116 : 	simThreadMask			= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 1117 : 	threadMask				= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 0

; 1118 : 	backgroundThreadMask	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], 0

; 1119 : 
; 1120 : 	bpType					= NX_BP_TYPE_SAP_SINGLE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 1121 : 	nbGridCellsX			= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+152], 0

; 1122 : 	nbGridCellsY			= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+156], 0

; 1123 : 
; 1124 : 	solverBatchSize			= 32;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 32			; 00000020H

; 1125 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxSceneDesc@@QAEXXZ ENDP			; NxSceneDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?zero@NxVec3@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?zero@NxVec3@@QAEXXZ PROC NEAR				; NxVec3::zero, COMDAT

; 594  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 595  : 	x = y = z = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 596  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?zero@NxVec3@@QAEXXZ ENDP				; NxVec3::zero
_TEXT	ENDS
PUBLIC	?setToDefault@NxMaterialDesc@@QAEXXZ		; NxMaterialDesc::setToDefault
;	COMDAT ??0NxMaterialDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxMaterialDesc@@QAE@XZ PROC NEAR			; NxMaterialDesc::NxMaterialDesc, COMDAT

; 326  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 327  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxMaterialDesc@@QAEXXZ	; NxMaterialDesc::setToDefault

; 328  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxMaterialDesc@@QAE@XZ ENDP				; NxMaterialDesc::NxMaterialDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxMaterialDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxMaterialDesc@@QAEXXZ PROC NEAR		; NxMaterialDesc::setToDefault, COMDAT

; 331  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 332  : 	dynamicFriction	= 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 333  : 	staticFriction	= 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 334  : 	restitution		= 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 335  : 
; 336  : 
; 337  : 	dynamicFrictionV= 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 338  : 	staticFrictionV = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 339  : 
; 340  : 	dirOfAnisotropy.set(1,0,0);

	push	0
	push	0
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?set@NxVec3@@QAEXMMM@Z			; NxVec3::set

; 341  : 	flags = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 342  : 	frictionCombineMode = NX_CM_AVERAGE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 343  : 	restitutionCombineMode = NX_CM_AVERAGE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 344  : 	spring = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 345  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxMaterialDesc@@QAEXXZ ENDP		; NxMaterialDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?FreePhysic@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?FreePhysic@CPhysicNovodex@@UAEXXZ PROC NEAR		; CPhysicNovodex::FreePhysic, COMDAT

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 	if( !m_pPhysics ) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L49229
	jmp	SHORT $L49228
$L49229:

; 265  : 
; 266  : 	if( m_pCooking )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1352], 0
	je	SHORT $L49230

; 267  : 		m_pCooking->NxCloseCooking();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1352]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+16]
$L49230:

; 268  : 
; 269  : 	m_pPhysics->releaseScene( *m_pScene );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+20]

; 270  : 	pNxReleasePhysicsSDK( m_pPhysics );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR _pNxReleasePhysicsSDK
	add	esp, 4

; 271  : 
; 272  : 	Sys_FreeLibrary( &hPhysics );

	push	OFFSET FLAT:_hPhysics
	call	?Sys_FreeLibrary@@YAXPAPAUHINSTANCE__@@@Z ; Sys_FreeLibrary
	add	esp, 4

; 273  : 	m_pPhysics = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0

; 274  : 	m_pScene = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0
$L49228:

; 275  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreePhysic@CPhysicNovodex@@UAEXXZ ENDP			; CPhysicNovodex::FreePhysic
_TEXT	ENDS
;	COMDAT ?GetUtilLibrary@CPhysicNovodex@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4
?GetUtilLibrary@CPhysicNovodex@@UAEPAXXZ PROC NEAR	; CPhysicNovodex::GetUtilLibrary, COMDAT

; 278  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 	return (void *)m_pUtils;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1356]

; 280  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetUtilLibrary@CPhysicNovodex@@UAEPAXXZ ENDP		; CPhysicNovodex::GetUtilLibrary
_TEXT	ENDS
PUBLIC	??_C@_0L@GIJ@sv_gravity?$AA@			; `string'
PUBLIC	??_C@_0BP@HBPI@gravity?5changed?5from?5?$CFg?5to?5?$CFg?6?$AA@ ; `string'
PUBLIC	__real@4@4008c800000000000000
EXTRN	?g_physfuncs@@3Userver_physics_api_s@@A:BYTE	; g_physfuncs
EXTRN	?g_psv_gravity@@3PAUcvar_s@@A:DWORD		; g_psv_gravity
EXTRN	?g_sync_physic@@3Ucvar_s@@A:BYTE		; g_sync_physic
;	COMDAT ??_C@_0L@GIJ@sv_gravity?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0L@GIJ@sv_gravity?$AA@ DB 'sv_gravity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HBPI@gravity?5changed?5from?5?$CFg?5to?5?$CFg?6?$AA@
CONST	SEGMENT
??_C@_0BP@HBPI@gravity?5changed?5from?5?$CFg?5to?5?$CFg?6?$AA@ DB 'gravit'
	DB	'y changed from %g to %g', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@4@4008c800000000000000
CONST	SEGMENT
__real@4@4008c800000000000000 DD 044480000r	; 800
CONST	ENDS
;	COMDAT ?Update@CPhysicNovodex@@UAEXM@Z
_TEXT	SEGMENT
_flTime$ = 8
_this$ = -4
_gravity$49246 = -16
?Update@CPhysicNovodex@@UAEXM@Z PROC NEAR		; CPhysicNovodex::Update, COMDAT

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 284  : 	if( !m_pScene || GET_SERVER_STATE() != SERVER_ACTIVE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L49241
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+20
	cmp	eax, 2
	je	SHORT $L49240
$L49241:

; 285  : 		return;

	jmp	$L49239
$L49240:

; 286  : 
; 287  : 	if( g_psv_gravity )

	cmp	DWORD PTR ?g_psv_gravity@@3PAUcvar_s@@A, 0 ; g_psv_gravity
	je	$L49247

; 289  : 		// clamp gravity
; 290  : 		if( g_psv_gravity->value < 0.0f )

	mov	ecx, DWORD PTR ?g_psv_gravity@@3PAUcvar_s@@A ; g_psv_gravity
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L49243

; 291  : 			CVAR_SET_FLOAT( "sv_gravity", 0.0f );

	push	0
	push	OFFSET FLAT:??_C@_0L@GIJ@sv_gravity?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+236
	add	esp, 8
$L49243:

; 292  : 		if( g_psv_gravity->value > 800.0f )

	mov	edx, DWORD PTR ?g_psv_gravity@@3PAUcvar_s@@A ; g_psv_gravity
	fld	DWORD PTR [edx+12]
	fcomp	DWORD PTR __real@4@4008c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L49245

; 293  : 			CVAR_SET_FLOAT( "sv_gravity", 800.0f );

	push	1145569280				; 44480000H
	push	OFFSET FLAT:??_C@_0L@GIJ@sv_gravity?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+236
	add	esp, 8
$L49245:

; 294  : 
; 295  : 		NxVec3 gravity;

	lea	ecx, DWORD PTR _gravity$49246[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 296  : 		m_pScene->getGravity( gravity );

	lea	eax, DWORD PTR _gravity$49246[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+24]

; 297  : 
; 298  : 		if( gravity.z != -( g_psv_gravity->value ))

	mov	eax, DWORD PTR ?g_psv_gravity@@3PAUcvar_s@@A ; g_psv_gravity
	fld	DWORD PTR [eax+12]
	fchs
	fcomp	DWORD PTR _gravity$49246[ebp+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L49247

; 300  : 			ALERT( at_aiconsole, "gravity changed from %g to %g\n", gravity.z, -(g_psv_gravity->value));

	mov	ecx, DWORD PTR ?g_psv_gravity@@3PAUcvar_s@@A ; g_psv_gravity
	fld	DWORD PTR [ecx+12]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	fld	DWORD PTR _gravity$49246[ebp+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0BP@HBPI@gravity?5changed?5from?5?$CFg?5to?5?$CFg?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 24					; 00000018H

; 301  : 			gravity.z = -(g_psv_gravity->value);

	mov	edx, DWORD PTR ?g_psv_gravity@@3PAUcvar_s@@A ; g_psv_gravity
	fld	DWORD PTR [edx+12]
	fchs
	fstp	DWORD PTR _gravity$49246[ebp+8]

; 302  : 			m_pScene->setGravity( gravity );

	lea	eax, DWORD PTR _gravity$49246[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+20]
$L49247:

; 305  : 
; 306  : 	if( g_sync_physic.value )

	fld	DWORD PTR ?g_sync_physic@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L49249

; 308  : 		m_pScene->simulate( flTime );

	mov	eax, DWORD PTR _flTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+560]

; 309  : 		m_pScene->flushStream();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+324]

; 310  : 		m_pScene->fetchResults( NX_RIGID_BODY_FINISHED, true );

	push	0
	push	1
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+568]

; 312  : 	else

	jmp	SHORT $L49250
$L49249:

; 314  : 		if( m_fNeedFetchResults )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+284], 0
	je	SHORT $L49251

; 315  : 			return; // waiting

	jmp	SHORT $L49239
$L49251:

; 316  : 
; 317  : 		m_pScene->simulate( flTime );

	mov	ecx, DWORD PTR _flTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+560]

; 318  : 		m_fNeedFetchResults = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+284], 1
$L49250:
$L49239:

; 320  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Update@CPhysicNovodex@@UAEXM@Z ENDP			; CPhysicNovodex::Update
_TEXT	ENDS
PUBLIC	??_C@_0EE@BFOI@?$CF3i?5active?5bodies?0?5?$CF3i?5actors?6?$CF3@ ; `string'
PUBLIC	??0NxSceneStats@@QAE@XZ				; NxSceneStats::NxSceneStats
EXTRN	?Q_snprintf@@YAHPADIPBDZZ:NEAR			; Q_snprintf
EXTRN	__ftol:NEAR
EXTRN	?p_speeds@@3PAUcvar_s@@A:DWORD			; p_speeds
;	COMDAT ??_C@_0EE@BFOI@?$CF3i?5active?5bodies?0?5?$CF3i?5actors?6?$CF3@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0EE@BFOI@?$CF3i?5active?5bodies?0?5?$CF3i?5actors?6?$CF3@ DB '%3i a'
	DB	'ctive bodies, %3i actors', 0aH, '%3i static shapes, %3i dynam'
	DB	'ic shapes', 00H				; `string'
CONST	ENDS
;	COMDAT ?EndFrame@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_stats$ = -84
?EndFrame@CPhysicNovodex@@UAEXXZ PROC NEAR		; CPhysicNovodex::EndFrame, COMDAT

; 323  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 324  : 	if( !m_pScene || GET_SERVER_STATE() != SERVER_ACTIVE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L49257
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+20
	cmp	eax, 2
	je	SHORT $L49256
$L49257:

; 325  : 		return;

	jmp	$L49255
$L49256:

; 326  : 
; 327  : 	if( m_fNeedFetchResults )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+284], 0
	je	SHORT $L49258

; 329  : 		m_pScene->flushStream();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+324]

; 330  : 		m_pScene->fetchResults( NX_RIGID_BODY_FINISHED, true );

	push	0
	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+568]

; 331  : 		m_fNeedFetchResults = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+284], 0
$L49258:

; 333  : 
; 334  : 	// fill physics stats
; 335  : 	if( !p_speeds || p_speeds->value <= 0.0f )

	cmp	DWORD PTR ?p_speeds@@3PAUcvar_s@@A, 0	; p_speeds
	je	SHORT $L49260
	mov	ecx, DWORD PTR ?p_speeds@@3PAUcvar_s@@A	; p_speeds
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L49259
$L49260:

; 336  : 		return;

	jmp	SHORT $L49255
$L49259:

; 337  : 
; 338  : 	NxSceneStats stats;

	lea	ecx, DWORD PTR _stats$[ebp]
	call	??0NxSceneStats@@QAE@XZ			; NxSceneStats::NxSceneStats

; 339  : 	m_pScene->getStats( stats );

	lea	edx, DWORD PTR _stats$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+344]

; 342  : 	{

	mov	eax, DWORD PTR ?p_speeds@@3PAUcvar_s@@A	; p_speeds
	fld	DWORD PTR [eax+12]
	call	__ftol
	mov	DWORD PTR -88+[ebp], eax
	cmp	DWORD PTR -88+[ebp], 1
	je	SHORT $L49267
	jmp	SHORT $L49264
$L49267:

; 343  : 	case 1:
; 344  : 		Q_snprintf( p_speeds_msg, sizeof( p_speeds_msg ), "%3i active bodies, %3i actors\n%3i static shapes, %3i dynamic shapes",
; 345  : 		stats.numDynamicActorsInAwakeGroups, stats.numActors, stats.numStaticShapes, stats.numDynamicShapes );

	mov	ecx, DWORD PTR _stats$[ebp+64]
	push	ecx
	mov	edx, DWORD PTR _stats$[ebp+56]
	push	edx
	mov	eax, DWORD PTR _stats$[ebp+40]
	push	eax
	mov	ecx, DWORD PTR _stats$[ebp+16]
	push	ecx
	push	OFFSET FLAT:??_C@_0EE@BFOI@?$CF3i?5active?5bodies?0?5?$CF3i?5actors?6?$CF3@ ; `string'
	push	1024					; 00000400H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 320				; 00000140H
	push	edx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 28					; 0000001cH
$L49264:
$L49255:

; 348  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EndFrame@CPhysicNovodex@@UAEXXZ ENDP			; CPhysicNovodex::EndFrame
_TEXT	ENDS
PUBLIC	?reset@NxSceneStats@@QAEXXZ			; NxSceneStats::reset
;	COMDAT ??0NxSceneStats@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxSceneStats@@QAE@XZ PROC NEAR			; NxSceneStats::NxSceneStats, COMDAT

; 118  : 	NxSceneStats()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 		{
; 120  : 		reset();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?reset@NxSceneStats@@QAEXXZ		; NxSceneStats::reset

; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxSceneStats@@QAE@XZ ENDP				; NxSceneStats::NxSceneStats
_TEXT	ENDS
;	COMDAT ?reset@NxSceneStats@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?reset@NxSceneStats@@QAEXXZ PROC NEAR			; NxSceneStats::reset, COMDAT

; 127  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		numContacts = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 129  : 		maxContacts = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 130  : 		numPairs = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 131  : 		maxPairs = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 132  : 		numDynamicActorsInAwakeGroups = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 133  : 		maxDynamicActorsInAwakeGroups = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 134  : 		numAxisConstraints = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 135  : 		maxAxisConstraints = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 136  : 		numSolverBodies = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 137  : 		maxSolverBodies = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], 0

; 138  : 		numActors = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 139  : 		maxActors = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 140  : 		numDynamicActors = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 141  : 		maxDynamicActors = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 142  : 		numStaticShapes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 143  : 		maxStaticShapes = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 144  : 		numDynamicShapes = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 145  : 		maxDynamicShapes = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 146  : 		numJoints = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 147  : 		maxJoints = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 148  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?reset@NxSceneStats@@QAEXXZ ENDP			; NxSceneStats::reset
_TEXT	ENDS
PUBLIC	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?RemoveBody@CPhysicNovodex@@UAEXPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
_this$ = -4
_pEntity$ = -8
_pActor$ = -12
?RemoveBody@CPhysicNovodex@@UAEXPAUedict_s@@@Z PROC NEAR ; CPhysicNovodex::RemoveBody, COMDAT

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 	if( !m_pScene || !pEdict || pEdict->free )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L49274
	cmp	DWORD PTR _pEdict$[ebp], 0
	je	SHORT $L49274
	mov	ecx, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L49273
$L49274:

; 353  : 		return; // scene purge all the objects automatically

	jmp	SHORT $L49272
$L49273:

; 354  : 
; 355  : 	CBaseEntity *pEntity = CBaseEntity::Instance( pEdict );

	mov	edx, DWORD PTR _pEdict$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 356  : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 357  : 
; 358  : 	if( pActor ) m_pScene->releaseActor( *pActor );

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L49277
	mov	ecx, DWORD PTR _pActor$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+32]
$L49277:

; 359  : 	pEntity->m_pUserData = NULL;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+244], 0
$L49272:

; 360  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveBody@CPhysicNovodex@@UAEXPAUedict_s@@@Z ENDP	; CPhysicNovodex::RemoveBody
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28411

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28410
$L28411:

; 104  : 	return NULL;

	xor	eax, eax
$L28410:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	??_C@_0EA@ECJ@ConvexMeshFromBmodel?3?5can?8t?5crea@ ; `string'
PUBLIC	??_C@_0DI@CMIM@ConvexMeshFromBmodel?3?5unbale?5to?5@ ; `string'
PUBLIC	??_C@_0DC@PGMH@ConvexMeshFromBmodel?3?5?$CFs?5has?5no?5@ ; `string'
PUBLIC	??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@ ; `string'
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::ConvexMeshFromBmodel
PUBLIC	??0NxConvexMeshDesc@@QAE@XZ			; NxConvexMeshDesc::NxConvexMeshDesc
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??0MemoryWriteBuffer@@QAE@XZ:NEAR		; MemoryWriteBuffer::MemoryWriteBuffer
EXTRN	??1MemoryWriteBuffer@@UAE@XZ:NEAR		; MemoryWriteBuffer::~MemoryWriteBuffer
EXTRN	??0MemoryReadBuffer@@QAE@PBE@Z:NEAR		; MemoryReadBuffer::MemoryReadBuffer
EXTRN	??1MemoryReadBuffer@@UAE@XZ:NEAR		; MemoryReadBuffer::~MemoryReadBuffer
;	COMDAT ??_C@_0EA@ECJ@ConvexMeshFromBmodel?3?5can?8t?5crea@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0EA@ECJ@ConvexMeshFromBmodel?3?5can?8t?5crea@ DB 'ConvexMeshFromBmo'
	DB	'del: can''t create convex hull from worldmodel', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CMIM@ConvexMeshFromBmodel?3?5unbale?5to?5@
CONST	SEGMENT
??_C@_0DI@CMIM@ConvexMeshFromBmodel?3?5unbale?5to?5@ DB 'ConvexMeshFromBm'
	DB	'odel: unbale to fetch model pointer %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PGMH@ConvexMeshFromBmodel?3?5?$CFs?5has?5no?5@
CONST	SEGMENT
??_C@_0DC@PGMH@ConvexMeshFromBmodel?3?5?$CFs?5has?5no?5@ DB 'ConvexMeshFr'
	DB	'omBmodel: %s has no visible surfaces', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@
CONST	SEGMENT
??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@ DB 'failed to creat'
	DB	'e convex mesh from %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$2
xdata$x	ENDS
;	COMDAT ?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT
_modelindex$ = 12
_this$ = -16
_bmodel$ = -20
_numVerts$ = -24
_totalVerts$ = -28
_pHull$ = -32
_psurf$ = -36
_verts$ = -40
_i$ = -44
_j$ = -48
_$S29$ = -52
_e$49314 = -56
_v$49315 = -60
_meshDesc$ = -88
_buf$ = -104
_status$ = -108
$T51797 = -112
$T51798 = -116
$T51803 = -120
$T51804 = -124
$T51805 = -132
$T51806 = -136
__$EHRec$ = -12
?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z PROC NEAR ; CPhysicNovodex::ConvexMeshFromBmodel, COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 	if( !m_pCooking )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1352], 0
	jne	SHORT $L49283

; 365  : 		return NULL; // don't spam console about missed NxCooking.dll

	xor	eax, eax
	jmp	$L49282
$L49283:

; 366  : 
; 367  : 	if( modelindex == 1 )

	cmp	DWORD PTR _modelindex$[ebp], 1
	jne	SHORT $L49284

; 369  : 		ALERT( at_error, "ConvexMeshFromBmodel: can't create convex hull from worldmodel\n" );

	push	OFFSET FLAT:??_C@_0EA@ECJ@ConvexMeshFromBmodel?3?5can?8t?5crea@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 370  : 		return NULL; // don't create rigidbody from world

	xor	eax, eax
	jmp	$L49282
$L49284:

; 374  : 
; 375  : 	// get a world struct
; 376  : 	if(( bmodel = (model_t *)MODEL_HANDLE( modelindex )) == NULL )

	mov	ecx, DWORD PTR _modelindex$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _bmodel$[ebp], eax
	cmp	DWORD PTR _bmodel$[ebp], 0
	jne	SHORT $L49288

; 378  : 		ALERT( at_error, "ConvexMeshFromBmodel: unbale to fetch model pointer %i\n", modelindex );

	mov	edx, DWORD PTR _modelindex$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DI@CMIM@ConvexMeshFromBmodel?3?5unbale?5to?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 379  : 		return NULL;

	xor	eax, eax
	jmp	$L49282
$L49288:

; 381  : 
; 382  : 	if( bmodel->nummodelsurfaces <= 0 )

	mov	eax, DWORD PTR _bmodel$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jg	SHORT $L49290

; 384  : 		ALERT( at_aiconsole, "ConvexMeshFromBmodel: %s has no visible surfaces\n", bmodel->name );

	mov	ecx, DWORD PTR _bmodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DC@PGMH@ConvexMeshFromBmodel?3?5?$CFs?5has?5no?5@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 385  : 		m_fDisableWarning = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 1

; 386  : 		return NULL;

	xor	eax, eax
	jmp	$L49282
$L49290:

; 388  : 
; 389  : 	int numVerts = 0, totalVerts = 0;

	mov	DWORD PTR _numVerts$[ebp], 0
	mov	DWORD PTR _totalVerts$[ebp], 0

; 390  : 	NxConvexMesh *pHull = NULL;

	mov	DWORD PTR _pHull$[ebp], 0

; 391  : 	msurface_t *psurf;
; 392  : 	Vector *verts;
; 393  : 	int i, j;
; 394  : 
; 395  : 	// compute vertexes count
; 396  : 	psurf = &bmodel->surfaces[bmodel->firstmodelsurface];

	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	imul	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR _bmodel$[ebp]
	mov	eax, DWORD PTR [edx+180]
	add	eax, ecx
	mov	DWORD PTR _psurf$[ebp], eax

; 397  : 	for( i = 0; i < bmodel->nummodelsurfaces; i++, psurf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49299
$L49300:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _psurf$[ebp]
	add	edx, 92					; 0000005cH
	mov	DWORD PTR _psurf$[ebp], edx
$L49299:
	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	SHORT $L49301

; 398  : 		totalVerts += psurf->numedges;

	mov	edx, DWORD PTR _psurf$[ebp]
	mov	eax, DWORD PTR _totalVerts$[ebp]
	add	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _totalVerts$[ebp], eax
	jmp	SHORT $L49300
$L49301:

; 399  : 
; 400  : 	// create a temp vertices array
; 401  : 	verts = new Vector[totalVerts];

	mov	ecx, DWORD PTR _totalVerts$[ebp]
	mov	DWORD PTR _$S29$[ebp], ecx
	mov	edx, DWORD PTR _$S29$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51798[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T51798[ebp], 0
	je	SHORT $L51799
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	mov	eax, DWORD PTR _$S29$[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T51798[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	edx, DWORD PTR $T51798[ebp]
	mov	DWORD PTR -140+[ebp], edx
	jmp	SHORT $L51800
$L51799:
	mov	DWORD PTR -140+[ebp], 0
$L51800:
	mov	eax, DWORD PTR -140+[ebp]
	mov	DWORD PTR $T51797[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T51797[ebp]
	mov	DWORD PTR _verts$[ebp], ecx

; 402  : 
; 403  : 	psurf = &bmodel->surfaces[bmodel->firstmodelsurface];

	mov	edx, DWORD PTR _bmodel$[ebp]
	mov	eax, DWORD PTR [edx+112]
	imul	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR _bmodel$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	add	edx, eax
	mov	DWORD PTR _psurf$[ebp], edx

; 404  : 	for( i = 0; i < bmodel->nummodelsurfaces; i++, psurf++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49308
$L49309:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _psurf$[ebp]
	add	ecx, 92					; 0000005cH
	mov	DWORD PTR _psurf$[ebp], ecx
$L49308:
	mov	edx, DWORD PTR _bmodel$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+116]
	jge	$L49310

; 406  : 		for( j = 0; j < psurf->numedges; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L49311
$L49312:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L49311:
	mov	edx, DWORD PTR _psurf$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jge	$L49313

; 408  : 			int e = bmodel->surfedges[psurf->firstedge+j];

	mov	ecx, DWORD PTR _psurf$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _e$49314[ebp], edx

; 409  : 			int v = (e > 0) ? bmodel->edges[e].v[0] : bmodel->edges[-e].v[1];

	cmp	DWORD PTR _e$49314[ebp], 0
	jle	SHORT $L51801
	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR _e$49314[ebp]
	mov	ax, WORD PTR [ecx+edx*8]
	mov	WORD PTR -144+[ebp], ax
	jmp	SHORT $L51802
$L51801:
	mov	ecx, DWORD PTR _e$49314[ebp]
	neg	ecx
	mov	edx, DWORD PTR _bmodel$[ebp]
	mov	eax, DWORD PTR [edx+156]
	mov	cx, WORD PTR [eax+ecx*8+2]
	mov	WORD PTR -144+[ebp], cx
$L51802:
	mov	edx, DWORD PTR -144+[ebp]
	and	edx, 65535				; 0000ffffH
	mov	DWORD PTR _v$49315[ebp], edx

; 410  : 			verts[numVerts++] = bmodel->vertexes[v].position;

	mov	eax, DWORD PTR _v$49315[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _bmodel$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	add	edx, eax
	mov	eax, DWORD PTR _numVerts$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _verts$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _numVerts$[ebp]
	add	eax, 1
	mov	DWORD PTR _numVerts$[ebp], eax

; 411  : 		}

	jmp	$L49312
$L49313:

; 412  : 	}

	jmp	$L49309
$L49310:

; 413  : 
; 414  : 	NxConvexMeshDesc meshDesc;

	lea	ecx, DWORD PTR _meshDesc$[ebp]
	call	??0NxConvexMeshDesc@@QAE@XZ		; NxConvexMeshDesc::NxConvexMeshDesc

; 415  : 	meshDesc.points = verts;

	mov	ecx, DWORD PTR _verts$[ebp]
	mov	DWORD PTR _meshDesc$[ebp+16], ecx

; 416  : 	meshDesc.pointStrideBytes = sizeof(Vector);

	mov	DWORD PTR _meshDesc$[ebp+8], 12		; 0000000cH

; 417  : 	meshDesc.numVertices = numVerts;

	mov	edx, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR _meshDesc$[ebp], edx

; 418  : 	meshDesc.flags |= NX_CF_COMPUTE_CONVEX;

	mov	eax, DWORD PTR _meshDesc$[ebp+24]
	or	al, 4
	mov	DWORD PTR _meshDesc$[ebp+24], eax

; 419  : 	m_pCooking->NxInitCooking();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1352]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+12]

; 420  : 
; 421  : 	MemoryWriteBuffer buf;

	lea	ecx, DWORD PTR _buf$[ebp]
	call	??0MemoryWriteBuffer@@QAE@XZ		; MemoryWriteBuffer::MemoryWriteBuffer
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 422  : 	bool status = m_pCooking->NxCookConvexMesh( meshDesc, buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _meshDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1352]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+24]
	mov	BYTE PTR _status$[ebp], al

; 423  : 	delete [] verts;

	mov	ecx, DWORD PTR _verts$[ebp]
	mov	DWORD PTR $T51803[ebp], ecx
	mov	edx, DWORD PTR $T51803[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 424  : 
; 425  : 	if( !status )

	mov	eax, DWORD PTR _status$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L49321

; 427  : 		ALERT( at_error, "failed to create convex mesh from %s\n", bmodel->name );

	mov	ecx, DWORD PTR _bmodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 428  : 		return NULL;

	mov	DWORD PTR $T51804[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _buf$[ebp]
	call	??1MemoryWriteBuffer@@UAE@XZ		; MemoryWriteBuffer::~MemoryWriteBuffer
	mov	eax, DWORD PTR $T51804[ebp]
	jmp	$L49282
$L49321:

; 430  : 
; 431  : 	pHull = m_pPhysics->createConvexMesh( MemoryReadBuffer( buf.data ));

	mov	edx, DWORD PTR _buf$[ebp+12]
	push	edx
	lea	ecx, DWORD PTR $T51805[ebp]
	call	??0MemoryReadBuffer@@QAE@PBE@Z		; MemoryReadBuffer::MemoryReadBuffer
	mov	DWORD PTR -148+[ebp], eax
	mov	eax, DWORD PTR -148+[ebp]
	mov	DWORD PTR -152+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR -152+[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+72]
	mov	DWORD PTR _pHull$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T51805[ebp]
	call	??1MemoryReadBuffer@@UAE@XZ		; MemoryReadBuffer::~MemoryReadBuffer

; 432  : 	if( !pHull ) ALERT( at_error, "failed to create convex mesh from %s\n", bmodel->name );

	cmp	DWORD PTR _pHull$[ebp], 0
	jne	SHORT $L49325
	mov	ecx, DWORD PTR _bmodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49325:

; 433  : 
; 434  : 	return pHull;

	mov	edx, DWORD PTR _pHull$[ebp]
	mov	DWORD PTR $T51806[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _buf$[ebp]
	call	??1MemoryWriteBuffer@@UAE@XZ		; MemoryWriteBuffer::~MemoryWriteBuffer
	mov	eax, DWORD PTR $T51806[ebp]
$L49282:

; 435  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$0:
	mov	eax, DWORD PTR $T51798[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$1:
	lea	ecx, DWORD PTR _buf$[ebp]
	call	??1MemoryWriteBuffer@@UAE@XZ		; MemoryWriteBuffer::~MemoryWriteBuffer
	ret	0
__unwindfunclet$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$2:
	lea	ecx, DWORD PTR $T51805[ebp]
	call	??1MemoryReadBuffer@@UAE@XZ		; MemoryReadBuffer::~MemoryReadBuffer
	ret	0
__ehhandler$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z ENDP ; CPhysicNovodex::ConvexMeshFromBmodel
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	?setToDefault@NxConvexMeshDesc@@QAEXXZ		; NxConvexMeshDesc::setToDefault
;	COMDAT ??0NxConvexMeshDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxConvexMeshDesc@@QAE@XZ PROC NEAR			; NxConvexMeshDesc::NxConvexMeshDesc, COMDAT

; 207  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxConvexMeshDesc@@QAEXXZ	; NxConvexMeshDesc::setToDefault

; 209  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxConvexMeshDesc@@QAE@XZ ENDP			; NxConvexMeshDesc::NxConvexMeshDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxConvexMeshDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxConvexMeshDesc@@QAEXXZ PROC NEAR	; NxConvexMeshDesc::setToDefault, COMDAT

; 212  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 	numVertices			= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 214  : 	numTriangles		= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 215  : 	pointStrideBytes	= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 216  : 	triangleStrideBytes	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 217  : 	points				= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 218  : 	triangles			= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 219  : 	flags				= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 220  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxConvexMeshDesc@@QAEXXZ ENDP		; NxConvexMeshDesc::setToDefault
_TEXT	ENDS
PUBLIC	??_C@_0EE@EBNF@TriangleMeshFromBmodel?3?5can?8t?5cr@ ; `string'
PUBLIC	??_C@_0DK@HFFC@TriangleMeshFromBmodel?3?5unable?5t@ ; `string'
PUBLIC	??_C@_0DE@CJEP@TriangleMeshFromBmodel?3?5?$CFs?5has?5n@ ; `string'
PUBLIC	??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@ ; `string'
PUBLIC	?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ; CPhysicNovodex::ConvertEdgeToIndex
PUBLIC	?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::TriangleMeshFromBmodel
PUBLIC	??0NxTriangleMeshDesc@@QAE@XZ			; NxTriangleMeshDesc::NxTriangleMeshDesc
;	COMDAT ??_C@_0EE@EBNF@TriangleMeshFromBmodel?3?5can?8t?5cr@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0EE@EBNF@TriangleMeshFromBmodel?3?5can?8t?5cr@ DB 'TriangleMeshFrom'
	DB	'Bmodel: can''t create triangle mesh from worldmodel', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HFFC@TriangleMeshFromBmodel?3?5unable?5t@
CONST	SEGMENT
??_C@_0DK@HFFC@TriangleMeshFromBmodel?3?5unable?5t@ DB 'TriangleMeshFromB'
	DB	'model: unable to fetch model pointer %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CJEP@TriangleMeshFromBmodel?3?5?$CFs?5has?5n@
CONST	SEGMENT
??_C@_0DE@CJEP@TriangleMeshFromBmodel?3?5?$CFs?5has?5n@ DB 'TriangleMeshF'
	DB	'romBmodel: %s has no visible surfaces', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@
CONST	SEGMENT
??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@ DB 'failed to creat'
	DB	'e triangle mesh from %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$1
xdata$x	ENDS
;	COMDAT ?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT
_modelindex$ = 12
_this$ = -16
_bmodel$ = -20
_i$ = -24
_numElems$ = -28
_totalElems$ = -32
_pMesh$ = -36
_psurf$ = -40
_indices$ = -44
_face$49356 = -48
_reverse$49357 = -52
_k$49358 = -56
_j$49359 = -60
_meshDesc$ = -112
_buf$ = -128
_status$ = -132
$T51824 = -136
$T51825 = -140
$T51826 = -144
$T51827 = -152
$T51828 = -156
__$EHRec$ = -12
?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z PROC NEAR ; CPhysicNovodex::TriangleMeshFromBmodel, COMDAT

; 438  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 	if( !m_pCooking )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1352], 0
	jne	SHORT $L49332

; 440  : 		return NULL; // don't spam console about missed NxCooking.dll

	xor	eax, eax
	jmp	$L49331
$L49332:

; 441  : 
; 442  : 	if( modelindex == 1 )

	cmp	DWORD PTR _modelindex$[ebp], 1
	jne	SHORT $L49333

; 444  : 		ALERT( at_error, "TriangleMeshFromBmodel: can't create triangle mesh from worldmodel\n" );

	push	OFFSET FLAT:??_C@_0EE@EBNF@TriangleMeshFromBmodel?3?5can?8t?5cr@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 445  : 		return NULL; // don't create rigidbody from world

	xor	eax, eax
	jmp	$L49331
$L49333:

; 449  : 
; 450  : 	// get a world struct
; 451  : 	if(( bmodel = (model_t *)MODEL_HANDLE( modelindex )) == NULL )

	mov	ecx, DWORD PTR _modelindex$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _bmodel$[ebp], eax
	cmp	DWORD PTR _bmodel$[ebp], 0
	jne	SHORT $L49337

; 453  : 		ALERT( at_error, "TriangleMeshFromBmodel: unable to fetch model pointer %i\n", modelindex );

	mov	edx, DWORD PTR _modelindex$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DK@HFFC@TriangleMeshFromBmodel?3?5unable?5t@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 454  : 		return NULL;

	xor	eax, eax
	jmp	$L49331
$L49337:

; 456  : 
; 457  : 	if( bmodel->nummodelsurfaces <= 0 )

	mov	eax, DWORD PTR _bmodel$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jg	SHORT $L49339

; 459  : 		ALERT( at_aiconsole, "TriangleMeshFromBmodel: %s has no visible surfaces\n", bmodel->name );

	mov	ecx, DWORD PTR _bmodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DE@CJEP@TriangleMeshFromBmodel?3?5?$CFs?5has?5n@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 460  : 		m_fDisableWarning = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 1

; 461  : 		return NULL;

	xor	eax, eax
	jmp	$L49331
$L49339:

; 463  : 
; 464  : 	// don't build hulls for water
; 465  : 	if( FBitSet( bmodel->flags, MODEL_LIQUID ))

	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L49341

; 467  : 		m_fDisableWarning = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 1

; 468  : 		return NULL;

	xor	eax, eax
	jmp	$L49331
$L49341:

; 470  : 
; 471  : 	int i, numElems = 0, totalElems = 0;

	mov	DWORD PTR _numElems$[ebp], 0
	mov	DWORD PTR _totalElems$[ebp], 0

; 472  : 	NxTriangleMesh *pMesh = NULL;

	mov	DWORD PTR _pMesh$[ebp], 0

; 473  : 	msurface_t *psurf;
; 474  : 
; 475  : 	// compute vertexes count
; 476  : 	for( i = 0; i < bmodel->nummodelsurfaces; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49347
$L49348:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L49347:
	mov	ecx, DWORD PTR _bmodel$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+116]
	jge	SHORT $L49349

; 478  : 		psurf = &bmodel->surfaces[bmodel->firstmodelsurface + i];

	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	add	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR _bmodel$[ebp]
	mov	eax, DWORD PTR [edx+180]
	add	eax, ecx
	mov	DWORD PTR _psurf$[ebp], eax

; 479  : 		totalElems += (psurf->numedges - 2);

	mov	ecx, DWORD PTR _psurf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _totalElems$[ebp]
	lea	ecx, DWORD PTR [eax+edx-2]
	mov	DWORD PTR _totalElems$[ebp], ecx

; 480  : 	}

	jmp	SHORT $L49348
$L49349:

; 481  : 
; 482  : 	// create a temp indices array
; 483  : 	NxU32 *indices = new NxU32[totalElems * 3];

	mov	edx, DWORD PTR _totalElems$[ebp]
	imul	edx, 3
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51824[ebp], eax
	mov	eax, DWORD PTR $T51824[ebp]
	mov	DWORD PTR _indices$[ebp], eax

; 484  : 
; 485  : 	for( i = 0; i < bmodel->nummodelsurfaces; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49353
$L49354:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L49353:
	mov	edx, DWORD PTR _bmodel$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+116]
	jge	$L49355

; 487  : 		msurface_t *face = &bmodel->surfaces[bmodel->firstmodelsurface + i];

	mov	ecx, DWORD PTR _bmodel$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	add	edx, DWORD PTR _i$[ebp]
	imul	edx, 92					; 0000005cH
	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR [eax+180]
	add	ecx, edx
	mov	DWORD PTR _face$49356[ebp], ecx

; 488  : 		bool reverse = (face->flags & SURF_PLANEBACK) ? true : false;

	mov	edx, DWORD PTR _face$49356[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 2
	test	eax, eax
	setne	cl
	mov	BYTE PTR _reverse$49357[ebp], cl

; 489  : 		int k = face->firstedge;

	mov	edx, DWORD PTR _face$49356[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _k$49358[ebp], eax

; 490  : 
; 491  : 		// build the triangles from polygons
; 492  : 		for( int j = 0; j < face->numedges - 2; j++ )

	mov	DWORD PTR _j$49359[ebp], 0
	jmp	SHORT $L49360
$L49361:
	mov	ecx, DWORD PTR _j$49359[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$49359[ebp], ecx
$L49360:
	mov	edx, DWORD PTR _face$49356[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 2
	cmp	DWORD PTR _j$49359[ebp], eax
	jge	SHORT $L49362

; 494  : 			indices[numElems*3+0] = ConvertEdgeToIndex( bmodel, k );

	mov	ecx, DWORD PTR _k$49358[ebp]
	push	ecx
	mov	edx, DWORD PTR _bmodel$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ; CPhysicNovodex::ConvertEdgeToIndex
	mov	ecx, DWORD PTR _numElems$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 495  : 			indices[numElems*3+1] = ConvertEdgeToIndex( bmodel, k + j + 2 );

	mov	eax, DWORD PTR _j$49359[ebp]
	mov	ecx, DWORD PTR _k$49358[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	push	edx
	mov	eax, DWORD PTR _bmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ; CPhysicNovodex::ConvertEdgeToIndex
	mov	ecx, DWORD PTR _numElems$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4+4], eax

; 496  : 			indices[numElems*3+2] = ConvertEdgeToIndex( bmodel, k + j + 1 );

	mov	eax, DWORD PTR _j$49359[ebp]
	mov	ecx, DWORD PTR _k$49358[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	mov	eax, DWORD PTR _bmodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ; CPhysicNovodex::ConvertEdgeToIndex
	mov	ecx, DWORD PTR _numElems$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 497  : 			numElems++;

	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 498  : 		}

	jmp	$L49361
$L49362:

; 499  : 	}

	jmp	$L49354
$L49355:

; 500  : 
; 501  : 	NxTriangleMeshDesc meshDesc;

	lea	ecx, DWORD PTR _meshDesc$[ebp]
	call	??0NxTriangleMeshDesc@@QAE@XZ		; NxTriangleMeshDesc::NxTriangleMeshDesc

; 502  : 	meshDesc.points = (const NxPoint*)&(bmodel->vertexes[0].position);	// pointer to all vertices in the map

	mov	ecx, DWORD PTR _bmodel$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	DWORD PTR _meshDesc$[ebp+16], edx

; 503  : 	meshDesc.pointStrideBytes = sizeof( mvertex_t );

	mov	DWORD PTR _meshDesc$[ebp+8], 12		; 0000000cH

; 504  : 	meshDesc.triangleStrideBytes = 3 * sizeof( NxU32 );

	mov	DWORD PTR _meshDesc$[ebp+12], 12	; 0000000cH

; 505  : 	meshDesc.numVertices = bmodel->numvertexes;

	mov	eax, DWORD PTR _bmodel$[ebp]
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _meshDesc$[ebp], ecx

; 506  : 	meshDesc.numTriangles = numElems;

	mov	edx, DWORD PTR _numElems$[ebp]
	mov	DWORD PTR _meshDesc$[ebp+4], edx

; 507  : 	meshDesc.triangles = indices;

	mov	eax, DWORD PTR _indices$[ebp]
	mov	DWORD PTR _meshDesc$[ebp+20], eax

; 508  : 	meshDesc.flags = 0;

	mov	DWORD PTR _meshDesc$[ebp+24], 0

; 509  : 	m_pCooking->NxInitCooking();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1352]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+12]

; 510  : 
; 511  : 	MemoryWriteBuffer buf;

	lea	ecx, DWORD PTR _buf$[ebp]
	call	??0MemoryWriteBuffer@@QAE@XZ		; MemoryWriteBuffer::MemoryWriteBuffer
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 512  : 	bool status = m_pCooking->NxCookTriangleMesh( meshDesc, buf );

	lea	eax, DWORD PTR _buf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _meshDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1352]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+20]
	mov	BYTE PTR _status$[ebp], al

; 513  : 	delete [] indices;

	mov	ecx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR $T51825[ebp], ecx
	mov	edx, DWORD PTR $T51825[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 514  : 
; 515  : 	if( !status )

	mov	eax, DWORD PTR _status$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L49370

; 517  : 		ALERT( at_error, "failed to create triangle mesh from %s\n", bmodel->name );

	mov	ecx, DWORD PTR _bmodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 518  : 		return NULL;

	mov	DWORD PTR $T51826[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _buf$[ebp]
	call	??1MemoryWriteBuffer@@UAE@XZ		; MemoryWriteBuffer::~MemoryWriteBuffer
	mov	eax, DWORD PTR $T51826[ebp]
	jmp	$L49331
$L49370:

; 520  : 
; 521  : 	pMesh = m_pPhysics->createTriangleMesh( MemoryReadBuffer( buf.data ));

	mov	edx, DWORD PTR _buf$[ebp+12]
	push	edx
	lea	ecx, DWORD PTR $T51827[ebp]
	call	??0MemoryReadBuffer@@QAE@PBE@Z		; MemoryReadBuffer::MemoryReadBuffer
	mov	DWORD PTR -160+[ebp], eax
	mov	eax, DWORD PTR -160+[ebp]
	mov	DWORD PTR -164+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR -164+[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+32]
	mov	DWORD PTR _pMesh$[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T51827[ebp]
	call	??1MemoryReadBuffer@@UAE@XZ		; MemoryReadBuffer::~MemoryReadBuffer

; 522  : 	if( !pMesh ) ALERT( at_error, "failed to create triangle mesh from %s\n", bmodel->name );

	cmp	DWORD PTR _pMesh$[ebp], 0
	jne	SHORT $L49374
	mov	ecx, DWORD PTR _bmodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49374:

; 523  : 
; 524  : 	return pMesh;

	mov	edx, DWORD PTR _pMesh$[ebp]
	mov	DWORD PTR $T51828[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _buf$[ebp]
	call	??1MemoryWriteBuffer@@UAE@XZ		; MemoryWriteBuffer::~MemoryWriteBuffer
	mov	eax, DWORD PTR $T51828[ebp]
$L49331:

; 525  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$0:
	lea	ecx, DWORD PTR _buf$[ebp]
	call	??1MemoryWriteBuffer@@UAE@XZ		; MemoryWriteBuffer::~MemoryWriteBuffer
	ret	0
__unwindfunclet$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$1:
	lea	ecx, DWORD PTR $T51827[ebp]
	call	??1MemoryReadBuffer@@UAE@XZ		; MemoryReadBuffer::~MemoryReadBuffer
	ret	0
__ehhandler$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z ENDP ; CPhysicNovodex::TriangleMeshFromBmodel
PUBLIC	?setToDefault@NxTriangleMeshDesc@@QAEXXZ	; NxTriangleMeshDesc::setToDefault
PUBLIC	??0NxSimpleTriangleMesh@@QAE@XZ			; NxSimpleTriangleMesh::NxSimpleTriangleMesh
;	COMDAT ??0NxTriangleMeshDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxTriangleMeshDesc@@QAE@XZ PROC NEAR			; NxTriangleMeshDesc::NxTriangleMeshDesc, COMDAT

; 187  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxSimpleTriangleMesh@@QAE@XZ		; NxSimpleTriangleMesh::NxSimpleTriangleMesh

; 188  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxTriangleMeshDesc@@QAEXXZ ; NxTriangleMeshDesc::setToDefault

; 189  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxTriangleMeshDesc@@QAE@XZ ENDP			; NxTriangleMeshDesc::NxTriangleMeshDesc
_TEXT	ENDS
PUBLIC	?setToDefault@NxSimpleTriangleMesh@@QAEXXZ	; NxSimpleTriangleMesh::setToDefault
;	COMDAT ??0NxSimpleTriangleMesh@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxSimpleTriangleMesh@@QAE@XZ PROC NEAR		; NxSimpleTriangleMesh::NxSimpleTriangleMesh, COMDAT

; 97   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxSimpleTriangleMesh@@QAEXXZ ; NxSimpleTriangleMesh::setToDefault

; 99   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxSimpleTriangleMesh@@QAE@XZ ENDP			; NxSimpleTriangleMesh::NxSimpleTriangleMesh
_TEXT	ENDS
;	COMDAT ?setToDefault@NxSimpleTriangleMesh@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxSimpleTriangleMesh@@QAEXXZ PROC NEAR	; NxSimpleTriangleMesh::setToDefault, COMDAT

; 102  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 	numVertices			= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 104  : 	numTriangles		= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 105  : 	pointStrideBytes	= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 106  : 	triangleStrideBytes	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 107  : 	points				= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 108  : 	triangles			= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 109  : 	flags				= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 110  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxSimpleTriangleMesh@@QAEXXZ ENDP		; NxSimpleTriangleMesh::setToDefault
_TEXT	ENDS
;	COMDAT ?setToDefault@NxTriangleMeshDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxTriangleMeshDesc@@QAEXXZ PROC NEAR	; NxTriangleMeshDesc::setToDefault, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 	NxSimpleTriangleMesh::setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxSimpleTriangleMesh@@QAEXXZ ; NxSimpleTriangleMesh::setToDefault

; 194  : 	materialIndexStride			= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 195  : 	materialIndices				= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 196  : 	heightFieldVerticalAxis		= NX_NOT_HEIGHTFIELD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 255			; 000000ffH

; 197  : 	heightFieldVerticalExtent	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 198  : 	convexEdgeThreshold			= 0.001f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 981668463		; 3a83126fH

; 199  : 	pmap						= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 200  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxTriangleMeshDesc@@QAEXXZ ENDP		; NxTriangleMeshDesc::setToDefault
_TEXT	ENDS
PUBLIC	?StudioCalcBoneQuaterion@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector4D@@@Z ; CPhysicNovodex::StudioCalcBoneQuaterion
PUBLIC	??0Radian@@QAE@XZ				; Radian::Radian
PUBLIC	??BRadian@@QAEPAMXZ				; Radian::operator float *
EXTRN	?AngleQuaternion@@YAXABVRadian@@AAVVector4D@@@Z:NEAR ; AngleQuaternion
;	COMDAT ?StudioCalcBoneQuaterion@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector4D@@@Z
_TEXT	SEGMENT
_pbone$ = 8
_panim$ = 12
_q$ = 16
_this$ = -4
_panimvalue$ = -8
_angle$ = -20
_j$ = -24
?StudioCalcBoneQuaterion@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector4D@@@Z PROC NEAR ; CPhysicNovodex::StudioCalcBoneQuaterion, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 529  : 	mstudioanimvalue_t *panimvalue;
; 530  : 	Radian angle;

	lea	ecx, DWORD PTR _angle$[ebp]
	call	??0Radian@@QAE@XZ			; Radian::Radian

; 531  : 
; 532  : 	for( int j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L49385
$L49386:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L49385:
	cmp	DWORD PTR _j$[ebp], 3
	jge	$L49387

; 534  : 		if( !panim || panim->offset[j+3] == 0 )

	cmp	DWORD PTR _panim$[ebp], 0
	je	SHORT $L49389
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _panim$[ebp]
	xor	eax, eax
	mov	ax, WORD PTR [edx+ecx*2+6]
	test	eax, eax
	jne	SHORT $L49388
$L49389:

; 536  : 			angle[j] = pbone->value[j+3]; // default;

	lea	ecx, DWORD PTR _angle$[ebp]
	call	??BRadian@@QAEPAMXZ			; Radian::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _pbone$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+76]
	mov	DWORD PTR [eax+ecx*4], edx

; 538  : 		else

	jmp	SHORT $L49390
$L49388:

; 540  : 			panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j+3]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _panim$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+eax*2+6]
	mov	eax, DWORD PTR _panim$[ebp]
	add	eax, edx
	mov	DWORD PTR _panimvalue$[ebp], eax

; 541  : 			angle[j] = panimvalue[1].value;

	mov	ecx, DWORD PTR _panimvalue$[ebp]
	movsx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR -28+[ebp], edx
	fild	DWORD PTR -28+[ebp]
	fstp	DWORD PTR -32+[ebp]
	lea	ecx, DWORD PTR _angle$[ebp]
	call	??BRadian@@QAEPAMXZ			; Radian::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 542  : 			angle[j] = pbone->value[j+3] + angle[j] * pbone->scale[j+3];

	lea	ecx, DWORD PTR _angle$[ebp]
	call	??BRadian@@QAEPAMXZ			; Radian::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _pbone$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fmul	DWORD PTR [esi+edx*4+100]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pbone$[ebp]
	fadd	DWORD PTR [ecx+eax*4+76]
	fstp	DWORD PTR -36+[ebp]
	lea	ecx, DWORD PTR _angle$[ebp]
	call	??BRadian@@QAEPAMXZ			; Radian::operator float *
	mov	edx, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
$L49390:

; 544  : 	}

	jmp	$L49386
$L49387:

; 545  : 
; 546  : 	AngleQuaternion( angle, q );

	mov	edx, DWORD PTR _q$[ebp]
	push	edx
	lea	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?AngleQuaternion@@YAXABVRadian@@AAVVector4D@@@Z ; AngleQuaternion
	add	esp, 8

; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StudioCalcBoneQuaterion@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector4D@@@Z ENDP ; CPhysicNovodex::StudioCalcBoneQuaterion
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Radian@@QAE@XZ PROC NEAR				; Radian::Radian, COMDAT

; 362  : 	inline Radian( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Radian@@QAE@XZ ENDP					; Radian::Radian
_TEXT	ENDS
;	COMDAT ??BRadian@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BRadian@@QAEPAMXZ PROC NEAR				; Radian::operator float *, COMDAT

; 370  : 	operator float *()				{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BRadian@@QAEPAMXZ ENDP				; Radian::operator float *
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	?StudioCalcBonePosition@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector@@@Z ; CPhysicNovodex::StudioCalcBonePosition
;	COMDAT ?StudioCalcBonePosition@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector@@@Z
_TEXT	SEGMENT
_pbone$ = 8
_panim$ = 12
_pos$ = 16
_this$ = -4
_panimvalue$ = -8
_j$ = -12
?StudioCalcBonePosition@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector@@@Z PROC NEAR ; CPhysicNovodex::StudioCalcBonePosition, COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 551  : 	mstudioanimvalue_t *panimvalue;
; 552  : 
; 553  : 	for( int j = 0; j < 3; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L49401
$L49402:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L49401:
	cmp	DWORD PTR _j$[ebp], 3
	jge	SHORT $L49403

; 555  : 		pos[j] = pbone->value[j]; // default;

	mov	ecx, DWORD PTR _pos$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _pbone$[ebp]
	mov	edx, DWORD PTR [esi+edx*4+64]
	mov	DWORD PTR [eax+ecx*4], edx

; 556  : 
; 557  : 		if( panim && panim->offset[j] != 0 )

	cmp	DWORD PTR _panim$[ebp], 0
	je	SHORT $L49404
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _panim$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+eax*2]
	test	edx, edx
	je	SHORT $L49404

; 559  : 			panimvalue = (mstudioanimvalue_t *)((byte *)panim + panim->offset[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _panim$[ebp]
	xor	edx, edx
	mov	dx, WORD PTR [ecx+eax*2]
	mov	eax, DWORD PTR _panim$[ebp]
	add	eax, edx
	mov	DWORD PTR _panimvalue$[ebp], eax

; 560  : 			pos[j] += panimvalue[1].value * pbone->scale[j];

	mov	ecx, DWORD PTR _pos$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _j$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR -16+[ebp], edx
	mov	eax, DWORD PTR _panimvalue$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	DWORD PTR -20+[ebp], ecx
	fild	DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pbone$[ebp]
	fmul	DWORD PTR [eax+edx*4+88]
	mov	ecx, DWORD PTR -16+[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR -16+[ebp]
	fstp	DWORD PTR [edx]
$L49404:

; 562  : 	}

	jmp	$L49402
$L49403:

; 563  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?StudioCalcBonePosition@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector@@@Z ENDP ; CPhysicNovodex::StudioCalcBonePosition
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
PUBLIC	??_C@_0CJ@MDAM@CollisionFromStudio?3?5not?5a?5studi@ ; `string'
PUBLIC	??_C@_0CH@GKBK@CollisionFromStudio?3?5bad?5model?5h@ ; `string'
PUBLIC	??_C@_0DA@MOEN@Convex?5mesh?5for?5?$CFs?5is?5corrupted?4@ ; `string'
PUBLIC	??_C@_0DC@FJAP@Convex?5mesh?5for?5?$CFs?5is?5out?5of?5Dat@ ; `string'
PUBLIC	??_C@_0DF@JAPI@CollisionFromStudio?3?5bad?5sequenc@ ; `string'
PUBLIC	?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::ConvexMeshFromStudio
PUBLIC	?CheckFileTimes@CPhysicNovodex@@AAEHPBD0@Z	; CPhysicNovodex::CheckFileTimes
PUBLIC	?HullNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z	; CPhysicNovodex::HullNameForModel
PUBLIC	??0matrix4x4@@QAE@ABV0@@Z			; matrix4x4::matrix4x4
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z	; matrix3x4::matrix3x4
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	?Identity@matrix4x4@@QAEXXZ:NEAR		; matrix4x4::Identity
EXTRN	??4matrix4x4@@QAEAAV0@ABVmatrix3x4@@@Z:NEAR	; matrix4x4::operator=
EXTRN	??4matrix4x4@@QAEAAV0@ABV0@@Z:NEAR		; matrix4x4::operator=
EXTRN	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorTransform
EXTRN	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z:NEAR	; matrix4x4::ConcatTransforms
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
EXTRN	??0UserStream@@QAE@PBD_N@Z:NEAR			; UserStream::UserStream
EXTRN	??1UserStream@@UAE@XZ:NEAR			; UserStream::~UserStream
EXTRN	__chkstk:NEAR
_BSS	SEGMENT
	ALIGN	4

_?pos@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector@@A DB 0600H DUP (?)
_?$S30@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4EA DB 01H DUP (?)
	ALIGN	4

_?q@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A DB 0800H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CJ@MDAM@CollisionFromStudio?3?5not?5a?5studi@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CJ@MDAM@CollisionFromStudio?3?5not?5a?5studi@ DB 'CollisionFromStu'
	DB	'dio: not a studio model', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GKBK@CollisionFromStudio?3?5bad?5model?5h@
CONST	SEGMENT
??_C@_0CH@GKBK@CollisionFromStudio?3?5bad?5model?5h@ DB 'CollisionFromStu'
	DB	'dio: bad model header', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@MOEN@Convex?5mesh?5for?5?$CFs?5is?5corrupted?4@
CONST	SEGMENT
??_C@_0DA@MOEN@Convex?5mesh?5for?5?$CFs?5is?5corrupted?4@ DB 'Convex mesh'
	DB	' for %s is corrupted. Rebuilding...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FJAP@Convex?5mesh?5for?5?$CFs?5is?5out?5of?5Dat@
CONST	SEGMENT
??_C@_0DC@FJAP@Convex?5mesh?5for?5?$CFs?5is?5out?5of?5Dat@ DB 'Convex mes'
	DB	'h for %s is out of Date. Rebuilding...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JAPI@CollisionFromStudio?3?5bad?5sequenc@
CONST	SEGMENT
??_C@_0DF@JAPI@CollisionFromStudio?3?5bad?5sequenc@ DB 'CollisionFromStud'
	DB	'io: bad sequence group (must be 0)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z DD 019930520H
	DD	05H
	DD	FLAT:__unwindtable$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$4
xdata$x	ENDS
;	COMDAT ?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT
_modelindex$ = 12
_this$ = -16
_smodel$ = -20
_phdr$ = -24
_szHullFilename$ = -284
_pHull$ = -288
_pseqdesc$ = -292
_pseqgroup$ = -296
_panim$ = -300
_pbone$ = -304
_i$ = -308
_transform$ = -372
_bonematrix$ = -436
_bonetransform$ = -8628
_pbodypart$ = -8632
_psubmodel$ = -8636
_pstudioverts$ = -8640
_m_verts$ = -8644
_$S33$ = -8648
_pvertbone$ = -8652
_verts$ = -8656
_$S34$ = -8660
_indices$ = -8664
_numVerts$ = -8668
_numElems$ = -8672
_tmp$ = -8684
_j$ = -8688
_pmesh$49517 = -8692
_ptricmds$49520 = -8696
_vertexState$49526 = -8700
_tri_strip$49527 = -8704
_meshDesc$ = -8732
_status$ = -8736
$T51857 = -8760
$T51858 = -8808
$T51859 = -8812
$T51860 = -8876
$T51861 = -8880
$T51862 = -8944
$T51863 = -8948
$T51864 = -8952
$T51867 = -8956
$T51868 = -8960
$T51871 = -8964
$T51872 = -8976
$T51873 = -9000
$T51874 = -9004
$T51875 = -9008
$T51876 = -9012
$T51877 = -9036
__$EHRec$ = -12
?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z PROC NEAR ; CPhysicNovodex::ConvexMeshFromStudio, COMDAT

; 566  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	mov	eax, 9120				; 000023a0H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 567  : 	if( UTIL_GetModelType( modelindex ) != mod_studio )

	mov	eax, DWORD PTR _modelindex$[ebp]
	push	eax
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	cmp	eax, 3
	je	SHORT $L49412

; 569  : 		ALERT( at_error, "CollisionFromStudio: not a studio model\n" );

	push	OFFSET FLAT:??_C@_0CJ@MDAM@CollisionFromStudio?3?5not?5a?5studi@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 570  : 		return NULL;

	xor	eax, eax
	jmp	$L49411
$L49412:

; 572  : 
; 573  : 	model_t *smodel = (model_t *)MODEL_HANDLE( modelindex );

	mov	ecx, DWORD PTR _modelindex$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _smodel$[ebp], eax

; 574  : 	studiohdr_t *phdr = (studiohdr_t *)smodel->cache.data;

	mov	edx, DWORD PTR _smodel$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR _phdr$[ebp], eax

; 575  : 
; 576  : 	if( !phdr || phdr->numbones < 1 )

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $L49419
	mov	ecx, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [ecx+140], 1
	jge	SHORT $L49418
$L49419:

; 578  : 		ALERT( at_error, "CollisionFromStudio: bad model header\n" );

	push	OFFSET FLAT:??_C@_0CH@GKBK@CollisionFromStudio?3?5bad?5model?5h@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 579  : 		return NULL;

	xor	eax, eax
	jmp	$L49411
$L49418:

; 583  : 	NxConvexMesh *pHull = NULL;

	mov	DWORD PTR _pHull$[ebp], 0

; 584  : 
; 585  : 	HullNameForModel( smodel->name, szHullFilename, sizeof( szHullFilename ));

	push	260					; 00000104H
	lea	edx, DWORD PTR _szHullFilename$[ebp]
	push	edx
	mov	eax, DWORD PTR _smodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HullNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z ; CPhysicNovodex::HullNameForModel

; 586  : 
; 587  : 	if( CheckFileTimes( smodel->name, szHullFilename ))

	lea	ecx, DWORD PTR _szHullFilename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _smodel$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckFileTimes@CPhysicNovodex@@AAEHPBD0@Z ; CPhysicNovodex::CheckFileTimes
	test	eax, eax
	je	$L49423

; 589  : 		// hull is never than studiomodel. Trying to load it
; 590  : 		pHull = m_pPhysics->createConvexMesh( UserStream( szHullFilename, true ));

	push	1
	lea	eax, DWORD PTR _szHullFilename$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T51857[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -9040+[ebp], eax
	mov	ecx, DWORD PTR -9040+[ebp]
	mov	DWORD PTR -9044+[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR -9044+[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+72]
	mov	DWORD PTR _pHull$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T51857[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 591  : 
; 592  : 		if( !pHull )

	cmp	DWORD PTR _pHull$[ebp], 0
	jne	SHORT $L49425

; 594  : 			// we failed to loading existed hull and can't cooking new :(
; 595  : 			if( m_pCooking == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1352], 0
	jne	SHORT $L49426

; 596  : 				return NULL; // don't spam console about missed nxCooking.dll

	xor	eax, eax
	jmp	$L49411
$L49426:

; 597  : 
; 598  : 			// trying to rebuild hull
; 599  : 			ALERT( at_error, "Convex mesh for %s is corrupted. Rebuilding...\n", smodel->name );

	mov	ecx, DWORD PTR _smodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DA@MOEN@Convex?5mesh?5for?5?$CFs?5is?5corrupted?4@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 601  : 		else

	jmp	SHORT $L49428
$L49425:

; 603  : 			// all is ok
; 604  : 			return pHull;

	mov	eax, DWORD PTR _pHull$[ebp]
	jmp	$L49411
$L49428:

; 607  : 	else

	jmp	SHORT $L49429
$L49423:

; 609  : 		// can't cooking new hull because nxCooking.dll is missed
; 610  : 		if( m_pCooking == NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1352], 0
	jne	SHORT $L49430

; 611  : 			return NULL; // don't spam console about missed nxCooking.dll

	xor	eax, eax
	jmp	$L49411
$L49430:

; 612  : 
; 613  : 		// trying to rebuild hull
; 614  : 		ALERT( at_console, "Convex mesh for %s is out of Date. Rebuilding...\n", smodel->name );

	mov	eax, DWORD PTR _smodel$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0DC@FJAP@Convex?5mesh?5for?5?$CFs?5is?5out?5of?5Dat@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49429:

; 616  : 
; 617  : 	// at this point nxCooking instance is always valid
; 618  : 
; 619  : 	// compute default pose for building mesh from
; 620  : 	mstudioseqdesc_t *pseqdesc = (mstudioseqdesc_t *)((byte *)phdr + phdr->seqindex);

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+168]
	mov	DWORD PTR _pseqdesc$[ebp], edx

; 621  : 	mstudioseqgroup_t *pseqgroup = (mstudioseqgroup_t *)((byte *)phdr + phdr->seqgroupindex) + pseqdesc->seqgroup;

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+176]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	mov	eax, DWORD PTR [edx+156]
	imul	eax, 104				; 00000068H
	add	ecx, eax
	mov	DWORD PTR _pseqgroup$[ebp], ecx

; 622  : 
; 623  : 	// sanity check
; 624  : 	if( pseqdesc->seqgroup != 0 )

	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [ecx+156], 0
	je	SHORT $L49438

; 626  : 		ALERT( at_error, "CollisionFromStudio: bad sequence group (must be 0)\n" );

	push	OFFSET FLAT:??_C@_0DF@JAPI@CollisionFromStudio?3?5bad?5sequenc@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 627  : 		return NULL;

	xor	eax, eax
	jmp	$L49411
$L49438:

; 629  : 
; 630  : 	mstudioanim_t *panim = (mstudioanim_t *)((byte *)phdr + pseqgroup->data + pseqdesc->animindex);

	mov	edx, DWORD PTR _pseqgroup$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _pseqdesc$[ebp]
	add	eax, DWORD PTR [ecx+124]
	mov	DWORD PTR _panim$[ebp], eax

; 631  : 	mstudiobone_t *pbone = (mstudiobone_t *)((byte *)phdr + phdr->boneindex);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _pbone$[ebp], eax

; 632  : 	static Vector pos[MAXSTUDIOBONES];

	xor	ecx, ecx
	mov	cl, BYTE PTR _?$S30@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4EA
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L49450
	mov	dl, BYTE PTR _?$S30@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4EA
	or	dl, 1
	mov	BYTE PTR _?$S30@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4EA, dl
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	push	OFFSET FLAT:_?pos@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E31
	call	_atexit
	add	esp, 4
$L49450:

; 633  : 	static Vector4D q[MAXSTUDIOBONES];

	xor	eax, eax
	mov	al, BYTE PTR _?$S30@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4EA
	and	eax, 2
	test	eax, eax
	jne	SHORT $L49455
	mov	cl, BYTE PTR _?$S30@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4EA
	or	cl, 2
	mov	BYTE PTR _?$S30@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4EA, cl
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	128					; 00000080H
	push	16					; 00000010H
	push	OFFSET FLAT:_?q@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E32
	call	_atexit
	add	esp, 4
$L49455:

; 634  : 
; 635  : 	for( int i = 0; i < phdr->numbones; i++, pbone++, panim++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49459
$L49460:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _pbone$[ebp]
	add	eax, 112				; 00000070H
	mov	DWORD PTR _pbone$[ebp], eax
	mov	ecx, DWORD PTR _panim$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], ecx
$L49459:
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	SHORT $L49461

; 637  : 		StudioCalcBoneQuaterion( pbone, panim, q[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET FLAT:_?q@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A
	push	ecx
	mov	edx, DWORD PTR _panim$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioCalcBoneQuaterion@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector4D@@@Z ; CPhysicNovodex::StudioCalcBoneQuaterion

; 638  : 		StudioCalcBonePosition( pbone, panim, pos[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_?pos@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector@@A
	push	ecx
	mov	edx, DWORD PTR _panim$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioCalcBonePosition@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector@@@Z ; CPhysicNovodex::StudioCalcBonePosition

; 639  : 	}

	jmp	$L49460
$L49461:

; 640  : 
; 641  : 	pbone = (mstudiobone_t *)((byte *)phdr + phdr->boneindex);

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR _pbone$[ebp], edx

; 642  : 	matrix4x4	transform, bonematrix, bonetransform[MAXSTUDIOBONES];

	lea	ecx, DWORD PTR _transform$[ebp]
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	push	OFFSET FLAT:??0matrix4x4@@QAE@XZ	; matrix4x4::matrix4x4
	push	128					; 00000080H
	push	64					; 00000040H
	lea	eax, DWORD PTR _bonetransform$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 643  : 	transform.Identity();

	lea	ecx, DWORD PTR _transform$[ebp]
	call	?Identity@matrix4x4@@QAEXXZ		; matrix4x4::Identity

; 644  : 
; 645  : 	// compute bones for default anim
; 646  : 	for( i = 0; i < phdr->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49468
$L49469:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L49468:
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+140]
	jge	$L49470

; 648  : 		// initialize bonematrix
; 649  : 		bonematrix = matrix3x4( pos[i], q[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	add	ecx, OFFSET FLAT:_?q@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, OFFSET FLAT:_?pos@?BJ@??ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z@4PAVVector@@A
	push	edx
	lea	ecx, DWORD PTR $T51858[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??4matrix4x4@@QAEAAV0@ABVmatrix3x4@@@Z	; matrix4x4::operator=

; 650  : 
; 651  : 		if( pbone[i].parent == -1 ) 

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _pbone$[ebp]
	cmp	DWORD PTR [ecx+eax+32], -1
	jne	SHORT $L49472

; 652  : 			bonetransform[i] = transform.ConcatTransforms( bonematrix );

	sub	esp, 64					; 00000040H
	mov	ecx, esp
	mov	DWORD PTR $T51859[ebp], esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T51860[ebp]
	push	eax
	lea	ecx, DWORD PTR _transform$[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+ecx]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 653  : 		else bonetransform[i] = bonetransform[pbone[i].parent].ConcatTransforms( bonematrix );

	jmp	SHORT $L49475
$L49472:
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	mov	DWORD PTR $T51861[ebp], esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T51862[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pbone$[ebp]
	mov	eax, DWORD PTR [edx+ecx+32]
	shl	eax, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+eax]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+ecx]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=
$L49475:

; 654  : 	}

	jmp	$L49469
$L49470:

; 655  : 
; 656  : 	mstudiobodyparts_t *pbodypart = (mstudiobodyparts_t *)((byte *)phdr + phdr->bodypartindex);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+208]
	mov	DWORD PTR _pbodypart$[ebp], eax

; 657  : 	mstudiomodel_t *psubmodel = (mstudiomodel_t *)((byte *)phdr + pbodypart->modelindex);

	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR _psubmodel$[ebp], edx

; 658  : 	Vector *pstudioverts = (Vector *)((byte *)phdr + psubmodel->vertindex);

	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _pstudioverts$[ebp], ecx

; 659  : 	Vector *m_verts = new Vector[psubmodel->numverts];

	mov	edx, DWORD PTR _psubmodel$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _$S33$[ebp], eax
	mov	ecx, DWORD PTR _$S33$[ebp]
	imul	ecx, 12					; 0000000cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51864[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T51864[ebp], 0
	je	SHORT $L51865
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	mov	edx, DWORD PTR _$S33$[ebp]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T51864[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR $T51864[ebp]
	mov	DWORD PTR -9048+[ebp], ecx
	jmp	SHORT $L51866
$L51865:
	mov	DWORD PTR -9048+[ebp], 0
$L51866:
	mov	edx, DWORD PTR -9048+[ebp]
	mov	DWORD PTR $T51863[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T51863[ebp]
	mov	DWORD PTR _m_verts$[ebp], eax

; 660  : 	byte *pvertbone = ((byte *)phdr + psubmodel->vertinfoindex);

	mov	ecx, DWORD PTR _psubmodel$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _pvertbone$[ebp], edx

; 661  : 	Vector *verts = new Vector[psubmodel->numverts * 8];	// allocate temporary vertices array

	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	shl	ecx, 3
	mov	DWORD PTR _$S34$[ebp], ecx
	mov	edx, DWORD PTR _$S34$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51868[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T51868[ebp], 0
	je	SHORT $L51869
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	mov	eax, DWORD PTR _$S34$[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T51868[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	edx, DWORD PTR $T51868[ebp]
	mov	DWORD PTR -9052+[ebp], edx
	jmp	SHORT $L51870
$L51869:
	mov	DWORD PTR -9052+[ebp], 0
$L51870:
	mov	eax, DWORD PTR -9052+[ebp]
	mov	DWORD PTR $T51867[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T51867[ebp]
	mov	DWORD PTR _verts$[ebp], ecx

; 662  : 	NxU32 *indices = new NxU32[psubmodel->numverts * 24];

	mov	edx, DWORD PTR _psubmodel$[ebp]
	mov	eax, DWORD PTR [edx+80]
	imul	eax, 24					; 00000018H
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51871[ebp], eax
	mov	ecx, DWORD PTR $T51871[ebp]
	mov	DWORD PTR _indices$[ebp], ecx

; 663  : 	int numVerts = 0, numElems = 0;

	mov	DWORD PTR _numVerts$[ebp], 0
	mov	DWORD PTR _numElems$[ebp], 0

; 664  : 	Vector tmp;

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 665  : 
; 666  : 	// setup all the vertices
; 667  : 	for( i = 0; i < psubmodel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49509
$L49510:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L49509:
	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $L49511

; 668  : 		m_verts[i] = bonetransform[pvertbone[i]].VectorTransform( pstudioverts[i] );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pstudioverts$[ebp]
	add	eax, edx
	push	eax
	lea	ecx, DWORD PTR $T51872[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvertbone$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx]
	shl	eax, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+eax]
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _m_verts$[ebp]
	add	edx, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $L49510
$L49511:

; 669  : 
; 670  : 	for( int j = 0; j < psubmodel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L49514
$L49515:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L49514:
	mov	edx, DWORD PTR _psubmodel$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jge	$L49516

; 672  : 		mstudiomesh_t *pmesh = (mstudiomesh_t *)((byte *)phdr + psubmodel->meshindex) + j;

	mov	ecx, DWORD PTR _psubmodel$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _j$[ebp]
	imul	eax, 20					; 00000014H
	add	edx, eax
	mov	DWORD PTR _pmesh$49517[ebp], edx

; 673  : 		short *ptricmds = (short *)((byte *)phdr + pmesh->triindex);

	mov	ecx, DWORD PTR _pmesh$49517[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _ptricmds$49520[ebp], edx
$L49524:

; 674  : 
; 675  : 		while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$49520[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ptricmds$49520[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$49520[ebp], eax
	test	edx, edx
	je	$L49525

; 677  : 			int	vertexState = 0;

	mov	DWORD PTR _vertexState$49526[ebp], 0

; 678  : 			qboolean	tri_strip;
; 679  : 
; 680  : 			if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $L49528

; 682  : 				tri_strip = false;

	mov	DWORD PTR _tri_strip$49527[ebp], 0

; 683  : 				i = -i;

	mov	ecx, DWORD PTR _i$[ebp]
	neg	ecx
	mov	DWORD PTR _i$[ebp], ecx

; 685  : 			else

	jmp	SHORT $L49529
$L49528:

; 686  : 				tri_strip = true;

	mov	DWORD PTR _tri_strip$49527[ebp], 1
$L49529:

; 687  : 
; 688  : 			for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $L49530
$L49531:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _ptricmds$49520[ebp]
	add	eax, 8
	mov	DWORD PTR _ptricmds$49520[ebp], eax
$L49530:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$L49532

; 690  : 				// build in indices
; 691  : 				if( vertexState++ < 3 )

	mov	ecx, DWORD PTR _vertexState$49526[ebp]
	mov	edx, DWORD PTR _vertexState$49526[ebp]
	add	edx, 1
	mov	DWORD PTR _vertexState$49526[ebp], edx
	cmp	ecx, 3
	jge	SHORT $L49533

; 693  : 					indices[numElems++] = numVerts;

	mov	eax, DWORD PTR _numElems$[ebp]
	mov	ecx, DWORD PTR _indices$[ebp]
	mov	edx, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 695  : 				else if( tri_strip )

	jmp	$L49538
$L49533:
	cmp	DWORD PTR _tri_strip$49527[ebp], 0
	je	$L49535

; 697  : 					// flip triangles between clockwise and counter clockwise
; 698  : 					if( vertexState & 1 )

	mov	ecx, DWORD PTR _vertexState$49526[ebp]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L49536

; 700  : 						// draw triangle [n-2 n-1 n]
; 701  : 						indices[numElems++] = numVerts - 2;

	mov	edx, DWORD PTR _numVerts$[ebp]
	sub	edx, 2
	mov	eax, DWORD PTR _numElems$[ebp]
	mov	ecx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	edx, DWORD PTR _numElems$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElems$[ebp], edx

; 702  : 						indices[numElems++] = numVerts - 1;

	mov	eax, DWORD PTR _numVerts$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 703  : 						indices[numElems++] = numVerts;

	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	eax, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _numElems$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numElems$[ebp], ecx

; 705  : 					else

	jmp	SHORT $L49537
$L49536:

; 707  : 						// draw triangle [n-1 n-2 n]
; 708  : 						indices[numElems++] = numVerts - 1;

	mov	edx, DWORD PTR _numVerts$[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _numElems$[ebp]
	mov	ecx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	edx, DWORD PTR _numElems$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElems$[ebp], edx

; 709  : 						indices[numElems++] = numVerts - 2;

	mov	eax, DWORD PTR _numVerts$[ebp]
	sub	eax, 2
	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 710  : 						indices[numElems++] = numVerts;

	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	eax, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _numElems$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numElems$[ebp], ecx
$L49537:

; 713  : 				else

	jmp	SHORT $L49538
$L49535:

; 715  : 					// draw triangle fan [0 n-1 n]
; 716  : 					indices[numElems++] = numVerts - ( vertexState - 1 );

	mov	edx, DWORD PTR _vertexState$49526[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _numVerts$[ebp]
	sub	eax, edx
	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 717  : 					indices[numElems++] = numVerts - 1;

	mov	ecx, DWORD PTR _numVerts$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _numElems$[ebp]
	mov	eax, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	ecx, DWORD PTR _numElems$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numElems$[ebp], ecx

; 718  : 					indices[numElems++] = numVerts;

	mov	edx, DWORD PTR _numElems$[ebp]
	mov	eax, DWORD PTR _indices$[ebp]
	mov	ecx, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _numElems$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElems$[ebp], edx
$L49538:

; 720  : 
; 721  : 				verts[numVerts++] = m_verts[ptricmds[0]];

	mov	eax, DWORD PTR _ptricmds$49520[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _m_verts$[ebp]
	add	edx, ecx
	mov	eax, DWORD PTR _numVerts$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _verts$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _numVerts$[ebp]
	add	eax, 1
	mov	DWORD PTR _numVerts$[ebp], eax

; 722  : 			}

	jmp	$L49531
$L49532:

; 723  : 		}

	jmp	$L49524
$L49525:

; 724  : 	}

	jmp	$L49515
$L49516:

; 725  : 
; 726  : 	NxConvexMeshDesc meshDesc;

	lea	ecx, DWORD PTR _meshDesc$[ebp]
	call	??0NxConvexMeshDesc@@QAE@XZ		; NxConvexMeshDesc::NxConvexMeshDesc

; 727  : 	meshDesc.numTriangles = numElems / 3;

	mov	eax, DWORD PTR _numElems$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _meshDesc$[ebp+4], eax

; 728  : 	meshDesc.pointStrideBytes = sizeof(Vector);

	mov	DWORD PTR _meshDesc$[ebp+8], 12		; 0000000cH

; 729  : 	meshDesc.triangleStrideBytes	= 3 * sizeof( NxU32 );

	mov	DWORD PTR _meshDesc$[ebp+12], 12	; 0000000cH

; 730  : 	meshDesc.points = verts;

	mov	edx, DWORD PTR _verts$[ebp]
	mov	DWORD PTR _meshDesc$[ebp+16], edx

; 731  : 	meshDesc.triangles = indices;

	mov	eax, DWORD PTR _indices$[ebp]
	mov	DWORD PTR _meshDesc$[ebp+20], eax

; 732  : 	meshDesc.numVertices = numVerts;

	mov	ecx, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR _meshDesc$[ebp], ecx

; 733  : 	meshDesc.flags |= NX_CF_COMPUTE_CONVEX;

	mov	edx, DWORD PTR _meshDesc$[ebp+24]
	or	edx, 4
	mov	DWORD PTR _meshDesc$[ebp+24], edx

; 734  : 
; 735  : 	m_pCooking->NxInitCooking();

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1352]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+12]

; 736  : 	bool status = m_pCooking->NxCookConvexMesh( meshDesc, UserStream( szHullFilename, false ));

	push	0
	lea	eax, DWORD PTR _szHullFilename$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T51873[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -9056+[ebp], eax
	mov	ecx, DWORD PTR -9056+[ebp]
	mov	DWORD PTR -9060+[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR -9060+[ebp]
	push	edx
	lea	eax, DWORD PTR _meshDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1352]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+24]
	mov	BYTE PTR _status$[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T51873[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 737  : 
; 738  : 	delete [] verts;

	mov	eax, DWORD PTR _verts$[ebp]
	mov	DWORD PTR $T51874[ebp], eax
	mov	ecx, DWORD PTR $T51874[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 739  : 	delete [] m_verts;

	mov	edx, DWORD PTR _m_verts$[ebp]
	mov	DWORD PTR $T51875[ebp], edx
	mov	eax, DWORD PTR $T51875[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 740  : 	delete [] indices;

	mov	ecx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR $T51876[ebp], ecx
	mov	edx, DWORD PTR $T51876[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 741  : 
; 742  : 	if( !status )

	mov	eax, DWORD PTR _status$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L49547

; 744  : 		ALERT( at_error, "failed to create convex mesh from %s\n", smodel->name );

	mov	ecx, DWORD PTR _smodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 745  : 		return NULL;

	xor	eax, eax
	jmp	$L49411
$L49547:

; 747  : 
; 748  : 	pHull = m_pPhysics->createConvexMesh( UserStream( szHullFilename, true ));

	push	1
	lea	edx, DWORD PTR _szHullFilename$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T51877[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -9064+[ebp], eax
	mov	eax, DWORD PTR -9064+[ebp]
	mov	DWORD PTR -9068+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR -9068+[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+72]
	mov	DWORD PTR _pHull$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T51877[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 749  : 	if( !pHull ) ALERT( at_error, "failed to create convex mesh from %s\n", smodel->name );

	cmp	DWORD PTR _pHull$[ebp], 0
	jne	SHORT $L49549
	mov	ecx, DWORD PTR _smodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CG@IDLA@failed?5to?5create?5convex?5mesh?5fro@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49549:

; 750  : 
; 751  : 	return pHull;

	mov	eax, DWORD PTR _pHull$[ebp]
$L49411:

; 752  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$0:
	lea	ecx, DWORD PTR $T51857[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$1:
	mov	eax, DWORD PTR $T51864[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$2:
	mov	eax, DWORD PTR $T51868[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$3:
	lea	ecx, DWORD PTR $T51873[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__unwindfunclet$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z$4:
	lea	ecx, DWORD PTR $T51877[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__ehhandler$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z ENDP ; CPhysicNovodex::ConvexMeshFromStudio
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z
_TEXT	SEGMENT
_this$ = -4
_origin$ = 8
_quaternion$ = 12
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z PROC NEAR	; matrix3x4::matrix3x4, COMDAT

; 461  : 	_forceinline matrix3x4( const Vector &origin, const Vector4D &quaternion )

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 462  : 	{
; 463  : 		mat[0][0] = 1.0f - 2.0f * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);

	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR [ecx+8]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [eax], edx

; 464  : 		mat[1][0] = 2.0f * (quaternion.x * quaternion.y - quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -12+[ebp]
	mov	DWORD PTR [eax], ecx

; 465  : 		mat[2][0] = 2.0f * (quaternion.x * quaternion.z + quaternion.y * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+12]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -16+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -16+[ebp]
	mov	DWORD PTR [eax], ecx

; 466  : 		mat[3][0] = origin[0];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 467  : 		mat[0][1] = 2.0f * (quaternion.x * quaternion.y + quaternion.z * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [eax+12]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -20+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -20+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 468  : 		mat[1][1] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -24+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 469  : 		mat[2][1] = 2.0f * (quaternion.y * quaternion.z - quaternion.x * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+12]
	fsubp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -28+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -28+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 470  : 		mat[3][1] = origin[1];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx

; 471  : 		mat[0][2] = 2.0f * (quaternion.x * quaternion.z - quaternion.y * quaternion.w);

	mov	eax, DWORD PTR _quaternion$[ebp]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+12]
	fsubp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -32+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 472  : 		mat[1][2] = 2.0f * (quaternion.y * quaternion.z + quaternion.x * quaternion.w);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR [edx+12]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 473  : 		mat[2][2] = 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);

	mov	edx, DWORD PTR _quaternion$[ebp]
	mov	eax, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _quaternion$[ebp]
	mov	edx, DWORD PTR _quaternion$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	fadd	ST(0), ST(0)
	fsubr	DWORD PTR __real@4@3fff8000000000000000
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 474  : 		mat[3][2] = origin[2];

	mov	ecx, DWORD PTR _origin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], edx

; 475  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ENDP	; matrix3x4::matrix3x4
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@ABV0@@Z			; Vector4D::Vector4D
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S7$ = -8
_$S8$ = -12
_$S9$ = -16
??0matrix4x4@@QAE@ABV0@@Z PROC NEAR			; matrix4x4::matrix4x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S7$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S9$[ebp], ecx
$L26166:
	mov	edx, DWORD PTR _$S9$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S8$[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D
	mov	eax, DWORD PTR _$S8$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR _$S9$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _$S9$[ebp], ecx
	mov	edx, DWORD PTR _$S7$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S7$[ebp], edx
	cmp	DWORD PTR _$S7$[ebp], 0
	ja	SHORT $L26166
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABV0@@Z ENDP				; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector4D@@QAE@ABV0@@Z PROC NEAR			; Vector4D::Vector4D, COMDAT

; 313  : 	inline Vector4D( const Vector4D& v ) { x = v.x; y = v.y; z = v.z, w = v.w; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABV0@@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT
_$E32	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E32	ENDP
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT
_$E31	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E31	ENDP
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
PUBLIC	?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::TriangleMeshFromStudio
PUBLIC	?MeshNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z	; CPhysicNovodex::MeshNameForModel
PUBLIC	??_C@_0CM@MCNP@TriangleMeshFromStudio?3?5not?5a?5st@ ; `string'
PUBLIC	??_C@_0CK@DKKI@TriangleMeshFromStudio?3?5bad?5mode@ ; `string'
PUBLIC	??_C@_0DC@OOBA@Triangle?5mesh?5for?5?$CFs?5is?5corrupte@ ; `string'
PUBLIC	??_C@_0DE@IGIH@Triangle?5mesh?5for?5?$CFs?5is?5out?5of?5D@ ; `string'
PUBLIC	??_C@_0DI@GABK@TriangleMeshFromStudio?3?5bad?5sequ@ ; `string'
PUBLIC	??0matrix3x4@@QAE@ABVVector@@00@Z		; matrix3x4::matrix3x4
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
_BSS	SEGMENT
_?pos@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector@@A DB 0600H DUP (?)
_?$S35@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4EA DB 01H DUP (?)
	ALIGN	4

_?q@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A DB 0800H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CM@MCNP@TriangleMeshFromStudio?3?5not?5a?5st@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CM@MCNP@TriangleMeshFromStudio?3?5not?5a?5st@ DB 'TriangleMeshFrom'
	DB	'Studio: not a studio model', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DKKI@TriangleMeshFromStudio?3?5bad?5mode@
CONST	SEGMENT
??_C@_0CK@DKKI@TriangleMeshFromStudio?3?5bad?5mode@ DB 'TriangleMeshFromS'
	DB	'tudio: bad model header', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@OOBA@Triangle?5mesh?5for?5?$CFs?5is?5corrupte@
CONST	SEGMENT
??_C@_0DC@OOBA@Triangle?5mesh?5for?5?$CFs?5is?5corrupte@ DB 'Triangle mes'
	DB	'h for %s is corrupted. Rebuilding...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@IGIH@Triangle?5mesh?5for?5?$CFs?5is?5out?5of?5D@
CONST	SEGMENT
??_C@_0DE@IGIH@Triangle?5mesh?5for?5?$CFs?5is?5out?5of?5D@ DB 'Triangle m'
	DB	'esh for %s is out of Date. Rebuilding...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@GABK@TriangleMeshFromStudio?3?5bad?5sequ@
CONST	SEGMENT
??_C@_0DI@GABK@TriangleMeshFromStudio?3?5bad?5sequ@ DB 'TriangleMeshFromS'
	DB	'tudio: bad sequence group (must be 0)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z DD 019930520H
	DD	05H
	DD	FLAT:__unwindtable$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$4
xdata$x	ENDS
;	COMDAT ?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
_TEXT	SEGMENT
_pev$ = 8
_modelindex$ = 12
_this$ = -16
_smodel$ = -20
_phdr$ = -24
_solidMeshes$ = -28
_ptexture$ = -32
_i$ = -36
_szMeshFilename$ = -296
_pMesh$ = -300
_pseqdesc$ = -304
_pseqgroup$ = -308
_panim$ = -312
_pbone$ = -316
_transform$ = -380
_bonematrix$ = -444
_bonetransform$ = -8636
_pbodypart$ = -8640
_psubmodel$ = -8644
_pstudioverts$ = -8648
_m_verts$ = -8652
_$S38$ = -8656
_pvertbone$ = -8660
_verts$ = -8664
_$S39$ = -8668
_indices$ = -8672
_numVerts$ = -8676
_numElems$ = -8680
_tmp$ = -8692
_pskinref$ = -8696
_j$ = -8700
_pmesh$49679 = -8704
_ptricmds$49682 = -8708
_vertexState$49690 = -8712
_tri_strip$49691 = -8716
_meshDesc$ = -8768
_status$ = -8772
$T51908 = -8796
$T51909 = -8844
$T51910 = -8892
$T51911 = -8896
$T51912 = -8960
$T51913 = -8964
$T51914 = -9028
$T51915 = -9032
$T51916 = -9036
$T51919 = -9040
$T51920 = -9044
$T51923 = -9048
$T51924 = -9060
$T51925 = -9084
$T51926 = -9088
$T51927 = -9092
$T51928 = -9096
$T51929 = -9120
__$EHRec$ = -12
?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z PROC NEAR ; CPhysicNovodex::TriangleMeshFromStudio, COMDAT

; 755  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	mov	eax, 9204				; 000023f4H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 756  : 	if( UTIL_GetModelType( modelindex ) != mod_studio )

	mov	eax, DWORD PTR _modelindex$[ebp]
	push	eax
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	cmp	eax, 3
	je	SHORT $L49557

; 758  : 		ALERT( at_error, "TriangleMeshFromStudio: not a studio model\n" );

	push	OFFSET FLAT:??_C@_0CM@MCNP@TriangleMeshFromStudio?3?5not?5a?5st@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 759  : 		return NULL;

	xor	eax, eax
	jmp	$L49556
$L49557:

; 761  : 
; 762  : 	model_t *smodel = (model_t *)MODEL_HANDLE( modelindex );

	mov	ecx, DWORD PTR _modelindex$[ebp]
	push	ecx
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _smodel$[ebp], eax

; 763  : 	studiohdr_t *phdr = (studiohdr_t *)smodel->cache.data;

	mov	edx, DWORD PTR _smodel$[ebp]
	mov	eax, DWORD PTR [edx+388]
	mov	DWORD PTR _phdr$[ebp], eax

; 764  : 	int solidMeshes = 0;

	mov	DWORD PTR _solidMeshes$[ebp], 0

; 765  : 
; 766  : 	if( !phdr || phdr->numbones < 1 )

	cmp	DWORD PTR _phdr$[ebp], 0
	je	SHORT $L49565
	mov	ecx, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [ecx+140], 1
	jge	SHORT $L49564
$L49565:

; 768  : 		ALERT( at_error, "TriangleMeshFromStudio: bad model header\n" );

	push	OFFSET FLAT:??_C@_0CK@DKKI@TriangleMeshFromStudio?3?5bad?5mode@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 769  : 		return NULL;

	xor	eax, eax
	jmp	$L49556
$L49564:

; 771  : 
; 772  : 	mstudiotexture_t *ptexture = (mstudiotexture_t *)((byte *)phdr + phdr->textureindex);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+184]
	mov	DWORD PTR _ptexture$[ebp], eax

; 773  : 
; 774  : 	for( int i = 0; i < phdr->numtextures; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49571
$L49572:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L49571:
	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+180]
	jge	SHORT $L49573

; 776  : 		// skip this mesh it's probably foliage or somewhat
; 777  : 		if( ptexture[i].flags & STUDIO_NF_MASKED )

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 80					; 00000050H
	mov	edx, DWORD PTR _ptexture$[ebp]
	mov	eax, DWORD PTR [edx+ecx+64]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L49574

; 778  : 			continue;

	jmp	SHORT $L49572
$L49574:

; 779  : 		solidMeshes++;

	mov	ecx, DWORD PTR _solidMeshes$[ebp]
	add	ecx, 1
	mov	DWORD PTR _solidMeshes$[ebp], ecx

; 780  : 	}

	jmp	SHORT $L49572
$L49573:

; 781  : 
; 782  : 	// model is non-solid
; 783  : 	if( !solidMeshes )

	cmp	DWORD PTR _solidMeshes$[ebp], 0
	jne	SHORT $L49575

; 785  : 		m_fDisableWarning = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+276], 1

; 786  : 		return NULL;

	xor	eax, eax
	jmp	$L49556
$L49575:

; 790  : 	NxTriangleMesh *pMesh = NULL;

	mov	DWORD PTR _pMesh$[ebp], 0

; 791  : 
; 792  : 	MeshNameForModel( smodel->name, szMeshFilename, sizeof( szMeshFilename ));

	push	260					; 00000104H
	lea	eax, DWORD PTR _szMeshFilename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _smodel$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MeshNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z ; CPhysicNovodex::MeshNameForModel

; 793  : 
; 794  : 	if( CheckFileTimes( smodel->name, szMeshFilename ) && !m_fWorldChanged )

	lea	edx, DWORD PTR _szMeshFilename$[ebp]
	push	edx
	mov	eax, DWORD PTR _smodel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckFileTimes@CPhysicNovodex@@AAEHPBD0@Z ; CPhysicNovodex::CheckFileTimes
	test	eax, eax
	je	$L49578
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+280], 0
	jne	$L49578

; 796  : 		// hull is never than studiomodel. Trying to load it
; 797  : 		pMesh = m_pPhysics->createTriangleMesh( UserStream( szMeshFilename, true ));

	push	1
	lea	edx, DWORD PTR _szMeshFilename$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T51908[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -9124+[ebp], eax
	mov	eax, DWORD PTR -9124+[ebp]
	mov	DWORD PTR -9128+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR -9128+[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+32]
	mov	DWORD PTR _pMesh$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T51908[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 798  : 
; 799  : 		if( !pMesh )

	cmp	DWORD PTR _pMesh$[ebp], 0
	jne	SHORT $L49580

; 801  : 			// we failed to loading existed hull and can't cooking new :(
; 802  : 			if( m_pCooking == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1352], 0
	jne	SHORT $L49581

; 803  : 				return NULL; // don't spam console about missed nxCooking.dll

	xor	eax, eax
	jmp	$L49556
$L49581:

; 804  : 
; 805  : 			// trying to rebuild hull
; 806  : 			ALERT( at_error, "Triangle mesh for %s is corrupted. Rebuilding...\n", smodel->name );

	mov	edx, DWORD PTR _smodel$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0DC@OOBA@Triangle?5mesh?5for?5?$CFs?5is?5corrupte@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 808  : 		else

	jmp	SHORT $L49583
$L49580:

; 810  : 			// all is ok
; 811  : 			return pMesh;

	mov	eax, DWORD PTR _pMesh$[ebp]
	jmp	$L49556
$L49583:

; 814  : 	else

	jmp	SHORT $L49584
$L49578:

; 816  : 		// can't cooking new hull because nxCooking.dll is missed
; 817  : 		if( m_pCooking == NULL )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1352], 0
	jne	SHORT $L49585

; 818  : 			return NULL; // don't spam console about missed nxCooking.dll

	xor	eax, eax
	jmp	$L49556
$L49585:

; 819  : 
; 820  : 		// trying to rebuild hull
; 821  : 		ALERT( at_console, "Triangle mesh for %s is out of Date. Rebuilding...\n", smodel->name );

	mov	ecx, DWORD PTR _smodel$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DE@IGIH@Triangle?5mesh?5for?5?$CFs?5is?5out?5of?5D@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49584:

; 823  : 
; 824  : 	// at this point nxCooking instance is always valid
; 825  : 
; 826  : 	// compute default pose for building mesh from
; 827  : 	mstudioseqdesc_t *pseqdesc = (mstudioseqdesc_t *)((byte *)phdr + phdr->seqindex);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+168]
	mov	DWORD PTR _pseqdesc$[ebp], eax

; 828  : 	mstudioseqgroup_t *pseqgroup = (mstudioseqgroup_t *)((byte *)phdr + phdr->seqgroupindex) + pseqdesc->seqgroup;

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+176]
	mov	eax, DWORD PTR _pseqdesc$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	imul	ecx, 104				; 00000068H
	add	edx, ecx
	mov	DWORD PTR _pseqgroup$[ebp], edx

; 829  : 
; 830  : 	// sanity check
; 831  : 	if( pseqdesc->seqgroup != 0 )

	mov	edx, DWORD PTR _pseqdesc$[ebp]
	cmp	DWORD PTR [edx+156], 0
	je	SHORT $L49593

; 833  : 		ALERT( at_error, "TriangleMeshFromStudio: bad sequence group (must be 0)\n" );

	push	OFFSET FLAT:??_C@_0DI@GABK@TriangleMeshFromStudio?3?5bad?5sequ@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 834  : 		return NULL;

	xor	eax, eax
	jmp	$L49556
$L49593:

; 836  : 
; 837  : 	mstudioanim_t *panim = (mstudioanim_t *)((byte *)phdr + pseqgroup->data + pseqdesc->animindex);

	mov	eax, DWORD PTR _pseqgroup$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _pseqdesc$[ebp]
	add	ecx, DWORD PTR [edx+124]
	mov	DWORD PTR _panim$[ebp], ecx

; 838  : 	mstudiobone_t *pbone = (mstudiobone_t *)((byte *)phdr + phdr->boneindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR _pbone$[ebp], ecx

; 839  : 	static Vector pos[MAXSTUDIOBONES];

	xor	edx, edx
	mov	dl, BYTE PTR _?$S35@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4EA
	and	edx, 1
	test	edx, edx
	jne	SHORT $L49605
	mov	al, BYTE PTR _?$S35@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4EA
	or	al, 1
	mov	BYTE PTR _?$S35@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4EA, al
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	128					; 00000080H
	push	12					; 0000000cH
	push	OFFSET FLAT:_?pos@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E36
	call	_atexit
	add	esp, 4
$L49605:

; 840  : 	static Vector4D q[MAXSTUDIOBONES];

	xor	ecx, ecx
	mov	cl, BYTE PTR _?$S35@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4EA
	and	ecx, 2
	test	ecx, ecx
	jne	SHORT $L49610
	mov	dl, BYTE PTR _?$S35@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4EA
	or	dl, 2
	mov	BYTE PTR _?$S35@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4EA, dl
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	128					; 00000080H
	push	16					; 00000010H
	push	OFFSET FLAT:_?q@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:_$E37
	call	_atexit
	add	esp, 4
$L49610:

; 841  : 
; 842  : 	for( i = 0; i < phdr->numbones; i++, pbone++, panim++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49613
$L49614:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _pbone$[ebp]
	add	ecx, 112				; 00000070H
	mov	DWORD PTR _pbone$[ebp], ecx
	mov	edx, DWORD PTR _panim$[ebp]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _panim$[ebp], edx
$L49613:
	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+140]
	jge	SHORT $L49615

; 844  : 		StudioCalcBoneQuaterion( pbone, panim, q[i] );

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	add	edx, OFFSET FLAT:_?q@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A
	push	edx
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbone$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioCalcBoneQuaterion@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector4D@@@Z ; CPhysicNovodex::StudioCalcBoneQuaterion

; 845  : 		StudioCalcBonePosition( pbone, panim, pos[i] );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, OFFSET FLAT:_?pos@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector@@A
	push	edx
	mov	eax, DWORD PTR _panim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbone$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioCalcBonePosition@CPhysicNovodex@@AAEXPAUmstudiobone_t@@PAUmstudioanim_t@@AAVVector@@@Z ; CPhysicNovodex::StudioCalcBonePosition

; 846  : 	}

	jmp	SHORT $L49614
$L49615:

; 847  : 
; 848  : 	pbone = (mstudiobone_t *)((byte *)phdr + phdr->boneindex);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _pbone$[ebp], eax

; 849  : 	matrix4x4	transform, bonematrix, bonetransform[MAXSTUDIOBONES];

	lea	ecx, DWORD PTR _transform$[ebp]
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	push	OFFSET FLAT:??0matrix4x4@@QAE@XZ	; matrix4x4::matrix4x4
	push	128					; 00000080H
	push	64					; 00000040H
	lea	ecx, DWORD PTR _bonetransform$[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 850  : 
; 851  : 	if( pev->startpos != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pev$[ebp]
	add	ecx, 140				; 0000008cH
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L49622

; 852  : 		transform = matrix3x4( g_vecZero, g_vecZero, pev->startpos );

	mov	edx, DWORD PTR _pev$[ebp]
	add	edx, 140				; 0000008cH
	push	edx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR $T51909[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@00@Z	; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _transform$[ebp]
	call	??4matrix4x4@@QAEAAV0@ABVmatrix3x4@@@Z	; matrix4x4::operator=

; 853  : 	else transform.Identity();

	jmp	SHORT $L49624
$L49622:
	lea	ecx, DWORD PTR _transform$[ebp]
	call	?Identity@matrix4x4@@QAEXXZ		; matrix4x4::Identity
$L49624:

; 854  : 
; 855  : 	// compute bones for default anim
; 856  : 	for( i = 0; i < phdr->numbones; i++ ) 

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49625
$L49626:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L49625:
	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+140]
	jge	$L49627

; 858  : 		// initialize bonematrix
; 859  : 		bonematrix = matrix3x4( pos[i], q[i] );

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	add	eax, OFFSET FLAT:_?q@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector4D@@A
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, OFFSET FLAT:_?pos@?CA@??TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z@4PAVVector@@A
	push	ecx
	lea	ecx, DWORD PTR $T51910[ebp]
	call	??0matrix3x4@@QAE@ABVVector@@ABVVector4D@@@Z ; matrix3x4::matrix3x4
	push	eax
	lea	ecx, DWORD PTR _bonematrix$[ebp]
	call	??4matrix4x4@@QAEAAV0@ABVmatrix3x4@@@Z	; matrix4x4::operator=

; 860  : 
; 861  : 		if( pbone[i].parent == -1 ) 

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 112				; 00000070H
	mov	eax, DWORD PTR _pbone$[ebp]
	cmp	DWORD PTR [eax+edx+32], -1
	jne	SHORT $L49629

; 862  : 			bonetransform[i] = transform.ConcatTransforms( bonematrix );

	sub	esp, 64					; 00000040H
	mov	ecx, esp
	mov	DWORD PTR $T51911[ebp], esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T51912[ebp]
	push	eax
	lea	ecx, DWORD PTR _transform$[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+ecx]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 863  : 		else bonetransform[i] = bonetransform[pbone[i].parent].ConcatTransforms( bonematrix );

	jmp	SHORT $L49632
$L49629:
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	mov	DWORD PTR $T51913[ebp], esp
	lea	edx, DWORD PTR _bonematrix$[ebp]
	push	edx
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	eax, DWORD PTR $T51914[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _pbone$[ebp]
	mov	eax, DWORD PTR [edx+ecx+32]
	shl	eax, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+eax]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+ecx]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=
$L49632:

; 864  : 	}

	jmp	$L49626
$L49627:

; 865  : 
; 866  : 	mstudiobodyparts_t *pbodypart = (mstudiobodyparts_t *)((byte *)phdr + phdr->bodypartindex);

	mov	edx, DWORD PTR _phdr$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+208]
	mov	DWORD PTR _pbodypart$[ebp], eax

; 867  : 	mstudiomodel_t *psubmodel = (mstudiomodel_t *)((byte *)phdr + pbodypart->modelindex);

	mov	ecx, DWORD PTR _pbodypart$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR _psubmodel$[ebp], edx

; 868  : 	Vector *pstudioverts = (Vector *)((byte *)phdr + psubmodel->vertindex);

	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR _pstudioverts$[ebp], ecx

; 869  : 	Vector *m_verts = new Vector[psubmodel->numverts];

	mov	edx, DWORD PTR _psubmodel$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR _$S38$[ebp], eax
	mov	ecx, DWORD PTR _$S38$[ebp]
	imul	ecx, 12					; 0000000cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51916[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T51916[ebp], 0
	je	SHORT $L51917
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	mov	edx, DWORD PTR _$S38$[ebp]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T51916[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR $T51916[ebp]
	mov	DWORD PTR -9132+[ebp], ecx
	jmp	SHORT $L51918
$L51917:
	mov	DWORD PTR -9132+[ebp], 0
$L51918:
	mov	edx, DWORD PTR -9132+[ebp]
	mov	DWORD PTR $T51915[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T51915[ebp]
	mov	DWORD PTR _m_verts$[ebp], eax

; 870  : 	byte *pvertbone = ((byte *)phdr + psubmodel->vertinfoindex);

	mov	ecx, DWORD PTR _psubmodel$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR _pvertbone$[ebp], edx

; 871  : 	Vector *verts = new Vector[psubmodel->numverts * 8];	// allocate temporary vertices array

	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	shl	ecx, 3
	mov	DWORD PTR _$S39$[ebp], ecx
	mov	edx, DWORD PTR _$S39$[ebp]
	imul	edx, 12					; 0000000cH
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51920[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T51920[ebp], 0
	je	SHORT $L51921
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	mov	eax, DWORD PTR _$S39$[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T51920[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	edx, DWORD PTR $T51920[ebp]
	mov	DWORD PTR -9136+[ebp], edx
	jmp	SHORT $L51922
$L51921:
	mov	DWORD PTR -9136+[ebp], 0
$L51922:
	mov	eax, DWORD PTR -9136+[ebp]
	mov	DWORD PTR $T51919[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T51919[ebp]
	mov	DWORD PTR _verts$[ebp], ecx

; 872  : 	NxU32 *indices = new NxU32[psubmodel->numverts * 24];

	mov	edx, DWORD PTR _psubmodel$[ebp]
	mov	eax, DWORD PTR [edx+80]
	imul	eax, 24					; 00000018H
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T51923[ebp], eax
	mov	ecx, DWORD PTR $T51923[ebp]
	mov	DWORD PTR _indices$[ebp], ecx

; 873  : 	int numVerts = 0, numElems = 0;

	mov	DWORD PTR _numVerts$[ebp], 0
	mov	DWORD PTR _numElems$[ebp], 0

; 874  : 	Vector tmp;

	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 875  : 
; 876  : 	// setup all the vertices
; 877  : 	for( i = 0; i < psubmodel->numverts; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49666
$L49667:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L49666:
	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jge	SHORT $L49668

; 878  : 		m_verts[i] = bonetransform[pvertbone[i]].VectorTransform( pstudioverts[i] );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pstudioverts$[ebp]
	add	eax, edx
	push	eax
	lea	ecx, DWORD PTR $T51924[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvertbone$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx]
	shl	eax, 6
	lea	ecx, DWORD PTR _bonetransform$[ebp+eax]
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _m_verts$[ebp]
	add	edx, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	jmp	SHORT $L49667
$L49668:

; 879  : 
; 880  : 	ptexture = (mstudiotexture_t *)((byte *)phdr + phdr->textureindex);

	mov	ecx, DWORD PTR _phdr$[ebp]
	mov	edx, DWORD PTR _phdr$[ebp]
	add	edx, DWORD PTR [ecx+184]
	mov	DWORD PTR _ptexture$[ebp], edx

; 881  : 	short *pskinref = (short *)((byte *)phdr + phdr->skinindex);

	mov	eax, DWORD PTR _phdr$[ebp]
	mov	ecx, DWORD PTR _phdr$[ebp]
	add	ecx, DWORD PTR [eax+200]
	mov	DWORD PTR _pskinref$[ebp], ecx

; 882  : 
; 883  : 	for( int j = 0; j < psubmodel->nummesh; j++ ) 

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L49676
$L49677:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L49676:
	mov	eax, DWORD PTR _psubmodel$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jge	$L49678

; 885  : 		mstudiomesh_t *pmesh = (mstudiomesh_t *)((byte *)phdr + psubmodel->meshindex) + j;

	mov	edx, DWORD PTR _psubmodel$[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _j$[ebp]
	imul	ecx, 20					; 00000014H
	add	eax, ecx
	mov	DWORD PTR _pmesh$49679[ebp], eax

; 886  : 		short *ptricmds = (short *)((byte *)phdr + pmesh->triindex);

	mov	edx, DWORD PTR _pmesh$49679[ebp]
	mov	eax, DWORD PTR _phdr$[ebp]
	add	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ptricmds$49682[ebp], eax

; 887  : 
; 888  : 		if( phdr->numtextures != 0 && phdr->textureindex != 0 )

	mov	ecx, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [ecx+180], 0
	je	SHORT $L49686
	mov	edx, DWORD PTR _phdr$[ebp]
	cmp	DWORD PTR [edx+184], 0
	je	SHORT $L49686

; 890  : 			// skip this mesh it's probably foliage or somewhat
; 891  : 			if( ptexture[pskinref[pmesh->skinref]].flags & STUDIO_NF_MASKED )

	mov	eax, DWORD PTR _pmesh$49679[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pskinref$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2]
	imul	eax, 80					; 00000050H
	mov	ecx, DWORD PTR _ptexture$[ebp]
	mov	edx, DWORD PTR [ecx+eax+64]
	and	edx, 64					; 00000040H
	test	edx, edx
	je	SHORT $L49686

; 892  : 				continue;

	jmp	$L49677
$L49686:

; 894  : 
; 895  : 		while( i = *( ptricmds++ ))

	mov	eax, DWORD PTR _ptricmds$49682[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _ptricmds$49682[ebp]
	add	eax, 2
	mov	DWORD PTR _ptricmds$49682[ebp], eax
	test	edx, edx
	je	$L49689

; 897  : 			int	vertexState = 0;

	mov	DWORD PTR _vertexState$49690[ebp], 0

; 898  : 			qboolean	tri_strip;
; 899  : 
; 900  : 			if( i < 0 )

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $L49692

; 902  : 				tri_strip = false;

	mov	DWORD PTR _tri_strip$49691[ebp], 0

; 903  : 				i = -i;

	mov	ecx, DWORD PTR _i$[ebp]
	neg	ecx
	mov	DWORD PTR _i$[ebp], ecx

; 905  : 			else

	jmp	SHORT $L49693
$L49692:

; 906  : 				tri_strip = true;

	mov	DWORD PTR _tri_strip$49691[ebp], 1
$L49693:

; 907  : 
; 908  : 			for( ; i > 0; i--, ptricmds += 4 )

	jmp	SHORT $L49694
$L49695:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	mov	eax, DWORD PTR _ptricmds$49682[ebp]
	add	eax, 8
	mov	DWORD PTR _ptricmds$49682[ebp], eax
$L49694:
	cmp	DWORD PTR _i$[ebp], 0
	jle	$L49696

; 910  : 				// build in indices
; 911  : 				if( vertexState++ < 3 )

	mov	ecx, DWORD PTR _vertexState$49690[ebp]
	mov	edx, DWORD PTR _vertexState$49690[ebp]
	add	edx, 1
	mov	DWORD PTR _vertexState$49690[ebp], edx
	cmp	ecx, 3
	jge	SHORT $L49697

; 913  : 					indices[numElems++] = numVerts;

	mov	eax, DWORD PTR _numElems$[ebp]
	mov	ecx, DWORD PTR _indices$[ebp]
	mov	edx, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 915  : 				else if( tri_strip )

	jmp	$L49702
$L49697:
	cmp	DWORD PTR _tri_strip$49691[ebp], 0
	je	$L49699

; 917  : 					// flip triangles between clockwise and counter clockwise
; 918  : 					if( vertexState & 1 )

	mov	ecx, DWORD PTR _vertexState$49690[ebp]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L49700

; 920  : 						// draw triangle [n-2 n-1 n]
; 921  : 						indices[numElems++] = numVerts - 2;

	mov	edx, DWORD PTR _numVerts$[ebp]
	sub	edx, 2
	mov	eax, DWORD PTR _numElems$[ebp]
	mov	ecx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	edx, DWORD PTR _numElems$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElems$[ebp], edx

; 922  : 						indices[numElems++] = numVerts - 1;

	mov	eax, DWORD PTR _numVerts$[ebp]
	sub	eax, 1
	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 923  : 						indices[numElems++] = numVerts;

	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	eax, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _numElems$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numElems$[ebp], ecx

; 925  : 					else

	jmp	SHORT $L49701
$L49700:

; 927  : 						// draw triangle [n-1 n-2 n]
; 928  : 						indices[numElems++] = numVerts - 1;

	mov	edx, DWORD PTR _numVerts$[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _numElems$[ebp]
	mov	ecx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	edx, DWORD PTR _numElems$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElems$[ebp], edx

; 929  : 						indices[numElems++] = numVerts - 2;

	mov	eax, DWORD PTR _numVerts$[ebp]
	sub	eax, 2
	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 930  : 						indices[numElems++] = numVerts;

	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	eax, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _numElems$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numElems$[ebp], ecx
$L49701:

; 933  : 				else

	jmp	SHORT $L49702
$L49699:

; 935  : 					// draw triangle fan [0 n-1 n]
; 936  : 					indices[numElems++] = numVerts - ( vertexState - 1 );

	mov	edx, DWORD PTR _vertexState$49690[ebp]
	sub	edx, 1
	mov	eax, DWORD PTR _numVerts$[ebp]
	sub	eax, edx
	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 937  : 					indices[numElems++] = numVerts - 1;

	mov	ecx, DWORD PTR _numVerts$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _numElems$[ebp]
	mov	eax, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	ecx, DWORD PTR _numElems$[ebp]
	add	ecx, 1
	mov	DWORD PTR _numElems$[ebp], ecx

; 938  : 					indices[numElems++] = numVerts;

	mov	edx, DWORD PTR _numElems$[ebp]
	mov	eax, DWORD PTR _indices$[ebp]
	mov	ecx, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _numElems$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElems$[ebp], edx
$L49702:

; 940  : 
; 941  : 				verts[numVerts++] = m_verts[ptricmds[0]];

	mov	eax, DWORD PTR _ptricmds$49682[ebp]
	movsx	ecx, WORD PTR [eax]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _m_verts$[ebp]
	add	edx, ecx
	mov	eax, DWORD PTR _numVerts$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _verts$[ebp]
	add	ecx, eax
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _numVerts$[ebp]
	add	eax, 1
	mov	DWORD PTR _numVerts$[ebp], eax

; 942  : 			}

	jmp	$L49695
$L49696:

; 943  : 		}

	jmp	$L49686
$L49689:

; 944  : 	}

	jmp	$L49677
$L49678:

; 945  : 
; 946  : 	NxTriangleMeshDesc meshDesc;

	lea	ecx, DWORD PTR _meshDesc$[ebp]
	call	??0NxTriangleMeshDesc@@QAE@XZ		; NxTriangleMeshDesc::NxTriangleMeshDesc

; 947  : 	meshDesc.numTriangles = numElems / 3;

	mov	eax, DWORD PTR _numElems$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	mov	DWORD PTR _meshDesc$[ebp+4], eax

; 948  : 	meshDesc.pointStrideBytes = sizeof(Vector);

	mov	DWORD PTR _meshDesc$[ebp+8], 12		; 0000000cH

; 949  : 	meshDesc.triangleStrideBytes	= 3 * sizeof( NxU32 );

	mov	DWORD PTR _meshDesc$[ebp+12], 12	; 0000000cH

; 950  : 	meshDesc.points = verts;

	mov	edx, DWORD PTR _verts$[ebp]
	mov	DWORD PTR _meshDesc$[ebp+16], edx

; 951  : 	meshDesc.triangles = indices;

	mov	eax, DWORD PTR _indices$[ebp]
	mov	DWORD PTR _meshDesc$[ebp+20], eax

; 952  : 	meshDesc.numVertices = numVerts;

	mov	ecx, DWORD PTR _numVerts$[ebp]
	mov	DWORD PTR _meshDesc$[ebp], ecx

; 953  : 	meshDesc.flags = 0;

	mov	DWORD PTR _meshDesc$[ebp+24], 0

; 954  : 
; 955  : 	m_pCooking->NxInitCooking();

	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1352]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+12]

; 956  : 	bool status = m_pCooking->NxCookTriangleMesh( meshDesc, UserStream( szMeshFilename, false ));

	push	0
	lea	ecx, DWORD PTR _szMeshFilename$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T51925[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -9140+[ebp], eax
	mov	edx, DWORD PTR -9140+[ebp]
	mov	DWORD PTR -9144+[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR -9144+[ebp]
	push	eax
	lea	ecx, DWORD PTR _meshDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1352]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+20]
	mov	BYTE PTR _status$[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T51925[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 957  : 
; 958  : 	delete [] verts;

	mov	ecx, DWORD PTR _verts$[ebp]
	mov	DWORD PTR $T51926[ebp], ecx
	mov	edx, DWORD PTR $T51926[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 959  : 	delete [] m_verts;

	mov	eax, DWORD PTR _m_verts$[ebp]
	mov	DWORD PTR $T51927[ebp], eax
	mov	ecx, DWORD PTR $T51927[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 960  : 	delete [] indices;

	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR $T51928[ebp], edx
	mov	eax, DWORD PTR $T51928[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 961  : 
; 962  : 	if( !status )

	mov	ecx, DWORD PTR _status$[ebp]
	and	ecx, 255				; 000000ffH
	test	ecx, ecx
	jne	SHORT $L49711

; 964  : 		ALERT( at_error, "failed to create triangle mesh from %s\n", smodel->name );

	mov	edx, DWORD PTR _smodel$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 965  : 		return NULL;

	xor	eax, eax
	jmp	$L49556
$L49711:

; 967  : 
; 968  : 	pMesh = m_pPhysics->createTriangleMesh( UserStream( szMeshFilename, true ));

	push	1
	lea	eax, DWORD PTR _szMeshFilename$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T51929[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -9148+[ebp], eax
	mov	ecx, DWORD PTR -9148+[ebp]
	mov	DWORD PTR -9152+[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR -9152+[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+32]
	mov	DWORD PTR _pMesh$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T51929[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 969  : 	if( !pMesh ) ALERT( at_error, "failed to create triangle mesh from %s\n", smodel->name );

	cmp	DWORD PTR _pMesh$[ebp], 0
	jne	SHORT $L49713
	mov	eax, DWORD PTR _smodel$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CI@KDID@failed?5to?5create?5triangle?5mesh?5f@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49713:

; 970  : 
; 971  : 	return pMesh;

	mov	eax, DWORD PTR _pMesh$[ebp]
$L49556:

; 972  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$0:
	lea	ecx, DWORD PTR $T51908[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$1:
	mov	eax, DWORD PTR $T51916[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$2:
	mov	eax, DWORD PTR $T51920[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$3:
	lea	ecx, DWORD PTR $T51925[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__unwindfunclet$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z$4:
	lea	ecx, DWORD PTR $T51929[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__ehhandler$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z ENDP ; CPhysicNovodex::TriangleMeshFromStudio
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L51945
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L51945
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L51945
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L51946
$L51945:
	mov	DWORD PTR -8+[ebp], 0
$L51946:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
PUBLIC	__real@8@3ff98efa351294e9c800
;	COMDAT __real@8@3ff98efa351294e9c800
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABVVector@@00@Z
_TEXT	SEGMENT
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
_origin$ = 8
_angles$ = 12
_scale$ = 16
??0matrix3x4@@QAE@ABVVector@@00@Z PROC NEAR		; matrix3x4::matrix3x4, COMDAT

; 273  : 	_forceinline matrix3x4( const Vector &origin, const Vector &angles, const Vector &scale )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 274  : 	{
; 275  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 276  : 
; 277  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25655

; 279  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 280  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 281  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 282  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 283  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 284  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 285  : 
; 286  : 			mat[0][0] = (cp*cy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	mov	ecx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], edx

; 287  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale.y;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], ecx

; 288  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale.z;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 289  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 290  : 			mat[0][1] = (cp*sy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 291  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale.y;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 292  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale.z;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 293  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 294  : 			mat[0][2] = (-sp) * scale.x;

	fld	DWORD PTR _sp$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 295  : 			mat[1][2] = (sr*cp) * scale.y;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 			mat[2][2] = (cr*cp) * scale.z;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 297  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 299  : 		else if( angles[PITCH] )

	jmp	$L25660
$L25655:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25657

; 301  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 302  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 303  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 304  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 305  : 
; 306  : 			mat[0][0] = (cp*cy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], ecx

; 307  : 			mat[1][0] = (-sy) * scale.y;

	fld	DWORD PTR _sy$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 308  : 			mat[2][0] = (sp*cy) * scale.z;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], ecx

; 309  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 310  : 			mat[0][1] = (cp*sy) * scale.x;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 311  : 			mat[1][1] = (cy) * scale.y;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 312  : 			mat[2][1] = (sp*sy) * scale.z;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 313  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 314  : 			mat[0][2] = (-sp) * scale.x;

	fld	DWORD PTR _sp$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 315  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 316  : 			mat[2][2] = (cp) * scale.z;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 317  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 319  : 		else if( angles[YAW] )

	jmp	$L25660
$L25657:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25659

; 321  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 322  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 323  : 
; 324  : 			mat[0][0] = (cy) * scale.x;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], ecx

; 325  : 			mat[1][0] = (-sy) * scale.y;

	fld	DWORD PTR _sy$[ebp]
	fchs
	mov	edx, DWORD PTR _scale$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 326  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 327  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 328  : 			mat[0][1] = (sy) * scale.x;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR [edx]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 329  : 			mat[1][1] = (cy) * scale.y;

	mov	edx, DWORD PTR _scale$[ebp]
	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR [edx+4]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 330  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 331  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 332  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 333  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 334  : 			mat[2][2] = scale.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 335  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 337  : 		else

	jmp	$L25660
$L25659:

; 339  : 			mat[0][0] = scale.x;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 340  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 341  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 342  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 343  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 344  : 			mat[1][1] = scale.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 345  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 346  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 347  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 348  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 349  : 			mat[2][2] = scale.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 350  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
$L25660:

; 352  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix3x4@@QAE@ABVVector@@00@Z ENDP			; matrix3x4::matrix3x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT
_$E37	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E37	ENDP
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT
_$E36	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E36	ENDP
_TEXT	ENDS
PUBLIC	?ConvexMeshFromEntity@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ConvexMeshFromEntity
PUBLIC	??_C@_0DA@FBM@ConvexMeshFromEntity?3?5entity?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0DA@BLIM@ConvexMeshFromEntity?3?5?$CFi?5has?5mis@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
;	COMDAT ??_C@_0DA@FBM@ConvexMeshFromEntity?3?5entity?5?$CFs?5@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0DA@FBM@ConvexMeshFromEntity?3?5entity?5?$CFs?5@ DB 'ConvexMeshFrom'
	DB	'Entity: entity %s has NULL model', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BLIM@ConvexMeshFromEntity?3?5?$CFi?5has?5mis@
CONST	SEGMENT
??_C@_0DA@BLIM@ConvexMeshFromEntity?3?5?$CFi?5has?5mis@ DB 'ConvexMeshFro'
	DB	'mEntity: %i has missing collision', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?ConvexMeshFromEntity@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -4
_model$ = -8
_pCollision$ = -12
?ConvexMeshFromEntity@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::ConvexMeshFromEntity, COMDAT

; 975  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 976  : 	if( !pObject || !m_pPhysics )

	cmp	DWORD PTR _pObject$[ebp], 0
	je	SHORT $L49721
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L49720
$L49721:

; 977  : 		return NULL;

	xor	eax, eax
	jmp	$L49719
$L49720:

; 978  : 
; 979  : 	// check for bspmodel
; 980  : 	model_t *model = (model_t *)MODEL_HANDLE( pObject->pev->modelindex );

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 981  : 
; 982  : 	if( !model || model->type == mod_bad )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $L49725
	mov	ecx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [ecx+68], -1
	jne	SHORT $L49724
$L49725:

; 984  : 		ALERT( at_aiconsole, "ConvexMeshFromEntity: entity %s has NULL model\n", pObject->GetClassname( )); 

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0DA@FBM@ConvexMeshFromEntity?3?5entity?5?$CFs?5@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 985  : 		return NULL;

	xor	eax, eax
	jmp	$L49719
$L49724:

; 987  : 
; 988  : 	NxConvexMesh *pCollision = NULL;

	mov	DWORD PTR _pCollision$[ebp], 0

; 992  : 	{

	mov	edx, DWORD PTR _model$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 0
	je	SHORT $L49732
	cmp	DWORD PTR -16+[ebp], 3
	je	SHORT $L49733
	jmp	SHORT $L49729
$L49732:

; 993  : 	case mod_brush:
; 994  : 		pCollision = ConvexMeshFromBmodel( pObject->pev, pObject->pev->modelindex );	

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvexMeshFromBmodel@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::ConvexMeshFromBmodel
	mov	DWORD PTR _pCollision$[ebp], eax

; 995  : 		break;

	jmp	SHORT $L49729
$L49733:

; 996  : 	case mod_studio:
; 997  : 		pCollision = ConvexMeshFromStudio( pObject->pev, pObject->pev->modelindex );	

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	mov	eax, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvexMeshFromStudio@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::ConvexMeshFromStudio
	mov	DWORD PTR _pCollision$[ebp], eax
$L49729:

; 1000 : 
; 1001 : 	if( !pCollision && !m_fDisableWarning )

	cmp	DWORD PTR _pCollision$[ebp], 0
	jne	SHORT $L49734
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+276], 0
	jne	SHORT $L49734

; 1002 : 		ALERT( at_warning, "ConvexMeshFromEntity: %i has missing collision\n", pObject->pev->modelindex ); 

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	push	OFFSET FLAT:??_C@_0DA@BLIM@ConvexMeshFromEntity?3?5?$CFi?5has?5mis@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49734:

; 1003 : 	m_fDisableWarning = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+276], 0

; 1004 : 
; 1005 : 	return pCollision;

	mov	eax, DWORD PTR _pCollision$[ebp]
$L49719:

; 1006 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ConvexMeshFromEntity@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::ConvexMeshFromEntity
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
PUBLIC	?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z ; CPhysicNovodex::TriangleMeshFromEntity
PUBLIC	??_C@_0DC@CFEB@TriangleMeshFromEntity?3?5entity?5?$CF@ ; `string'
PUBLIC	??_C@_0DC@KHDF@TriangleMeshFromEntity?3?5?$CFs?5has?5m@ ; `string'
;	COMDAT ??_C@_0DC@CFEB@TriangleMeshFromEntity?3?5entity?5?$CF@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0DC@CFEB@TriangleMeshFromEntity?3?5entity?5?$CF@ DB 'TriangleMeshFr'
	DB	'omEntity: entity %s has NULL model', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KHDF@TriangleMeshFromEntity?3?5?$CFs?5has?5m@
CONST	SEGMENT
??_C@_0DC@KHDF@TriangleMeshFromEntity?3?5?$CFs?5has?5m@ DB 'TriangleMeshF'
	DB	'romEntity: %s has missing collision', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -4
_model$ = -8
_pCollision$ = -12
?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::TriangleMeshFromEntity, COMDAT

; 1009 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1010 : 	if( !pObject || !m_pPhysics )

	cmp	DWORD PTR _pObject$[ebp], 0
	je	SHORT $L49741
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L49740
$L49741:

; 1011 : 		return NULL;

	xor	eax, eax
	jmp	$L49739
$L49740:

; 1012 : 
; 1013 : 	// check for bspmodel
; 1014 : 	model_t *model = (model_t *)MODEL_HANDLE( pObject->pev->modelindex );

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	DWORD PTR _model$[ebp], eax

; 1015 : 
; 1016 : 	if( !model || model->type == mod_bad )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $L49745
	mov	ecx, DWORD PTR _model$[ebp]
	cmp	DWORD PTR [ecx+68], -1
	jne	SHORT $L49744
$L49745:

; 1018 : 		ALERT( at_aiconsole, "TriangleMeshFromEntity: entity %s has NULL model\n", pObject->GetClassname( )); 

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0DC@CFEB@TriangleMeshFromEntity?3?5entity?5?$CF@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1019 : 		return NULL;

	xor	eax, eax
	jmp	$L49739
$L49744:

; 1021 : 
; 1022 : 	NxTriangleMesh *pCollision = NULL;

	mov	DWORD PTR _pCollision$[ebp], 0

; 1026 : 	{

	mov	edx, DWORD PTR _model$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR -16+[ebp], eax
	cmp	DWORD PTR -16+[ebp], 0
	je	SHORT $L49752
	cmp	DWORD PTR -16+[ebp], 3
	je	SHORT $L49753
	jmp	SHORT $L49749
$L49752:

; 1027 : 	case mod_brush:
; 1028 : 		pCollision = TriangleMeshFromBmodel( pObject->pev, pObject->pev->modelindex );	

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TriangleMeshFromBmodel@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::TriangleMeshFromBmodel
	mov	DWORD PTR _pCollision$[ebp], eax

; 1029 : 		break;

	jmp	SHORT $L49749
$L49753:

; 1030 : 	case mod_studio:
; 1031 : 		pCollision = TriangleMeshFromStudio( pObject->pev, pObject->pev->modelindex );	

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	mov	eax, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TriangleMeshFromStudio@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAUentvars_s@@H@Z ; CPhysicNovodex::TriangleMeshFromStudio
	mov	DWORD PTR _pCollision$[ebp], eax
$L49749:

; 1034 : 
; 1035 : 	if( !pCollision && !m_fDisableWarning )

	cmp	DWORD PTR _pCollision$[ebp], 0
	jne	SHORT $L49754
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+276], 0
	jne	SHORT $L49754

; 1036 : 		ALERT( at_warning, "TriangleMeshFromEntity: %s has missing collision\n", pObject->GetClassname( )); 

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0DC@KHDF@TriangleMeshFromEntity?3?5?$CFs?5has?5m@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L49754:

; 1037 : 	m_fDisableWarning = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+276], 0

; 1038 : 
; 1039 : 	return pCollision;

	mov	eax, DWORD PTR _pCollision$[ebp]
$L49739:

; 1040 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::TriangleMeshFromEntity
_TEXT	ENDS
EXTRN	?FNullEnt@@YAHPAVCBaseEntity@@@Z:NEAR		; FNullEnt
;	COMDAT ?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -4
?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::ActorFromEntity, COMDAT

; 1043 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1044 : 	if( FNullEnt( pObject ) || !pObject->m_pUserData )

	mov	eax, DWORD PTR _pObject$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L49761
	mov	ecx, DWORD PTR _pObject$[ebp]
	cmp	DWORD PTR [ecx+244], 0
	jne	SHORT $L49760
$L49761:

; 1045 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L49759
$L49760:

; 1046 : #if defined (HAS_PHYSIC_VEHICLE)
; 1047 : 	if( pObject->m_iActorType == ACTOR_VEHICLE )
; 1048 : 	{
; 1049 : 		NxVehicle	*pVehicle = (NxVehicle *)pObject->m_pUserData;
; 1050 : 		return pVehicle->getActor();
; 1051 : 	}
; 1052 : #endif
; 1053 : 	return (NxActor *)pObject->m_pUserData;

	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx+244]
$L49759:

; 1054 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::ActorFromEntity
_TEXT	ENDS
PUBLIC	?EntityFromActor@CPhysicNovodex@@AAEPAVCBaseEntity@@PAVNxActor@@@Z ; CPhysicNovodex::EntityFromActor
;	COMDAT ?EntityFromActor@CPhysicNovodex@@AAEPAVCBaseEntity@@PAVNxActor@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -4
?EntityFromActor@CPhysicNovodex@@AAEPAVCBaseEntity@@PAVNxActor@@@Z PROC NEAR ; CPhysicNovodex::EntityFromActor, COMDAT

; 1057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1058 : 	if( !pObject || !pObject->userData )

	cmp	DWORD PTR _pObject$[ebp], 0
	je	SHORT $L49768
	mov	eax, DWORD PTR _pObject$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L49767
$L49768:

; 1059 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L49766
$L49767:

; 1060 : 
; 1061 : 	return CBaseEntity::Instance( (edict_t *)pObject->userData );

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
$L49766:

; 1062 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EntityFromActor@CPhysicNovodex@@AAEPAVCBaseEntity@@PAVNxActor@@@Z ENDP ; CPhysicNovodex::EntityFromActor
_TEXT	ENDS
PUBLIC	??0NxBodyDesc@@QAE@XZ				; NxBodyDesc::NxBodyDesc
PUBLIC	??1NxBodyDesc@@QAE@XZ				; NxBodyDesc::~NxBodyDesc
PUBLIC	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack
PUBLIC	??0matrix4x4@@QAE@ABVVector@@0M@Z		; matrix4x4::matrix4x4
PUBLIC	??0NxActorDesc@@QAE@XZ				; NxActorDesc::NxActorDesc
PUBLIC	??1NxActorDesc@@QAE@XZ				; NxActorDesc::~NxActorDesc
PUBLIC	?CopyToArray@matrix4x4@@QBEXPAM@Z		; matrix4x4::CopyToArray
PUBLIC	??_C@_0CL@HLHI@failed?5to?5create?5rigidbody?5from?5@ ; `string'
PUBLIC	??0NxConvexShapeDesc@@QAE@XZ			; NxConvexShapeDesc::NxConvexShapeDesc
PUBLIC	??1NxConvexShapeDesc@@UAE@XZ			; NxConvexShapeDesc::~NxConvexShapeDesc
PUBLIC	??0NxMat34@@QAE@_N@Z				; NxMat34::NxMat34
PUBLIC	?setColumnMajor44@NxMat34@@QAEXPBM@Z		; NxMat34::setColumnMajor44
PUBLIC	??1NxMat34@@QAE@XZ				; NxMat34::~NxMat34
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalVelocity
EXTRN	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAvelocity
;	COMDAT ??_C@_0CL@HLHI@failed?5to?5create?5rigidbody?5from?5@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CL@HLHI@failed?5to?5create?5rigidbody?5from?5@ DB 'failed to creat'
	DB	'e rigidbody from entity %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 019930520H
	DD	04H
	DD	FLAT:__unwindtable$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$3
xdata$x	ENDS
;	COMDAT ?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -16
_pCollision$ = -20
_BodyDesc$ = -156
_ActorDesc$ = -260
_meshShapeDesc$ = -376
_pActor$ = -380
_pose$ = -428
_mat$ = -492
$T51969 = -496
$T51970 = -500
$T51971 = -564
$T51972 = -576
$T51973 = -588
$T51974 = -592
__$EHRec$ = -12
?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::CreateBodyFromEntity, COMDAT

; 1065 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 644				; 00000284H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1066 : 	NxConvexMesh *pCollision = ConvexMeshFromEntity( pObject );

	mov	eax, DWORD PTR _pObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvexMeshFromEntity@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ConvexMeshFromEntity
	mov	DWORD PTR _pCollision$[ebp], eax

; 1067 : 	if( !pCollision ) return NULL;

	cmp	DWORD PTR _pCollision$[ebp], 0
	jne	SHORT $L49775
	xor	eax, eax
	jmp	$L49773
$L49775:

; 1068 : 
; 1069 : 	NxBodyDesc BodyDesc;

	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??0NxBodyDesc@@QAE@XZ			; NxBodyDesc::NxBodyDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1070 : 	NxActorDesc ActorDesc;

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??0NxActorDesc@@QAE@XZ			; NxActorDesc::NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1071 : 	NxConvexShapeDesc meshShapeDesc;

	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??0NxConvexShapeDesc@@QAE@XZ		; NxConvexShapeDesc::NxConvexShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1072 : 	BodyDesc.flags = NX_BF_VISUALIZATION|NX_BF_FILTER_SLEEP_VEL;

	mov	DWORD PTR _BodyDesc$[ebp+108], 1280	; 00000500H

; 1073 : 	BodyDesc.solverIterationCount = SOLVER_ITERATION_COUNT;

	mov	DWORD PTR _BodyDesc$[ebp+120], 16	; 00000010H

; 1074 : 
; 1075 : 	ActorDesc.body = &BodyDesc;

	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	mov	DWORD PTR _ActorDesc$[ebp+48], ecx

; 1076 : 	ActorDesc.density = DENSITY_FACTOR;

	mov	DWORD PTR _ActorDesc$[ebp+52], 984245443 ; 3aaa64c3H

; 1077 : 	ActorDesc.userData = pObject->edict();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ActorDesc$[ebp+72], eax

; 1078 : 
; 1079 : 	meshShapeDesc.meshData = pCollision;

	mov	edx, DWORD PTR _pCollision$[ebp]
	mov	DWORD PTR _meshShapeDesc$[ebp+108], edx

; 1080 : 	ActorDesc.shapes.pushBack( &meshShapeDesc );

	lea	eax, DWORD PTR _meshShapeDesc$[ebp]
	mov	DWORD PTR $T51969[ebp], eax
	lea	ecx, DWORD PTR $T51969[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 1081 : 	NxActor *pActor = m_pScene->createActor( ActorDesc );

	lea	edx, DWORD PTR _ActorDesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+28]
	mov	DWORD PTR _pActor$[ebp], eax

; 1082 : 
; 1083 : 	if( !pActor )

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49781

; 1085 : 		ALERT( at_error, "failed to create rigidbody from entity %s\n", pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CL@HLHI@failed?5to?5create?5rigidbody?5from?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1086 : 		return NULL;

	mov	DWORD PTR $T51970[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	eax, DWORD PTR $T51970[ebp]
	jmp	$L49773
$L49781:

; 1088 : 
; 1089 : 	pActor->setName( pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+12]

; 1090 : 
; 1091 : 	NxMat34 pose;

	push	1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1092 : 	float mat[16];
; 1093 : 	matrix4x4( pObject->GetAbsOrigin(), pObject->GetAbsAngles(), 1.0f ).CopyToArray( mat );

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T51971[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	mov	ecx, eax
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 1094 : 
; 1095 : 	pose.setColumnMajor44( mat );

	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?setColumnMajor44@NxMat34@@QAEXPBM@Z	; NxMat34::setColumnMajor44

; 1096 : 	pActor->setGlobalPose( pose );

	lea	edx, DWORD PTR _pose$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+20]

; 1097 : 	pActor->setLinearVelocity( pObject->GetLocalVelocity() );

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	push	eax
	lea	ecx, DWORD PTR $T51972[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T51972[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+224]

; 1098 : 	pActor->setAngularVelocity( pObject->GetLocalAvelocity() );

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR $T51973[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T51973[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+228]

; 1099 : 	pObject->m_iActorType = ACTOR_DYNAMIC;

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	BYTE PTR [eax+1604], 1

; 1100 : 	pObject->m_pUserData = pActor;

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR [ecx+244], edx

; 1101 : 
; 1102 : 	return pActor;

	mov	eax, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR $T51974[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	eax, DWORD PTR $T51974[ebp]
$L49773:

; 1103 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	ret	0
__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1:
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	ret	0
__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2:
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	ret	0
__unwindfunclet$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$3:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::CreateBodyFromEntity
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_origin$ = 8
_angles$ = 12
_scale$ = 16
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix4x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 701  : 	_forceinline matrix4x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 702  : 	{
; 703  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 704  : 
; 705  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L26007

; 707  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 708  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 709  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 710  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 711  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 712  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 713  : 
; 714  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 715  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 716  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 717  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 718  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 719  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 720  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 721  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 722  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 723  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 724  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 725  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 726  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 727  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 728  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 729  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 731  : 		else if( angles[PITCH] )

	jmp	$L26012
$L26007:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L26009

; 733  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 734  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 735  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 736  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 737  : 
; 738  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 739  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 741  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 742  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 743  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 744  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 745  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 746  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 747  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 748  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 749  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 750  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 751  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 752  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 753  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 755  : 		else if( angles[YAW] )

	jmp	$L26012
$L26009:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L26011

; 757  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 758  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 759  : 
; 760  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 761  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 762  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 763  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 764  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 765  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 766  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 767  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 768  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 769  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 770  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 771  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 772  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 773  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 774  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 775  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 777  : 		else

	jmp	$L26012
$L26011:

; 779  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 780  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 781  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 782  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 783  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 784  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 785  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 786  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 787  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 788  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 789  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 790  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 791  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 792  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 793  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 794  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
$L26012:

; 796  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix4x4@@QAE@ABVVector@@0M@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QAEPAMXZ PROC NEAR				; Vector4D::operator float *, COMDAT

; 325  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
PUBLIC	??BVector4D@@QBEPBMXZ				; Vector4D::operator float const *
;	COMDAT ?CopyToArray@matrix4x4@@QBEXPAM@Z
_TEXT	SEGMENT
_rgfl$ = 8
_this$ = -4
?CopyToArray@matrix4x4@@QBEXPAM@Z PROC NEAR		; matrix4x4::CopyToArray, COMDAT

; 1055 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1056 : 		rgfl[ 0] = mat[0][0];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx

; 1057 : 		rgfl[ 1] = mat[0][1];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 1058 : 		rgfl[ 2] = mat[0][2];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx

; 1059 : 		rgfl[ 3] = mat[0][3];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx

; 1060 : 		rgfl[ 4] = mat[1][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+16], edx

; 1061 : 		rgfl[ 5] = mat[1][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+20], edx

; 1062 : 		rgfl[ 6] = mat[1][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+24], edx

; 1063 : 		rgfl[ 7] = mat[1][3];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+28], edx

; 1064 : 		rgfl[ 8] = mat[2][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+32], edx

; 1065 : 		rgfl[ 9] = mat[2][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+36], edx

; 1066 : 		rgfl[10] = mat[2][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+40], edx

; 1067 : 		rgfl[11] = mat[2][3];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+44], edx

; 1068 : 		rgfl[12] = mat[3][0];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+48], edx

; 1069 : 		rgfl[13] = mat[3][1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+52], edx

; 1070 : 		rgfl[14] = mat[3][2];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+56], edx

; 1071 : 		rgfl[15] = mat[3][3];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBEPBMXZ			; Vector4D::operator float const *
	mov	ecx, DWORD PTR _rgfl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+60], edx

; 1072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CopyToArray@matrix4x4@@QBEXPAM@Z ENDP			; matrix4x4::CopyToArray
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QBEPBMXZ PROC NEAR				; Vector4D::operator float const *, COMDAT

; 326  : 	operator const float *() const			{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QBEPBMXZ ENDP				; Vector4D::operator float const *
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	??1NxMat33@@QAE@XZ				; NxMat33::~NxMat33
;	COMDAT ??1NxMat34@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxMat34@@QAE@XZ PROC NEAR				; NxMat34::~NxMat34, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxMat34@@QAE@XZ ENDP					; NxMat34::~NxMat34
_TEXT	ENDS
;	COMDAT ??1NxMat33@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxMat33@@QAE@XZ PROC NEAR				; NxMat33::~NxMat33, COMDAT

; 378  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 379  : 	//nothing
; 380  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxMat33@@QAE@XZ ENDP					; NxMat33::~NxMat33
_TEXT	ENDS
PUBLIC	?id@NxMat33@@QAEXXZ				; NxMat33::id
PUBLIC	??0NxMat33@@QAE@XZ				; NxMat33::NxMat33
;	COMDAT xdata$x
; File z:\xashxtsrc\phys_shared\nxmat34.h
xdata$x	SEGMENT
__ehfuncinfo$??0NxMat34@@QAE@_N@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0NxMat34@@QAE@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxMat34@@QAE@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxMat34@@QAE@_N@Z$0
xdata$x	ENDS
;	COMDAT ??0NxMat34@@QAE@_N@Z
_TEXT	SEGMENT
_init$ = 8
_this$ = -16
__$EHRec$ = -12
??0NxMat34@@QAE@_N@Z PROC NEAR				; NxMat34::NxMat34, COMDAT

; 141  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxMat34@@QAE@_N@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxMat33@@QAE@XZ			; NxMat33::NxMat33
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 142  : 	if (init)

	mov	eax, DWORD PTR _init$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39951

; 144  : 		t.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 145  : 		M.id();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?id@NxMat33@@QAEXXZ			; NxMat33::id
$L39951:

; 147  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxMat34@@QAE@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__ehhandler$??0NxMat34@@QAE@_N@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxMat34@@QAE@_N@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxMat34@@QAE@_N@Z ENDP				; NxMat34::NxMat34
;	COMDAT ??0NxMat33@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxMat33@@QAE@XZ PROC NEAR				; NxMat33::NxMat33, COMDAT

; 344  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxMat33@@QAE@XZ ENDP					; NxMat33::NxMat33
_TEXT	ENDS
;	COMDAT ?id@NxMat33@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?id@NxMat33@@QAEXXZ PROC NEAR				; NxMat33::id, COMDAT

; 1109 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 	data.s._11 = NxReal(1.0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 1111 : 	data.s._12 = NxReal(0.0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1112 : 	data.s._13 = NxReal(0.0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1113 : 
; 1114 : 	data.s._21 = NxReal(0.0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1115 : 	data.s._22 = NxReal(1.0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 1065353216		; 3f800000H

; 1116 : 	data.s._23 = NxReal(0.0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1117 : 
; 1118 : 	data.s._31 = NxReal(0.0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1119 : 	data.s._32 = NxReal(0.0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 1120 : 	data.s._33 = NxReal(1.0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 1065353216		; 3f800000H

; 1121 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?id@NxMat33@@QAEXXZ ENDP				; NxMat33::id
_TEXT	ENDS
PUBLIC	?setColumnMajorStride4@NxMat33@@QAEXPBM@Z	; NxMat33::setColumnMajorStride4
;	COMDAT ?setColumnMajor44@NxMat34@@QAEXPBM@Z
_TEXT	SEGMENT
_d$ = 8
_this$ = -4
?setColumnMajor44@NxMat34@@QAEXPBM@Z PROC NEAR		; NxMat34::setColumnMajor44, COMDAT

; 236  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	M.setColumnMajorStride4(d);

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setColumnMajorStride4@NxMat33@@QAEXPBM@Z ; NxMat33::setColumnMajorStride4

; 238  :     t.x = d[12];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+36], eax

; 239  : 	t.y = d[13];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR [ecx+40], eax

; 240  : 	t.z = d[14];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+44], eax

; 241  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setColumnMajor44@NxMat34@@QAEXPBM@Z ENDP		; NxMat34::setColumnMajor44
_TEXT	ENDS
;	COMDAT ?setColumnMajorStride4@NxMat33@@QAEXPBM@Z
_TEXT	SEGMENT
_d$ = 8
_this$ = -4
?setColumnMajorStride4@NxMat33@@QAEXPBM@Z PROC NEAR	; NxMat33::setColumnMajorStride4, COMDAT

; 562  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 563  : 	//we are column major, so copy transposed.
; 564  : 	//however we've got to skip every 4th element.
; 565  : 	data.s._11 = (NxReal)d[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 566  : 	data.s._12 = (NxReal)d[4];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+4], edx

; 567  : 	data.s._13 = (NxReal)d[8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+8], edx

; 568  : 
; 569  : 	data.s._21 = (NxReal)d[1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx

; 570  : 	data.s._22 = (NxReal)d[5];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+16], edx

; 571  : 	data.s._23 = (NxReal)d[9];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+20], edx

; 572  : 
; 573  : 	data.s._31 = (NxReal)d[2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+24], edx

; 574  : 	data.s._32 = (NxReal)d[6];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+28], edx

; 575  : 	data.s._33 = (NxReal)d[10];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+32], edx

; 576  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setColumnMajorStride4@NxMat33@@QAEXPBM@Z ENDP		; NxMat33::setColumnMajorStride4
_TEXT	ENDS
PUBLIC	?setToDefault@NxBodyDesc@@QAEXXZ		; NxBodyDesc::setToDefault
;	COMDAT xdata$x
; File z:\xashxtsrc\phys_shared\nxbodydesc.h
xdata$x	SEGMENT
__ehfuncinfo$??0NxBodyDesc@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0NxBodyDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxBodyDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxBodyDesc@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0NxBodyDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0NxBodyDesc@@QAE@XZ PROC NEAR				; NxBodyDesc::NxBodyDesc, COMDAT

; 351  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxBodyDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 352  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxBodyDesc@@QAEXXZ	; NxBodyDesc::setToDefault

; 353  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxBodyDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$??0NxBodyDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxBodyDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxBodyDesc@@QAE@XZ ENDP				; NxBodyDesc::NxBodyDesc
PUBLIC	?id@NxMat34@@QAEXXZ				; NxMat34::id
;	COMDAT ?setToDefault@NxBodyDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxBodyDesc@@QAEXXZ PROC NEAR		; NxBodyDesc::setToDefault, COMDAT

; 356  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 357  : 	massLocalPose			.id();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?id@NxMat34@@QAEXXZ			; NxMat34::id

; 358  : 	massSpaceInertia		.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 359  : 	linearVelocity			.zero();	//setNotUsed();	//when doing a loadFromDesc, the user expects to set the complete state, so this is not OK.

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 360  : 	angularVelocity			.zero();	//setNotUsed();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 361  : 	wakeUpCounter			= 20.0f*0.02f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 1053609164		; 3eccccccH

; 362  : 	mass					= 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 363  : 	linearDamping			= 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0

; 364  : 	angularDamping			= 0.05f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 1028443341		; 3d4ccccdH

; 365  : 	maxAngularVelocity		= -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], -1082130432	; bf800000H

; 366  : 	flags					= NX_BF_VISUALIZATION;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 256		; 00000100H

; 367  : 	sleepLinearVelocity		= -1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], -1082130432	; bf800000H

; 368  : 	sleepAngularVelocity	= -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], -1082130432	; bf800000H

; 369  : 	CCDMotionThreshold		= 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0

; 370  : 	solverIterationCount    = 4;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], 4

; 371  : 	flags					|= NX_BF_ENERGY_SLEEP_TEST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	or	dh, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], edx

; 372  : 	sleepEnergyThreshold	= -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], -1082130432	; bf800000H

; 373  : 	sleepDamping			= 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], 0

; 374  : 	contactReportThreshold  = NX_MAX_REAL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+132], 2139095039		; 7f7fffffH

; 375  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxBodyDesc@@QAEXXZ ENDP			; NxBodyDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?id@NxMat34@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?id@NxMat34@@QAEXXZ PROC NEAR				; NxMat34::id, COMDAT

; 158  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 	M.id();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?id@NxMat33@@QAEXXZ			; NxMat33::id

; 160  : 	t.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 161  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?id@NxMat34@@QAEXXZ ENDP				; NxMat34::id
_TEXT	ENDS
PUBLIC	??0NxActorDescBase@@IAE@XZ			; NxActorDescBase::NxActorDescBase
PUBLIC	??1NxActorDescBase@@QAE@XZ			; NxActorDescBase::~NxActorDescBase
PUBLIC	??0?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::NxArray<NxShapeDesc *,NxAllocatorDefault>
PUBLIC	??1?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::~NxArray<NxShapeDesc *,NxAllocatorDefault>
PUBLIC	?setToDefault@NxActorDesc@@QAEXXZ		; NxActorDesc::setToDefault
;	COMDAT xdata$x
; File z:\xashxtsrc\phys_shared\nxactordesc.h
xdata$x	SEGMENT
__ehfuncinfo$??0NxActorDesc@@QAE@XZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??0NxActorDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxActorDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxActorDesc@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0NxActorDesc@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT ??0NxActorDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0NxActorDesc@@QAE@XZ PROC NEAR			; NxActorDesc::NxActorDesc, COMDAT

; 473  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxActorDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxActorDescBase@@IAE@XZ		; NxActorDescBase::NxActorDescBase
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::NxArray<NxShapeDesc *,NxAllocatorDefault>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 474  : 		memset(this,0,sizeof(NxActorDesc));

	mov	ecx, 26					; 0000001aH
	xor	eax, eax
	mov	edi, DWORD PTR _this$[ebp]
	rep stosd

; 475  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxActorDesc@@QAEXXZ	; NxActorDesc::setToDefault

; 476  : 	type = NX_ADT_DEFAULT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 1

; 477  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxActorDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxActorDescBase@@QAE@XZ		; NxActorDescBase::~NxActorDescBase
	ret	0
__unwindfunclet$??0NxActorDesc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??1?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::~NxArray<NxShapeDesc *,NxAllocatorDefault>
	ret	0
__ehhandler$??0NxActorDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxActorDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxActorDesc@@QAE@XZ ENDP				; NxActorDesc::NxActorDesc
;	COMDAT ??0NxActorDescBase@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxActorDescBase@@IAE@XZ PROC NEAR			; NxActorDescBase::NxActorDescBase, COMDAT

; 417  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34

; 418  : 	//nothing!  Don't call setToDefault() here!
; 419  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxActorDescBase@@IAE@XZ ENDP				; NxActorDescBase::NxActorDescBase
_TEXT	ENDS
;	COMDAT ??1NxActorDescBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxActorDescBase@@QAE@XZ PROC NEAR			; NxActorDescBase::~NxActorDescBase, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxActorDescBase@@QAE@XZ ENDP				; NxActorDescBase::~NxActorDescBase
_TEXT	ENDS
PUBLIC	?setToDefault@NxActorDescBase@@QAEXXZ		; NxActorDescBase::setToDefault
PUBLIC	?clear@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::clear
;	COMDAT ?setToDefault@NxActorDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxActorDesc@@QAEXXZ PROC NEAR		; NxActorDesc::setToDefault, COMDAT

; 480  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 	NxActorDescBase::setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxActorDescBase@@QAEXXZ	; NxActorDescBase::setToDefault

; 482  : 	shapes		.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	?clear@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::clear

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxActorDesc@@QAEXXZ ENDP			; NxActorDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?setToDefault@NxActorDescBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxActorDescBase@@QAEXXZ PROC NEAR		; NxActorDescBase::setToDefault, COMDAT

; 423  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	body		= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 425  : 	density		= 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 426  : 	globalPose	.id();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?id@NxMat34@@QAEXXZ			; NxMat34::id

; 427  : 	flags		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0

; 428  : 	userData	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 429  : 	name		= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 430  : 	group		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+60], 0

; 431  : 	dominanceGroup = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+62], 0

; 432  : 	contactReportFlags = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 0

; 433  : 	forceFieldMaterial = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+68], 0

; 434  : 	compartment = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 435  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxActorDescBase@@QAEXXZ ENDP		; NxActorDescBase::setToDefault
_TEXT	ENDS
PUBLIC	??1NxShapeDesc@@UAE@XZ				; NxShapeDesc::~NxShapeDesc
PUBLIC	??0NxShapeDesc@@IAE@W4NxShapeType@@@Z		; NxShapeDesc::NxShapeDesc
PUBLIC	?setToDefault@NxConvexShapeDesc@@UAEXXZ		; NxConvexShapeDesc::setToDefault
PUBLIC	?isValid@NxConvexShapeDesc@@UBE_NXZ		; NxConvexShapeDesc::isValid
PUBLIC	??_7NxConvexShapeDesc@@6B@			; NxConvexShapeDesc::`vftable'
PUBLIC	??_GNxConvexShapeDesc@@UAEPAXI@Z		; NxConvexShapeDesc::`scalar deleting destructor'
PUBLIC	??_ENxConvexShapeDesc@@UAEPAXI@Z		; NxConvexShapeDesc::`vector deleting destructor'
;	COMDAT ??_7NxConvexShapeDesc@@6B@
; File z:\xashxtsrc\phys_shared\nxconvexshapedesc.h
CONST	SEGMENT
??_7NxConvexShapeDesc@@6B@ DD FLAT:??_ENxConvexShapeDesc@@UAEPAXI@Z ; NxConvexShapeDesc::`vftable'
	DD	FLAT:?setToDefault@NxConvexShapeDesc@@UAEXXZ
	DD	FLAT:?isValid@NxConvexShapeDesc@@UBE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0NxConvexShapeDesc@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0NxConvexShapeDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxConvexShapeDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxConvexShapeDesc@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0NxConvexShapeDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0NxConvexShapeDesc@@QAE@XZ PROC NEAR			; NxConvexShapeDesc::NxConvexShapeDesc, COMDAT

; 81   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxConvexShapeDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxShapeDesc@@IAE@W4NxShapeType@@@Z	; NxShapeDesc::NxShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxConvexShapeDesc@@6B@ ; NxConvexShapeDesc::`vftable'

; 82   : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxConvexShapeDesc@@UAEXXZ	; NxConvexShapeDesc::setToDefault

; 83   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxConvexShapeDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxShapeDesc@@UAE@XZ			; NxShapeDesc::~NxShapeDesc
	ret	0
__ehhandler$??0NxConvexShapeDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxConvexShapeDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxConvexShapeDesc@@QAE@XZ ENDP			; NxConvexShapeDesc::NxConvexShapeDesc
PUBLIC	?setToDefault@NxShapeDesc@@UAEXXZ		; NxShapeDesc::setToDefault
PUBLIC	?isValid@NxShapeDesc@@UBE_NXZ			; NxShapeDesc::isValid
PUBLIC	??_7NxShapeDesc@@6B@				; NxShapeDesc::`vftable'
PUBLIC	??_GNxShapeDesc@@UAEPAXI@Z			; NxShapeDesc::`scalar deleting destructor'
PUBLIC	??_ENxShapeDesc@@UAEPAXI@Z			; NxShapeDesc::`vector deleting destructor'
PUBLIC	??0NxGroupsMask@@QAE@XZ				; NxGroupsMask::NxGroupsMask
PUBLIC	??1NxGroupsMask@@QAE@XZ				; NxGroupsMask::~NxGroupsMask
;	COMDAT ??_7NxShapeDesc@@6B@
; File z:\xashxtsrc\phys_shared\nxshapedesc.h
CONST	SEGMENT
??_7NxShapeDesc@@6B@ DD FLAT:??_ENxShapeDesc@@UAEPAXI@Z	; NxShapeDesc::`vftable'
	DD	FLAT:?setToDefault@NxShapeDesc@@UAEXXZ
	DD	FLAT:?isValid@NxShapeDesc@@UBE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z$1
xdata$x	ENDS
;	COMDAT ??0NxShapeDesc@@IAE@W4NxShapeType@@@Z
_TEXT	SEGMENT
_t$ = 8
_this$ = -16
__$EHRec$ = -12
??0NxShapeDesc@@IAE@W4NxShapeType@@@Z PROC NEAR		; NxShapeDesc::NxShapeDesc, COMDAT

; 308  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+4], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0NxGroupsMask@@QAE@XZ			; NxGroupsMask::NxGroupsMask
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7NxShapeDesc@@6B@ ; NxShapeDesc::`vftable'

; 309  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxShapeDesc@@UAEXXZ	; NxShapeDesc::setToDefault

; 310  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__unwindfunclet$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??1NxGroupsMask@@QAE@XZ			; NxGroupsMask::~NxGroupsMask
	ret	0
__ehhandler$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxShapeDesc@@IAE@W4NxShapeType@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxShapeDesc@@IAE@W4NxShapeType@@@Z ENDP		; NxShapeDesc::NxShapeDesc
;	COMDAT ??0NxGroupsMask@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxGroupsMask@@QAE@XZ PROC NEAR			; NxGroupsMask::NxGroupsMask, COMDAT

; 2136 : 		NX_INLINE	NxGroupsMask()	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxGroupsMask@@QAE@XZ ENDP				; NxGroupsMask::NxGroupsMask
_TEXT	ENDS
;	COMDAT ??1NxGroupsMask@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxGroupsMask@@QAE@XZ PROC NEAR			; NxGroupsMask::~NxGroupsMask, COMDAT

; 2137 : 		NX_INLINE	~NxGroupsMask()	{}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxGroupsMask@@QAE@XZ ENDP				; NxGroupsMask::~NxGroupsMask
_TEXT	ENDS
;	COMDAT ??_GNxShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxShapeDesc@@UAEPAXI@Z PROC NEAR			; NxShapeDesc::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxShapeDesc@@UAE@XZ			; NxShapeDesc::~NxShapeDesc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L45193
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L45193:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxShapeDesc@@UAEPAXI@Z ENDP				; NxShapeDesc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\phys_shared\nxshapedesc.h
xdata$x	SEGMENT
__ehfuncinfo$??1NxShapeDesc@@UAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1NxShapeDesc@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1NxShapeDesc@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1NxShapeDesc@@UAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1NxShapeDesc@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1NxShapeDesc@@UAE@XZ PROC NEAR			; NxShapeDesc::~NxShapeDesc, COMDAT

; 313  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1NxShapeDesc@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxShapeDesc@@6B@ ; NxShapeDesc::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 314  : 	}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??1NxGroupsMask@@QAE@XZ			; NxGroupsMask::~NxGroupsMask
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1NxShapeDesc@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$??1NxShapeDesc@@UAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1NxShapeDesc@@UAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1NxShapeDesc@@UAE@XZ ENDP				; NxShapeDesc::~NxShapeDesc
;	COMDAT ?setToDefault@NxShapeDesc@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxShapeDesc@@UAEXXZ PROC NEAR		; NxShapeDesc::setToDefault, COMDAT

; 317  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 318  : 	localPose.id();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?id@NxMat34@@QAEXXZ			; NxMat34::id

; 319  : 	shapeFlags			= NX_SF_VISUALIZATION | NX_SF_CLOTH_TWOWAY | NX_SF_SOFTBODY_TWOWAY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 1179656		; 00120008H

; 320  : 	group				= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+60], 0

; 321  : 	materialIndex		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+62], 0

; 322  : 	ccdSkeleton		= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 323  : 	skinWidth			= -1.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], -1082130432		; bf800000H

; 324  : 	density				=  1.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 1065353216		; 3f800000H

; 325  : 	mass				= -1.0f;  // by default we let the mass be determined by its density.  

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], -1082130432		; bf800000H

; 326  : 	userData			= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 0

; 327  : 	name				= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], 0

; 328  : 	groupsMask.bits0	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+88], 0

; 329  : 	groupsMask.bits1	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0

; 330  : 	groupsMask.bits2	= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0

; 331  : 	groupsMask.bits3	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 332  : 	nonInteractingCompartmentTypes = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], 0

; 333  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxShapeDesc@@UAEXXZ ENDP			; NxShapeDesc::setToDefault
_TEXT	ENDS
PUBLIC	__real@4@bfff8000000000000000
PUBLIC	?isFinite@NxMat34@@QBE_NXZ			; NxMat34::isFinite
;	COMDAT __real@4@bfff8000000000000000
; File z:\xashxtsrc\phys_shared\nxshapedesc.h
CONST	SEGMENT
__real@4@bfff8000000000000000 DD 0bf800000r	; -1
CONST	ENDS
;	COMDAT ?isValid@NxShapeDesc@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isValid@NxShapeDesc@@UBE_NXZ PROC NEAR			; NxShapeDesc::isValid, COMDAT

; 336  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 337  : 	if(!localPose.isFinite())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?isFinite@NxMat34@@QBE_NXZ		; NxMat34::isFinite
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L45203

; 338  : 		return false;

	xor	al, al
	jmp	SHORT $L45202
$L45203:

; 339  : 	if(group>=32)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+60]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $L45204

; 340  : 		return false;	// We only support 32 different groups

	xor	al, al
	jmp	SHORT $L45202
$L45204:

; 341  : 	// dsullins: I removed this bogus shapeFlags check because it was preventing core dumps from loading
; 342  : 	//if(shapeFlags&0xffff0000)
; 343  : 	//	return false;	// Only 16-bit flags supported here
; 344  : 	if(type >= NX_SHAPE_COUNT)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 10			; 0000000aH
	jl	SHORT $L45205

; 345  : 		return false;

	xor	al, al
	jmp	SHORT $L45202
$L45205:

; 346  : 	if(materialIndex==0xffff)

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cx, WORD PTR [eax+62]
	cmp	ecx, 65535				; 0000ffffH
	jne	SHORT $L45206

; 347  : 		return false;	// 0xffff is reserved for internal usage

	xor	al, al
	jmp	SHORT $L45202
$L45206:

; 348  : 	if (skinWidth != -1 && skinWidth < 0)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+76]
	fcomp	DWORD PTR __real@4@bfff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L45207
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+76]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L45207

; 349  : 		return false;

	xor	al, al
	jmp	SHORT $L45202
$L45207:

; 350  : 	return true;

	mov	al, 1
$L45202:

; 351  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@NxShapeDesc@@UBE_NXZ ENDP			; NxShapeDesc::isValid
_TEXT	ENDS
PUBLIC	?isFinite@NxMat33@@QBE_NXZ			; NxMat33::isFinite
PUBLIC	?isFinite@NxVec3@@QBE_NXZ			; NxVec3::isFinite
;	COMDAT ?isFinite@NxMat34@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isFinite@NxMat34@@QBE_NXZ PROC NEAR			; NxMat34::isFinite, COMDAT

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 	if(!M.isFinite())	return false;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isFinite@NxMat33@@QBE_NXZ		; NxMat33::isFinite
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39966
	xor	al, al
	jmp	SHORT $L39965
$L39966:

; 175  : 	if(!t.isFinite())	return false;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?isFinite@NxVec3@@QBE_NXZ		; NxVec3::isFinite
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L39967
	xor	al, al
	jmp	SHORT $L39965
$L39967:

; 176  : 	return true;

	mov	al, 1
$L39965:

; 177  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isFinite@NxMat34@@QBE_NXZ ENDP				; NxMat34::isFinite
_TEXT	ENDS
PUBLIC	?isFinite@NxMath@@SA_NM@Z			; NxMath::isFinite
;	COMDAT ?isFinite@NxVec3@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isFinite@NxVec3@@QBE_NXZ PROC NEAR			; NxVec3::isFinite, COMDAT

; 722  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 723  : 	return NxMath::isFinite(x) && NxMath::isFinite(y) && NxMath::isFinite(z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52097
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52097
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52097
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L52098
$L52097:
	mov	DWORD PTR -8+[ebp], 0
$L52098:
	mov	al, BYTE PTR -8+[ebp]

; 724  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isFinite@NxVec3@@QBE_NXZ ENDP				; NxVec3::isFinite
_TEXT	ENDS
EXTRN	__fpclass:NEAR
;	COMDAT ?isFinite@NxMath@@SA_NM@Z
_TEXT	SEGMENT
_f$ = 8
?isFinite@NxMath@@SA_NM@Z PROC NEAR			; NxMath::isFinite, COMDAT

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 46   : 	return (0 == ((_FPCLASS_SNAN | _FPCLASS_QNAN | _FPCLASS_NINF | _FPCLASS_PINF) & _fpclass(f) ));

	fld	DWORD PTR _f$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	__fpclass
	add	esp, 8
	and	eax, 519				; 00000207H
	neg	eax
	sbb	eax, eax
	inc	eax

; 47   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isFinite@NxMath@@SA_NM@Z ENDP				; NxMath::isFinite
_TEXT	ENDS
;	COMDAT ?isFinite@NxMat33@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isFinite@NxMat33@@QBE_NXZ PROC NEAR			; NxMat33::isFinite, COMDAT

; 1076 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1077 : 	return NxMath::isFinite(data.s._11)
; 1078 : 	&& NxMath::isFinite(data.s._12)
; 1079 : 	&& NxMath::isFinite(data.s._13)
; 1080 : 
; 1081 : 	&& NxMath::isFinite(data.s._21)
; 1082 : 	&& NxMath::isFinite(data.s._22)
; 1083 : 	&& NxMath::isFinite(data.s._23)
; 1084 : 
; 1085 : 	&& NxMath::isFinite(data.s._31)
; 1086 : 	&& NxMath::isFinite(data.s._32)
; 1087 : 	&& NxMath::isFinite(data.s._33);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L52103
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L52103
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L52103
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L52103
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52103
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52103
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52103
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52103
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?isFinite@NxMath@@SA_NM@Z		; NxMath::isFinite
	add	esp, 4
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L52103
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L52104
$L52103:
	mov	DWORD PTR -8+[ebp], 0
$L52104:
	mov	al, BYTE PTR -8+[ebp]

; 1088 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isFinite@NxMat33@@QBE_NXZ ENDP				; NxMat33::isFinite
_TEXT	ENDS
;	COMDAT ??_GNxConvexShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxConvexShapeDesc@@UAEPAXI@Z PROC NEAR		; NxConvexShapeDesc::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L46764
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46764:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxConvexShapeDesc@@UAEPAXI@Z ENDP			; NxConvexShapeDesc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1NxConvexShapeDesc@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxConvexShapeDesc@@UAE@XZ PROC NEAR			; NxConvexShapeDesc::~NxConvexShapeDesc, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxShapeDesc@@UAE@XZ			; NxShapeDesc::~NxShapeDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxConvexShapeDesc@@UAE@XZ ENDP			; NxConvexShapeDesc::~NxConvexShapeDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxConvexShapeDesc@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxConvexShapeDesc@@UAEXXZ PROC NEAR	; NxConvexShapeDesc::setToDefault, COMDAT

; 86   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 	NxShapeDesc::setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxShapeDesc@@UAEXXZ	; NxShapeDesc::setToDefault

; 88   : 	meshData	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0

; 89   : 	meshFlags	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0

; 90   : #ifdef NX_SUPPORT_CONVEX_SCALE
; 91   : 	scale		= 1.0f;
; 92   : #endif
; 93   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxConvexShapeDesc@@UAEXXZ ENDP		; NxConvexShapeDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?isValid@NxConvexShapeDesc@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isValid@NxConvexShapeDesc@@UBE_NXZ PROC NEAR		; NxConvexShapeDesc::isValid, COMDAT

; 96   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 	if(!meshData)	return false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 0
	jne	SHORT $L46773
	xor	al, al
	jmp	SHORT $L46772
$L46773:

; 98   : #ifdef NX_SUPPORT_CONVEX_SCALE
; 99   : 	if(scale<=0.0f)	return false;
; 100  : #endif
; 101  : 	return NxShapeDesc::isValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isValid@NxShapeDesc@@UBE_NXZ		; NxShapeDesc::isValid
$L46772:

; 102  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@NxConvexShapeDesc@@UBE_NXZ ENDP		; NxConvexShapeDesc::isValid
_TEXT	ENDS
;	COMDAT ??1NxBodyDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxBodyDesc@@QAE@XZ PROC NEAR				; NxBodyDesc::~NxBodyDesc, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxBodyDesc@@QAE@XZ ENDP				; NxBodyDesc::~NxBodyDesc
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1NxActorDesc@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1NxActorDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1NxActorDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1NxActorDesc@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1NxActorDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??1NxActorDesc@@QAE@XZ PROC NEAR			; NxActorDesc::~NxActorDesc, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1NxActorDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??1?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::~NxArray<NxShapeDesc *,NxAllocatorDefault>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxActorDescBase@@QAE@XZ		; NxActorDescBase::~NxActorDescBase
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1NxActorDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxActorDescBase@@QAE@XZ		; NxActorDescBase::~NxActorDescBase
	ret	0
__ehhandler$??1NxActorDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1NxActorDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1NxActorDesc@@QAE@XZ ENDP				; NxActorDesc::~NxActorDesc
PUBLIC	??4NxVec3@@QAEABV0@ABVVector@@@Z		; NxVec3::operator=
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	__real@4@40008000000000000000
PUBLIC	??0NxBoxShapeDesc@@QAE@XZ			; NxBoxShapeDesc::NxBoxShapeDesc
PUBLIC	??1NxBoxShapeDesc@@UAE@XZ			; NxBoxShapeDesc::~NxBoxShapeDesc
;	COMDAT __real@4@40008000000000000000
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2
xdata$x	ENDS
;	COMDAT ?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -16
_BodyDesc$ = -152
_ActorDesc$ = -256
_boxDesc$ = -376
_pActor$ = -380
_vecOffset$ = -392
$T52129 = -404
$T52130 = -408
$T52131 = -412
$T52132 = -416
$T52133 = -428
$T52136 = -440
$T52137 = -452
$T52138 = -456
__$EHRec$ = -12
?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::CreateBoxFromEntity, COMDAT

; 1113 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 512				; 00000200H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 	NxBodyDesc BodyDesc;

	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??0NxBodyDesc@@QAE@XZ			; NxBodyDesc::NxBodyDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1115 : 	BodyDesc.flags |= NX_BF_KINEMATIC|NX_BF_VISUALIZATION;

	mov	eax, DWORD PTR _BodyDesc$[ebp+108]
	or	eax, 384				; 00000180H
	mov	DWORD PTR _BodyDesc$[ebp+108], eax

; 1116 : 
; 1117 : 	NxActorDesc ActorDesc;

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??0NxActorDesc@@QAE@XZ			; NxActorDesc::NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1118 : 	NxBoxShapeDesc boxDesc;

	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??0NxBoxShapeDesc@@QAE@XZ		; NxBoxShapeDesc::NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1119 : 	boxDesc.dimensions = pObject->pev->size * PADDING_FACTOR;

	push	1056629064				; 3efae148H
	lea	ecx, DWORD PTR $T52129[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _boxDesc$[ebp+108]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 1120 : 
; 1121 : 	ActorDesc.body = &BodyDesc;

	lea	eax, DWORD PTR _BodyDesc$[ebp]
	mov	DWORD PTR _ActorDesc$[ebp+48], eax

; 1122 : 	ActorDesc.density = DENSITY_FACTOR;

	mov	DWORD PTR _ActorDesc$[ebp+52], 984245443 ; 3aaa64c3H

; 1123 : 	ActorDesc.userData = pObject->edict();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ActorDesc$[ebp+72], eax

; 1124 : 	ActorDesc.shapes.pushBack( &boxDesc );

	lea	ecx, DWORD PTR _boxDesc$[ebp]
	mov	DWORD PTR $T52130[ebp], ecx
	lea	edx, DWORD PTR $T52130[ebp]
	push	edx
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 1125 : 
; 1126 : 	NxActor *pActor = m_pScene->createActor( ActorDesc );

	lea	eax, DWORD PTR _ActorDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+28]
	mov	DWORD PTR _pActor$[ebp], eax

; 1127 : 
; 1128 : 	if( !pActor )

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49804

; 1130 : 		ALERT( at_error, "failed to create rigidbody from entity %s\n", pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CL@HLHI@failed?5to?5create?5rigidbody?5from?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1131 : 		return NULL;

	mov	DWORD PTR $T52131[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	eax, DWORD PTR $T52131[ebp]
	jmp	$L49797
$L49804:

; 1133 : 
; 1134 : 	Vector vecOffset = (pObject->IsMonster()) ? Vector( 0, 0, pObject->pev->maxs.z / 2.0f ) : g_vecZero;

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	DWORD PTR [edx+232]
	test	eax, eax
	je	SHORT $L52134
	mov	eax, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+240]
	fdiv	DWORD PTR __real@4@40008000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	push	0
	lea	ecx, DWORD PTR $T52133[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	DWORD PTR -460+[ebp], eax
	jmp	SHORT $L52135
$L52134:
	mov	DWORD PTR -460+[ebp], OFFSET FLAT:?g_vecZero@@3VVector@@B ; g_vecZero
$L52135:
	mov	edx, DWORD PTR -460+[ebp]
	mov	DWORD PTR $T52132[ebp], edx
	mov	eax, DWORD PTR $T52132[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOffset$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1135 : 
; 1136 : 	pActor->setName( pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+12]

; 1137 : 	pActor->setGlobalPosition( pObject->GetAbsOrigin() + vecOffset );

	lea	eax, DWORD PTR _vecOffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52137[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR $T52136[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52136[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+24]

; 1138 : 	pObject->m_iActorType = ACTOR_CHARACTER;

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	BYTE PTR [eax+1604], 3

; 1139 : 	pObject->m_pUserData = pActor;

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR [ecx+244], edx

; 1140 : 
; 1141 : 	return pActor;

	mov	eax, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR $T52138[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	eax, DWORD PTR $T52138[ebp]
$L49797:

; 1142 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	ret	0
__unwindfunclet$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1:
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	ret	0
__unwindfunclet$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2:
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	ret	0
__ehhandler$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateBoxFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::CreateBoxFromEntity
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T52150 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T52150[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??4NxVec3@@QAEABV0@ABVVector@@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??4NxVec3@@QAEABV0@ABVVector@@@Z PROC NEAR		; NxVec3::operator=, COMDAT

; 446  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 447  : 	x = v.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 448  : 	y = v.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 449  : 	z = v.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 450  : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 451  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4NxVec3@@QAEABV0@ABVVector@@@Z ENDP			; NxVec3::operator=
_TEXT	ENDS
PUBLIC	?setToDefault@NxBoxShapeDesc@@UAEXXZ		; NxBoxShapeDesc::setToDefault
PUBLIC	?isValid@NxBoxShapeDesc@@UBE_NXZ		; NxBoxShapeDesc::isValid
PUBLIC	??_7NxBoxShapeDesc@@6B@				; NxBoxShapeDesc::`vftable'
PUBLIC	??_GNxBoxShapeDesc@@UAEPAXI@Z			; NxBoxShapeDesc::`scalar deleting destructor'
PUBLIC	??_ENxBoxShapeDesc@@UAEPAXI@Z			; NxBoxShapeDesc::`vector deleting destructor'
;	COMDAT ??_7NxBoxShapeDesc@@6B@
; File z:\xashxtsrc\phys_shared\nxboxshapedesc.h
CONST	SEGMENT
??_7NxBoxShapeDesc@@6B@ DD FLAT:??_ENxBoxShapeDesc@@UAEPAXI@Z ; NxBoxShapeDesc::`vftable'
	DD	FLAT:?setToDefault@NxBoxShapeDesc@@UAEXXZ
	DD	FLAT:?isValid@NxBoxShapeDesc@@UBE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0NxBoxShapeDesc@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0NxBoxShapeDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxBoxShapeDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxBoxShapeDesc@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0NxBoxShapeDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0NxBoxShapeDesc@@QAE@XZ PROC NEAR			; NxBoxShapeDesc::NxBoxShapeDesc, COMDAT

; 63   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxBoxShapeDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxShapeDesc@@IAE@W4NxShapeType@@@Z	; NxShapeDesc::NxShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxBoxShapeDesc@@6B@ ; NxBoxShapeDesc::`vftable'

; 64   : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxBoxShapeDesc@@UAEXXZ	; NxBoxShapeDesc::setToDefault

; 65   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxBoxShapeDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxShapeDesc@@UAE@XZ			; NxShapeDesc::~NxShapeDesc
	ret	0
__ehhandler$??0NxBoxShapeDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxBoxShapeDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxBoxShapeDesc@@QAE@XZ ENDP				; NxBoxShapeDesc::NxBoxShapeDesc
;	COMDAT ??_GNxBoxShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxBoxShapeDesc@@UAEPAXI@Z PROC NEAR			; NxBoxShapeDesc::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L46894
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46894:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxBoxShapeDesc@@UAEPAXI@Z ENDP			; NxBoxShapeDesc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1NxBoxShapeDesc@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxBoxShapeDesc@@UAE@XZ PROC NEAR			; NxBoxShapeDesc::~NxBoxShapeDesc, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxShapeDesc@@UAE@XZ			; NxShapeDesc::~NxShapeDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxBoxShapeDesc@@UAE@XZ ENDP				; NxBoxShapeDesc::~NxBoxShapeDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxBoxShapeDesc@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxBoxShapeDesc@@UAEXXZ PROC NEAR		; NxBoxShapeDesc::setToDefault, COMDAT

; 68   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 	NxShapeDesc::setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxShapeDesc@@UAEXXZ	; NxShapeDesc::setToDefault

; 70   : 	dimensions.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 71   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxBoxShapeDesc@@UAEXXZ ENDP		; NxBoxShapeDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?isValid@NxBoxShapeDesc@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isValid@NxBoxShapeDesc@@UBE_NXZ PROC NEAR		; NxBoxShapeDesc::isValid, COMDAT

; 74   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 	if(!dimensions.isFinite())			return false;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	call	?isFinite@NxVec3@@QBE_NXZ		; NxVec3::isFinite
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L46903
	xor	al, al
	jmp	SHORT $L46902
$L46903:

; 76   : 	if(dimensions.x<0.0f)				return false;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+108]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L46904
	xor	al, al
	jmp	SHORT $L46902
$L46904:

; 77   : 	if(dimensions.y<0.0f)				return false;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+112]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L46905
	xor	al, al
	jmp	SHORT $L46902
$L46905:

; 78   : 	if(dimensions.z<0.0f)				return false;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+116]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L46906
	xor	al, al
	jmp	SHORT $L46902
$L46906:

; 79   : 	return NxShapeDesc::isValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isValid@NxShapeDesc@@UBE_NXZ		; NxShapeDesc::isValid
$L46902:

; 80   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@NxBoxShapeDesc@@UBE_NXZ ENDP			; NxBoxShapeDesc::isValid
_TEXT	ENDS
PUBLIC	??1NxTriangleMeshShapeDesc@@UAE@XZ		; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
PUBLIC	??_C@_0CL@FINK@failed?5to?5create?5kinematic?5from?5@ ; `string'
PUBLIC	?hideWarning@NxErrorStream@@QAEX_N@Z		; NxErrorStream::hideWarning
PUBLIC	??0NxTriangleMeshShapeDesc@@QAE@XZ		; NxTriangleMeshShapeDesc::NxTriangleMeshShapeDesc
EXTRN	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z:NEAR	; UTIL_CanRotate
;	COMDAT ??_C@_0CL@FINK@failed?5to?5create?5kinematic?5from?5@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CL@FINK@failed?5to?5create?5kinematic?5from?5@ DB 'failed to creat'
	DB	'e kinematic from entity %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 019930520H
	DD	04H
	DD	FLAT:__unwindtable$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$3
xdata$x	ENDS
;	COMDAT ?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -16
_pCollision$ = -20
_BodyDesc$ = -156
_ActorDesc$ = -260
_meshShapeDesc$ = -380
_pActor$ = -384
_pose$ = -432
_mat$ = -496
$T52173 = -500
$T52174 = -504
$T52175 = -568
$T52176 = -572
__$EHRec$ = -12
?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::CreateKinematicBodyFromEntity, COMDAT

; 1145 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 624				; 00000270H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 	NxTriangleMesh *pCollision = TriangleMeshFromEntity( pObject );

	mov	eax, DWORD PTR _pObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z ; CPhysicNovodex::TriangleMeshFromEntity
	mov	DWORD PTR _pCollision$[ebp], eax

; 1147 : 	if( !pCollision ) return NULL;

	cmp	DWORD PTR _pCollision$[ebp], 0
	jne	SHORT $L49817
	xor	eax, eax
	jmp	$L49815
$L49817:

; 1148 : 
; 1149 : 	NxBodyDesc BodyDesc;

	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??0NxBodyDesc@@QAE@XZ			; NxBodyDesc::NxBodyDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1150 : 	NxActorDesc ActorDesc;

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??0NxActorDesc@@QAE@XZ			; NxActorDesc::NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1151 : 	NxTriangleMeshShapeDesc meshShapeDesc;

	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??0NxTriangleMeshShapeDesc@@QAE@XZ	; NxTriangleMeshShapeDesc::NxTriangleMeshShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1152 : 	BodyDesc.flags = NX_BF_VISUALIZATION|NX_BF_KINEMATIC|NX_BF_FILTER_SLEEP_VEL;

	mov	DWORD PTR _BodyDesc$[ebp+108], 1408	; 00000580H

; 1153 : 	BodyDesc.solverIterationCount = SOLVER_ITERATION_COUNT;

	mov	DWORD PTR _BodyDesc$[ebp+120], 16	; 00000010H

; 1154 : 
; 1155 : 	if( !UTIL_CanRotate( pObject ))

	mov	ecx, DWORD PTR _pObject$[ebp]
	push	ecx
	call	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z	; UTIL_CanRotate
	add	esp, 4
	test	eax, eax
	jne	SHORT $L49821

; 1156 : 		BodyDesc.flags |= NX_BF_FROZEN_ROT; // entity missed origin-brush

	mov	edx, DWORD PTR _BodyDesc$[ebp+108]
	or	edx, 112				; 00000070H
	mov	DWORD PTR _BodyDesc$[ebp+108], edx
$L49821:

; 1157 : 
; 1158 : 	ActorDesc.body = &BodyDesc;

	lea	eax, DWORD PTR _BodyDesc$[ebp]
	mov	DWORD PTR _ActorDesc$[ebp+48], eax

; 1159 : 	ActorDesc.density = DENSITY_FACTOR;

	mov	DWORD PTR _ActorDesc$[ebp+52], 984245443 ; 3aaa64c3H

; 1160 : 	ActorDesc.userData = pObject->edict();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ActorDesc$[ebp+72], eax

; 1161 : 
; 1162 : 	meshShapeDesc.meshData = pCollision;

	mov	ecx, DWORD PTR _pCollision$[ebp]
	mov	DWORD PTR _meshShapeDesc$[ebp+108], ecx

; 1163 : 	ActorDesc.shapes.pushBack( &meshShapeDesc );

	lea	edx, DWORD PTR _meshShapeDesc$[ebp]
	mov	DWORD PTR $T52173[ebp], edx
	lea	eax, DWORD PTR $T52173[ebp]
	push	eax
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 1164 : 	m_ErrorStream.hideWarning( true );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	?hideWarning@NxErrorStream@@QAEX_N@Z	; NxErrorStream::hideWarning

; 1165 : 	NxActor *pActor = m_pScene->createActor( ActorDesc );

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+28]
	mov	DWORD PTR _pActor$[ebp], eax

; 1166 : 	m_ErrorStream.hideWarning( false );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	?hideWarning@NxErrorStream@@QAEX_N@Z	; NxErrorStream::hideWarning

; 1167 : 
; 1168 : 	if( !pActor )

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49824

; 1170 : 		ALERT( at_error, "failed to create kinematic from entity %s\n", pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CL@FINK@failed?5to?5create?5kinematic?5from?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1171 : 		return NULL;

	mov	DWORD PTR $T52174[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	eax, DWORD PTR $T52174[ebp]
	jmp	$L49815
$L49824:

; 1173 : 
; 1174 : 	pActor->setName( pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+12]

; 1175 : 
; 1176 : 	NxMat34 pose;

	push	1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1177 : 	float mat[16];
; 1178 : 	matrix4x4( pObject->GetAbsOrigin(), pObject->GetAbsAngles(), 1.0f ).CopyToArray( mat );

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T52175[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	mov	ecx, eax
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 1179 : 
; 1180 : 	pose.setColumnMajor44( mat );

	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?setColumnMajor44@NxMat34@@QAEXPBM@Z	; NxMat34::setColumnMajor44

; 1181 : 	pActor->setGlobalPose( pose );

	lea	edx, DWORD PTR _pose$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+20]

; 1182 : 	pObject->m_iActorType = ACTOR_KINEMATIC;

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	BYTE PTR [eax+1604], 2

; 1183 : 	pObject->m_pUserData = pActor;

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR [ecx+244], edx

; 1184 : 
; 1185 : 	return pActor;

	mov	eax, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR $T52176[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	eax, DWORD PTR $T52176[ebp]
$L49815:

; 1186 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	ret	0
__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1:
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	ret	0
__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2:
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	ret	0
__unwindfunclet$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$3:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateKinematicBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::CreateKinematicBodyFromEntity
;	COMDAT ?hideWarning@NxErrorStream@@QAEX_N@Z
_TEXT	SEGMENT
_bHide$ = 8
_this$ = -4
?hideWarning@NxErrorStream@@QAEX_N@Z PROC NEAR		; NxErrorStream::hideWarning, COMDAT

; 61   : 	void hideWarning( bool bHide ) { m_fHideWarning = bHide; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bHide$[ebp]
	mov	BYTE PTR [eax+4], cl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?hideWarning@NxErrorStream@@QAEX_N@Z ENDP		; NxErrorStream::hideWarning
_TEXT	ENDS
PUBLIC	??_7NxTriangleMeshShapeDesc@@6B@		; NxTriangleMeshShapeDesc::`vftable'
PUBLIC	??_GNxTriangleMeshShapeDesc@@UAEPAXI@Z		; NxTriangleMeshShapeDesc::`scalar deleting destructor'
PUBLIC	??_ENxTriangleMeshShapeDesc@@UAEPAXI@Z		; NxTriangleMeshShapeDesc::`vector deleting destructor'
PUBLIC	?setToDefault@NxTriangleMeshShapeDesc@@UAEXXZ	; NxTriangleMeshShapeDesc::setToDefault
PUBLIC	?isValid@NxTriangleMeshShapeDesc@@UBE_NXZ	; NxTriangleMeshShapeDesc::isValid
;	COMDAT ??_7NxTriangleMeshShapeDesc@@6B@
; File z:\xashxtsrc\phys_shared\nxtrianglemeshshapedesc.h
CONST	SEGMENT
??_7NxTriangleMeshShapeDesc@@6B@ DD FLAT:??_ENxTriangleMeshShapeDesc@@UAEPAXI@Z ; NxTriangleMeshShapeDesc::`vftable'
	DD	FLAT:?setToDefault@NxTriangleMeshShapeDesc@@UAEXXZ
	DD	FLAT:?isValid@NxTriangleMeshShapeDesc@@UBE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0NxTriangleMeshShapeDesc@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0NxTriangleMeshShapeDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxTriangleMeshShapeDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxTriangleMeshShapeDesc@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0NxTriangleMeshShapeDesc@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0NxTriangleMeshShapeDesc@@QAE@XZ PROC NEAR		; NxTriangleMeshShapeDesc::NxTriangleMeshShapeDesc, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxTriangleMeshShapeDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	6
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxShapeDesc@@IAE@W4NxShapeType@@@Z	; NxShapeDesc::NxShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxTriangleMeshShapeDesc@@6B@ ; NxTriangleMeshShapeDesc::`vftable'

; 93   : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxTriangleMeshShapeDesc@@UAEXXZ ; NxTriangleMeshShapeDesc::setToDefault

; 94   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxTriangleMeshShapeDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxShapeDesc@@UAE@XZ			; NxShapeDesc::~NxShapeDesc
	ret	0
__ehhandler$??0NxTriangleMeshShapeDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxTriangleMeshShapeDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxTriangleMeshShapeDesc@@QAE@XZ ENDP			; NxTriangleMeshShapeDesc::NxTriangleMeshShapeDesc
;	COMDAT ??_GNxTriangleMeshShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxTriangleMeshShapeDesc@@UAEPAXI@Z PROC NEAR	; NxTriangleMeshShapeDesc::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L46095
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46095:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxTriangleMeshShapeDesc@@UAEPAXI@Z ENDP		; NxTriangleMeshShapeDesc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1NxTriangleMeshShapeDesc@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxTriangleMeshShapeDesc@@UAE@XZ PROC NEAR		; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxShapeDesc@@UAE@XZ			; NxShapeDesc::~NxShapeDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxTriangleMeshShapeDesc@@UAE@XZ ENDP			; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxTriangleMeshShapeDesc@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxTriangleMeshShapeDesc@@UAEXXZ PROC NEAR	; NxTriangleMeshShapeDesc::setToDefault, COMDAT

; 97   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 	NxShapeDesc::setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxShapeDesc@@UAEXXZ	; NxShapeDesc::setToDefault

; 99   : 	meshData		= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0

; 100  : 	meshFlags		= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0

; 101  : 	meshPagingMode	= NX_MESH_PAGING_MANUAL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 0

; 102  : #ifdef NX_SUPPORT_MESH_SCALE
; 103  : 	scale		= 1.0f;
; 104  : #endif
; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxTriangleMeshShapeDesc@@UAEXXZ ENDP	; NxTriangleMeshShapeDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?isValid@NxTriangleMeshShapeDesc@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isValid@NxTriangleMeshShapeDesc@@UBE_NXZ PROC NEAR	; NxTriangleMeshShapeDesc::isValid, COMDAT

; 108  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 	if(!meshData)	return false;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+108], 0
	jne	SHORT $L46104
	xor	al, al
	jmp	SHORT $L46103
$L46104:

; 110  : #ifdef NX_SUPPORT_MESH_SCALE
; 111  : 	if(scale<=0.0f)	return false;
; 112  : #endif
; 113  : 	return NxShapeDesc::isValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isValid@NxShapeDesc@@UBE_NXZ		; NxShapeDesc::isValid
$L46103:

; 114  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@NxTriangleMeshShapeDesc@@UBE_NXZ ENDP		; NxTriangleMeshShapeDesc::isValid
_TEXT	ENDS
PUBLIC	??_C@_0CI@GEAK@failed?5to?5create?5static?5from?5ent@ ; `string'
PUBLIC	??4NxMat34@@QAEAAV0@ABV0@@Z			; NxMat34::operator=
;	COMDAT ??_C@_0CI@GEAK@failed?5to?5create?5static?5from?5ent@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CI@GEAK@failed?5to?5create?5static?5from?5ent@ DB 'failed to creat'
	DB	'e static from entity %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2
xdata$x	ENDS
;	COMDAT ?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pObject$ = 8
_this$ = -16
_pCollision$ = -20
_pose$ = -68
_mat$ = -132
_ActorDesc$ = -236
_meshShapeDesc$ = -356
_pActor$ = -360
$T52209 = -424
$T52210 = -428
$T52211 = -432
$T52212 = -436
__$EHRec$ = -12
?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::CreateStaticBodyFromEntity, COMDAT

; 1189 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 488				; 000001e8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1190 : 	NxTriangleMesh *pCollision = TriangleMeshFromEntity( pObject );

	mov	eax, DWORD PTR _pObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z ; CPhysicNovodex::TriangleMeshFromEntity
	mov	DWORD PTR _pCollision$[ebp], eax

; 1191 : 	if( !pCollision ) return NULL;

	cmp	DWORD PTR _pCollision$[ebp], 0
	jne	SHORT $L49836
	xor	eax, eax
	jmp	$L49834
$L49836:

; 1192 : 
; 1193 : 	NxMat34 pose;

	push	1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1194 : 	float mat[16];
; 1195 : 	matrix4x4( pObject->GetAbsOrigin(), pObject->GetAbsAngles(), 1.0f ).CopyToArray( mat );

	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T52209[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	mov	ecx, eax
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 1196 : 
; 1197 : 	pose.setColumnMajor44( mat );

	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?setColumnMajor44@NxMat34@@QAEXPBM@Z	; NxMat34::setColumnMajor44

; 1198 : 
; 1199 : 	NxActorDesc ActorDesc;

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??0NxActorDesc@@QAE@XZ			; NxActorDesc::NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1200 : 	NxTriangleMeshShapeDesc meshShapeDesc;

	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??0NxTriangleMeshShapeDesc@@QAE@XZ	; NxTriangleMeshShapeDesc::NxTriangleMeshShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1201 : 	ActorDesc.density = DENSITY_FACTOR;

	mov	DWORD PTR _ActorDesc$[ebp+52], 984245443 ; 3aaa64c3H

; 1202 : 	ActorDesc.userData = pObject->edict();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ActorDesc$[ebp+72], eax

; 1203 : 	ActorDesc.globalPose = pose;

	lea	eax, DWORD PTR _pose$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??4NxMat34@@QAEAAV0@ABV0@@Z		; NxMat34::operator=

; 1204 : 
; 1205 : 	if( pObject->pev->flags & FL_CONVEYOR )

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 4
	test	eax, eax
	je	SHORT $L49842

; 1206 : 		meshShapeDesc.materialIndex = 1;

	mov	WORD PTR _meshShapeDesc$[ebp+62], 1
$L49842:

; 1207 : 	meshShapeDesc.meshData = pCollision;

	mov	ecx, DWORD PTR _pCollision$[ebp]
	mov	DWORD PTR _meshShapeDesc$[ebp+108], ecx

; 1208 : 	ActorDesc.shapes.pushBack( &meshShapeDesc );

	lea	edx, DWORD PTR _meshShapeDesc$[ebp]
	mov	DWORD PTR $T52210[ebp], edx
	lea	eax, DWORD PTR $T52210[ebp]
	push	eax
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 1209 : 	NxActor *pActor = m_pScene->createActor( ActorDesc );

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+28]
	mov	DWORD PTR _pActor$[ebp], eax

; 1210 : 
; 1211 : 	if( !pActor )

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49845

; 1213 : 		ALERT( at_error, "failed to create static from entity %s\n", pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CI@GEAK@failed?5to?5create?5static?5from?5ent@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1214 : 		return NULL;

	mov	DWORD PTR $T52211[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	eax, DWORD PTR $T52211[ebp]
	jmp	SHORT $L49834
$L49845:

; 1216 : 
; 1217 : 	pActor->setName( pObject->GetClassname( ));

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+12]

; 1218 : //	pActor->setGlobalPose( pose );
; 1219 : 	pObject->m_iActorType = ACTOR_STATIC;

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	BYTE PTR [eax+1604], 4

; 1220 : 	pObject->m_pUserData = pActor;

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR [ecx+244], edx

; 1221 : 
; 1222 : 	return pActor;

	mov	eax, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR $T52212[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	eax, DWORD PTR $T52212[ebp]
$L49834:

; 1223 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__unwindfunclet$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1:
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	ret	0
__unwindfunclet$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2:
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	ret	0
__ehhandler$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateStaticBodyFromEntity@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::CreateStaticBodyFromEntity
PUBLIC	??4NxMat33@@QAEABV0@ABV0@@Z			; NxMat33::operator=
;	COMDAT ??4NxMat34@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4NxMat34@@QAEAAV0@ABV0@@Z PROC NEAR			; NxMat34::operator=, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4NxMat33@@QAEABV0@ABV0@@Z		; NxMat33::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4NxVec3@@QAEABV0@ABV0@@Z		; NxVec3::operator=
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4NxMat34@@QAEAAV0@ABV0@@Z ENDP			; NxMat34::operator=
_TEXT	ENDS
;	COMDAT ??4NxMat33@@QAEABV0@ABV0@@Z
_TEXT	SEGMENT
_a$ = 8
_this$ = -4
??4NxMat33@@QAEABV0@ABV0@@Z PROC NEAR			; NxMat33::operator=, COMDAT

; 384  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 	data = a.data;

	mov	esi, DWORD PTR _a$[ebp]
	mov	ecx, 9
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd

; 386  : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 387  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4NxMat33@@QAEABV0@ABV0@@Z ENDP			; NxMat33::operator=
_TEXT	ENDS
;	COMDAT ?CreateVehicle@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_this$ = -4
?CreateVehicle@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@H@Z PROC NEAR ; CPhysicNovodex::CreateVehicle, COMDAT

; 1226 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1227 : #if defined (HAS_PHYSIC_VEHICLE)
; 1228 : 	NxBoxShapeDesc	boxShapes[MAXSTUDIOBONES];
; 1229 : 	vehicleparams_t	vehicleParams;
; 1230 : 	NxVehicleDesc	vehicleDesc;
; 1231 : 	int		i, j, index;
; 1232 : 	int		wheel_count;
; 1233 : 	Vector		wheel_pos;
; 1234 : 
; 1235 : 	if( UTIL_GetModelType( pObject->pev->modelindex ) != mod_studio )
; 1236 : 	{
; 1237 : 		ALERT( at_error, "CreateVehicle: not a studio model\n" );
; 1238 : 		return NULL;
; 1239 :           }
; 1240 : 
; 1241 : 	if( !ParseVehicleScript( STRING( scriptName ), vehicleParams ))
; 1242 : 	{
; 1243 : 		ALERT( at_error, "CreateVehicle: couldn't load %s\n", STRING( scriptName ));
; 1244 : 		return NULL;
; 1245 :           }
; 1246 : 
; 1247 : 	model_t *smodel = (model_t *)MODEL_HANDLE( pObject->pev->modelindex );
; 1248 : 	studiohdr_t *phdr = (studiohdr_t *)smodel->cache.data;
; 1249 : 
; 1250 : 	if( !phdr || phdr->numbones < 1 )
; 1251 : 	{
; 1252 : 		ALERT( at_error, "CreateVehicle: bad model header\n" );
; 1253 : 		return NULL;
; 1254 : 	}
; 1255 : 
; 1256 : 	// compute default pose for building mesh from
; 1257 : 	mstudioseqdesc_t *pseqdesc = (mstudioseqdesc_t *)((byte *)phdr + phdr->seqindex);
; 1258 : 	mstudioseqgroup_t *pseqgroup = (mstudioseqgroup_t *)((byte *)phdr + phdr->seqgroupindex) + pseqdesc->seqgroup;
; 1259 : 	mstudioattachment_t	*pattachment = (mstudioattachment_t *) ((byte *)phdr + phdr->attachmentindex);
; 1260 : 	mstudioanim_t *panim = (mstudioanim_t *)((byte *)phdr + pseqgroup->data + pseqdesc->animindex);
; 1261 : 	mstudiobone_t *pbone = (mstudiobone_t *)((byte *)phdr + phdr->boneindex);
; 1262 : 	static Vector pos[MAXSTUDIOBONES];
; 1263 : 	static Vector4D q[MAXSTUDIOBONES];
; 1264 : 
; 1265 : 	for( i = 0; i < phdr->numbones; i++, pbone++, panim++ )
; 1266 : 	{
; 1267 : 		StudioCalcBoneQuaterion( pbone, panim, q[i] );
; 1268 : 		StudioCalcBonePosition( pbone, panim, pos[i] );
; 1269 : 	}
; 1270 : 
; 1271 : 	pbone = (mstudiobone_t *)((byte *)phdr + phdr->boneindex);
; 1272 : 	matrix4x4	transform, bonematrix, bonetransform[MAXSTUDIOBONES];
; 1273 : 	transform.Identity();
; 1274 : 
; 1275 : 	// compute bones for default anim
; 1276 : 	for( i = 0; i < phdr->numbones; i++ ) 
; 1277 : 	{
; 1278 : 		// initialize bonematrix
; 1279 : 		bonematrix = matrix3x4( pos[i], q[i] );
; 1280 : 
; 1281 : 		if( pbone[i].parent == -1 ) 
; 1282 : 			bonetransform[i] = transform.ConcatTransforms( bonematrix );
; 1283 : 		else bonetransform[i] = bonetransform[pbone[i].parent].ConcatTransforms( bonematrix );
; 1284 : 	}
; 1285 : 
; 1286 : 	// create body vehicle from hitboxes
; 1287 : 	for( i = 0; i < phdr->numhitboxes; i++ )
; 1288 : 	{
; 1289 : 		mstudiobbox_t	*pbbox = (mstudiobbox_t *)((byte *)phdr + phdr->hitboxindex);
; 1290 : 		vec3_t		tmp, p[8], mins, maxs, size, pos;
; 1291 : 
; 1292 : 		ClearBounds( mins , maxs );
; 1293 : 
; 1294 : 		for( j = 0; j < 8; j++ )
; 1295 : 		{
; 1296 : 			tmp[0] = (j & 1) ? pbbox[i].bbmin[0] : pbbox[i].bbmax[0];
; 1297 : 			tmp[1] = (j & 2) ? pbbox[i].bbmin[1] : pbbox[i].bbmax[1];
; 1298 : 			tmp[2] = (j & 4) ? pbbox[i].bbmin[2] : pbbox[i].bbmax[2];
; 1299 : 			p[j] = bonetransform[pbbox[i].bone].VectorTransform( tmp );
; 1300 : 			AddPointToBounds( p[j], mins, maxs );
; 1301 : 		}
; 1302 : 
; 1303 : 		boxShapes[i].dimensions.set( NxVec3( maxs - mins ) * 0.5 );		// half-size
; 1304 : 		boxShapes[i].localPose.t.set( NxVec3(( mins + maxs ) * 0.5f ));	// origin
; 1305 : 		vehicleDesc.carShapes.pushBack( &boxShapes[i] );
; 1306 : 	}
; 1307 : 
; 1308 : 	vehicleDesc.mass = 1200.0f;
; 1309 : 	vehicleDesc.digitalSteeringDelta = 0.04f;
; 1310 : 	vehicleDesc.steeringMaxAngle = 30.0f;
; 1311 : 	vehicleDesc.motorForce = 3500.0f;
; 1312 : 	vehicleDesc.centerOfMass.set( -24, 0, -16 );
; 1313 : 	vehicleDesc.maxVelocity = 60.0f;
; 1314 : 	float scale = 32.0f;
; 1315 : 
; 1316 : 	NxVehicleMotorDesc motorDesc;
; 1317 : 	NxVehicleGearDesc gearDesc;
; 1318 : 	NxWheelDesc wheelDesc[VEHICLE_MAX_WHEEL_COUNT];
; 1319 : 	NxReal wheelRadius = 20.0f;
; 1320 : 
; 1321 : 	gearDesc.setToCorvette();
; 1322 : 	motorDesc.setToCorvette();
; 1323 : 
; 1324 : 	vehicleDesc.motorDesc = &motorDesc;
; 1325 : 	vehicleDesc.gearDesc = &gearDesc;
; 1326 : 
; 1327 : 	// setup wheels
; 1328 : 	for( i = wheel_count = 0; i < vehicleParams.axleCount; i++ )
; 1329 : 	{
; 1330 : 		axleparams_t *axle = &vehicleParams.axles[i];
; 1331 : 
; 1332 : 		for( j = 0; j < axle->wheelsPerAxle; j++ )
; 1333 : 		{
; 1334 : 			wheelparams_t *wheel = &axle->wheels[j];
; 1335 : 			NxU32 flags = NX_WF_USE_WHEELSHAPE;
; 1336 : 
; 1337 : 			wheelDesc[wheel_count].wheelApproximation = 10;
; 1338 : 			wheelDesc[wheel_count].wheelRadius = wheel->radius;
; 1339 : 			wheelDesc[wheel_count].wheelWidth = 0.1f * scale;	// FIXME
; 1340 : 			wheelDesc[wheel_count].wheelSuspension = axle->suspension.springHeight;
; 1341 : 			wheelDesc[wheel_count].springRestitution = axle->suspension.springConstant;
; 1342 : 			wheelDesc[wheel_count].springDamping = axle->suspension.springDamping;
; 1343 : 			wheelDesc[wheel_count].springBias = axle->suspension.springDampingCompression;
; 1344 : 			wheelDesc[wheel_count].maxBrakeForce = axle->suspension.brakeForce;
; 1345 : 			wheelDesc[wheel_count].frictionToFront = wheel->frontFriction;
; 1346 : 			wheelDesc[wheel_count].frictionToSide = wheel->sideFriction;
; 1347 : 			wheelDesc[wheel_count].wheelPoseParamIndex = pObject->LookupPoseParameter( wheel->wheelName );
; 1348 : 			wheelDesc[wheel_count].suspensionPoseParamIndex = pObject->LookupPoseParameter( wheel->suspensionName );
; 1349 : 
; 1350 : 			// set wheel flags
; 1351 : 			if( axle->steerable )
; 1352 : 				SetBits( flags, NX_WF_STEERABLE_INPUT );
; 1353 : 
; 1354 : 			if( axle->driven )
; 1355 : 				SetBits( flags, NX_WF_ACCELERATED );
; 1356 : 
; 1357 : 			if( axle->affectBrake )
; 1358 : 				SetBits( flags, NX_WF_AFFECTED_BY_HANDBRAKE );
; 1359 : 
; 1360 : 			wheelDesc[wheel_count].wheelFlags = flags;
; 1361 : 
; 1362 : 			// set wheel position
; 1363 : 			if(( index = FindAttachmentByName( phdr, wheel->attachmentName )) != -1 )
; 1364 : 			{
; 1365 : 				wheel_pos = bonetransform[pattachment[index].bone].VectorTransform( pattachment[i].org );
; 1366 : 				wheelDesc[wheel_count].position.set( NxVec3( wheel_pos ));
; 1367 : 			}
; 1368 : 			vehicleDesc.carWheels.pushBack( &wheelDesc[wheel_count] );
; 1369 : 			wheel_count++;
; 1370 : 		}
; 1371 : 	}
; 1372 : 
; 1373 : 	vehicleDesc.steeringSteerPoint.set( 1.8 * scale, 0, 0 );
; 1374 : 	vehicleDesc.steeringTurnPoint.set( -1.5 * scale, 0, 0 );
; 1375 : 
; 1376 : 	NxVehicle *pVehicle = NxVehicle :: createVehicle( m_pScene, pObject, &vehicleDesc );
; 1377 : 
; 1378 : 	if( !pVehicle )
; 1379 : 	{
; 1380 : 		ALERT( at_error, "failed to create vehicle from entity %s\n", pObject->GetClassname( ));
; 1381 : 		return NULL;
; 1382 : 	}
; 1383 : 
; 1384 : 	// get steer controller index
; 1385 : 	pVehicle->steerPoseParamIndex = pObject->LookupPoseParameter( vehicleParams.steering.steeringName );
; 1386 : 
; 1387 : 	NxActor *pActor = pVehicle->getActor();
; 1388 : 
; 1389 : 	if( !pActor )
; 1390 : 	{
; 1391 : 		ALERT( at_error, "failed to create vehicle from entity %s\n", pObject->GetClassname( ));
; 1392 : 		delete pVehicle;
; 1393 : 		return NULL;
; 1394 : 	}
; 1395 : 
; 1396 : 	pActor->setName( pObject->GetClassname( ));
; 1397 : 
; 1398 : 	NxMat34 pose;
; 1399 : 	float mat[16];
; 1400 : 	matrix4x4( pObject->GetAbsOrigin(), pObject->GetAbsAngles(), 1.0f ).CopyToArray( mat );
; 1401 : 
; 1402 : 	pose.setColumnMajor44( mat );
; 1403 : 	pActor->setGlobalPose( pose );
; 1404 : 	pActor->setLinearVelocity( pObject->GetLocalVelocity() );
; 1405 : 	pActor->setAngularVelocity( pObject->GetLocalAvelocity() );
; 1406 : 
; 1407 : 	return pVehicle;
; 1408 : #else
; 1409 : 	return NULL;

	xor	eax, eax

; 1410 : #endif
; 1411 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CreateVehicle@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@H@Z ENDP ; CPhysicNovodex::CreateVehicle
_TEXT	ENDS
;	COMDAT ?UpdateVehicle@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?UpdateVehicle@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::UpdateVehicle, COMDAT

; 1414 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1415 : #if defined (HAS_PHYSIC_VEHICLE)
; 1416 : 	if( !pObject || pObject->m_iActorType != ACTOR_VEHICLE )
; 1417 : 		return;
; 1418 : 
; 1419 : 	NxVehicle *pVehicle = (NxVehicle *)pObject->m_pUserData;
; 1420 : 
; 1421 : 	for( NxU32 i = 0; i < pVehicle->getNbWheels(); i++ )
; 1422 : 	{
; 1423 : 		NxWheel *pWheel = (NxWheel *)pVehicle->getWheel( i );	
; 1424 : 
; 1425 : 		pObject->SetPoseParameter( pWheel->wheelPoseParamIndex, -pWheel->getRollAngle( ));
; 1426 : 		pObject->SetPoseParameter( pWheel->suspensionPoseParamIndex, pWheel->getSuspensionHeight( ));
; 1427 : 	}
; 1428 : 
; 1429 : 	CBaseEntity *pDriver = pObject->GetVehicleDriver();
; 1430 : 
; 1431 : 	if( pDriver != NULL )
; 1432 : 	{
; 1433 : 		bool left = !!FBitSet( pDriver->pev->button, IN_MOVELEFT );
; 1434 : 		bool right = !!FBitSet( pDriver->pev->button, IN_MOVERIGHT );
; 1435 : 		bool forward = !!FBitSet( pDriver->pev->button, IN_FORWARD );
; 1436 : 		bool backward = !!FBitSet( pDriver->pev->button, IN_BACK );
; 1437 : 		bool handBrake = !!FBitSet( pDriver->pev->button, IN_JUMP );
; 1438 : 
; 1439 : 		NxReal steering = 0;
; 1440 : 		if( left && !right) steering = -1;
; 1441 : 		else if (right && !left) steering = 1;
; 1442 : 		NxReal acceleration = 0;
; 1443 : 		if (forward && !backward) acceleration = -1;
; 1444 : 		else if (backward && !forward) acceleration = 1;
; 1445 : 
; 1446 : 		pVehicle->control( steering, false, acceleration, false, handBrake );
; 1447 : 		pObject->SetPoseParameter( pVehicle->steerPoseParamIndex, pVehicle->getSteeringAngle() );
; 1448 : 	}
; 1449 : 
; 1450 : 	pVehicle->updateVehicle( gpGlobals->frametime );
; 1451 : #endif
; 1452 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateVehicle@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::UpdateVehicle
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@PAM@Z				; matrix4x4::matrix4x4
PUBLIC	?GetOrigin@matrix4x4@@QBE?AVVector@@XZ		; matrix4x4::GetOrigin
PUBLIC	?GetAngles@matrix4x4@@QAE?AVVector@@XZ		; matrix4x4::GetAngles
PUBLIC	?getColumnMajor44@NxMat34@@QBEXPAM@Z		; NxMat34::getColumnMajor44
EXTRN	??0Vector@@QAE@ABVNxVec3@@@Z:NEAR		; Vector::Vector
EXTRN	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalOrigin
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalVelocity
EXTRN	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAvelocity
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z$0
xdata$x	ENDS
;	COMDAT ?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T52232 = -244
$T52233 = -256
$T52234 = -268
$T52235 = -280
$T52236 = -292
$T52237 = -304
$T52238 = -308
__$EHRec$ = -12
_pEntity$ = 8
_this$ = -16
_pActor$ = -20
_pose$ = -68
_mat$ = -132
_m$ = -196
_angles$ = -208
_origin$ = -220
_vecPrevOrigin$ = -232
?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::UpdateEntityPos, COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1456 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1457 : 
; 1458 : 	if( !pActor || pActor->isSleeping( ))

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L49867
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+320]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L49866
$L49867:

; 1459 : 		return false;

	xor	al, al
	jmp	$L49864
$L49866:

; 1460 : 
; 1461 : 	NxMat34 pose = pActor->getGlobalPose();

	lea	eax, DWORD PTR _pose$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+36]
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1462 : 	float mat[16];
; 1463 : 
; 1464 : 	pose.getColumnMajor44( mat );

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?getColumnMajor44@NxMat34@@QBEXPAM@Z	; NxMat34::getColumnMajor44

; 1465 : 	matrix4x4	m( mat );

	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m$[ebp]
	call	??0matrix4x4@@QAE@PAM@Z			; matrix4x4::matrix4x4

; 1466 : 
; 1467 : 	Vector angles = m.GetAngles();

	lea	edx, DWORD PTR $T52232[ebp]
	push	edx
	lea	ecx, DWORD PTR _m$[ebp]
	call	?GetAngles@matrix4x4@@QAE?AVVector@@XZ	; matrix4x4::GetAngles
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1468 : 	Vector origin = m.GetOrigin();

	lea	eax, DWORD PTR $T52233[ebp]
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	?GetOrigin@matrix4x4@@QBE?AVVector@@XZ	; matrix4x4::GetOrigin
	push	eax
	lea	ecx, DWORD PTR _origin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1469 : 
; 1470 : 	// store actor velocities too
; 1471 : 	pEntity->SetLocalVelocity( pActor->getLinearVelocity() );

	lea	ecx, DWORD PTR $T52235[ebp]
	push	ecx
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+232]
	push	eax
	lea	ecx, DWORD PTR $T52234[ebp]
	call	??0Vector@@QAE@ABVNxVec3@@@Z		; Vector::Vector
	lea	ecx, DWORD PTR $T52234[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity

; 1472 : 	pEntity->SetLocalAvelocity( pActor->getAngularVelocity() );

	lea	edx, DWORD PTR $T52237[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+236]
	push	eax
	lea	ecx, DWORD PTR $T52236[ebp]
	call	??0Vector@@QAE@ABVNxVec3@@@Z		; Vector::Vector
	lea	eax, DWORD PTR $T52236[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity

; 1473 : 	Vector vecPrevOrigin = pEntity->GetAbsOrigin();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecPrevOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1474 : 
; 1475 : 	pEntity->SetLocalAngles( angles );

	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1476 : 	pEntity->SetLocalOrigin( origin );

	lea	edx, DWORD PTR _origin$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 1477 : 	pEntity->RelinkEntity( TRUE, &vecPrevOrigin );

	push	0
	lea	eax, DWORD PTR _vecPrevOrigin$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 1478 : 
; 1479 : 	return true;

	mov	BYTE PTR $T52238[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	al, BYTE PTR $T52238[ebp]
$L49864:

; 1480 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?UpdateEntityPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::UpdateEntityPos
;	COMDAT ??0matrix4x4@@QAE@PAM@Z
_TEXT	SEGMENT
_opengl_matrix$ = 8
_this$ = -4
??0matrix4x4@@QAE@PAM@Z PROC NEAR			; matrix4x4::matrix4x4, COMDAT

; 680  : 	matrix4x4( float *opengl_matrix )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 681  : 	{
; 682  : 		mat[0][0] = opengl_matrix[0];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 683  : 		mat[0][1] = opengl_matrix[1];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 684  : 		mat[0][2] = opengl_matrix[2];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 685  : 		mat[0][3] = opengl_matrix[3];

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 686  : 		mat[1][0] = opengl_matrix[4];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax], edx

; 687  : 		mat[1][1] = opengl_matrix[5];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx

; 688  : 		mat[1][2] = opengl_matrix[6];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx

; 689  : 		mat[1][3] = opengl_matrix[7];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx

; 690  : 		mat[2][0] = opengl_matrix[8];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax], edx

; 691  : 		mat[2][1] = opengl_matrix[9];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+4], edx

; 692  : 		mat[2][2] = opengl_matrix[10];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+8], edx

; 693  : 		mat[2][3] = opengl_matrix[11];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+12], edx

; 694  : 		mat[3][0] = opengl_matrix[12];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax], edx

; 695  : 		mat[3][1] = opengl_matrix[13];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+4], edx

; 696  : 		mat[3][2] = opengl_matrix[14];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+8], edx

; 697  : 		mat[3][3] = opengl_matrix[15];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _opengl_matrix$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+12], edx

; 698  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@PAM@Z ENDP				; matrix4x4::matrix4x4
_TEXT	ENDS
PUBLIC	??BVector4D@@QBE?BVVector@@XZ			; Vector4D::operator Vector const 
;	COMDAT ?GetOrigin@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
$T52250 = -16
$T52251 = -28
___$ReturnUdt$ = 8
_this$ = -4
?GetOrigin@matrix4x4@@QBE?AVVector@@XZ PROC NEAR	; matrix4x4::GetOrigin, COMDAT

; 980  : 	Vector	GetOrigin() const { return mat[3]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T52251[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QBE?BVVector@@XZ		; Vector4D::operator Vector const 
	push	eax
	lea	ecx, DWORD PTR $T52250[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR $T52250[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix4x4@@QBE?AVVector@@XZ ENDP		; matrix4x4::GetOrigin
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT
$T52254 = -16
___$ReturnUdt$ = 8
_this$ = -4
??BVector4D@@QBE?BVVector@@XZ PROC NEAR			; Vector4D::operator Vector const , COMDAT

; 330  : 	operator const Vector() const				{ return Vector( x, y, z ); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR $T52254[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??BVector4D@@QBE?BVVector@@XZ ENDP			; Vector4D::operator Vector const 
_TEXT	ENDS
PUBLIC	__real@4@3ff583126f0000000000
PUBLIC	__real@4@4004e52ee10000000000
EXTRN	_atan2:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT __real@4@3ff583126f0000000000
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@4@3ff583126f0000000000 DD 03a83126fr	; 0.001
CONST	ENDS
;	COMDAT __real@4@4004e52ee10000000000
CONST	SEGMENT
__real@4@4004e52ee10000000000 DD 042652ee1r	; 57.2958
CONST	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_xyDist$ = -8
_angles$ = -20
?GetAngles@matrix4x4@@QAE?AVVector@@XZ PROC NEAR	; matrix4x4::GetAngles, COMDAT

; 993  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 994  : 		float xyDist = sqrt( mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -24+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _xyDist$[ebp]

; 995  : 		Vector angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 996  : 
; 997  : 		// enough here to get angles?
; 998  : 		if( xyDist > 0.001f )

	fld	DWORD PTR _xyDist$[ebp]
	fcomp	DWORD PTR __real@4@3ff583126f0000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L26109

; 1000 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -28+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -32+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax], ecx

; 1001 : 			angles[1] = RAD2DEG( atan2( mat[0][1], mat[0][0] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -36+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -40+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+4], edx

; 1002 : 			angles[2] = RAD2DEG( atan2( mat[1][2], mat[2][2] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -44+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -48+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1004 : 		else	// forward is mostly Z, gimbal lock

	jmp	$L26116
$L26109:

; 1006 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -52+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -56+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax], edx

; 1007 : 			angles[1] = RAD2DEG( atan2( -mat[1][0], mat[1][1] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -60+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -64+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1008 : 			angles[2] = 0;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0
$L26116:

; 1010 : 
; 1011 : 		return angles;

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1012 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix4x4@@QAE?AVVector@@XZ ENDP		; matrix4x4::GetAngles
_TEXT	ENDS
PUBLIC	?getColumnMajorStride4@NxMat33@@QBEXPAM@Z	; NxMat33::getColumnMajorStride4
;	COMDAT ?getColumnMajor44@NxMat34@@QBEXPAM@Z
_TEXT	SEGMENT
_d$ = 8
_this$ = -4
?getColumnMajor44@NxMat34@@QBEXPAM@Z PROC NEAR		; NxMat34::getColumnMajor44, COMDAT

; 252  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 253  : 	M.getColumnMajorStride4(d);

	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getColumnMajorStride4@NxMat33@@QBEXPAM@Z ; NxMat33::getColumnMajorStride4

; 254  :     d[12] = t.x;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+48], eax

; 255  : 	d[13] = t.y;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+52], eax

; 256  : 	d[14] = t.z;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+56], eax

; 257  : 	d[3] = d[7] = d[11] = 0.0f;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [edx+28], 0
	mov	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR [eax+12], 0

; 258  : 	d[15] = 1.0f;

	mov	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR [ecx+60], 1065353216		; 3f800000H

; 259  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?getColumnMajor44@NxMat34@@QBEXPAM@Z ENDP		; NxMat34::getColumnMajor44
_TEXT	ENDS
;	COMDAT ?getColumnMajorStride4@NxMat33@@QBEXPAM@Z
_TEXT	SEGMENT
_d$ = 8
_this$ = -4
?getColumnMajorStride4@NxMat33@@QBEXPAM@Z PROC NEAR	; NxMat33::getColumnMajorStride4, COMDAT

; 632  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 	//we are column major, so copy transposed.
; 634  : 	//however we've got to skip every 4th element.
; 635  : 	d[0] = (NxF32)data.s._11;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 636  : 	d[4] = (NxF32)data.s._12;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+16], edx

; 637  : 	d[8] = (NxF32)data.s._13;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+32], edx

; 638  : 
; 639  : 	d[1] = (NxF32)data.s._21;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx

; 640  : 	d[5] = (NxF32)data.s._22;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+20], edx

; 641  : 	d[9] = (NxF32)data.s._23;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+36], edx

; 642  : 
; 643  : 	d[2] = (NxF32)data.s._31;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+8], edx

; 644  : 	d[6] = (NxF32)data.s._32;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+24], edx

; 645  : 	d[10]= (NxF32)data.s._33;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+40], edx

; 646  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?getColumnMajorStride4@NxMat33@@QBEXPAM@Z ENDP		; NxMat33::getColumnMajorStride4
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z$0
xdata$x	ENDS
;	COMDAT ?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T52267 = -208
$T52268 = -220
$T52269 = -224
__$EHRec$ = -12
_pEntity$ = 8
_this$ = -16
_pActor$ = -20
_pose$ = -68
_mat$ = -132
_m$ = -196
?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::UpdateActorPos, COMDAT

; 1483 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 276				; 00000114H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1484 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1485 : 	if( !pActor ) return false;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49887
	xor	al, al
	jmp	$L49885
$L49887:

; 1486 : 
; 1487 : 	NxMat34 pose;

	push	1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1488 : 	float mat[16];
; 1489 : 
; 1490 : 	matrix4x4	m( pEntity->GetAbsOrigin(), pEntity->GetAbsAngles(), 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 1491 : 	m.CopyToArray( mat );

	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m$[ebp]
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 1492 : 
; 1493 : 	pose.setColumnMajor44( mat );

	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?setColumnMajor44@NxMat34@@QAEXPBM@Z	; NxMat34::setColumnMajor44

; 1494 : 	pActor->setGlobalPose( pose );

	lea	eax, DWORD PTR _pose$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+20]

; 1495 : 
; 1496 : 	if( !pActor->readBodyFlag( NX_BF_KINEMATIC ))

	push	128					; 00000080H
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+364]
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L49891

; 1498 : 		pActor->setLinearVelocity( pEntity->GetLocalVelocity() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalVelocity
	push	eax
	lea	ecx, DWORD PTR $T52267[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T52267[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+224]

; 1499 : 		pActor->setAngularVelocity( pEntity->GetLocalAvelocity() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
	push	eax
	lea	ecx, DWORD PTR $T52268[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T52268[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+228]
$L49891:

; 1501 : 
; 1502 : 	return true;

	mov	BYTE PTR $T52269[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	al, BYTE PTR $T52269[ebp]
$L49885:

; 1503 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?UpdateActorPos@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::UpdateActorPos
;	COMDAT ?IsBodySleeping@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
_pActor$ = -8
?IsBodySleeping@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::IsBodySleeping, COMDAT

; 1506 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1507 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1508 : 	if( !pActor ) return false;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49900
	xor	al, al
	jmp	SHORT $L49898
$L49900:

; 1509 : 	return pActor->isSleeping();

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+320]
$L49898:

; 1510 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsBodySleeping@CPhysicNovodex@@UAE_NPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::IsBodySleeping
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
EXTRN	?ClearBounds@@YAXAAVVector@@0@Z:NEAR		; ClearBounds
EXTRN	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z:NEAR	; AddPointToBounds
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0
xdata$x	ENDS
;	COMDAT ?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T52281 = -64
$T52282 = -76
$T52283 = -88
$T52284 = -100
$T52285 = -112
__$EHRec$ = -12
_pEntity$ = 8
_this$ = -16
_pActor$ = -20
_i$ = -24
_pShape$49912 = -28
_bbox$49913 = -52
?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::UpdateEntityAABB, COMDAT

; 1513 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1514 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1515 : 
; 1516 : 	if( !pActor || pActor->getNbShapes() <= 0 )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L49907
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	ja	SHORT $L49906
$L49907:

; 1517 : 		return;

	jmp	$L49904
$L49906:

; 1518 : 
; 1519 : 	ClearBounds( pEntity->pev->absmin, pEntity->pev->absmax );

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 208				; 000000d0H
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 196				; 000000c4H
	push	eax
	call	?ClearBounds@@YAXAAVVector@@0@Z		; ClearBounds
	add	esp, 8

; 1520 : 
; 1521 : 	for( uint i = 0; i < pActor->getNbShapes(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L49909
$L49910:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L49909:
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+76]
	cmp	DWORD PTR _i$[ebp], eax
	jae	$L49911

; 1523 : 		NxShape *pShape = pActor->getShapes()[i];

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pShape$49912[ebp], edx

; 1524 : 		NxBounds3 bbox;

	lea	ecx, DWORD PTR _bbox$49913[ebp]
	call	??0NxBounds3@@QAE@XZ			; NxBounds3::NxBounds3
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1525 : 
; 1526 : 		// already transformed as OBB
; 1527 : 		pShape->getWorldBounds( bbox );

	lea	eax, DWORD PTR _bbox$49913[ebp]
	push	eax
	mov	ecx, DWORD PTR _pShape$49912[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pShape$49912[ebp]
	call	DWORD PTR [edx+16]

; 1528 : 
; 1529 : 		AddPointToBounds( bbox.min, pEntity->pev->absmin, pEntity->pev->absmax );

	lea	eax, DWORD PTR _bbox$49913[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52281[ebp]
	call	??0Vector@@QAE@ABVNxVec3@@@Z		; Vector::Vector
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 208				; 000000d0H
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 196				; 000000c4H
	push	ecx
	lea	edx, DWORD PTR $T52281[ebp]
	push	edx
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H

; 1530 : 		AddPointToBounds( bbox.max, pEntity->pev->absmin, pEntity->pev->absmax );

	lea	eax, DWORD PTR _bbox$49913[ebp+12]
	push	eax
	lea	ecx, DWORD PTR $T52282[ebp]
	call	??0Vector@@QAE@ABVNxVec3@@@Z		; Vector::Vector
	push	0
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 208				; 000000d0H
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 196				; 000000c4H
	push	ecx
	lea	edx, DWORD PTR $T52282[ebp]
	push	edx
	call	?AddPointToBounds@@YAXABVVector@@AAV1@1M@Z ; AddPointToBounds
	add	esp, 16					; 00000010H

; 1531 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bbox$49913[ebp]
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	jmp	$L49910
$L49911:

; 1532 : 
; 1533 : 	// shrink AABB by 1 units in each axis
; 1534 : 	// or pushers can't be moving them
; 1535 : 	pEntity->pev->absmin.x += 1;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+196]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+196]

; 1536 : 	pEntity->pev->absmin.y += 1;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+200]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+200]

; 1537 : 	pEntity->pev->absmin.z += 1;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+204]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+204]

; 1538 : 	pEntity->pev->absmax.x -= 1;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+208]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+208]

; 1539 : 	pEntity->pev->absmax.y -= 1;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+212]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+212]

; 1540 : 	pEntity->pev->absmax.z -= 1;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+216]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+216]

; 1541 : 
; 1542 : 	pEntity->pev->mins = pEntity->pev->absmin - pEntity->pev->origin;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR $T52283[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 196				; 000000c4H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1543 : 	pEntity->pev->maxs = pEntity->pev->absmax - pEntity->pev->origin;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR $T52284[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 232				; 000000e8H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1544 : 	pEntity->pev->size = pEntity->pev->maxs - pEntity->pev->mins;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	push	edx
	lea	eax, DWORD PTR $T52285[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 232				; 000000e8H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L49904:

; 1545 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _bbox$49913[ebp]
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	ret	0
__ehhandler$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?UpdateEntityAABB@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::UpdateEntityAABB
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
$T52295 = -16
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T52295[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
PUBLIC	??_C@_0CK@HPGI@SaveBody?3?5physic?5entity?5?$CFi?5misse@ ; `string'
;	COMDAT ??_C@_0CK@HPGI@SaveBody?3?5physic?5entity?5?$CFi?5misse@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CK@HPGI@SaveBody?3?5physic?5entity?5?$CFi?5misse@ DB 'SaveBody: ph'
	DB	'ysic entity %i missed actor!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$1
xdata$x	ENDS
;	COMDAT ?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_pEntity$ = 8
_this$ = -16
_pActor$ = -20
_actorDesc$ = -124
_bodyDesc$ = -260
?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::SaveBody, COMDAT

; 1598 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 312				; 00000138H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1599 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1600 : 
; 1601 : 	if( !pActor )

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49924

; 1603 : 		ALERT( at_warning, "SaveBody: physic entity %i missed actor!\n", pEntity->m_iActorType );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	push	edx
	push	OFFSET FLAT:??_C@_0CK@HPGI@SaveBody?3?5physic?5entity?5?$CFi?5misse@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1604 : 		return;

	jmp	$L49922
$L49924:

; 1606 : 
; 1607 : 	NxActorDesc actorDesc;

	lea	ecx, DWORD PTR _actorDesc$[ebp]
	call	??0NxActorDesc@@QAE@XZ			; NxActorDesc::NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1608 : 	NxBodyDesc bodyDesc;

	lea	ecx, DWORD PTR _bodyDesc$[ebp]
	call	??0NxBodyDesc@@QAE@XZ			; NxBodyDesc::NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1609 : 
; 1610 : 	pActor->saveToDesc( actorDesc );

	lea	eax, DWORD PTR _actorDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+8]

; 1611 : 	pActor->saveBodyToDesc( bodyDesc );

	lea	eax, DWORD PTR _bodyDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+368]

; 1612 : 
; 1613 : 	pEntity->m_iActorFlags = actorDesc.flags;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR _actorDesc$[ebp+56]
	mov	DWORD PTR [eax+1608], ecx

; 1614 : 	pEntity->m_iBodyFlags = bodyDesc.flags;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR _bodyDesc$[ebp+108]
	mov	DWORD PTR [edx+1612], eax

; 1615 : 	pEntity->m_usActorGroup = actorDesc.group;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	dx, WORD PTR _actorDesc$[ebp+60]
	mov	WORD PTR [ecx+1616], dx

; 1616 : 	pEntity->m_flBodyMass = bodyDesc.mass;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR _bodyDesc$[ebp+60]
	mov	DWORD PTR [eax+1620], ecx

; 1617 : 	pEntity->m_fFreezed = pActor->isSleeping();

	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+320]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [ecx+1624], eax

; 1618 : 
; 1619 : 	if( pEntity->m_iActorType == ACTOR_DYNAMIC )

	mov	edx, DWORD PTR _pEntity$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 1
	jne	SHORT $L49928

; 1621 : 		// update movement variables
; 1622 : 		UpdateEntityPos( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+116]
$L49928:

; 1624 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _bodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
$L49922:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _actorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	ret	0
__unwindfunclet$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$1:
	lea	ecx, DWORD PTR _bodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	ret	0
__ehhandler$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?SaveBody@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ENDP	; CPhysicNovodex::SaveBody
PUBLIC	?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::size
PUBLIC	??_C@_0CE@LIJA@RestoreBody?3?5invalid?5actor?5type?5@ ; `string'
PUBLIC	??_C@_0DE@PPLN@RestoreBody?3?5unbale?5to?5create?5ac@ ; `string'
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
EXTRN	?GetAbsAvelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAvelocity
;	COMDAT ??_C@_0CE@LIJA@RestoreBody?3?5invalid?5actor?5type?5@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0CE@LIJA@RestoreBody?3?5invalid?5actor?5type?5@ DB 'RestoreBody: in'
	DB	'valid actor type %i', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PPLN@RestoreBody?3?5unbale?5to?5create?5ac@
CONST	SEGMENT
??_C@_0DE@PPLN@RestoreBody?3?5unbale?5to?5create?5ac@ DB 'RestoreBody: un'
	DB	'bale to create actor with type (%i)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 019930520H
	DD	06H
	DD	FLAT:__unwindtable$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$5
xdata$x	ENDS
;	COMDAT ?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T52308 = -808
$T52309 = -812
$T52310 = -824
$T52311 = -828
$T52312 = -832
$T52313 = -836
$T52314 = -840
$T52315 = -844
$T52316 = -848
$T52317 = -852
__$EHRec$ = -12
_pEntity$ = 8
_this$ = -16
_meshShapeDesc$ = -132
_triMeshShapeDesc$ = -252
_boxDesc$ = -372
_ActorDesc$ = -476
_BodyDesc$ = -612
_pose$ = -660
_mat$ = -724
_angles$ = -736
_m$ = -800
_pActor$ = -804
?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::RestoreBody, COMDAT

; 1634 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 908				; 0000038cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1635 : 	// physics not initialized?
; 1636 : 	if( !m_pScene ) return NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L49933
	xor	eax, eax
	jmp	$L49932
$L49933:

; 1637 : 
; 1638 : 	NxConvexShapeDesc meshShapeDesc;

	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??0NxConvexShapeDesc@@QAE@XZ		; NxConvexShapeDesc::NxConvexShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1639 : 	NxTriangleMeshShapeDesc triMeshShapeDesc;

	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??0NxTriangleMeshShapeDesc@@QAE@XZ	; NxTriangleMeshShapeDesc::NxTriangleMeshShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1640 : 	NxBoxShapeDesc boxDesc;

	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??0NxBoxShapeDesc@@QAE@XZ		; NxBoxShapeDesc::NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1641 : 	NxActorDesc ActorDesc;

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??0NxActorDesc@@QAE@XZ			; NxActorDesc::NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 1642 : 	NxBodyDesc BodyDesc;

	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??0NxBodyDesc@@QAE@XZ			; NxBodyDesc::NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1645 : 	{

	mov	ecx, DWORD PTR _pEntity$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	mov	DWORD PTR -856+[ebp], edx
	mov	eax, DWORD PTR -856+[ebp]
	sub	eax, 1
	mov	DWORD PTR -856+[ebp], eax
	cmp	DWORD PTR -856+[ebp], 3
	ja	$L49955
	mov	ecx, DWORD PTR -856+[ebp]
	jmp	DWORD PTR $L52327[ecx*4]
$L49943:

; 1646 : 	case ACTOR_DYNAMIC:
; 1647 : 		meshShapeDesc.meshData = ConvexMeshFromEntity( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvexMeshFromEntity@CPhysicNovodex@@AAEPAVNxConvexMesh@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ConvexMeshFromEntity
	mov	DWORD PTR _meshShapeDesc$[ebp+108], eax

; 1648 : 		if( !meshShapeDesc.meshData ) return NULL;

	cmp	DWORD PTR _meshShapeDesc$[ebp+108], 0
	jne	SHORT $L49944
	mov	DWORD PTR $T52308[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	eax, DWORD PTR $T52308[ebp]
	jmp	$L49932
$L49944:

; 1649 : 		ActorDesc.shapes.pushBack( &meshShapeDesc );

	lea	eax, DWORD PTR _meshShapeDesc$[ebp]
	mov	DWORD PTR $T52309[ebp], eax
	lea	ecx, DWORD PTR $T52309[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 1650 : 		break;

	jmp	$L49940
$L49947:

; 1651 : 	case ACTOR_CHARACTER:
; 1652 : 		boxDesc.dimensions = pEntity->pev->size * PADDING_FACTOR;

	push	1056629064				; 3efae148H
	lea	edx, DWORD PTR $T52310[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _boxDesc$[ebp+108]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 1653 : 		ActorDesc.shapes.pushBack( &boxDesc );

	lea	ecx, DWORD PTR _boxDesc$[ebp]
	mov	DWORD PTR $T52311[ebp], ecx
	lea	edx, DWORD PTR $T52311[ebp]
	push	edx
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 1654 : 		break;

	jmp	$L49940
$L49950:

; 1655 : 	case ACTOR_KINEMATIC:
; 1656 : 	case ACTOR_STATIC:
; 1657 : 		triMeshShapeDesc.meshData = TriangleMeshFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TriangleMeshFromEntity@CPhysicNovodex@@AAEPAVNxTriangleMesh@@PAVCBaseEntity@@@Z ; CPhysicNovodex::TriangleMeshFromEntity
	mov	DWORD PTR _triMeshShapeDesc$[ebp+108], eax

; 1658 : 		if( !triMeshShapeDesc.meshData ) return NULL;

	cmp	DWORD PTR _triMeshShapeDesc$[ebp+108], 0
	jne	SHORT $L49951
	mov	DWORD PTR $T52312[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	eax, DWORD PTR $T52312[ebp]
	jmp	$L49932
$L49951:

; 1659 : 		if( pEntity->pev->flags & FL_CONVEYOR )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 4
	test	eax, eax
	je	SHORT $L49953

; 1660 : 			triMeshShapeDesc.materialIndex = 1;

	mov	WORD PTR _triMeshShapeDesc$[ebp+62], 1
$L49953:

; 1661 : 		ActorDesc.shapes.pushBack( &triMeshShapeDesc );

	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	mov	DWORD PTR $T52313[ebp], ecx
	lea	edx, DWORD PTR $T52313[ebp]
	push	edx
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 1662 : 		break;

	jmp	SHORT $L49940
$L49955:

; 1663 : 	default:
; 1664 : 		ALERT( at_error, "RestoreBody: invalid actor type %i\n", pEntity->m_iActorType );

	mov	eax, DWORD PTR _pEntity$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	push	ecx
	push	OFFSET FLAT:??_C@_0CE@LIJA@RestoreBody?3?5invalid?5actor?5type?5@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1665 : 		return NULL;

	mov	DWORD PTR $T52314[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	eax, DWORD PTR $T52314[ebp]
	jmp	$L49932
$L49940:

; 1667 : 
; 1668 : 	if( ActorDesc.shapes.size() <= 0 )

	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::size
	test	eax, eax
	ja	SHORT $L49958

; 1669 : 		return NULL; // failed to create shape

	mov	DWORD PTR $T52315[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	eax, DWORD PTR $T52315[ebp]
	jmp	$L49932
$L49958:

; 1670 : 
; 1671 : 	NxMat34 pose;

	push	1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1672 : 	float mat[16];
; 1673 : 
; 1674 : 	Vector angles = pEntity->GetAbsAngles();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1675 : 
; 1676 : 	if( pEntity->m_iActorType == ACTOR_CHARACTER )

	mov	edx, DWORD PTR _pEntity$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 3
	jne	SHORT $L49963

; 1677 : 		angles = g_vecZero;	// no angles for NPC and client

	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR _angles$[ebp], ecx
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR _angles$[ebp+4], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR _angles$[ebp+8], eax
$L49963:

; 1678 : 
; 1679 : 	matrix4x4	m( pEntity->GetAbsOrigin(), angles, 1.0f );

	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 1680 : 	m.CopyToArray( mat );

	lea	edx, DWORD PTR _mat$[ebp]
	push	edx
	lea	ecx, DWORD PTR _m$[ebp]
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 1681 : 	pose.setColumnMajor44( mat );

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?setColumnMajor44@NxMat34@@QAEXPBM@Z	; NxMat34::setColumnMajor44

; 1682 : 
; 1683 : 	// fill in actor description
; 1684 : 	if( pEntity->m_iActorType != ACTOR_STATIC )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	cmp	edx, 4
	je	SHORT $L49965

; 1686 : 		BodyDesc.flags = pEntity->m_iBodyFlags;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+1612]
	mov	DWORD PTR _BodyDesc$[ebp+108], ecx

; 1687 : //		BodyDesc.mass = pEntity->m_flBodyMass;
; 1688 : 		BodyDesc.solverIterationCount = SOLVER_ITERATION_COUNT;

	mov	DWORD PTR _BodyDesc$[ebp+120], 16	; 00000010H

; 1689 : 
; 1690 : 		if( pEntity->m_iActorType != ACTOR_KINEMATIC )

	mov	edx, DWORD PTR _pEntity$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 2
	je	SHORT $L49966

; 1692 : 			BodyDesc.linearVelocity = pEntity->GetAbsVelocity(); 

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _BodyDesc$[ebp+64]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 1693 : 			BodyDesc.angularVelocity = pEntity->GetAbsAvelocity();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAvelocity
	push	eax
	lea	ecx, DWORD PTR _BodyDesc$[ebp+76]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=
$L49966:

; 1695 : 
; 1696 : 		ActorDesc.body = &BodyDesc;

	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	mov	DWORD PTR _ActorDesc$[ebp+48], ecx
$L49965:

; 1698 :   
; 1699 : 	ActorDesc.density = DENSITY_FACTOR;

	mov	DWORD PTR _ActorDesc$[ebp+52], 984245443 ; 3aaa64c3H

; 1700 : 	ActorDesc.userData = pEntity->edict();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ActorDesc$[ebp+72], eax

; 1701 : 	ActorDesc.flags = pEntity->m_iActorFlags;

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+1608]
	mov	DWORD PTR _ActorDesc$[ebp+56], eax

; 1702 : 	ActorDesc.group = pEntity->m_usActorGroup;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	dx, WORD PTR [ecx+1616]
	mov	WORD PTR _ActorDesc$[ebp+60], dx

; 1703 : 	ActorDesc.globalPose = pose; // saved pose

	lea	eax, DWORD PTR _pose$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??4NxMat34@@QAEAAV0@ABV0@@Z		; NxMat34::operator=

; 1704 : 
; 1705 : 	if( pEntity->m_iActorType == ACTOR_KINEMATIC )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	cmp	edx, 2
	jne	SHORT $L49967

; 1706 : 		m_ErrorStream.hideWarning( true );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	?hideWarning@NxErrorStream@@QAEX_N@Z	; NxErrorStream::hideWarning
$L49967:

; 1707 : 
; 1708 : 	NxActor *pActor = m_pScene->createActor( ActorDesc );

	lea	eax, DWORD PTR _ActorDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+28]
	mov	DWORD PTR _pActor$[ebp], eax

; 1709 : 
; 1710 : 	if( pEntity->m_iActorType == ACTOR_KINEMATIC )

	mov	eax, DWORD PTR _pEntity$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 2
	jne	SHORT $L49969

; 1711 : 		m_ErrorStream.hideWarning( false );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1344				; 00000540H
	call	?hideWarning@NxErrorStream@@QAEX_N@Z	; NxErrorStream::hideWarning
$L49969:

; 1712 : 
; 1713 : 	if( !pActor )

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	$L49970

; 1715 : 		ALERT( at_error, "RestoreBody: unbale to create actor with type (%i)\n", pEntity->m_iActorType );

	mov	edx, DWORD PTR _pEntity$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	push	eax
	push	OFFSET FLAT:??_C@_0DE@PPLN@RestoreBody?3?5unbale?5to?5create?5ac@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1716 : 		return NULL;

	mov	DWORD PTR $T52316[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	eax, DWORD PTR $T52316[ebp]
	jmp	$L49932
$L49970:

; 1718 : 
; 1719 : 	// apply specific actor params
; 1720 : 	pActor->setName( pEntity->GetClassname( ));

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+12]

; 1721 : 	pEntity->m_pUserData = pActor;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR [eax+244], ecx

; 1722 : 
; 1723 : 	if( pEntity->m_fFreezed && pEntity->m_iActorType == ACTOR_DYNAMIC )

	mov	edx, DWORD PTR _pEntity$[ebp]
	cmp	DWORD PTR [edx+1624], 0
	je	SHORT $L49973
	mov	eax, DWORD PTR _pEntity$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 1
	jne	SHORT $L49973

; 1724 : 		pActor->putToSleep();

	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+352]
$L49973:

; 1725 : 
; 1726 : 	return pActor;

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	DWORD PTR $T52317[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	mov	eax, DWORD PTR $T52317[ebp]
$L49932:

; 1727 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L52327:
	DD	$L49943
	DD	$L49950
	DD	$L49947
	DD	$L49950
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _meshShapeDesc$[ebp]
	call	??1NxConvexShapeDesc@@UAE@XZ		; NxConvexShapeDesc::~NxConvexShapeDesc
	ret	0
__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$1:
	lea	ecx, DWORD PTR _triMeshShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	ret	0
__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$2:
	lea	ecx, DWORD PTR _boxDesc$[ebp]
	call	??1NxBoxShapeDesc@@UAE@XZ		; NxBoxShapeDesc::~NxBoxShapeDesc
	ret	0
__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$3:
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	ret	0
__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$4:
	lea	ecx, DWORD PTR _BodyDesc$[ebp]
	call	??1NxBodyDesc@@QAE@XZ			; NxBodyDesc::~NxBodyDesc
	ret	0
__unwindfunclet$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z$5:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?RestoreBody@CPhysicNovodex@@UAEPAXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::RestoreBody
PUBLIC	??0matrix3x3@@QAE@ABVVector@@@Z			; matrix3x3::matrix3x3
PUBLIC	??Bmatrix3x3@@QAEPAMXZ				; matrix3x3::operator float *
PUBLIC	?setRowMajor@NxMat33@@QAEXPBM@Z			; NxMat33::setRowMajor
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z$0
xdata$x	ENDS
;	COMDAT ?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_pEntity$ = 8
_angles$ = 12
_this$ = -16
_pActor$ = -20
_rot$ = -56
_m$ = -92
?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::SetAngles, COMDAT

; 1730 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1731 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1732 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49981
	jmp	SHORT $L49979
$L49981:

; 1733 : 
; 1734 : 	NxMat33 rot;

	lea	ecx, DWORD PTR _rot$[ebp]
	call	??0NxMat33@@QAE@XZ			; NxMat33::NxMat33
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1735 : 	matrix3x3	m( angles );

	mov	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m$[ebp]
	call	??0matrix3x3@@QAE@ABVVector@@@Z		; matrix3x3::matrix3x3

; 1736 : 	rot.setRowMajor( (float *)m );

	lea	ecx, DWORD PTR _m$[ebp]
	call	??Bmatrix3x3@@QAEPAMXZ			; matrix3x3::operator float *
	push	eax
	lea	ecx, DWORD PTR _rot$[ebp]
	call	?setRowMajor@NxMat33@@QAEXPBM@Z		; NxMat33::setRowMajor

; 1737 : 	pActor->setGlobalOrientation( rot );

	lea	edx, DWORD PTR _rot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+28]

; 1738 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _rot$[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
$L49979:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z$0:
	lea	ecx, DWORD PTR _rot$[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__ehhandler$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?SetAngles@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::SetAngles
;	COMDAT ??0matrix3x3@@QAE@ABVVector@@@Z
_TEXT	SEGMENT
_angles$ = 8
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix3x3@@QAE@ABVVector@@@Z PROC NEAR		; matrix3x3::matrix3x3, COMDAT

; 50   : 	_forceinline matrix3x3( const Vector &angles )

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	3
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 51   : 	{
; 52   : 		float	angle, sr, sp, sy, cr, cp, cy;
; 53   : 
; 54   : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25424

; 56   : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 57   : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 58   : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 59   : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 60   : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 61   : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 62   : 
; 63   : 			mat[0][0] = (cp*cy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 64   : 			mat[1][0] = (sr*sp*cy+cr*-sy);

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 65   : 			mat[2][0] = (cr*sp*cy+-sr*-sy);

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 66   : 			mat[0][1] = (cp*sy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 67   : 			mat[1][1] = (sr*sp*sy+cr*cy);

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 68   : 			mat[2][1] = (cr*sp*sy+-sr*cy);

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 69   : 			mat[0][2] = (-sp);

	fld	DWORD PTR _sp$[ebp]
	fchs
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 70   : 			mat[1][2] = (sr*cp);

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 71   : 			mat[2][2] = (cr*cp);

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 73   : 		else if( angles[PITCH] )

	jmp	$L25429
$L25424:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25426

; 75   : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 76   : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 77   : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 78   : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 79   : 
; 80   : 			mat[0][0] = (cp*cy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 81   : 			mat[1][0] = (-sy);

	fld	DWORD PTR _sy$[ebp]
	fchs
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 82   : 			mat[2][0] = (sp*cy);

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 83   : 			mat[0][1] = (cp*sy);

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 84   : 			mat[1][1] = (cy);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _cy$[ebp]
	mov	DWORD PTR [eax+4], edx

; 85   : 			mat[2][1] = (sp*sy);

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 86   : 			mat[0][2] = (-sp);

	fld	DWORD PTR _sp$[ebp]
	fchs
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+8], edx

; 87   : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 88   : 			mat[2][2] = (cp);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _cp$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 90   : 		else if( angles[YAW] )

	jmp	$L25429
$L25426:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25428

; 92   : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 93   : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 94   : 
; 95   : 			mat[0][0] = (cy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _cy$[ebp]
	mov	DWORD PTR [eax], edx

; 96   : 			mat[1][0] = (-sy);

	fld	DWORD PTR _sy$[ebp]
	fchs
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax], ecx

; 97   : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 98   : 			mat[0][1] = (sy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR _sy$[ebp]
	mov	DWORD PTR [eax+4], edx

; 99   : 			mat[1][1] = (cy);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR _cy$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 100  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 101  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 102  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 103  : 			mat[2][2] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 1065353216		; 3f800000H

; 105  : 		else

	jmp	$L25429
$L25428:

; 107  : 			mat[0][0] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 1065353216		; 3f800000H

; 108  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 109  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax], 0

; 110  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 111  : 			mat[1][1] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 1065353216		; 3f800000H

; 112  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+4], 0

; 113  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 114  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 115  : 			mat[2][2] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 1065353216		; 3f800000H
$L25429:

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix3x3@@QAE@ABVVector@@@Z ENDP			; matrix3x3::matrix3x3
_TEXT	ENDS
;	COMDAT ??Bmatrix3x3@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??Bmatrix3x3@@QAEPAMXZ PROC NEAR			; matrix3x3::operator float *, COMDAT

; 135  : 	operator float *() { return (float *)&mat[0][0]; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??Bmatrix3x3@@QAEPAMXZ ENDP				; matrix3x3::operator float *
_TEXT	ENDS
;	COMDAT ?setRowMajor@NxMat33@@QAEXPBM@Z
_TEXT	SEGMENT
_d$ = 8
_this$ = -4
?setRowMajor@NxMat33@@QAEXPBM@Z PROC NEAR		; NxMat33::setRowMajor, COMDAT

; 391  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 	//we are also row major, so this is a direct copy
; 393  : 	data.s._11 = (NxReal)d[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 394  : 	data.s._12 = (NxReal)d[1];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 395  : 	data.s._13 = (NxReal)d[2];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 396  : 
; 397  : 	data.s._21 = (NxReal)d[3];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx

; 398  : 	data.s._22 = (NxReal)d[4];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 399  : 	data.s._23 = (NxReal)d[5];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx

; 400  : 
; 401  : 	data.s._31 = (NxReal)d[6];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx

; 402  : 	data.s._32 = (NxReal)d[7];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx

; 403  : 	data.s._33 = (NxReal)d[8];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 404  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setRowMajor@NxMat33@@QAEXPBM@Z ENDP			; NxMat33::setRowMajor
_TEXT	ENDS
;	COMDAT ?SetOrigin@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
$T52348 = -20
_pEntity$ = 8
_origin$ = 12
_this$ = -4
_pActor$ = -8
?SetOrigin@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::SetOrigin, COMDAT

; 1741 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1742 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1743 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49991
	jmp	SHORT $L49989
$L49991:

; 1744 : 
; 1745 : 	pActor->setGlobalPosition( origin );

	mov	ecx, DWORD PTR _origin$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52348[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52348[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+24]
$L49989:

; 1746 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetOrigin@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::SetOrigin
_TEXT	ENDS
;	COMDAT ?SetVelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
$T52351 = -20
_pEntity$ = 8
_velocity$ = 12
_this$ = -4
_pActor$ = -8
?SetVelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::SetVelocity, COMDAT

; 1749 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1750 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1751 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L49999
	jmp	SHORT $L49997
$L49999:

; 1752 : 
; 1753 : 	pActor->setLinearVelocity( velocity );

	mov	ecx, DWORD PTR _velocity$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52351[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52351[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+224]
$L49997:

; 1754 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetVelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::SetVelocity
_TEXT	ENDS
;	COMDAT ?SetAvelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
$T52354 = -20
_pEntity$ = 8
_velocity$ = 12
_this$ = -4
_pActor$ = -8
?SetAvelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::SetAvelocity, COMDAT

; 1757 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1758 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1759 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L50007
	jmp	SHORT $L50005
$L50007:

; 1760 : 
; 1761 : 	pActor->setAngularVelocity( velocity );

	mov	ecx, DWORD PTR _velocity$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52354[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52354[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+228]
$L50005:

; 1762 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetAvelocity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::SetAvelocity
_TEXT	ENDS
;	COMDAT ?MoveObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
$T52357 = -20
_pEntity$ = 8
_finalPos$ = 12
_this$ = -4
_pActor$ = -8
?MoveObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::MoveObject, COMDAT

; 1765 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1766 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1767 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L50015
	jmp	SHORT $L50013
$L50015:

; 1768 : 
; 1769 : 	pActor->moveGlobalPosition( finalPos );

	mov	ecx, DWORD PTR _finalPos$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52357[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52357[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+56]
$L50013:

; 1770 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?MoveObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::MoveObject
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z$0
xdata$x	ENDS
;	COMDAT ?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_pEntity$ = 8
_finalAngle$ = 12
_this$ = -16
_pActor$ = -20
_rot$ = -56
_m$ = -92
?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::RotateObject, COMDAT

; 1773 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1774 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1775 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L50023
	jmp	SHORT $L50021
$L50023:

; 1776 : 
; 1777 : 	NxMat33 rot;

	lea	ecx, DWORD PTR _rot$[ebp]
	call	??0NxMat33@@QAE@XZ			; NxMat33::NxMat33
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1778 : 	matrix3x3	m( finalAngle );

	mov	ecx, DWORD PTR _finalAngle$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m$[ebp]
	call	??0matrix3x3@@QAE@ABVVector@@@Z		; matrix3x3::matrix3x3

; 1779 : 	rot.setRowMajor( (float *)m );

	lea	ecx, DWORD PTR _m$[ebp]
	call	??Bmatrix3x3@@QAEPAMXZ			; matrix3x3::operator float *
	push	eax
	lea	ecx, DWORD PTR _rot$[ebp]
	call	?setRowMajor@NxMat33@@QAEXPBM@Z		; NxMat33::setRowMajor

; 1780 : 	pActor->moveGlobalOrientation( rot );

	lea	edx, DWORD PTR _rot$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+60]

; 1781 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _rot$[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
$L50021:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z$0:
	lea	ecx, DWORD PTR _rot$[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__ehhandler$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?RotateObject@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::RotateObject
;	COMDAT ?SetLinearMomentum@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
$T52369 = -20
_pEntity$ = 8
_velocity$ = 12
_this$ = -4
_pActor$ = -8
?SetLinearMomentum@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::SetLinearMomentum, COMDAT

; 1784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1785 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1786 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L50033
	jmp	SHORT $L50031
$L50033:

; 1787 : 
; 1788 : 	pActor->setLinearMomentum( velocity );

	mov	ecx, DWORD PTR _velocity$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52369[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52369[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+256]
$L50031:

; 1789 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetLinearMomentum@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::SetLinearMomentum
_TEXT	ENDS
PUBLIC	__real@4@4008fa00000000000000
PUBLIC	__real@4@40028000000000000000
PUBLIC	__real@4@3ff1d1b7170000000000
;	COMDAT __real@4@4008fa00000000000000
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
__real@4@4008fa00000000000000 DD 0447a0000r	; 1000
CONST	ENDS
;	COMDAT __real@4@40028000000000000000
CONST	SEGMENT
__real@4@40028000000000000000 DD 041000000r	; 8
CONST	ENDS
;	COMDAT __real@4@3ff1d1b7170000000000
CONST	SEGMENT
__real@4@3ff1d1b7170000000000 DD 038d1b717r	; 0.0001
CONST	ENDS
;	COMDAT ?AddImpulse@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1M@Z
_TEXT	SEGMENT
$T52372 = -24
$T52373 = -36
$T52374 = -48
_pEntity$ = 8
_impulse$ = 12
_position$ = 16
_factor$ = 20
_this$ = -4
_pActor$ = -8
_coeff$ = -12
?AddImpulse@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1M@Z PROC NEAR ; CPhysicNovodex::AddImpulse, COMDAT

; 1792 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1793 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1794 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L50043
	jmp	SHORT $L50041
$L50043:

; 1795 : 
; 1796 : 	NxF32 coeff = (1000.0f / pActor->getMass()) * factor;

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+184]
	fdivr	DWORD PTR __real@4@4008fa00000000000000
	fmul	DWORD PTR _factor$[ebp]
	fstp	DWORD PTR _coeff$[ebp]

; 1797 : 
; 1798 : 	// prevent to apply too much impulse
; 1799 : 	if( pActor->getMass() < 8.0f )

	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+184]
	fcomp	DWORD PTR __real@4@40028000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L50045

; 1801 : 		coeff *= 0.0001f;

	fld	DWORD PTR _coeff$[ebp]
	fmul	DWORD PTR __real@4@3ff1d1b7170000000000
	fstp	DWORD PTR _coeff$[ebp]
$L50045:

; 1803 : 
; 1804 : 	pActor->addForceAtPos( NxVec3(impulse * coeff), (NxVec3)position, NX_IMPULSE );

	push	1
	push	1
	mov	eax, DWORD PTR _position$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52372[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	push	eax
	mov	ecx, DWORD PTR _coeff$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T52374[ebp]
	push	edx
	mov	ecx, DWORD PTR _impulse$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T52373[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	push	eax
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+272]
$L50041:

; 1805 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddImpulse@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1M@Z ENDP ; CPhysicNovodex::AddImpulse
_TEXT	ENDS
;	COMDAT ?AddForce@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
$T52383 = -20
_pEntity$ = 8
_force$ = 12
_this$ = -4
_pActor$ = -8
?AddForce@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::AddForce, COMDAT

; 1808 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1809 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 1810 : 	if( !pActor ) return;

	cmp	DWORD PTR _pActor$[ebp], 0
	jne	SHORT $L50056
	jmp	SHORT $L50054
$L50056:

; 1811 : 
; 1812 : 	pActor->addForce( force, NX_FORCE );

	mov	ecx, DWORD PTR _force$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52383[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	push	1
	push	0
	lea	edx, DWORD PTR $T52383[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+288]
$L50054:

; 1813 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddForce@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::AddForce
_TEXT	ENDS
PUBLIC	?push_back@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::push_back
PUBLIC	?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z ; CPhysicNovodex::CreateForceField
PUBLIC	??0NxForceFieldDesc@@QAE@XZ			; NxForceFieldDesc::NxForceFieldDesc
PUBLIC	??1NxForceFieldDesc@@QAE@XZ			; NxForceFieldDesc::~NxForceFieldDesc
PUBLIC	??0NxForceFieldLinearKernelDesc@@QAE@XZ		; NxForceFieldLinearKernelDesc::NxForceFieldLinearKernelDesc
PUBLIC	??1NxForceFieldLinearKernelDesc@@QAE@XZ		; NxForceFieldLinearKernelDesc::~NxForceFieldLinearKernelDesc
PUBLIC	??0NxBoxForceFieldShapeDesc@@QAE@XZ		; NxBoxForceFieldShapeDesc::NxBoxForceFieldShapeDesc
PUBLIC	??1NxBoxForceFieldShapeDesc@@UAE@XZ		; NxBoxForceFieldShapeDesc::~NxBoxForceFieldShapeDesc
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z$2
xdata$x	ENDS
;	COMDAT ?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z
_TEXT	SEGMENT
$T52386 = -408
$T52387 = -420
$T52388 = -432
$T52389 = -444
$T52390 = -456
$T52391 = -468
$T52392 = -480
$T52393 = -484
$T52394 = -488
__$EHRec$ = -12
_pEntity$ = 8
_this$ = -16
_linearKernelDesc$ = -172
_pLinearKernel$ = -176
_fieldDesc$ = -320
_box$ = -396
?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z PROC NEAR ; CPhysicNovodex::CreateForceField, COMDAT

; 1816 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 540				; 0000021cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1817 : 	// create a forcefield kernel
; 1818 : 	NxForceFieldLinearKernelDesc	linearKernelDesc;

	lea	ecx, DWORD PTR _linearKernelDesc$[ebp]
	call	??0NxForceFieldLinearKernelDesc@@QAE@XZ	; NxForceFieldLinearKernelDesc::NxForceFieldLinearKernelDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1819 : 
; 1820 : 	linearKernelDesc.constant = NxVec3( 1, 0, 0.2 );//force;

	push	1045220557				; 3e4ccccdH
	push	0
	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR $T52386[ebp]
	call	??0NxVec3@@QAE@MMM@Z			; NxVec3::NxVec3
	push	eax
	lea	ecx, DWORD PTR _linearKernelDesc$[ebp]
	call	??4NxVec3@@QAEABV0@ABV0@@Z		; NxVec3::operator=

; 1821 : //	linearKernelDesc.velocityTarget = NxVec3( 0.5, 0, 0.2 );
; 1822 : //	linearKernelDesc.falloffLinear = NxVec3( 100, 0, 0.2 );
; 1823 : 	NxForceFieldLinearKernel *pLinearKernel;
; 1824 : 	pLinearKernel = m_pScene->createForceFieldLinearKernel( linearKernelDesc );

	lea	eax, DWORD PTR _linearKernelDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+72]
	mov	DWORD PTR _pLinearKernel$[ebp], eax

; 1825 : 
; 1826 : 	// The forcefield descriptor
; 1827 : 	NxForceFieldDesc fieldDesc;

	lea	ecx, DWORD PTR _fieldDesc$[ebp]
	call	??0NxForceFieldDesc@@QAE@XZ		; NxForceFieldDesc::NxForceFieldDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1828 : 	fieldDesc.kernel = pLinearKernel;

	mov	eax, DWORD PTR _pLinearKernel$[ebp]
	mov	DWORD PTR _fieldDesc$[ebp+108], eax

; 1829 : 	fieldDesc.rigidBodyType = NX_FF_TYPE_OTHER;

	mov	DWORD PTR _fieldDesc$[ebp+128], 3

; 1830 : 
; 1831 : 	// A box forcefield shape descriptor
; 1832 : 	NxBoxForceFieldShapeDesc box;

	lea	ecx, DWORD PTR _box$[ebp]
	call	??0NxBoxForceFieldShapeDesc@@QAE@XZ	; NxBoxForceFieldShapeDesc::NxBoxForceFieldShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1833 : 	box.dimensions = (pEntity->pev->size - Vector( 2, 2, 2 )) * 0.5f;

	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T52389[ebp]
	push	ecx
	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR $T52387[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T52388[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _box$[ebp+64]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 1834 : 	box.pose.t = pEntity->Center() + Vector( 0, 0, pEntity->pev->size.z - 2 );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+252]
	fsub	DWORD PTR __real@4@40008000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	push	0
	lea	ecx, DWORD PTR $T52391[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T52392[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52390[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+304]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _box$[ebp+44]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 1835 : 
; 1836 : 	fieldDesc.includeGroupShapes.push_back( &box );

	lea	ecx, DWORD PTR _box$[ebp]
	mov	DWORD PTR $T52393[ebp], ecx
	lea	edx, DWORD PTR $T52393[ebp]
	push	edx
	lea	ecx, DWORD PTR _fieldDesc$[ebp+56]
	call	?push_back@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::push_back

; 1837 : 	return m_pScene->createForceField( fieldDesc );

	lea	eax, DWORD PTR _fieldDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+56]
	mov	DWORD PTR $T52394[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _box$[ebp]
	call	??1NxBoxForceFieldShapeDesc@@UAE@XZ	; NxBoxForceFieldShapeDesc::~NxBoxForceFieldShapeDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _fieldDesc$[ebp]
	call	??1NxForceFieldDesc@@QAE@XZ		; NxForceFieldDesc::~NxForceFieldDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _linearKernelDesc$[ebp]
	call	??1NxForceFieldLinearKernelDesc@@QAE@XZ	; NxForceFieldLinearKernelDesc::~NxForceFieldLinearKernelDesc
	mov	eax, DWORD PTR $T52394[ebp]

; 1838 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z$0:
	lea	ecx, DWORD PTR _linearKernelDesc$[ebp]
	call	??1NxForceFieldLinearKernelDesc@@QAE@XZ	; NxForceFieldLinearKernelDesc::~NxForceFieldLinearKernelDesc
	ret	0
__unwindfunclet$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z$1:
	lea	ecx, DWORD PTR _fieldDesc$[ebp]
	call	??1NxForceFieldDesc@@QAE@XZ		; NxForceFieldDesc::~NxForceFieldDesc
	ret	0
__unwindfunclet$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z$2:
	lea	ecx, DWORD PTR _box$[ebp]
	call	??1NxBoxForceFieldShapeDesc@@UAE@XZ	; NxBoxForceFieldShapeDesc::~NxBoxForceFieldShapeDesc
	ret	0
__ehhandler$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateForceField@CPhysicNovodex@@AAEPAXPAVCBaseEntity@@ABVVector@@@Z ENDP ; CPhysicNovodex::CreateForceField
PUBLIC	??0?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
PUBLIC	??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
PUBLIC	??0?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
PUBLIC	??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
PUBLIC	?setToDefault@NxForceFieldDesc@@QAEXXZ		; NxForceFieldDesc::setToDefault
;	COMDAT xdata$x
; File z:\xashxtsrc\phys_shared\nxforcefielddesc.h
xdata$x	SEGMENT
__ehfuncinfo$??0NxForceFieldDesc@@QAE@XZ DD 019930520H
	DD	04H
	DD	FLAT:__unwindtable$??0NxForceFieldDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxForceFieldDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$3
xdata$x	ENDS
;	COMDAT ??0NxForceFieldDesc@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0NxForceFieldDesc@@QAE@XZ PROC NEAR			; NxForceFieldDesc::NxForceFieldDesc, COMDAT

; 315  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxForceFieldDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??0?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??0NxGroupsMask@@QAE@XZ			; NxGroupsMask::NxGroupsMask
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 316  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxForceFieldDesc@@QAEXXZ	; NxForceFieldDesc::setToDefault

; 317  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
	ret	0
__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
	ret	0
__unwindfunclet$??0NxForceFieldDesc@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??1NxGroupsMask@@QAE@XZ			; NxGroupsMask::~NxGroupsMask
	ret	0
__ehhandler$??0NxForceFieldDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxForceFieldDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxForceFieldDesc@@QAE@XZ ENDP			; NxForceFieldDesc::NxForceFieldDesc
PUBLIC	?clear@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::clear
;	COMDAT ?setToDefault@NxForceFieldDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxForceFieldDesc@@QAEXXZ PROC NEAR	; NxForceFieldDesc::setToDefault, COMDAT

; 320  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 	pose.id();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?id@NxMat34@@QAEXXZ			; NxMat34::id

; 322  : 	actor = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 323  : 	coordinates = NX_FFC_CARTESIAN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 324  : 
; 325  : 	includeGroupShapes	.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	?clear@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::clear

; 326  : 
; 327  : 	group				= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+88], 0

; 328  : 	groupsMask.bits0	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 329  : 	groupsMask.bits1	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0

; 330  : 	groupsMask.bits2	= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0

; 331  : 	groupsMask.bits3	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0

; 332  : 
; 333  : 	kernel = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0

; 334  : 
; 335  : 	flags = NX_FFF_VOLUMETRIC_SCALING_FLUID | 
; 336  : 			NX_FFF_VOLUMETRIC_SCALING_CLOTH |
; 337  : 			NX_FFF_VOLUMETRIC_SCALING_SOFTBODY |
; 338  : 			NX_FFF_VOLUMETRIC_SCALING_RIGIDBODY;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], 480		; 000001e0H

; 339  : 
; 340  : 	forceFieldVariety	= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+112], 0

; 341  : 
; 342  : 	fluidType		= NX_FF_TYPE_OTHER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+116], 3

; 343  : 	clothType		= NX_FF_TYPE_OTHER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], 3

; 344  : 	softBodyType	= NX_FF_TYPE_OTHER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 3

; 345  : 	rigidBodyType	= NX_FF_TYPE_OTHER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 3

; 346  : 
; 347  : 	name		= NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], 0

; 348  : 	userData	= NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+140], 0

; 349  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxForceFieldDesc@@QAEXXZ ENDP		; NxForceFieldDesc::setToDefault
_TEXT	ENDS
PUBLIC	?setToDefault@NxForceFieldLinearKernelDesc@@QAEXXZ ; NxForceFieldLinearKernelDesc::setToDefault
;	COMDAT xdata$x
; File z:\xashxtsrc\phys_shared\nxforcefieldlinearkerneldesc.h
xdata$x	SEGMENT
__ehfuncinfo$??0NxForceFieldLinearKernelDesc@@QAE@XZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$??0NxForceFieldLinearKernelDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxForceFieldLinearKernelDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxForceFieldLinearKernelDesc@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0NxForceFieldLinearKernelDesc@@QAE@XZ$1
xdata$x	ENDS
;	COMDAT ??0NxForceFieldLinearKernelDesc@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0NxForceFieldLinearKernelDesc@@QAE@XZ PROC NEAR	; NxForceFieldLinearKernelDesc::NxForceFieldLinearKernelDesc, COMDAT

; 209  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxForceFieldLinearKernelDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0NxMat33@@QAE@XZ			; NxMat33::NxMat33
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0NxMat33@@QAE@XZ			; NxMat33::NxMat33
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 210  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxForceFieldLinearKernelDesc@@QAEXXZ ; NxForceFieldLinearKernelDesc::setToDefault

; 211  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxForceFieldLinearKernelDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__unwindfunclet$??0NxForceFieldLinearKernelDesc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__ehhandler$??0NxForceFieldLinearKernelDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxForceFieldLinearKernelDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxForceFieldLinearKernelDesc@@QAE@XZ ENDP		; NxForceFieldLinearKernelDesc::NxForceFieldLinearKernelDesc
PUBLIC	?zero@NxMat33@@QAEXXZ				; NxMat33::zero
;	COMDAT ?setToDefault@NxForceFieldLinearKernelDesc@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxForceFieldLinearKernelDesc@@QAEXXZ PROC NEAR ; NxForceFieldLinearKernelDesc::setToDefault, COMDAT

; 214  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 	constant			.zero(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 216  : 	positionMultiplier	.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?zero@NxMat33@@QAEXXZ			; NxMat33::zero

; 217  : 	positionTarget		.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 218  : 	velocityMultiplier	.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?zero@NxMat33@@QAEXXZ			; NxMat33::zero

; 219  : 	velocityTarget		.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 220  : 	falloffLinear		.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 221  : 	falloffQuadratic	.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 222  : 	noise				.zero();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	?zero@NxVec3@@QAEXXZ			; NxVec3::zero

; 223  : 	torusRadius			= 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 1065353216		; 3f800000H

; 224  : 	name				= NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], 0

; 225  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxForceFieldLinearKernelDesc@@QAEXXZ ENDP	; NxForceFieldLinearKernelDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?zero@NxMat33@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?zero@NxMat33@@QAEXXZ PROC NEAR				; NxMat33::zero, COMDAT

; 1093 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 	data.s._11 = NxReal(0.0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 1095 : 	data.s._12 = NxReal(0.0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 1096 : 	data.s._13 = NxReal(0.0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1097 : 
; 1098 : 	data.s._21 = NxReal(0.0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1099 : 	data.s._22 = NxReal(0.0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1100 : 	data.s._23 = NxReal(0.0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1101 : 
; 1102 : 	data.s._31 = NxReal(0.0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0

; 1103 : 	data.s._32 = NxReal(0.0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 1104 : 	data.s._33 = NxReal(0.0);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 1105 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?zero@NxMat33@@QAEXXZ ENDP				; NxMat33::zero
_TEXT	ENDS
PUBLIC	??1NxForceFieldShapeDesc@@UAE@XZ		; NxForceFieldShapeDesc::~NxForceFieldShapeDesc
PUBLIC	??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z	; NxForceFieldShapeDesc::NxForceFieldShapeDesc
PUBLIC	?setToDefault@NxBoxForceFieldShapeDesc@@UAEXXZ	; NxBoxForceFieldShapeDesc::setToDefault
PUBLIC	?isValid@NxBoxForceFieldShapeDesc@@UBE_NXZ	; NxBoxForceFieldShapeDesc::isValid
PUBLIC	??_7NxBoxForceFieldShapeDesc@@6B@		; NxBoxForceFieldShapeDesc::`vftable'
PUBLIC	??_GNxBoxForceFieldShapeDesc@@UAEPAXI@Z		; NxBoxForceFieldShapeDesc::`scalar deleting destructor'
PUBLIC	??_ENxBoxForceFieldShapeDesc@@UAEPAXI@Z		; NxBoxForceFieldShapeDesc::`vector deleting destructor'
;	COMDAT ??_7NxBoxForceFieldShapeDesc@@6B@
; File z:\xashxtsrc\phys_shared\nxboxforcefieldshapedesc.h
CONST	SEGMENT
??_7NxBoxForceFieldShapeDesc@@6B@ DD FLAT:??_ENxBoxForceFieldShapeDesc@@UAEPAXI@Z ; NxBoxForceFieldShapeDesc::`vftable'
	DD	FLAT:?setToDefault@NxBoxForceFieldShapeDesc@@UAEXXZ
	DD	FLAT:?isValid@NxBoxForceFieldShapeDesc@@UBE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0NxBoxForceFieldShapeDesc@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0NxBoxForceFieldShapeDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxBoxForceFieldShapeDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxBoxForceFieldShapeDesc@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0NxBoxForceFieldShapeDesc@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0NxBoxForceFieldShapeDesc@@QAE@XZ PROC NEAR		; NxBoxForceFieldShapeDesc::NxBoxForceFieldShapeDesc, COMDAT

; 76   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxBoxForceFieldShapeDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z ; NxForceFieldShapeDesc::NxForceFieldShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxBoxForceFieldShapeDesc@@6B@ ; NxBoxForceFieldShapeDesc::`vftable'

; 77   : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxBoxForceFieldShapeDesc@@UAEXXZ ; NxBoxForceFieldShapeDesc::setToDefault

; 78   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxBoxForceFieldShapeDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxForceFieldShapeDesc@@UAE@XZ	; NxForceFieldShapeDesc::~NxForceFieldShapeDesc
	ret	0
__ehhandler$??0NxBoxForceFieldShapeDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxBoxForceFieldShapeDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxBoxForceFieldShapeDesc@@QAE@XZ ENDP		; NxBoxForceFieldShapeDesc::NxBoxForceFieldShapeDesc
PUBLIC	?setToDefault@NxForceFieldShapeDesc@@UAEXXZ	; NxForceFieldShapeDesc::setToDefault
PUBLIC	?isValid@NxForceFieldShapeDesc@@UBE_NXZ		; NxForceFieldShapeDesc::isValid
PUBLIC	??_7NxForceFieldShapeDesc@@6B@			; NxForceFieldShapeDesc::`vftable'
PUBLIC	??_GNxForceFieldShapeDesc@@UAEPAXI@Z		; NxForceFieldShapeDesc::`scalar deleting destructor'
PUBLIC	??_ENxForceFieldShapeDesc@@UAEPAXI@Z		; NxForceFieldShapeDesc::`vector deleting destructor'
;	COMDAT ??_7NxForceFieldShapeDesc@@6B@
; File z:\xashxtsrc\phys_shared\nxforcefieldshapedesc.h
CONST	SEGMENT
??_7NxForceFieldShapeDesc@@6B@ DD FLAT:??_ENxForceFieldShapeDesc@@UAEPAXI@Z ; NxForceFieldShapeDesc::`vftable'
	DD	FLAT:?setToDefault@NxForceFieldShapeDesc@@UAEXXZ
	DD	FLAT:?isValid@NxForceFieldShapeDesc@@UBE_NXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z$0
xdata$x	ENDS
;	COMDAT ??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z
_TEXT	SEGMENT
_t$ = 8
_this$ = -16
__$EHRec$ = -12
??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z PROC NEAR ; NxForceFieldShapeDesc::NxForceFieldShapeDesc, COMDAT

; 118  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _t$[ebp]
	mov	DWORD PTR [eax+4], ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7NxForceFieldShapeDesc@@6B@ ; NxForceFieldShapeDesc::`vftable'

; 119  : 	setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxForceFieldShapeDesc@@UAEXXZ ; NxForceFieldShapeDesc::setToDefault

; 120  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0NxForceFieldShapeDesc@@IAE@W4NxShapeType@@@Z ENDP	; NxForceFieldShapeDesc::NxForceFieldShapeDesc
;	COMDAT ??_GNxForceFieldShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxForceFieldShapeDesc@@UAEPAXI@Z PROC NEAR		; NxForceFieldShapeDesc::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxForceFieldShapeDesc@@UAE@XZ	; NxForceFieldShapeDesc::~NxForceFieldShapeDesc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L46183
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46183:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxForceFieldShapeDesc@@UAEPAXI@Z ENDP		; NxForceFieldShapeDesc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1NxForceFieldShapeDesc@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxForceFieldShapeDesc@@UAE@XZ PROC NEAR		; NxForceFieldShapeDesc::~NxForceFieldShapeDesc, COMDAT

; 123  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7NxForceFieldShapeDesc@@6B@ ; NxForceFieldShapeDesc::`vftable'

; 124  : 	}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxForceFieldShapeDesc@@UAE@XZ ENDP			; NxForceFieldShapeDesc::~NxForceFieldShapeDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxForceFieldShapeDesc@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxForceFieldShapeDesc@@UAEXXZ PROC NEAR	; NxForceFieldShapeDesc::setToDefault, COMDAT

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 	pose.id();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?id@NxMat34@@QAEXXZ			; NxMat34::id

; 129  : 
; 130  : 	name = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], 0

; 131  : 	userData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0

; 132  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxForceFieldShapeDesc@@UAEXXZ ENDP	; NxForceFieldShapeDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?isValid@NxForceFieldShapeDesc@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isValid@NxForceFieldShapeDesc@@UBE_NXZ PROC NEAR	; NxForceFieldShapeDesc::isValid, COMDAT

; 135  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 	return true;

	mov	al, 1

; 137  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@NxForceFieldShapeDesc@@UBE_NXZ ENDP		; NxForceFieldShapeDesc::isValid
_TEXT	ENDS
;	COMDAT ??_GNxBoxForceFieldShapeDesc@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
_this$ = -4
??_GNxBoxForceFieldShapeDesc@@UAEPAXI@Z PROC NEAR	; NxBoxForceFieldShapeDesc::`scalar deleting destructor', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxBoxForceFieldShapeDesc@@UAE@XZ	; NxBoxForceFieldShapeDesc::~NxBoxForceFieldShapeDesc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	test	eax, eax
	je	SHORT $L46568
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46568:
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNxBoxForceFieldShapeDesc@@UAEPAXI@Z ENDP		; NxBoxForceFieldShapeDesc::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1NxBoxForceFieldShapeDesc@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxBoxForceFieldShapeDesc@@UAE@XZ PROC NEAR		; NxBoxForceFieldShapeDesc::~NxBoxForceFieldShapeDesc, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxForceFieldShapeDesc@@UAE@XZ	; NxForceFieldShapeDesc::~NxForceFieldShapeDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxBoxForceFieldShapeDesc@@UAE@XZ ENDP		; NxBoxForceFieldShapeDesc::~NxBoxForceFieldShapeDesc
_TEXT	ENDS
;	COMDAT ?setToDefault@NxBoxForceFieldShapeDesc@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?setToDefault@NxBoxForceFieldShapeDesc@@UAEXXZ PROC NEAR ; NxBoxForceFieldShapeDesc::setToDefault, COMDAT

; 81   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	NxForceFieldShapeDesc::setToDefault();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setToDefault@NxForceFieldShapeDesc@@UAEXXZ ; NxForceFieldShapeDesc::setToDefault

; 83   : 	dimensions.set(1.0f, 1.0f, 1.0f);	//note: NxBoxShape defaults to x0x0x but this is inconsistent with other shapes that are unity-sized by default.

	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?set@NxVec3@@QAEXMMM@Z			; NxVec3::set

; 84   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?setToDefault@NxBoxForceFieldShapeDesc@@UAEXXZ ENDP	; NxBoxForceFieldShapeDesc::setToDefault
_TEXT	ENDS
;	COMDAT ?isValid@NxBoxForceFieldShapeDesc@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?isValid@NxBoxForceFieldShapeDesc@@UBE_NXZ PROC NEAR	; NxBoxForceFieldShapeDesc::isValid, COMDAT

; 87   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 	if(!dimensions.isFinite())			return false;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	?isFinite@NxVec3@@QBE_NXZ		; NxVec3::isFinite
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L46577
	xor	al, al
	jmp	SHORT $L46576
$L46577:

; 89   : 	if(dimensions.x<0.0f)				return false;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+64]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L46578
	xor	al, al
	jmp	SHORT $L46576
$L46578:

; 90   : 	if(dimensions.y<0.0f)				return false;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+68]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L46579
	xor	al, al
	jmp	SHORT $L46576
$L46579:

; 91   : 	if(dimensions.z<0.0f)				return false;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+72]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L46580
	xor	al, al
	jmp	SHORT $L46576
$L46580:

; 92   : 	return NxForceFieldShapeDesc::isValid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isValid@NxForceFieldShapeDesc@@UBE_NXZ	; NxForceFieldShapeDesc::isValid
$L46576:

; 93   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@NxBoxForceFieldShapeDesc@@UBE_NXZ ENDP		; NxBoxForceFieldShapeDesc::isValid
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1NxForceFieldLinearKernelDesc@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1NxForceFieldLinearKernelDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1NxForceFieldLinearKernelDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1NxForceFieldLinearKernelDesc@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1NxForceFieldLinearKernelDesc@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1NxForceFieldLinearKernelDesc@@QAE@XZ PROC NEAR	; NxForceFieldLinearKernelDesc::~NxForceFieldLinearKernelDesc, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1NxForceFieldLinearKernelDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1NxForceFieldLinearKernelDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__ehhandler$??1NxForceFieldLinearKernelDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1NxForceFieldLinearKernelDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1NxForceFieldLinearKernelDesc@@QAE@XZ ENDP		; NxForceFieldLinearKernelDesc::~NxForceFieldLinearKernelDesc
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1NxForceFieldDesc@@QAE@XZ DD 019930520H
	DD	03H
	DD	FLAT:__unwindtable$??1NxForceFieldDesc@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1NxForceFieldDesc@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1NxForceFieldDesc@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1NxForceFieldDesc@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1NxForceFieldDesc@@QAE@XZ$2
xdata$x	ENDS
;	COMDAT ??1NxForceFieldDesc@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1NxForceFieldDesc@@QAE@XZ PROC NEAR			; NxForceFieldDesc::~NxForceFieldDesc, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1NxForceFieldDesc@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??1NxGroupsMask@@QAE@XZ			; NxGroupsMask::~NxGroupsMask
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1NxForceFieldDesc@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__unwindfunclet$??1NxForceFieldDesc@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
	ret	0
__unwindfunclet$??1NxForceFieldDesc@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
	ret	0
__ehhandler$??1NxForceFieldDesc@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1NxForceFieldDesc@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1NxForceFieldDesc@@QAE@XZ ENDP			; NxForceFieldDesc::~NxForceFieldDesc
PUBLIC	??_C@_0BC@GOLK@cache?1maps?1?$CFs?4bin?$AA@	; `string'
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:NEAR			; Q_strnicmp
;	COMDAT ??_C@_0BC@GOLK@cache?1maps?1?$CFs?4bin?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0BC@GOLK@cache?1maps?1?$CFs?4bin?$AA@ DB 'cache/maps/%s.bin', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z$0
xdata$x	ENDS
;	COMDAT ?FLoadTree@CPhysicNovodex@@UAEHPAD@Z
_TEXT	SEGMENT
$T52492 = -300
__$EHRec$ = -12
_szMapName$ = 8
_this$ = -16
_szHullFilename$ = -276
?FLoadTree@CPhysicNovodex@@UAEHPAD@Z PROC NEAR		; CPhysicNovodex::FLoadTree, COMDAT

; 1841 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 360				; 00000168H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1842 : 	if( !szMapName || !*szMapName || !m_pPhysics )

	cmp	DWORD PTR _szMapName$[ebp], 0
	je	SHORT $L50085
	mov	eax, DWORD PTR _szMapName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L50085
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L50084
$L50085:

; 1843 : 		return 0;

	xor	eax, eax
	jmp	$L50083
$L50084:

; 1844 : 
; 1845 : 	if( m_fLoaded )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+272], 0
	je	$L50086

; 1847 : 		if( !Q_stricmp( szMapName, m_szMapName ))

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _szMapName$[ebp]
	push	edx
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L50087

; 1849 : 			// stay on same map - no reload
; 1850 : 			return 1;

	mov	eax, 1
	jmp	$L50083
$L50087:

; 1852 : 
; 1853 : 		if( m_pSceneActor )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+292], 0
	je	SHORT $L50088

; 1854 : 			m_pScene->releaseActor( *m_pSceneActor );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+32]
$L50088:

; 1855 : 		m_pSceneActor = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0

; 1856 : 
; 1857 : 		if( m_pSceneMesh )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	je	SHORT $L50089

; 1858 : 			m_pPhysics->releaseTriangleMesh( *m_pSceneMesh );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+36]
$L50089:

; 1859 : 		m_pSceneMesh = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+288], 0

; 1860 : 
; 1861 : 		m_fLoaded = FALSE; // trying to load new collision tree 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+272], 0
$L50086:

; 1863 : 
; 1864 : 	// save off mapname
; 1865 : 	strcpy ( m_szMapName, szMapName );

	mov	edi, DWORD PTR _szMapName$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	esi, edi
	mov	eax, ecx
	mov	edi, edx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 1866 : 
; 1867 : 	char szHullFilename[MAX_PATH];
; 1868 : 
; 1869 : 	Q_snprintf( szHullFilename, sizeof( szHullFilename ), "cache/maps/%s.bin", szMapName );

	mov	ecx, DWORD PTR _szMapName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@GOLK@cache?1maps?1?$CFs?4bin?$AA@ ; `string'
	push	260					; 00000104H
	lea	edx, DWORD PTR _szHullFilename$[ebp]
	push	edx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 1870 : 	m_pSceneMesh = m_pPhysics->createTriangleMesh( UserStream( szHullFilename, true ));

	push	1
	lea	eax, DWORD PTR _szHullFilename$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52492[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -304+[ebp], eax
	mov	ecx, DWORD PTR -304+[ebp]
	mov	DWORD PTR -308+[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR -308+[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T52492[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 1871 : 	m_fWorldChanged = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+280], 0

; 1872 : 
; 1873 : 	return (m_pSceneMesh != NULL) ? TRUE : FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+288], 0
	setne	cl
	mov	eax, ecx
$L50083:

; 1874 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z$0:
	lea	ecx, DWORD PTR $T52492[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__ehhandler$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?FLoadTree@CPhysicNovodex@@UAEHPAD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?FLoadTree@CPhysicNovodex@@UAEHPAD@Z ENDP		; CPhysicNovodex::FLoadTree
PUBLIC	??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@		; `string'
PUBLIC	??_C@_0BM@JDKP@?4BIN?5file?5will?5be?5updated?6?6?$AA@ ; `string'
;	COMDAT ??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@ DB 'maps/%s.bsp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JDKP@?4BIN?5file?5will?5be?5updated?6?6?$AA@
CONST	SEGMENT
??_C@_0BM@JDKP@?4BIN?5file?5will?5be?5updated?6?6?$AA@ DB '.BIN file will'
	DB	' be updated', 0aH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?CheckBINFile@CPhysicNovodex@@UAEHPAD@Z
_TEXT	SEGMENT
_szMapName$ = 8
_this$ = -4
_szBspFilename$ = -264
_szHullFilename$ = -524
_retValue$ = -528
_iCompare$ = -532
?CheckBINFile@CPhysicNovodex@@UAEHPAD@Z PROC NEAR	; CPhysicNovodex::CheckBINFile, COMDAT

; 1877 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 596				; 00000254H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1878 : 	if( !szMapName || !*szMapName || !m_pPhysics )

	cmp	DWORD PTR _szMapName$[ebp], 0
	je	SHORT $L50098
	mov	eax, DWORD PTR _szMapName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L50098
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $L50097
$L50098:

; 1879 : 		return FALSE;

	xor	eax, eax
	jmp	$L50096
$L50097:

; 1882 : 	char szHullFilename[MAX_PATH];
; 1883 : 
; 1884 : 	Q_snprintf( szBspFilename, sizeof( szBspFilename ), "maps/%s.bsp", szMapName );

	mov	eax, DWORD PTR _szMapName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@HBDC@maps?1?$CFs?4bsp?$AA@ ; `string'
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szBspFilename$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 1885 : 	Q_snprintf( szHullFilename, sizeof( szHullFilename ), "cache/maps/%s.bin", szMapName );

	mov	edx, DWORD PTR _szMapName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BC@GOLK@cache?1maps?1?$CFs?4bin?$AA@ ; `string'
	push	260					; 00000104H
	lea	eax, DWORD PTR _szHullFilename$[ebp]
	push	eax
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 1886 : 
; 1887 : 	BOOL retValue = TRUE;

	mov	DWORD PTR _retValue$[ebp], 1

; 1888 : 
; 1889 : 	int iCompare;
; 1890 : 	if ( COMPARE_FILE_TIME( szBspFilename, szHullFilename, &iCompare ))

	lea	ecx, DWORD PTR _iCompare$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szHullFilename$[ebp]
	push	edx
	lea	eax, DWORD PTR _szBspFilename$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+392
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L50104

; 1892 : 		if( iCompare > 0 )

	cmp	DWORD PTR _iCompare$[ebp], 0
	jle	SHORT $L50105

; 1894 : 			// BSP file is newer.
; 1895 : 			ALERT ( at_console, ".BIN file will be updated\n\n" );

	push	OFFSET FLAT:??_C@_0BM@JDKP@?4BIN?5file?5will?5be?5updated?6?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1896 : 			retValue = FALSE;

	mov	DWORD PTR _retValue$[ebp], 0
$L50105:

; 1899 : 	else

	jmp	SHORT $L50107
$L50104:

; 1901 : 		retValue = FALSE;

	mov	DWORD PTR _retValue$[ebp], 0
$L50107:

; 1903 : 
; 1904 : 	return retValue;

	mov	eax, DWORD PTR _retValue$[ebp]
$L50096:

; 1905 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CheckBINFile@CPhysicNovodex@@UAEHPAD@Z ENDP		; CPhysicNovodex::CheckBINFile
_TEXT	ENDS
PUBLIC	??_C@_07KPOE@models?1?$AA@			; `string'
PUBLIC	??_C@_0BB@NNAO@cache?1?$CFs?1?$CFs?4hull?$AA@	; `string'
PUBLIC	??_C@_0O@DCDF@cache?1?$CFs?4hull?$AA@		; `string'
EXTRN	?Q_strlen@@YAHPBD@Z:NEAR			; Q_strlen
EXTRN	?COM_FileBase@@YAXPBDPAD@Z:NEAR			; COM_FileBase
EXTRN	?COM_ExtractFilePath@@YAXPBDPAD@Z:NEAR		; COM_ExtractFilePath
;	COMDAT ??_C@_07KPOE@models?1?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_07KPOE@models?1?$AA@ DB 'models/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNAO@cache?1?$CFs?1?$CFs?4hull?$AA@
CONST	SEGMENT
??_C@_0BB@NNAO@cache?1?$CFs?1?$CFs?4hull?$AA@ DB 'cache/%s/%s.hull', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DCDF@cache?1?$CFs?4hull?$AA@
CONST	SEGMENT
??_C@_0O@DCDF@cache?1?$CFs?4hull?$AA@ DB 'cache/%s.hull', 00H ; `string'
CONST	ENDS
;	COMDAT ?HullNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z
_TEXT	SEGMENT
_model$ = 8
_hullfile$ = 12
_size$ = 16
_this$ = -4
_baseFolderLength$ = -8
_szModelBasename$ = -268
_szModelFilepath$ = -528
?HullNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z PROC NEAR ; CPhysicNovodex::HullNameForModel, COMDAT

; 1908 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1909 : 	if( !model || !*model || !hullfile )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $L50115
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L50115
	cmp	DWORD PTR _hullfile$[ebp], 0
	jne	SHORT $L50114
$L50115:

; 1910 : 		return;

	jmp	$L50113
$L50114:

; 1911 : 
; 1912 : 	size_t baseFolderLength = Q_strlen( "models/" );

	push	OFFSET FLAT:??_C@_07KPOE@models?1?$AA@	; `string'
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	DWORD PTR _baseFolderLength$[ebp], eax

; 1913 : 
; 1914 : 	char szModelBasename[MAX_PATH];
; 1915 : 	char szModelFilepath[MAX_PATH];
; 1916 : 
; 1917 : 	COM_ExtractFilePath( model + baseFolderLength, szModelFilepath );

	lea	edx, DWORD PTR _szModelFilepath$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	add	eax, DWORD PTR _baseFolderLength$[ebp]
	push	eax
	call	?COM_ExtractFilePath@@YAXPBDPAD@Z	; COM_ExtractFilePath
	add	esp, 8

; 1918 : 	COM_FileBase( model, szModelBasename );

	lea	ecx, DWORD PTR _szModelBasename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?COM_FileBase@@YAXPBDPAD@Z		; COM_FileBase
	add	esp, 8

; 1919 : 
; 1920 : 	if( szModelFilepath[0] )

	movsx	eax, BYTE PTR _szModelFilepath$[ebp]
	test	eax, eax
	je	SHORT $L50120

; 1921 : 		Q_snprintf( hullfile, size, "cache/%s/%s.hull", szModelFilepath, szModelBasename );

	lea	ecx, DWORD PTR _szModelBasename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szModelFilepath$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@NNAO@cache?1?$CFs?1?$CFs?4hull?$AA@ ; `string'
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hullfile$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 1922 : 	else

	jmp	SHORT $L50122
$L50120:

; 1923 : 		Q_snprintf( hullfile, size, "cache/%s.hull", szModelBasename );

	lea	edx, DWORD PTR _szModelBasename$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0O@DCDF@cache?1?$CFs?4hull?$AA@ ; `string'
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hullfile$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H
$L50122:
$L50113:

; 1924 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?HullNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z ENDP	; CPhysicNovodex::HullNameForModel
_TEXT	ENDS
PUBLIC	??_C@_0BB@FIIK@cache?1?$CFs?1?$CFs?4mesh?$AA@	; `string'
PUBLIC	??_C@_0O@LHLB@cache?1?$CFs?4mesh?$AA@		; `string'
;	COMDAT ??_C@_0BB@FIIK@cache?1?$CFs?1?$CFs?4mesh?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0BB@FIIK@cache?1?$CFs?1?$CFs?4mesh?$AA@ DB 'cache/%s/%s.mesh', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LHLB@cache?1?$CFs?4mesh?$AA@
CONST	SEGMENT
??_C@_0O@LHLB@cache?1?$CFs?4mesh?$AA@ DB 'cache/%s.mesh', 00H ; `string'
CONST	ENDS
;	COMDAT ?MeshNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z
_TEXT	SEGMENT
_model$ = 8
_hullfile$ = 12
_size$ = 16
_this$ = -4
_baseFolderLength$ = -8
_szModelBasename$ = -268
_szModelFilepath$ = -528
?MeshNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z PROC NEAR ; CPhysicNovodex::MeshNameForModel, COMDAT

; 1927 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1928 : 	if( !model || !*model || !hullfile )

	cmp	DWORD PTR _model$[ebp], 0
	je	SHORT $L50131
	mov	eax, DWORD PTR _model$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L50131
	cmp	DWORD PTR _hullfile$[ebp], 0
	jne	SHORT $L50130
$L50131:

; 1929 : 		return;

	jmp	$L50129
$L50130:

; 1930 : 
; 1931 : 	size_t baseFolderLength = Q_strlen( "models/" );

	push	OFFSET FLAT:??_C@_07KPOE@models?1?$AA@	; `string'
	call	?Q_strlen@@YAHPBD@Z			; Q_strlen
	add	esp, 4
	mov	DWORD PTR _baseFolderLength$[ebp], eax

; 1932 : 
; 1933 : 	char szModelBasename[MAX_PATH];
; 1934 : 	char szModelFilepath[MAX_PATH];
; 1935 : 
; 1936 : 	COM_ExtractFilePath( model + baseFolderLength, szModelFilepath );

	lea	edx, DWORD PTR _szModelFilepath$[ebp]
	push	edx
	mov	eax, DWORD PTR _model$[ebp]
	add	eax, DWORD PTR _baseFolderLength$[ebp]
	push	eax
	call	?COM_ExtractFilePath@@YAXPBDPAD@Z	; COM_ExtractFilePath
	add	esp, 8

; 1937 : 	COM_FileBase( model, szModelBasename );

	lea	ecx, DWORD PTR _szModelBasename$[ebp]
	push	ecx
	mov	edx, DWORD PTR _model$[ebp]
	push	edx
	call	?COM_FileBase@@YAXPBDPAD@Z		; COM_FileBase
	add	esp, 8

; 1938 : 
; 1939 : 	if( szModelFilepath[0] )

	movsx	eax, BYTE PTR _szModelFilepath$[ebp]
	test	eax, eax
	je	SHORT $L50135

; 1940 : 		Q_snprintf( hullfile, size, "cache/%s/%s.mesh", szModelFilepath, szModelBasename );

	lea	ecx, DWORD PTR _szModelBasename$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szModelFilepath$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@FIIK@cache?1?$CFs?1?$CFs?4mesh?$AA@ ; `string'
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hullfile$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 20					; 00000014H

; 1941 : 	else

	jmp	SHORT $L50137
$L50135:

; 1942 : 		Q_snprintf( hullfile, size, "cache/%s.mesh", szModelBasename );

	lea	edx, DWORD PTR _szModelBasename$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0O@LHLB@cache?1?$CFs?4mesh?$AA@ ; `string'
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hullfile$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H
$L50137:
$L50129:

; 1943 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MeshNameForModel@CPhysicNovodex@@AAEXPBDPADI@Z ENDP	; CPhysicNovodex::MeshNameForModel
_TEXT	ENDS
;	COMDAT ?CheckFileTimes@CPhysicNovodex@@AAEHPBD0@Z
_TEXT	SEGMENT
_szFile1$ = 8
_szFile2$ = 12
_this$ = -4
_retValue$ = -8
_iCompare$ = -12
?CheckFileTimes@CPhysicNovodex@@AAEHPBD0@Z PROC NEAR	; CPhysicNovodex::CheckFileTimes, COMDAT

; 1950 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1951 : 	if( !szFile1 || !*szFile1 || !szFile2 || !*szFile2 )

	cmp	DWORD PTR _szFile1$[ebp], 0
	je	SHORT $L50145
	mov	eax, DWORD PTR _szFile1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L50145
	cmp	DWORD PTR _szFile2$[ebp], 0
	je	SHORT $L50145
	mov	edx, DWORD PTR _szFile2$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L50144
$L50145:

; 1952 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L50143
$L50144:

; 1953 : 
; 1954 : 	BOOL retValue = TRUE;

	mov	DWORD PTR _retValue$[ebp], 1

; 1955 : 
; 1956 : 	int iCompare;
; 1957 : 	if ( COMPARE_FILE_TIME( (char *)szFile1, (char *)szFile2, &iCompare ))

	lea	ecx, DWORD PTR _iCompare$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFile2$[ebp]
	push	edx
	mov	eax, DWORD PTR _szFile1$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+392
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L50150

; 1959 : 		if( iCompare > 0 )

	cmp	DWORD PTR _iCompare$[ebp], 0
	jle	SHORT $L50151

; 1961 : 			// MDL file is newer.
; 1962 : 			retValue = FALSE;

	mov	DWORD PTR _retValue$[ebp], 0
$L50151:

; 1965 : 	else

	jmp	SHORT $L50152
$L50150:

; 1967 : 		retValue = FALSE;

	mov	DWORD PTR _retValue$[ebp], 0
$L50152:

; 1969 : 
; 1970 : 	return retValue;

	mov	eax, DWORD PTR _retValue$[ebp]
$L50143:

; 1971 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CheckFileTimes@CPhysicNovodex@@AAEHPBD0@Z ENDP		; CPhysicNovodex::CheckFileTimes
_TEXT	ENDS
;	COMDAT ?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z
_TEXT	SEGMENT
_model$ = 8
_edge$ = 12
_this$ = -4
_e$ = -8
?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z PROC NEAR ; CPhysicNovodex::ConvertEdgeToIndex, COMDAT

; 1977 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1978 : 	int e = model->surfedges[edge];

	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+188]
	mov	edx, DWORD PTR _edge$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _e$[ebp], eax

; 1979 : 	return (e > 0) ? model->edges[e].v[0] : model->edges[-e].v[1];

	cmp	DWORD PTR _e$[ebp], 0
	jle	SHORT $L52510
	mov	ecx, DWORD PTR _model$[ebp]
	mov	edx, DWORD PTR [ecx+156]
	mov	eax, DWORD PTR _e$[ebp]
	mov	cx, WORD PTR [edx+eax*8]
	mov	WORD PTR -12+[ebp], cx
	jmp	SHORT $L52511
$L52510:
	mov	edx, DWORD PTR _e$[ebp]
	neg	edx
	mov	eax, DWORD PTR _model$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	dx, WORD PTR [ecx+edx*8+2]
	mov	WORD PTR -12+[ebp], dx
$L52511:
	mov	eax, DWORD PTR -12+[ebp]
	and	eax, 65535				; 0000ffffH

; 1980 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ENDP ; CPhysicNovodex::ConvertEdgeToIndex
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z@4FA ; `CPhysicNovodex::BuildCollisionTree'::`2'::__LINE__Var
PUBLIC	??_C@_0CA@OAD@z?3?2xashxtsrc?2server?2novodex?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0BH@BNBF@totalElems?5?$DN?$DN?5numElems?$AA@ ; `string'
PUBLIC	??_C@_0DG@GILB@BuildCollisionTree?3?5unbale?5to?5fe@ ; `string'
PUBLIC	??_C@_0CL@OMND@Tree?5Collision?5out?5of?5Date?4?5Rebu@ ; `string'
EXTRN	__assert:NEAR
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:NEAR			; Q_strncpy
;	COMDAT ?__LINE__Var@?1??BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z@4FA
; File z:\xashxtsrc\server\novodex.cpp
_DATA	SEGMENT
?__LINE__Var@?1??BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z@4FA DW 07bfH ; `CPhysicNovodex::BuildCollisionTree'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0DG@GILB@BuildCollisionTree?3?5unbale?5to?5fe@
CONST	SEGMENT
??_C@_0DG@GILB@BuildCollisionTree?3?5unbale?5to?5fe@ DB 'BuildCollisionTr'
	DB	'ee: unbale to fetch world pointer %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OMND@Tree?5Collision?5out?5of?5Date?4?5Rebu@
CONST	SEGMENT
??_C@_0CL@OMND@Tree?5Collision?5out?5of?5Date?4?5Rebu@ DB 'Tree Collision'
	DB	' out of Date. Rebuilding...', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OAD@z?3?2xashxtsrc?2server?2novodex?4cpp?$AA@
CONST	SEGMENT
??_C@_0CA@OAD@z?3?2xashxtsrc?2server?2novodex?4cpp?$AA@ DB 'z:\xashxtsrc\'
	DB	'server\novodex.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BNBF@totalElems?5?$DN?$DN?5numElems?$AA@
CONST	SEGMENT
??_C@_0BH@BNBF@totalElems?5?$DN?$DN?5numElems?$AA@ DB 'totalElems == numE'
	DB	'lems', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z$1
xdata$x	ENDS
;	COMDAT ?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z
_TEXT	SEGMENT
_indices$ = -36
_k$50184 = -40
_j$50186 = -44
_levelDesc$ = -96
_szHullFilename$ = -356
_status$50200 = -360
$T52514 = -364
$T52516 = -388
$T52517 = -392
$T52518 = -416
__$EHRec$ = -12
_szMapName$ = 8
_this$ = -16
_i$ = -20
_numElems$ = -24
_totalElems$ = -28
_psurf$ = -32
?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z PROC NEAR	; CPhysicNovodex::BuildCollisionTree, COMDAT

; 1983 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 484				; 000001e4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1984 : 	if( !m_pPhysics )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L50163

; 1985 : 		return FALSE;

	xor	eax, eax
	jmp	$L50162
$L50163:

; 1986 : 	 
; 1987 : 	// get a world struct
; 1988 : 	if(( m_pWorldModel = (model_t *)MODEL_HANDLE( 1 )) == NULL )

	push	1
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $L50165

; 1990 : 		ALERT( at_error, "BuildCollisionTree: unbale to fetch world pointer %s\n", szMapName );

	mov	eax, DWORD PTR _szMapName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0DG@GILB@BuildCollisionTree?3?5unbale?5to?5fe@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1991 : 		return FALSE;

	xor	eax, eax
	jmp	$L50162
$L50165:

; 1993 : 
; 1994 : 	if( m_pSceneActor )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+292], 0
	je	SHORT $L50167

; 1995 : 		m_pScene->releaseActor( *m_pSceneActor );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+32]
$L50167:

; 1996 : 	m_pSceneActor = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+292], 0

; 1997 : 
; 1998 : 	if( m_pSceneMesh )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	je	SHORT $L50168

; 1999 : 		m_pPhysics->releaseTriangleMesh( *m_pSceneMesh );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+36]
$L50168:

; 2000 : 	m_pSceneMesh = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+288], 0

; 2001 : 
; 2002 : 	// save off mapname
; 2003 : 	Q_strcpy( m_szMapName, szMapName );

	push	99999					; 0001869fH
	mov	ecx, DWORD PTR _szMapName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 2004 : 
; 2005 : 	ALERT( at_console, "Tree Collision out of Date. Rebuilding...\n" );

	push	OFFSET FLAT:??_C@_0CL@OMND@Tree?5Collision?5out?5of?5Date?4?5Rebu@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2006 : 
; 2007 : 	// convert world from polygons to tri-list
; 2008 : 	int i, numElems = 0, totalElems = 0;

	mov	DWORD PTR _numElems$[ebp], 0
	mov	DWORD PTR _totalElems$[ebp], 0

; 2009 : 	msurface_t *psurf;
; 2010 : 
; 2011 : 	// compute vertexes count
; 2012 : 	for( i = 0; i < m_pWorldModel->nummodelsurfaces; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L50174
$L50175:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L50174:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+116]
	jge	SHORT $L50176

; 2014 : 		psurf = &m_pWorldModel->surfaces[m_pWorldModel->firstmodelsurface + i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [ecx+112]
	add	eax, DWORD PTR _i$[ebp]
	imul	eax, 92					; 0000005cH
	mov	ecx, DWORD PTR [edx+180]
	add	ecx, eax
	mov	DWORD PTR _psurf$[ebp], ecx

; 2015 : 
; 2016 : 		if( psurf->flags & ( SURF_DRAWTURB|SURF_DRAWSKY ))

	mov	edx, DWORD PTR _psurf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 20					; 00000014H
	test	eax, eax
	je	SHORT $L50177

; 2017 : 			continue;

	jmp	SHORT $L50175
$L50177:

; 2018 : 
; 2019 : 		totalElems += (psurf->numedges - 2);

	mov	ecx, DWORD PTR _psurf$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _totalElems$[ebp]
	lea	ecx, DWORD PTR [eax+edx-2]
	mov	DWORD PTR _totalElems$[ebp], ecx

; 2020 : 	}

	jmp	SHORT $L50175
$L50176:

; 2021 : 
; 2022 : 	NxU32 *indices = new NxU32[totalElems * 3];

	mov	edx, DWORD PTR _totalElems$[ebp]
	imul	edx, 3
	shl	edx, 2
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T52514[ebp], eax
	mov	eax, DWORD PTR $T52514[ebp]
	mov	DWORD PTR _indices$[ebp], eax

; 2023 : 
; 2024 : 	for( i = 0; i < m_pWorldModel->nummodelsurfaces; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L50181
$L50182:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L50181:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+116]
	jge	$L50183

; 2026 : 		psurf = &m_pWorldModel->surfaces[m_pWorldModel->firstmodelsurface + i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [edx+112]
	add	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 92					; 0000005cH
	mov	edx, DWORD PTR [eax+180]
	add	edx, ecx
	mov	DWORD PTR _psurf$[ebp], edx

; 2027 : 		int k = psurf->firstedge;

	mov	eax, DWORD PTR _psurf$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _k$50184[ebp], ecx

; 2028 : 
; 2029 : 		// don't create collision for water
; 2030 : 		if( psurf->flags & ( SURF_DRAWTURB|SURF_DRAWSKY ))

	mov	edx, DWORD PTR _psurf$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, 20					; 00000014H
	test	eax, eax
	je	SHORT $L50185

; 2031 : 			continue;

	jmp	SHORT $L50182
$L50185:

; 2032 : 
; 2033 : 		for( int j = 0; j < psurf->numedges - 2; j++ )

	mov	DWORD PTR _j$50186[ebp], 0
	jmp	SHORT $L50187
$L50188:
	mov	ecx, DWORD PTR _j$50186[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$50186[ebp], ecx
$L50187:
	mov	edx, DWORD PTR _psurf$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 2
	cmp	DWORD PTR _j$50186[ebp], eax
	jge	SHORT $L50189

; 2035 : 			indices[numElems*3+0] = ConvertEdgeToIndex( m_pWorldModel, k );

	mov	ecx, DWORD PTR _k$50184[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ; CPhysicNovodex::ConvertEdgeToIndex
	mov	ecx, DWORD PTR _numElems$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2036 : 			indices[numElems*3+1] = ConvertEdgeToIndex( m_pWorldModel, k + j + 2 );

	mov	eax, DWORD PTR _j$50186[ebp]
	mov	ecx, DWORD PTR _k$50184[ebp]
	lea	edx, DWORD PTR [ecx+eax+2]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ; CPhysicNovodex::ConvertEdgeToIndex
	mov	edx, DWORD PTR _numElems$[ebp]
	imul	edx, 3
	mov	ecx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [ecx+edx*4+4], eax

; 2037 : 			indices[numElems*3+2] = ConvertEdgeToIndex( m_pWorldModel, k + j + 1 );

	mov	edx, DWORD PTR _j$50186[ebp]
	mov	eax, DWORD PTR _k$50184[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConvertEdgeToIndex@CPhysicNovodex@@AAEHPAUmodel_s@@H@Z ; CPhysicNovodex::ConvertEdgeToIndex
	mov	ecx, DWORD PTR _numElems$[ebp]
	imul	ecx, 3
	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR [edx+ecx*4+8], eax

; 2038 : 			numElems++;

	mov	eax, DWORD PTR _numElems$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElems$[ebp], eax

; 2039 : 		}

	jmp	$L50188
$L50189:

; 2040 : 	}

	jmp	$L50182
$L50183:

; 2041 : 
; 2042 : 	NX_ASSERT( totalElems == numElems );

	mov	ecx, DWORD PTR _totalElems$[ebp]
	cmp	ecx, DWORD PTR _numElems$[ebp]
	je	SHORT $L52515
	movsx	edx, WORD PTR ?__LINE__Var@?1??BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z@4FA ; `CPhysicNovodex::BuildCollisionTree'::`2'::__LINE__Var
	add	edx, 59					; 0000003bH
	push	edx
	push	OFFSET FLAT:??_C@_0CA@OAD@z?3?2xashxtsrc?2server?2novodex?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BH@BNBF@totalElems?5?$DN?$DN?5numElems?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L52515:

; 2043 : 
; 2044 : 	// build physical model
; 2045 : 	NxTriangleMeshDesc levelDesc;

	lea	ecx, DWORD PTR _levelDesc$[ebp]
	call	??0NxTriangleMeshDesc@@QAE@XZ		; NxTriangleMeshDesc::NxTriangleMeshDesc

; 2046 : 	levelDesc.pointStrideBytes = sizeof( mvertex_t );

	mov	DWORD PTR _levelDesc$[ebp+8], 12	; 0000000cH

; 2047 : 	levelDesc.triangleStrideBytes	= 3 * sizeof( NxU32 );

	mov	DWORD PTR _levelDesc$[ebp+12], 12	; 0000000cH

; 2048 : 	levelDesc.points = (const NxPoint*)&(m_pWorldModel->vertexes[0].position);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR _levelDesc$[ebp+16], eax

; 2049 : 	levelDesc.numVertices = m_pWorldModel->numvertexes;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _levelDesc$[ebp], eax

; 2050 : 	levelDesc.numTriangles = numElems;

	mov	ecx, DWORD PTR _numElems$[ebp]
	mov	DWORD PTR _levelDesc$[ebp+4], ecx

; 2051 : 	levelDesc.triangles = indices;

	mov	edx, DWORD PTR _indices$[ebp]
	mov	DWORD PTR _levelDesc$[ebp+20], edx

; 2052 : 	levelDesc.flags = 0;

	mov	DWORD PTR _levelDesc$[ebp+24], 0

; 2053 : 
; 2054 : 	char szHullFilename[MAX_PATH];
; 2055 : 	Q_snprintf( szHullFilename, sizeof( szHullFilename ), "cache/maps/%s.bin", szMapName );

	mov	eax, DWORD PTR _szMapName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BC@GOLK@cache?1maps?1?$CFs?4bin?$AA@ ; `string'
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szHullFilename$[ebp]
	push	ecx
	call	?Q_snprintf@@YAHPADIPBDZZ		; Q_snprintf
	add	esp, 16					; 00000010H

; 2056 : 
; 2057 : 	if( m_pCooking )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1352], 0
	je	$L50199

; 2059 : 		m_pCooking->NxInitCooking();

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1352]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+12]

; 2060 : 		bool status = m_pCooking->NxCookTriangleMesh( levelDesc, UserStream( szHullFilename, false ));

	push	0
	lea	eax, DWORD PTR _szHullFilename$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52516[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -420+[ebp], eax
	mov	ecx, DWORD PTR -420+[ebp]
	mov	DWORD PTR -424+[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR -424+[ebp]
	push	edx
	lea	eax, DWORD PTR _levelDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1352]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+20]
	mov	BYTE PTR _status$50200[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T52516[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
$L50199:

; 2062 : 
; 2063 : 	delete [] indices;

	mov	eax, DWORD PTR _indices$[ebp]
	mov	DWORD PTR $T52517[ebp], eax
	mov	ecx, DWORD PTR $T52517[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 2064 : 
; 2065 : 	m_pSceneMesh = m_pPhysics->createTriangleMesh( UserStream( szHullFilename, true ));

	push	1
	lea	edx, DWORD PTR _szHullFilename$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T52518[ebp]
	call	??0UserStream@@QAE@PBD_N@Z		; UserStream::UserStream
	mov	DWORD PTR -428+[ebp], eax
	mov	eax, DWORD PTR -428+[ebp]
	mov	DWORD PTR -432+[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR -432+[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T52518[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream

; 2066 : 	m_fWorldChanged = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+280], 1

; 2067 : 
; 2068 : 	return (m_pSceneMesh != NULL) ? TRUE : FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+288], 0
	setne	cl
	mov	eax, ecx
$L50162:

; 2069 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z$0:
	lea	ecx, DWORD PTR $T52516[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__unwindfunclet$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z$1:
	lea	ecx, DWORD PTR $T52518[ebp]
	call	??1UserStream@@UAE@XZ			; UserStream::~UserStream
	ret	0
__ehhandler$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?BuildCollisionTree@CPhysicNovodex@@UAEHPAD@Z ENDP	; CPhysicNovodex::BuildCollisionTree
PUBLIC	??_C@_0BM@HNGO@?$CKcollision?5tree?5not?5ready?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CO@IPEB@SetupWorld?3?5unbale?5to?5fetch?5worl@ ; `string'
EXTRN	?g_pWorld@@3PAVCBaseEntity@@A:DWORD		; g_pWorld
;	COMDAT ??_C@_0BM@HNGO@?$CKcollision?5tree?5not?5ready?$CB?6?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0BM@HNGO@?$CKcollision?5tree?5not?5ready?$CB?6?$AA@ DB '*collision '
	DB	'tree not ready!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IPEB@SetupWorld?3?5unbale?5to?5fetch?5worl@
CONST	SEGMENT
??_C@_0CO@IPEB@SetupWorld?3?5unbale?5to?5fetch?5worl@ DB 'SetupWorld: unb'
	DB	'ale to fetch world pointer %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SetupWorld@CPhysicNovodex@@UAEXXZ DD 019930520H
	DD	02H
	DD	FLAT:__unwindtable$?SetupWorld@CPhysicNovodex@@UAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?SetupWorld@CPhysicNovodex@@UAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetupWorld@CPhysicNovodex@@UAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetupWorld@CPhysicNovodex@@UAEXXZ$1
xdata$x	ENDS
;	COMDAT ?SetupWorld@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT
_this$ = -16
_levelShapeDesc$ = -136
_ActorDesc$ = -240
_pSceneShape$ = -244
$T52529 = -248
__$EHRec$ = -12
?SetupWorld@CPhysicNovodex@@UAEXXZ PROC NEAR		; CPhysicNovodex::SetupWorld, COMDAT

; 2072 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetupWorld@CPhysicNovodex@@UAEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2073 : 	if( m_pSceneActor )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+292], 0
	je	SHORT $L50208

; 2074 : 		return;	// already loaded

	jmp	$L50207
$L50208:

; 2075 : 
; 2076 : 	if( !m_pSceneMesh )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+288], 0
	jne	SHORT $L50209

; 2078 : 		ALERT( at_error, "*collision tree not ready!\n" );

	push	OFFSET FLAT:??_C@_0BM@HNGO@?$CKcollision?5tree?5not?5ready?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2079 : 		return;

	jmp	$L50207
$L50209:

; 2081 : 
; 2082 : 	// get a world struct
; 2083 : 	if(( m_pWorldModel = (model_t *)MODEL_HANDLE( 1 )) == NULL )

	push	1
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+12
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $L50212

; 2085 : 		ALERT( at_error, "SetupWorld: unbale to fetch world pointer %s\n", m_szMapName );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET FLAT:??_C@_0CO@IPEB@SetupWorld?3?5unbale?5to?5fetch?5worl@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2086 : 		return;

	jmp	$L50207
$L50212:

; 2088 : 
; 2089 : 	NxTriangleMeshShapeDesc levelShapeDesc;

	lea	ecx, DWORD PTR _levelShapeDesc$[ebp]
	call	??0NxTriangleMeshShapeDesc@@QAE@XZ	; NxTriangleMeshShapeDesc::NxTriangleMeshShapeDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2090 : 	NxActorDesc ActorDesc;

	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??0NxActorDesc@@QAE@XZ			; NxActorDesc::NxActorDesc
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2091 : 
; 2092 : 	ActorDesc.userData = g_pWorld->edict();

	mov	ecx, DWORD PTR ?g_pWorld@@3PAVCBaseEntity@@A ; g_pWorld
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _ActorDesc$[ebp+72], eax

; 2093 : 	levelShapeDesc.meshData = m_pSceneMesh;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+288]
	mov	DWORD PTR _levelShapeDesc$[ebp+108], eax

; 2094 : 	ActorDesc.shapes.pushBack( &levelShapeDesc );

	lea	ecx, DWORD PTR _levelShapeDesc$[ebp]
	mov	DWORD PTR $T52529[ebp], ecx
	lea	edx, DWORD PTR $T52529[ebp]
	push	edx
	lea	ecx, DWORD PTR _ActorDesc$[ebp+88]
	call	?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack

; 2095 : 	m_pSceneActor = m_pScene->createActor( ActorDesc );

	lea	eax, DWORD PTR _ActorDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], eax

; 2096 : 	m_fLoaded = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], 1

; 2097 : 
; 2098 : 	// update the world bounds for NX_BP_TYPE_SAP_MULTI
; 2099 : 	NxShape *pSceneShape = m_pSceneActor->getShapes()[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+292]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+80]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pSceneShape$[ebp], eax

; 2100 : 	pSceneShape->getWorldBounds( worldBounds );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	mov	edx, DWORD PTR _pSceneShape$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pSceneShape$[ebp]
	call	DWORD PTR [eax+16]

; 2101 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _levelShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
$L50207:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetupWorld@CPhysicNovodex@@UAEXXZ$0:
	lea	ecx, DWORD PTR _levelShapeDesc$[ebp]
	call	??1NxTriangleMeshShapeDesc@@UAE@XZ	; NxTriangleMeshShapeDesc::~NxTriangleMeshShapeDesc
	ret	0
__unwindfunclet$?SetupWorld@CPhysicNovodex@@UAEXXZ$1:
	lea	ecx, DWORD PTR _ActorDesc$[ebp]
	call	??1NxActorDesc@@QAE@XZ			; NxActorDesc::~NxActorDesc
	ret	0
__ehhandler$?SetupWorld@CPhysicNovodex@@UAEXXZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?SetupWorld@CPhysicNovodex@@UAEXXZ
	jmp	___CxxFrameHandler
text$x	ENDS
?SetupWorld@CPhysicNovodex@@UAEXXZ ENDP			; CPhysicNovodex::SetupWorld
PUBLIC	?renderData@DebugRenderer@@QBEXABVNxDebugRenderable@@@Z ; DebugRenderer::renderData
;	COMDAT ?DebugDraw@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DebugDraw@CPhysicNovodex@@UAEXXZ PROC NEAR		; CPhysicNovodex::DebugDraw, COMDAT

; 2104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2105 : 	if( !m_pPhysics || !m_pScene )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L50223
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $L50222
$L50223:

; 2106 : 		return;

	jmp	SHORT $L50221
$L50222:

; 2107 : 
; 2108 : 	gDebugRenderer.renderData( *m_pScene->getDebugRenderable( ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+336]
	push	eax
	mov	ecx, OFFSET FLAT:?gDebugRenderer@@3VDebugRenderer@@A ; gDebugRenderer
	call	?renderData@DebugRenderer@@QBEXABVNxDebugRenderable@@@Z ; DebugRenderer::renderData
$L50221:

; 2109 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DebugDraw@CPhysicNovodex@@UAEXXZ ENDP			; CPhysicNovodex::DebugDraw
_TEXT	ENDS
PUBLIC	?getNbPoints@NxDebugRenderable@@QBEIXZ		; NxDebugRenderable::getNbPoints
PUBLIC	?getPoints@NxDebugRenderable@@QBEPBUNxDebugPoint@@XZ ; NxDebugRenderable::getPoints
PUBLIC	?getNbLines@NxDebugRenderable@@QBEIXZ		; NxDebugRenderable::getNbLines
PUBLIC	?getLines@NxDebugRenderable@@QBEPBUNxDebugLine@@XZ ; NxDebugRenderable::getLines
PUBLIC	?getNbTriangles@NxDebugRenderable@@QBEIXZ	; NxDebugRenderable::getNbTriangles
PUBLIC	?getTriangles@NxDebugRenderable@@QBEPBUNxDebugTriangle@@XZ ; NxDebugRenderable::getTriangles
PUBLIC	?setupColor@DebugRenderer@@QBEXI@Z		; DebugRenderer::setupColor
;	COMDAT ?renderData@DebugRenderer@@QBEXABVNxDebugRenderable@@@Z
_TEXT	SEGMENT
_data$ = 8
_this$ = -4
_NbPoints$ = -8
_Points$ = -12
_NbLines$ = -16
_Lines$ = -20
_NbTris$ = -24
_Triangles$ = -28
?renderData@DebugRenderer@@QBEXABVNxDebugRenderable@@@Z PROC NEAR ; DebugRenderer::renderData, COMDAT

; 73   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 		// Render points
; 75   : 		NxU32 NbPoints = data.getNbPoints();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?getNbPoints@NxDebugRenderable@@QBEIXZ	; NxDebugRenderable::getNbPoints
	mov	DWORD PTR _NbPoints$[ebp], eax

; 76   : 		const NxDebugPoint* Points = data.getPoints();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?getPoints@NxDebugRenderable@@QBEPBUNxDebugPoint@@XZ ; NxDebugRenderable::getPoints
	mov	DWORD PTR _Points$[ebp], eax

; 77   : 
; 78   : 		Tri->Begin( TRI_POINTS );

	push	7
	mov	eax, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [eax+8]
	add	esp, 4
$L49118:

; 79   : 		while( NbPoints-- )

	mov	ecx, DWORD PTR _NbPoints$[ebp]
	mov	edx, DWORD PTR _NbPoints$[ebp]
	sub	edx, 1
	mov	DWORD PTR _NbPoints$[ebp], edx
	test	ecx, ecx
	je	SHORT $L49119

; 81   : 			setupColor( Points->color );

	mov	eax, DWORD PTR _Points$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setupColor@DebugRenderer@@QBEXI@Z	; DebugRenderer::setupColor

; 82   : 			Tri->Vertex3fv( (float *)&Points->p.x );

	mov	edx, DWORD PTR _Points$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [eax+28]
	add	esp, 4

; 83   : 			Points++;

	mov	ecx, DWORD PTR _Points$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _Points$[ebp], ecx

; 84   : 		}

	jmp	SHORT $L49118
$L49119:

; 85   : 		Tri->End();

	mov	edx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [edx+12]

; 86   : 
; 87   : 		// Render lines
; 88   : 		NxU32 NbLines = data.getNbLines();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?getNbLines@NxDebugRenderable@@QBEIXZ	; NxDebugRenderable::getNbLines
	mov	DWORD PTR _NbLines$[ebp], eax

; 89   : 		const NxDebugLine* Lines = data.getLines();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?getLines@NxDebugRenderable@@QBEPBUNxDebugLine@@XZ ; NxDebugRenderable::getLines
	mov	DWORD PTR _Lines$[ebp], eax

; 90   : 
; 91   : 		Tri->Begin( TRI_LINES );

	push	4
	mov	eax, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [eax+8]
	add	esp, 4
$L49124:

; 92   : 		while( NbLines-- )

	mov	ecx, DWORD PTR _NbLines$[ebp]
	mov	edx, DWORD PTR _NbLines$[ebp]
	sub	edx, 1
	mov	DWORD PTR _NbLines$[ebp], edx
	test	ecx, ecx
	je	SHORT $L49125

; 94   : 			setupColor( Lines->color );

	mov	eax, DWORD PTR _Lines$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setupColor@DebugRenderer@@QBEXI@Z	; DebugRenderer::setupColor

; 95   : 			Tri->Vertex3fv( (float *)&Lines->p0.x );

	mov	edx, DWORD PTR _Lines$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [eax+28]
	add	esp, 4

; 96   : 			Tri->Vertex3fv( (float *)&Lines->p1.x );

	mov	ecx, DWORD PTR _Lines$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [edx+28]
	add	esp, 4

; 97   : 			Lines++;

	mov	eax, DWORD PTR _Lines$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR _Lines$[ebp], eax

; 98   : 		}

	jmp	SHORT $L49124
$L49125:

; 99   : 		Tri->End();

	mov	ecx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [ecx+12]

; 100  : 
; 101  : 		// Render triangles
; 102  : 		NxU32 NbTris = data.getNbTriangles();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?getNbTriangles@NxDebugRenderable@@QBEIXZ ; NxDebugRenderable::getNbTriangles
	mov	DWORD PTR _NbTris$[ebp], eax

; 103  : 		const NxDebugTriangle* Triangles = data.getTriangles();

	mov	ecx, DWORD PTR _data$[ebp]
	call	?getTriangles@NxDebugRenderable@@QBEPBUNxDebugTriangle@@XZ ; NxDebugRenderable::getTriangles
	mov	DWORD PTR _Triangles$[ebp], eax

; 104  : 
; 105  : 		Tri->Begin( TRI_TRIANGLES );

	push	0
	mov	edx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [edx+8]
	add	esp, 4
$L49131:

; 106  : 		while( NbTris-- )

	mov	eax, DWORD PTR _NbTris$[ebp]
	mov	ecx, DWORD PTR _NbTris$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _NbTris$[ebp], ecx
	test	eax, eax
	je	SHORT $L49132

; 108  : 			setupColor( Triangles->color );

	mov	edx, DWORD PTR _Triangles$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setupColor@DebugRenderer@@QBEXI@Z	; DebugRenderer::setupColor

; 109  : 			Tri->Vertex3fv( (float *)&Triangles->p0.x );

	mov	ecx, DWORD PTR _Triangles$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [edx+28]
	add	esp, 4

; 110  : 			Tri->Vertex3fv( (float *)&Triangles->p1.x );

	mov	eax, DWORD PTR _Triangles$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [ecx+28]
	add	esp, 4

; 111  : 			Tri->Vertex3fv( (float *)&Triangles->p2.x );

	mov	edx, DWORD PTR _Triangles$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	eax, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [eax+28]
	add	esp, 4

; 112  : 			Triangles++;

	mov	ecx, DWORD PTR _Triangles$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _Triangles$[ebp], ecx

; 113  : 		}

	jmp	SHORT $L49131
$L49132:

; 114  : 		Tri->End();

	mov	edx, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [edx+12]

; 115  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?renderData@DebugRenderer@@QBEXABVNxDebugRenderable@@@Z ENDP ; DebugRenderer::renderData
_TEXT	ENDS
;	COMDAT ?getNbPoints@NxDebugRenderable@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?getNbPoints@NxDebugRenderable@@QBEIXZ PROC NEAR	; NxDebugRenderable::getNbPoints, COMDAT

; 83   : 	NX_INLINE NxU32 getNbPoints() const						{ return numPoints; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbPoints@NxDebugRenderable@@QBEIXZ ENDP		; NxDebugRenderable::getNbPoints
_TEXT	ENDS
;	COMDAT ?getPoints@NxDebugRenderable@@QBEPBUNxDebugPoint@@XZ
_TEXT	SEGMENT
_this$ = -4
?getPoints@NxDebugRenderable@@QBEPBUNxDebugPoint@@XZ PROC NEAR ; NxDebugRenderable::getPoints, COMDAT

; 89   : 	NX_INLINE const NxDebugPoint* getPoints() const			{ return points; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getPoints@NxDebugRenderable@@QBEPBUNxDebugPoint@@XZ ENDP ; NxDebugRenderable::getPoints
_TEXT	ENDS
;	COMDAT ?getNbLines@NxDebugRenderable@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?getNbLines@NxDebugRenderable@@QBEIXZ PROC NEAR		; NxDebugRenderable::getNbLines, COMDAT

; 97   : 	NX_INLINE NxU32 getNbLines() const						{ return numLines; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbLines@NxDebugRenderable@@QBEIXZ ENDP		; NxDebugRenderable::getNbLines
_TEXT	ENDS
;	COMDAT ?getLines@NxDebugRenderable@@QBEPBUNxDebugLine@@XZ
_TEXT	SEGMENT
_this$ = -4
?getLines@NxDebugRenderable@@QBEPBUNxDebugLine@@XZ PROC NEAR ; NxDebugRenderable::getLines, COMDAT

; 103  : 	NX_INLINE const NxDebugLine* getLines() const			{ return lines; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getLines@NxDebugRenderable@@QBEPBUNxDebugLine@@XZ ENDP	; NxDebugRenderable::getLines
_TEXT	ENDS
;	COMDAT ?getNbTriangles@NxDebugRenderable@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?getNbTriangles@NxDebugRenderable@@QBEIXZ PROC NEAR	; NxDebugRenderable::getNbTriangles, COMDAT

; 109  : 	NX_INLINE NxU32 getNbTriangles() const					{ return numTriangles; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getNbTriangles@NxDebugRenderable@@QBEIXZ ENDP		; NxDebugRenderable::getNbTriangles
_TEXT	ENDS
;	COMDAT ?getTriangles@NxDebugRenderable@@QBEPBUNxDebugTriangle@@XZ
_TEXT	SEGMENT
_this$ = -4
?getTriangles@NxDebugRenderable@@QBEPBUNxDebugTriangle@@XZ PROC NEAR ; NxDebugRenderable::getTriangles, COMDAT

; 115  : 	NX_INLINE const NxDebugTriangle* getTriangles() const	{ return triangles; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?getTriangles@NxDebugRenderable@@QBEPBUNxDebugTriangle@@XZ ENDP ; NxDebugRenderable::getTriangles
_TEXT	ENDS
PUBLIC	__real@4@4006ff00000000000000
;	COMDAT __real@4@4006ff00000000000000
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
__real@4@4006ff00000000000000 DD 0437f0000r	; 255
CONST	ENDS
;	COMDAT ?setupColor@DebugRenderer@@QBEXI@Z
_TEXT	SEGMENT
_color$ = 8
_this$ = -4
_Blue$ = -8
_Green$ = -12
_Red$ = -16
?setupColor@DebugRenderer@@QBEXI@Z PROC NEAR		; DebugRenderer::setupColor, COMDAT

; 65   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 		NxF32 Blue = NxF32((color) & 0xff) / 255.0f;

	mov	eax, DWORD PTR _color$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR -24+[ebp], eax
	mov	DWORD PTR -24+[ebp+4], 0
	fild	QWORD PTR -24+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _Blue$[ebp]

; 67   : 		NxF32 Green = NxF32((color>>8) & 0xff) / 255.0f;

	mov	ecx, DWORD PTR _color$[ebp]
	shr	ecx, 8
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR -32+[ebp], ecx
	mov	DWORD PTR -32+[ebp+4], 0
	fild	QWORD PTR -32+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _Green$[ebp]

; 68   : 		NxF32 Red	= NxF32((color>>16) & 0xff) / 255.0f;

	mov	edx, DWORD PTR _color$[ebp]
	shr	edx, 16					; 00000010H
	and	edx, 255				; 000000ffH
	mov	DWORD PTR -40+[ebp], edx
	mov	DWORD PTR -40+[ebp+4], 0
	fild	QWORD PTR -40+[ebp]
	fdiv	DWORD PTR __real@4@4006ff00000000000000
	fstp	DWORD PTR _Red$[ebp]

; 69   : 		Tri->Color4f( Red, Green, Blue, 1.0f );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _Blue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Green$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Red$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+28
	call	DWORD PTR [eax+16]
	add	esp, 16					; 00000010H

; 70   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?setupColor@DebugRenderer@@QBEXI@Z ENDP			; DebugRenderer::setupColor
_TEXT	ENDS
PUBLIC	?P_SpeedsMessage@CPhysicNovodex@@AAE_NPADI@Z	; CPhysicNovodex::P_SpeedsMessage
;	COMDAT ?P_SpeedsMessage@CPhysicNovodex@@AAE_NPADI@Z
_TEXT	SEGMENT
_out$ = 8
_size$ = 12
_this$ = -4
?P_SpeedsMessage@CPhysicNovodex@@AAE_NPADI@Z PROC NEAR	; CPhysicNovodex::P_SpeedsMessage, COMDAT

; 2117 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2118 : 	if( !p_speeds || p_speeds->value <= 0.0f )

	cmp	DWORD PTR ?p_speeds@@3PAUcvar_s@@A, 0	; p_speeds
	je	SHORT $L50230
	mov	eax, DWORD PTR ?p_speeds@@3PAUcvar_s@@A	; p_speeds
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L50229
$L50230:

; 2119 : 		return false;

	xor	al, al
	jmp	SHORT $L50228
$L50229:

; 2120 : 
; 2121 : 	if( !out || !size ) return false;

	cmp	DWORD PTR _out$[ebp], 0
	je	SHORT $L50232
	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $L50231
$L50232:
	xor	al, al
	jmp	SHORT $L50228
$L50231:

; 2122 : 	Q_strncpy( out, p_speeds_msg, size );

	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 320				; 00000140H
	push	edx
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 2123 : 
; 2124 : 	return true;

	mov	al, 1
$L50228:

; 2125 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?P_SpeedsMessage@CPhysicNovodex@@AAE_NPADI@Z ENDP	; CPhysicNovodex::P_SpeedsMessage
_TEXT	ENDS
PUBLIC	??_C@_05PNBN@width?$AA@				; `string'
EXTRN	?Q_strchr@@YAPADPBDD@Z:NEAR			; Q_strchr
;	COMDAT ??_C@_05PNBN@width?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_05PNBN@width?$AA@ DB 'width', 00H			; `string'
CONST	ENDS
;	COMDAT ?DrawPSpeeds@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_msg$ = -1028
_iScrWidth$ = -1032
_x$50241 = -1036
_y$50242 = -1040
_height$50243 = -1044
_p$50244 = -1048
_start$50245 = -1052
_end$50246 = -1056
?DrawPSpeeds@CPhysicNovodex@@UAEXXZ PROC NEAR		; CPhysicNovodex::DrawPSpeeds, COMDAT

; 2133 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1120				; 00000460H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2134 : 	char	msg[1024];
; 2135 : 	int	iScrWidth = CVAR_GET_FLOAT( "width" );

	push	OFFSET FLAT:??_C@_05PNBN@width?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	call	__ftol
	mov	DWORD PTR _iScrWidth$[ebp], eax

; 2136 : 
; 2137 : 	if( P_SpeedsMessage( msg, sizeof( msg )))

	push	1024					; 00000400H
	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?P_SpeedsMessage@CPhysicNovodex@@AAE_NPADI@Z ; CPhysicNovodex::P_SpeedsMessage
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L50249

; 2139 : 		int	x, y, height;
; 2140 : 		char	*p, *start, *end;
; 2141 : 
; 2142 : 		x = iScrWidth - 320;

	mov	ecx, DWORD PTR _iScrWidth$[ebp]
	sub	ecx, 320				; 00000140H
	mov	DWORD PTR _x$50241[ebp], ecx

; 2143 : 		y = 128;

	mov	DWORD PTR _y$50242[ebp], 128		; 00000080H

; 2144 : 
; 2145 : 		DrawConsoleStringLen( NULL, NULL, &height );

	lea	edx, DWORD PTR _height$50243[ebp]
	push	edx
	push	0
	push	0
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+40
	add	esp, 12					; 0000000cH

; 2146 : 		DrawSetTextColor( 1.0f, 1.0f, 1.0f );

	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	push	1065353216				; 3f800000H
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+36
	add	esp, 12					; 0000000cH

; 2147 : 
; 2148 : 		p = start = msg;

	lea	eax, DWORD PTR _msg$[ebp]
	mov	DWORD PTR _start$50245[ebp], eax
	mov	ecx, DWORD PTR _start$50245[ebp]
	mov	DWORD PTR _p$50244[ebp], ecx
$L50247:

; 2151 : 			end = Q_strchr( p, '\n' );

	push	10					; 0000000aH
	mov	edx, DWORD PTR _p$50244[ebp]
	push	edx
	call	?Q_strchr@@YAPADPBDD@Z			; Q_strchr
	add	esp, 8
	mov	DWORD PTR _end$50246[ebp], eax

; 2152 : 			if( end ) msg[end-start] = '\0';

	cmp	DWORD PTR _end$50246[ebp], 0
	je	SHORT $L50250
	mov	eax, DWORD PTR _end$50246[ebp]
	sub	eax, DWORD PTR _start$50245[ebp]
	mov	BYTE PTR _msg$[ebp+eax], 0
$L50250:

; 2153 : 
; 2154 : 			DrawConsoleString( x, y, p );

	mov	ecx, DWORD PTR _p$50244[ebp]
	push	ecx
	mov	edx, DWORD PTR _y$50242[ebp]
	push	edx
	mov	eax, DWORD PTR _x$50241[ebp]
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+32
	add	esp, 12					; 0000000cH

; 2155 : 			y += height;

	mov	ecx, DWORD PTR _y$50242[ebp]
	add	ecx, DWORD PTR _height$50243[ebp]
	mov	DWORD PTR _y$50242[ebp], ecx

; 2156 : 
; 2157 : 			if( end )

	cmp	DWORD PTR _end$50246[ebp], 0
	je	SHORT $L50251

; 2158 : 				p = end + 1;

	mov	edx, DWORD PTR _end$50246[ebp]
	add	edx, 1
	mov	DWORD PTR _p$50244[ebp], edx

; 2159 : 			else

	jmp	SHORT $L50252
$L50251:

; 2160 : 				break;

	jmp	SHORT $L50249
$L50252:

; 2161 : 		} while( 1 );

	mov	eax, 1
	test	eax, eax
	jne	$L50247
$L50249:

; 2163 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawPSpeeds@CPhysicNovodex@@UAEXXZ ENDP		; CPhysicNovodex::DrawPSpeeds
_TEXT	ENDS
;	COMDAT ?FreeAllBodies@CPhysicNovodex@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_actor$50261 = -8
?FreeAllBodies@CPhysicNovodex@@UAEXXZ PROC NEAR		; CPhysicNovodex::FreeAllBodies, COMDAT

; 2166 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2167 : 	if( !m_pScene ) return;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L50257
	jmp	SHORT $L50256
$L50257:

; 2168 : 
; 2169 : 	// throw all bodies
; 2170 : 	while( m_pScene->getNbActors())

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+252]
	test	eax, eax
	je	SHORT $L50260

; 2172 : 		NxActor *actor = m_pScene->getActors()[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+256]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _actor$50261[ebp], eax

; 2173 : 		m_pScene->releaseActor( *actor );

	mov	ecx, DWORD PTR _actor$50261[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+32]

; 2174 : 	}

	jmp	SHORT $L50257
$L50260:

; 2175 : 	m_pSceneActor = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+292], 0
$L50256:

; 2176 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeAllBodies@CPhysicNovodex@@UAEXXZ ENDP		; CPhysicNovodex::FreeAllBodies
_TEXT	ENDS
;	COMDAT ?TeleportCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
_pActor$ = -8
_pShape$ = -12
_vecOffset$ = -24
$T52566 = -28
$T52567 = -40
$T52570 = -52
$T52571 = -64
$T52572 = -76
$T52573 = -88
?TeleportCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::TeleportCharacter, COMDAT

; 2179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2180 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2181 : 	if( !pActor || pActor->getNbShapes() <= 0 )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50268
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	ja	SHORT $L50267
$L50268:

; 2182 : 		return;

	jmp	$L50265
$L50267:

; 2183 : 
; 2184 : 	if( m_fNeedFetchResults )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+284], 0
	je	SHORT $L50269

; 2185 : 		return;

	jmp	$L50265
$L50269:

; 2186 : 
; 2187 : 	NxBoxShape *pShape = (NxBoxShape *)pActor->getShapes()[0];

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+80]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pShape$[ebp], eax

; 2188 : 	Vector vecOffset = (pEntity->IsMonster()) ? Vector( 0, 0, pEntity->pev->maxs.z / 2.0f ) : g_vecZero;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+232]
	test	eax, eax
	je	SHORT $L52568
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+240]
	fdiv	DWORD PTR __real@4@40008000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	push	0
	lea	ecx, DWORD PTR $T52567[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	DWORD PTR -92+[ebp], eax
	jmp	SHORT $L52569
$L52568:
	mov	DWORD PTR -92+[ebp], OFFSET FLAT:?g_vecZero@@3VVector@@B ; g_vecZero
$L52569:
	mov	edx, DWORD PTR -92+[ebp]
	mov	DWORD PTR $T52566[ebp], edx
	mov	eax, DWORD PTR $T52566[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOffset$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2189 : 
; 2190 : 	pShape->setDimensions( pEntity->pev->size * PADDING_FACTOR );

	push	1056629064				; 3efae148H
	lea	ecx, DWORD PTR $T52571[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T52570[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T52570[ebp]
	push	eax
	mov	ecx, DWORD PTR _pShape$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pShape$[ebp]
	call	DWORD PTR [edx+156]

; 2191 : 	pActor->setGlobalPosition( pEntity->GetAbsOrigin() + vecOffset );

	lea	eax, DWORD PTR _vecOffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52573[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR $T52572[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52572[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+24]
$L50265:

; 2192 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?TeleportCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::TeleportCharacter
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0
xdata$x	ENDS
;	COMDAT ?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -16
_pActor$ = -20
_pose$ = -68
_mat$ = -132
_m$ = -196
__$EHRec$ = -12
?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::TeleportActor, COMDAT

; 2195 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2196 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2197 : 	if( !pActor || pActor->getNbShapes() <= 0 )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50285
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	ja	SHORT $L50284
$L50285:

; 2198 : 		return;

	jmp	SHORT $L50282
$L50284:

; 2199 : 
; 2200 : 	NxMat34 pose;

	push	1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2201 : 	float mat[16];
; 2202 : 
; 2203 : 	matrix4x4	m( pEntity->GetAbsOrigin(), pEntity->GetAbsAngles( ), 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 2204 : 	m.CopyToArray( mat );

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 2205 : 
; 2206 : 	// complex move for kinematic entities
; 2207 : 	pose.setColumnMajor44( mat );

	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?setColumnMajor44@NxMat34@@QAEXPBM@Z	; NxMat34::setColumnMajor44

; 2208 : 	pActor->setGlobalPose( pose );

	lea	edx, DWORD PTR _pose$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+20]

; 2209 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
$L50282:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?TeleportActor@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::TeleportActor
;	COMDAT ?MoveCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
_pActor$ = -8
_pShape$ = -12
_vecOffset$ = -24
$T52585 = -28
$T52586 = -40
$T52589 = -52
$T52590 = -64
$T52591 = -76
$T52592 = -88
?MoveCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::MoveCharacter, COMDAT

; 2212 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2213 : 	if( !pEntity || pEntity->m_vecOldPosition == pEntity->pev->origin )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L50294
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 1632				; 00000660H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L50293
$L50294:

; 2214 : 		return;

	jmp	$L50292
$L50293:

; 2215 : 
; 2216 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2217 : 	if( !pActor || pActor->getNbShapes() <= 0 )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50297
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	ja	SHORT $L50296
$L50297:

; 2218 : 		return;

	jmp	$L50292
$L50296:

; 2219 : 
; 2220 : 	if( m_fNeedFetchResults )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+284], 0
	je	SHORT $L50298

; 2221 : 		return;

	jmp	$L50292
$L50298:

; 2222 : 
; 2223 : 	NxBoxShape *pShape = (NxBoxShape *)pActor->getShapes()[0];

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+80]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pShape$[ebp], eax

; 2224 : 
; 2225 : 	// if were in NOCLIP or FLY (ladder climbing) mode - disable collisions
; 2226 : 	if( pEntity->pev->movetype != MOVETYPE_WALK )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 3
	je	SHORT $L50301

; 2227 : 		pActor->raiseActorFlag( NX_AF_DISABLE_COLLISION );

	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+100]

; 2228 : 	else pActor->clearActorFlag( NX_AF_DISABLE_COLLISION );

	jmp	SHORT $L50302
$L50301:
	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+104]
$L50302:

; 2229 : 
; 2230 : 	Vector vecOffset = (pEntity->IsMonster()) ? Vector( 0, 0, pEntity->pev->maxs.z / 2.0f ) : g_vecZero;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+232]
	test	eax, eax
	je	SHORT $L52587
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+240]
	fdiv	DWORD PTR __real@4@40008000000000000000
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	push	0
	lea	ecx, DWORD PTR $T52586[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	DWORD PTR -92+[ebp], eax
	jmp	SHORT $L52588
$L52587:
	mov	DWORD PTR -92+[ebp], OFFSET FLAT:?g_vecZero@@3VVector@@B ; g_vecZero
$L52588:
	mov	edx, DWORD PTR -92+[ebp]
	mov	DWORD PTR $T52585[ebp], edx
	mov	eax, DWORD PTR $T52585[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOffset$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2231 : 
; 2232 : 	pShape->setDimensions( pEntity->pev->size * PADDING_FACTOR );

	push	1056629064				; 3efae148H
	lea	ecx, DWORD PTR $T52590[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T52589[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T52589[ebp]
	push	eax
	mov	ecx, DWORD PTR _pShape$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pShape$[ebp]
	call	DWORD PTR [edx+156]

; 2233 : 	pActor->moveGlobalPosition( pEntity->GetAbsOrigin() + vecOffset );

	lea	eax, DWORD PTR _vecOffset$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52592[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR $T52591[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52591[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+56]

; 2234 : 	pEntity->m_vecOldPosition = pEntity->GetAbsOrigin(); // update old position

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 1632				; 00000660H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L50292:

; 2235 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?MoveCharacter@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::MoveCharacter
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\server\novodex.cpp
xdata$x	SEGMENT
__ehfuncinfo$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0
xdata$x	ENDS
;	COMDAT ?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -16
_pActor$ = -20
_pose$ = -68
_mat$ = -132
_m$ = -196
__$EHRec$ = -12
?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CPhysicNovodex::MoveKinematic, COMDAT

; 2238 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2239 : 	if( !pEntity || ( pEntity->pev->movetype != MOVETYPE_PUSH && pEntity->pev->movetype != MOVETYPE_PUSHSTEP ))

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L50315
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 7
	je	SHORT $L50314
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 13			; 0000000dH
	je	SHORT $L50314
$L50315:

; 2240 : 		return;	// probably not a mover

	jmp	$L50313
$L50314:

; 2241 : 
; 2242 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2243 : 	if( !pActor || pActor->getNbShapes() <= 0 )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50318
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+76]
	test	eax, eax
	ja	SHORT $L50317
$L50318:

; 2244 : 		return;

	jmp	$L50313
$L50317:

; 2245 : 
; 2246 : 	if( m_fNeedFetchResults )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+284], 0
	je	SHORT $L50319

; 2247 : 		return;

	jmp	$L50313
$L50319:

; 2248 : 
; 2249 : 	if( pEntity->pev->solid == SOLID_NOT || pEntity->pev->solid == SOLID_TRIGGER )

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+268], 0
	je	SHORT $L50321
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 1
	jne	SHORT $L50320
$L50321:

; 2250 : 		pActor->raiseActorFlag( NX_AF_DISABLE_COLLISION );

	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+100]

; 2251 : 	else pActor->clearActorFlag( NX_AF_DISABLE_COLLISION );

	jmp	SHORT $L50322
$L50320:
	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+104]
$L50322:

; 2252 : 
; 2253 : 	NxMat34 pose;

	push	1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??0NxMat34@@QAE@_N@Z			; NxMat34::NxMat34
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2254 : 	float mat[16];
; 2255 : 
; 2256 : 	matrix4x4	m( pEntity->GetAbsOrigin(), pEntity->GetAbsAngles( ), 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 2257 : 	m.CopyToArray( mat );

	lea	eax, DWORD PTR _mat$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m$[ebp]
	call	?CopyToArray@matrix4x4@@QBEXPAM@Z	; matrix4x4::CopyToArray

; 2258 : 
; 2259 : 	// complex move for kinematic entities
; 2260 : 	pose.setColumnMajor44( mat );

	lea	ecx, DWORD PTR _mat$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pose$[ebp]
	call	?setColumnMajor44@NxMat34@@QAEXPBM@Z	; NxMat34::setColumnMajor44

; 2261 : 	pActor->moveGlobalPose( pose );

	lea	edx, DWORD PTR _pose$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+52]

; 2262 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
$L50313:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z$0:
	lea	ecx, DWORD PTR _pose$[ebp]
	call	??1NxMat34@@QAE@XZ			; NxMat34::~NxMat34
	ret	0
__ehhandler$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?MoveKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@@Z ENDP ; CPhysicNovodex::MoveKinematic
;	COMDAT ?EnableCollision@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_pEntity$ = 8
_fEnable$ = 12
_this$ = -4
_pActor$ = -8
?EnableCollision@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z PROC NEAR ; CPhysicNovodex::EnableCollision, COMDAT

; 2265 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2266 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2267 : 	if( !pActor || pActor->getNbShapes() <= 0 )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50333
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	ja	SHORT $L50332
$L50333:

; 2268 : 		return;

	jmp	SHORT $L50330
$L50332:

; 2269 : 
; 2270 : 	if( fEnable )

	cmp	DWORD PTR _fEnable$[ebp], 0
	je	SHORT $L50334

; 2272 : 		pActor->clearActorFlag( NX_AF_DISABLE_COLLISION );

	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+104]

; 2273 : 		pActor->raiseBodyFlag( NX_BF_VISUALIZATION );

	push	256					; 00000100H
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+356]

; 2275 : 	else

	jmp	SHORT $L50335
$L50334:

; 2277 : 		pActor->raiseActorFlag( NX_AF_DISABLE_COLLISION );

	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+100]

; 2278 : 		pActor->clearBodyFlag( NX_BF_VISUALIZATION );

	push	256					; 00000100H
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+360]
$L50335:
$L50330:

; 2280 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?EnableCollision@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z ENDP ; CPhysicNovodex::EnableCollision
_TEXT	ENDS
;	COMDAT ?MakeKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_pEntity$ = 8
_fEnable$ = 12
_this$ = -4
_pActor$ = -8
?MakeKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z PROC NEAR ; CPhysicNovodex::MakeKinematic, COMDAT

; 2283 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2284 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2285 : 	if( !pActor || pActor->getNbShapes() <= 0 )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50343
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	ja	SHORT $L50342
$L50343:

; 2286 : 		return;

	jmp	SHORT $L50340
$L50342:

; 2287 : 
; 2288 : 	if( fEnable )

	cmp	DWORD PTR _fEnable$[ebp], 0
	je	SHORT $L50344

; 2289 : 		pActor->raiseBodyFlag( NX_BF_KINEMATIC );

	push	128					; 00000080H
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+356]

; 2290 : 	else

	jmp	SHORT $L50345
$L50344:

; 2291 : 		pActor->clearBodyFlag( NX_BF_KINEMATIC );

	push	128					; 00000080H
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+360]
$L50345:
$L50340:

; 2292 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?MakeKinematic@CPhysicNovodex@@UAEXPAVCBaseEntity@@H@Z ENDP ; CPhysicNovodex::MakeKinematic
_TEXT	ENDS
PUBLIC	??0NxVec3@@QAE@ABV0@@Z				; NxVec3::NxVec3
PUBLIC	?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z	; NxMat33::multiply
PUBLIC	??HNxVec3@@QBE?AV0@ABV0@@Z			; NxVec3::operator+
PUBLIC	??_C@_0BO@NGDC@failed?5to?5build?5mesh?5from?5?$CFs?6?$AA@ ; `string'
PUBLIC	?GetHeadNode@CMeshDesc@@QAEPAUareanode_s@@XZ	; CMeshDesc::GetHeadNode
PUBLIC	?GetMesh@CMeshDesc@@QAEPAUmmesh_t@@XZ		; CMeshDesc::GetMesh
PUBLIC	?getCenter@NxBounds3@@QBEXAAVNxVec3@@@Z		; NxBounds3::getCenter
PUBLIC	?getExtents@NxBounds3@@QBEXAAVNxVec3@@@Z	; NxBounds3::getExtents
PUBLIC	??0NxBox@@QAE@XZ				; NxBox::NxBox
PUBLIC	??0NxBox@@QAE@ABVNxVec3@@0ABVNxMat33@@@Z	; NxBox::NxBox
PUBLIC	??1NxBox@@QAE@XZ				; NxBox::~NxBox
PUBLIC	??4NxBox@@QAEAAV0@ABV0@@Z			; NxBox::operator=
PUBLIC	?GetModel@CBaseEntity@@QAEPBDXZ			; CBaseEntity::GetModel
PUBLIC	??0TraceMesh@@QAE@XZ				; TraceMesh::TraceMesh
PUBLIC	??1TraceMesh@@QAE@XZ				; TraceMesh::~TraceMesh
PUBLIC	?SetTraceMesh@TraceMesh@@QAEXPAUmmesh_t@@PAUareanode_s@@@Z ; TraceMesh::SetTraceMesh
EXTRN	??4Vector@@QAEABV0@ABVNxVec3@@@Z:NEAR		; Vector::operator=
EXTRN	?InitMeshBuild@CMeshDesc@@QAE_NPBDH@Z:NEAR	; CMeshDesc::InitMeshBuild
EXTRN	?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z:NEAR ; CMeshDesc::AddMeshTrinagle
EXTRN	?FinishMeshBuild@CMeshDesc@@QAE_NXZ:NEAR	; CMeshDesc::FinishMeshBuild
EXTRN	?CheckMesh@CMeshDesc@@QAEPAUmmesh_t@@ABVVector@@0@Z:NEAR ; CMeshDesc::CheckMesh
EXTRN	?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z:NEAR ; UTIL_MoveBounds
EXTRN	?BoundsIntersect@@YA_NABVVector@@000@Z:NEAR	; BoundsIntersect
EXTRN	?SetupTrace@TraceMesh@@QAEXABVVector@@000PAUtrace_s@@@Z:NEAR ; TraceMesh::SetupTrace
EXTRN	?DoTrace@TraceMesh@@QAE_NXZ:NEAR		; TraceMesh::DoTrace
;	COMDAT ??_C@_0BO@NGDC@failed?5to?5build?5mesh?5from?5?$CFs?6?$AA@
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
??_C@_0BO@NGDC@failed?5to?5build?5mesh?5from?5?$CFs?6?$AA@ DB 'failed to '
	DB	'build mesh from %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z DD 019930520H
	DD	06H
	DD	FLAT:__unwindtable$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$5
xdata$x	ENDS
;	COMDAT ?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z
_TEXT	SEGMENT
_pTouch$ = 8
_start$ = 12
_mins$ = 16
_maxs$ = 20
_end$ = 24
_tr$ = 28
_this$ = -16
_pActor$ = -20
_trace_mins$ = -32
_trace_maxs$ = -44
_pMesh$ = -48
_pHeadNode$ = -52
_pShape$50364 = -56
_shapeType$50365 = -60
_indices$50366 = -64
_verts$50367 = -68
_triangle$50368 = -104
_NbTris$50370 = -108
_pConvexShape$50372 = -112
_cm$50374 = -116
_pTriangleMeshShape$50379 = -120
_trm$50381 = -124
_points$50387 = -220
_ext$50389 = -232
_cnt$50390 = -244
_bounds$50391 = -268
_obb$50392 = -328
_i$50393 = -332
_pBoxShape$50397 = -336
_absRot$50399 = -372
_absPos$50401 = -384
_j$50406 = -388
_i0$50410 = -392
_i1$50411 = -396
_i2$50412 = -400
_absRot$50414 = -436
_absPos$50416 = -448
_i0$50421 = -452
_i1$50422 = -456
_i2$50423 = -460
_v0$50424 = -472
_v1$50425 = -484
_v2$50426 = -496
_trm$ = -616
$T52608 = -628
$T52609 = -688
$T52610 = -700
$T52611 = -712
$T52612 = -724
$T52613 = -736
__$EHRec$ = -12
?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z PROC NEAR ; CPhysicNovodex::SweepTest, COMDAT

; 2295 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 796				; 0000031cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2296 : 	NxActor *pActor = ActorFromEntity( pTouch );

	mov	eax, DWORD PTR _pTouch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2297 : 
; 2298 : 	if( !pActor || pActor->getNbShapes() <= 0 || pActor->readActorFlag( NX_AF_DISABLE_COLLISION ))

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50357
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	jbe	SHORT $L50357
	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+108]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L50356
$L50357:

; 2300 : 		// bad actor?
; 2301 : 		tr->allsolid = false;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [eax], 0

; 2302 : 		return;

	jmp	$L50354
$L50356:

; 2304 : 
; 2305 : 	Vector trace_mins, trace_maxs;

	lea	ecx, DWORD PTR _trace_mins$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _trace_maxs$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 2306 : 	UTIL_MoveBounds( start, mins, maxs, end, trace_mins, trace_maxs );

	lea	ecx, DWORD PTR _trace_maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _trace_mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	call	?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z ; UTIL_MoveBounds
	add	esp, 24					; 00000018H

; 2307 : 
; 2308 : 	// NOTE: pmove code completely ignore a bounds checking. So we need to do it here
; 2309 : 	if( !BoundsIntersect( trace_mins, trace_maxs, pTouch->pev->absmin, pTouch->pev->absmax ))

	mov	ecx, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 208				; 000000d0H
	push	edx
	mov	eax, DWORD PTR _pTouch$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 196				; 000000c4H
	push	ecx
	lea	edx, DWORD PTR _trace_maxs$[ebp]
	push	edx
	lea	eax, DWORD PTR _trace_mins$[ebp]
	push	eax
	call	?BoundsIntersect@@YA_NABVVector@@000@Z	; BoundsIntersect
	add	esp, 16					; 00000010H
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L50360

; 2311 : 		tr->allsolid = false;

	mov	ecx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [ecx], 0

; 2312 : 		return;

	jmp	$L50354
$L50360:

; 2314 : 
; 2315 : 	mmesh_t *pMesh = pTouch->m_BodyMesh.CheckMesh( pTouch->GetAbsOrigin(), pTouch->GetAbsAngles( ));

	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?CheckMesh@CMeshDesc@@QAEPAUmmesh_t@@ABVVector@@0@Z ; CMeshDesc::CheckMesh
	mov	DWORD PTR _pMesh$[ebp], eax

; 2316 : 	areanode_t *pHeadNode = pTouch->m_BodyMesh.GetHeadNode();

	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?GetHeadNode@CMeshDesc@@QAEPAUareanode_s@@XZ ; CMeshDesc::GetHeadNode
	mov	DWORD PTR _pHeadNode$[ebp], eax

; 2317 : 
; 2318 : 	if( !pMesh )

	cmp	DWORD PTR _pMesh$[ebp], 0
	jne	$L50363

; 2320 : 		// update cache or build from scratch
; 2321 : 		NxShape *pShape = pActor->getShapes()[0];

	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pShape$50364[ebp], ecx

; 2322 : 		int shapeType = pShape->getType();

	mov	edx, DWORD PTR _pShape$50364[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pShape$50364[ebp]
	call	DWORD PTR [eax+92]
	mov	DWORD PTR _shapeType$50365[ebp], eax

; 2323 : 		const NxU32 *indices;
; 2324 : 		const NxVec3 *verts;
; 2325 : 		Vector triangle[3];

	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	3
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _triangle$50368[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 2326 : 		NxU32 NbTris;
; 2327 : 
; 2328 : 		if( shapeType == NX_SHAPE_CONVEX )

	cmp	DWORD PTR _shapeType$50365[ebp], 5
	jne	SHORT $L50371

; 2330 : 			NxConvexShape *pConvexShape = (NxConvexShape *)pShape;

	mov	edx, DWORD PTR _pShape$50364[ebp]
	mov	DWORD PTR _pConvexShape$50372[ebp], edx

; 2331 : 			NxConvexMesh& cm = pConvexShape->getConvexMesh();

	mov	eax, DWORD PTR _pConvexShape$50372[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pConvexShape$50372[ebp]
	call	DWORD PTR [edx+164]
	mov	DWORD PTR _cm$50374[ebp], eax

; 2332 : 
; 2333 : 			NbTris = cm.getCount( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _cm$50374[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cm$50374[ebp]
	call	DWORD PTR [edx+8]
	mov	DWORD PTR _NbTris$50370[ebp], eax

; 2334 : 			indices = (const NxU32 *)cm.getBase( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _cm$50374[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cm$50374[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _indices$50366[ebp], eax

; 2335 : 			verts = (const NxVec3 *)cm.getBase( 0, NX_ARRAY_VERTICES );

	push	1
	push	0
	mov	eax, DWORD PTR _cm$50374[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cm$50374[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _verts$50367[ebp], eax

; 2337 : 		else if( shapeType == NX_SHAPE_MESH )

	jmp	SHORT $L50385
$L50371:
	cmp	DWORD PTR _shapeType$50365[ebp], 6
	jne	SHORT $L50378

; 2339 : 			NxTriangleMeshShape *pTriangleMeshShape = (NxTriangleMeshShape *)pShape;

	mov	eax, DWORD PTR _pShape$50364[ebp]
	mov	DWORD PTR _pTriangleMeshShape$50379[ebp], eax

; 2340 : 			NxTriangleMesh& trm = pTriangleMeshShape->getTriangleMesh();

	mov	ecx, DWORD PTR _pTriangleMeshShape$50379[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTriangleMeshShape$50379[ebp]
	call	DWORD PTR [edx+164]
	mov	DWORD PTR _trm$50381[ebp], eax

; 2341 : 
; 2342 : 			NbTris = trm.getCount( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _trm$50381[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _trm$50381[ebp]
	call	DWORD PTR [edx+8]
	mov	DWORD PTR _NbTris$50370[ebp], eax

; 2343 : 			indices = (const NxU32 *)trm.getBase( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _trm$50381[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _trm$50381[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _indices$50366[ebp], eax

; 2344 : 			verts = (const NxVec3 *)trm.getBase( 0, NX_ARRAY_VERTICES );

	push	1
	push	0
	mov	eax, DWORD PTR _trm$50381[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _trm$50381[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _verts$50367[ebp], eax

; 2346 : 		else if( shapeType != NX_SHAPE_BOX )

	jmp	SHORT $L50385
$L50378:
	cmp	DWORD PTR _shapeType$50365[ebp], 2
	je	SHORT $L50385

; 2348 : 			// unsupported mesh type, so skip them
; 2349 : 			tr->allsolid = false;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [eax], 0

; 2350 : 			return;

	jmp	$L50354
$L50385:

; 2352 : 
; 2353 : 		if( shapeType == NX_SHAPE_BOX )

	cmp	DWORD PTR _shapeType$50365[ebp], 2
	jne	$L50386

; 2355 : 			NxVec3	points[8];

	push	OFFSET FLAT:??0NxVec3@@QAE@XZ		; NxVec3::NxVec3
	push	8
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _points$50387[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 2356 : 			NxVec3	ext, cnt;

	lea	ecx, DWORD PTR _ext$50389[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	lea	ecx, DWORD PTR _cnt$50390[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 2357 : 			NxBounds3	bounds;

	lea	ecx, DWORD PTR _bounds$50391[ebp]
	call	??0NxBounds3@@QAE@XZ			; NxBounds3::NxBounds3
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2358 : 			NxBox	obb;

	lea	ecx, DWORD PTR _obb$50392[ebp]
	call	??0NxBox@@QAE@XZ			; NxBox::NxBox
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2359 : 
; 2360 : 			// each box shape contain 12 triangles
; 2361 : 			pTouch->m_BodyMesh.InitMeshBuild( pTouch->GetModel(), pActor->getNbShapes() * 12 );

	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+76]
	imul	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?InitMeshBuild@CMeshDesc@@QAE_NPBDH@Z	; CMeshDesc::InitMeshBuild

; 2362 : 
; 2363 : 			for( uint i = 0; i < pActor->getNbShapes(); i++ )

	mov	DWORD PTR _i$50393[ebp], 0
	jmp	SHORT $L50394
$L50395:
	mov	ecx, DWORD PTR _i$50393[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$50393[ebp], ecx
$L50394:
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+76]
	cmp	DWORD PTR _i$50393[ebp], eax
	jae	$L50396

; 2365 : 				NxBoxShape *pBoxShape = (NxBoxShape *)pActor->getShapes()[i];

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _i$50393[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pBoxShape$50397[ebp], edx

; 2366 : 				NxMat33 absRot = pBoxShape->getGlobalOrientation();

	lea	eax, DWORD PTR _absRot$50399[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBoxShape$50397[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBoxShape$50397[ebp]
	call	DWORD PTR [edx+72]
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2367 : 				NxVec3 absPos = pBoxShape->getGlobalPosition();

	lea	eax, DWORD PTR $T52608[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBoxShape$50397[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBoxShape$50397[ebp]
	call	DWORD PTR [edx+68]
	push	eax
	lea	ecx, DWORD PTR _absPos$50401[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2368 : 
; 2369 : 				// don't use pBoxShape->getWorldAABB it's caused to broke suspension and deadlocks !!!
; 2370 : 				pBoxShape->getWorldBounds( bounds );

	lea	eax, DWORD PTR _bounds$50391[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBoxShape$50397[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBoxShape$50397[ebp]
	call	DWORD PTR [edx+16]

; 2371 : 				bounds.getExtents( ext );

	lea	eax, DWORD PTR _ext$50389[ebp]
	push	eax
	lea	ecx, DWORD PTR _bounds$50391[ebp]
	call	?getExtents@NxBounds3@@QBEXAAVNxVec3@@@Z ; NxBounds3::getExtents

; 2372 : 				bounds.getCenter( cnt );

	lea	ecx, DWORD PTR _cnt$50390[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bounds$50391[ebp]
	call	?getCenter@NxBounds3@@QBEXAAVNxVec3@@@Z	; NxBounds3::getCenter

; 2373 : 				obb = NxBox( cnt, ext, absRot );

	lea	edx, DWORD PTR _absRot$50399[ebp]
	push	edx
	lea	eax, DWORD PTR _ext$50389[ebp]
	push	eax
	lea	ecx, DWORD PTR _cnt$50390[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52609[ebp]
	call	??0NxBox@@QAE@ABVNxVec3@@0ABVNxMat33@@@Z ; NxBox::NxBox
	mov	DWORD PTR -740+[ebp], eax
	mov	edx, DWORD PTR -740+[ebp]
	mov	DWORD PTR -744+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR -744+[ebp]
	push	eax
	lea	ecx, DWORD PTR _obb$50392[ebp]
	call	??4NxBox@@QAEAAV0@ABV0@@Z		; NxBox::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T52609[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox

; 2374 : 
; 2375 : 				indices = (const NxU32 *)m_pUtils->NxGetBoxTriangles();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1356]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+28]
	mov	DWORD PTR _indices$50366[ebp], eax

; 2376 : 				m_pUtils->NxComputeBoxPoints( obb, points );

	lea	eax, DWORD PTR _points$50387[ebp]
	push	eax
	lea	ecx, DWORD PTR _obb$50392[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1356]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1356]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+12]

; 2377 : 				verts = (const NxVec3 *)points;

	lea	ecx, DWORD PTR _points$50387[ebp]
	mov	DWORD PTR _verts$50367[ebp], ecx

; 2378 : 
; 2379 : 				for( int j = 0; j < 12; j++ )

	mov	DWORD PTR _j$50406[ebp], 0
	jmp	SHORT $L50407
$L50408:
	mov	edx, DWORD PTR _j$50406[ebp]
	add	edx, 1
	mov	DWORD PTR _j$50406[ebp], edx
$L50407:
	cmp	DWORD PTR _j$50406[ebp], 12		; 0000000cH
	jge	$L50409

; 2381 : 					NxU32 i0 = *indices++;

	mov	eax, DWORD PTR _indices$50366[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i0$50410[ebp], ecx
	mov	edx, DWORD PTR _indices$50366[ebp]
	add	edx, 4
	mov	DWORD PTR _indices$50366[ebp], edx

; 2382 : 					NxU32 i1 = *indices++;

	mov	eax, DWORD PTR _indices$50366[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i1$50411[ebp], ecx
	mov	edx, DWORD PTR _indices$50366[ebp]
	add	edx, 4
	mov	DWORD PTR _indices$50366[ebp], edx

; 2383 : 					NxU32 i2 = *indices++;

	mov	eax, DWORD PTR _indices$50366[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i2$50412[ebp], ecx
	mov	edx, DWORD PTR _indices$50366[ebp]
	add	edx, 4
	mov	DWORD PTR _indices$50366[ebp], edx

; 2384 : 					triangle[0] = verts[i0];

	mov	eax, DWORD PTR _i0$50410[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _verts$50367[ebp]
	add	ecx, eax
	push	ecx
	lea	ecx, DWORD PTR _triangle$50368[ebp]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2385 : 					triangle[1] = verts[i1];

	mov	edx, DWORD PTR _i1$50411[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _verts$50367[ebp]
	add	eax, edx
	push	eax
	lea	ecx, DWORD PTR _triangle$50368[ebp+12]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2386 : 					triangle[2] = verts[i2];

	mov	ecx, DWORD PTR _i2$50412[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _verts$50367[ebp]
	add	edx, ecx
	push	edx
	lea	ecx, DWORD PTR _triangle$50368[ebp+24]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2387 : 
; 2388 : 					pTouch->m_BodyMesh.AddMeshTrinagle( triangle );

	lea	eax, DWORD PTR _triangle$50368[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z ; CMeshDesc::AddMeshTrinagle

; 2389 : 				}

	jmp	$L50408
$L50409:

; 2390 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _absRot$50399[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	jmp	$L50395
$L50396:

; 2391 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _obb$50392[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _bounds$50391[ebp]
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3

; 2392 : 		else

	jmp	$L50413
$L50386:

; 2394 : 			NxMat33 absRot = pShape->getGlobalOrientation();

	lea	ecx, DWORD PTR _absRot$50414[ebp]
	push	ecx
	mov	edx, DWORD PTR _pShape$50364[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pShape$50364[ebp]
	call	DWORD PTR [eax+72]
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 2395 : 			NxVec3 absPos = pShape->getGlobalPosition();

	lea	ecx, DWORD PTR $T52610[ebp]
	push	ecx
	mov	edx, DWORD PTR _pShape$50364[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pShape$50364[ebp]
	call	DWORD PTR [eax+68]
	push	eax
	lea	ecx, DWORD PTR _absPos$50416[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2396 : 
; 2397 : 			pTouch->m_BodyMesh.InitMeshBuild( pTouch->GetModel(), NbTris );

	mov	ecx, DWORD PTR _NbTris$50370[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?InitMeshBuild@CMeshDesc@@QAE_NPBDH@Z	; CMeshDesc::InitMeshBuild
$L50419:

; 2398 : 
; 2399 : 			// NOTE: we compute triangles in abs coords because player AABB
; 2400 : 			// can't be transformed as done for not axial cases
; 2401 : 			// FIXME: store all meshes as local and use capsule instead of bbox
; 2402 : 			while( NbTris-- )

	mov	edx, DWORD PTR _NbTris$50370[ebp]
	mov	eax, DWORD PTR _NbTris$50370[ebp]
	sub	eax, 1
	mov	DWORD PTR _NbTris$50370[ebp], eax
	test	edx, edx
	je	$L50420

; 2404 : 				NxU32 i0 = *indices++;

	mov	ecx, DWORD PTR _indices$50366[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _i0$50421[ebp], edx
	mov	eax, DWORD PTR _indices$50366[ebp]
	add	eax, 4
	mov	DWORD PTR _indices$50366[ebp], eax

; 2405 : 				NxU32 i1 = *indices++;

	mov	ecx, DWORD PTR _indices$50366[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _i1$50422[ebp], edx
	mov	eax, DWORD PTR _indices$50366[ebp]
	add	eax, 4
	mov	DWORD PTR _indices$50366[ebp], eax

; 2406 : 				NxU32 i2 = *indices++;

	mov	ecx, DWORD PTR _indices$50366[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _i2$50423[ebp], edx
	mov	eax, DWORD PTR _indices$50366[ebp]
	add	eax, 4
	mov	DWORD PTR _indices$50366[ebp], eax

; 2407 : 				NxVec3 v0 = verts[i0];

	mov	ecx, DWORD PTR _i0$50421[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _verts$50367[ebp]
	add	edx, ecx
	push	edx
	lea	ecx, DWORD PTR _v0$50424[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2408 : 				NxVec3 v1 = verts[i1];

	mov	eax, DWORD PTR _i1$50422[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _verts$50367[ebp]
	add	ecx, eax
	push	ecx
	lea	ecx, DWORD PTR _v1$50425[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2409 : 				NxVec3 v2 = verts[i2];

	mov	edx, DWORD PTR _i2$50423[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _verts$50367[ebp]
	add	eax, edx
	push	eax
	lea	ecx, DWORD PTR _v2$50426[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2410 : 
; 2411 : 				absRot.multiply( v0, v0 );

	lea	ecx, DWORD PTR _v0$50424[ebp]
	push	ecx
	lea	edx, DWORD PTR _v0$50424[ebp]
	push	edx
	lea	ecx, DWORD PTR _absRot$50414[ebp]
	call	?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z ; NxMat33::multiply

; 2412 : 				absRot.multiply( v1, v1 );

	lea	eax, DWORD PTR _v1$50425[ebp]
	push	eax
	lea	ecx, DWORD PTR _v1$50425[ebp]
	push	ecx
	lea	ecx, DWORD PTR _absRot$50414[ebp]
	call	?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z ; NxMat33::multiply

; 2413 : 				absRot.multiply( v2, v2 );

	lea	edx, DWORD PTR _v2$50426[ebp]
	push	edx
	lea	eax, DWORD PTR _v2$50426[ebp]
	push	eax
	lea	ecx, DWORD PTR _absRot$50414[ebp]
	call	?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z ; NxMat33::multiply

; 2414 : 				triangle[0] = v0 + absPos;

	lea	ecx, DWORD PTR _absPos$50416[ebp]
	push	ecx
	lea	edx, DWORD PTR $T52611[ebp]
	push	edx
	lea	ecx, DWORD PTR _v0$50424[ebp]
	call	??HNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator+
	push	eax
	lea	ecx, DWORD PTR _triangle$50368[ebp]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2415 : 				triangle[1] = v1 + absPos;

	lea	eax, DWORD PTR _absPos$50416[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52612[ebp]
	push	ecx
	lea	ecx, DWORD PTR _v1$50425[ebp]
	call	??HNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator+
	push	eax
	lea	ecx, DWORD PTR _triangle$50368[ebp+12]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2416 : 				triangle[2] = v2 + absPos;

	lea	edx, DWORD PTR _absPos$50416[ebp]
	push	edx
	lea	eax, DWORD PTR $T52613[ebp]
	push	eax
	lea	ecx, DWORD PTR _v2$50426[ebp]
	call	??HNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator+
	push	eax
	lea	ecx, DWORD PTR _triangle$50368[ebp+24]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2417 : 
; 2418 : 				pTouch->m_BodyMesh.AddMeshTrinagle( triangle );

	lea	ecx, DWORD PTR _triangle$50368[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?AddMeshTrinagle@CMeshDesc@@QAE_NQBVVector@@@Z ; CMeshDesc::AddMeshTrinagle

; 2419 : 			}

	jmp	$L50419
$L50420:

; 2420 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _absRot$50414[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
$L50413:

; 2421 : 
; 2422 : 		if( !pTouch->m_BodyMesh.FinishMeshBuild( ))

	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?FinishMeshBuild@CMeshDesc@@QAE_NXZ	; CMeshDesc::FinishMeshBuild
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L50430

; 2424 : 			ALERT( at_error, "failed to build mesh from %s\n", pTouch->GetModel() );

	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	push	OFFSET FLAT:??_C@_0BO@NGDC@failed?5to?5build?5mesh?5from?5?$CFs?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 2425 : 			tr->allsolid = false;

	mov	edx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [edx], 0

; 2426 : 			return;

	jmp	$L50354
$L50430:

; 2428 : 
; 2429 : 		// NOTE: don't care about validity this pointer
; 2430 : 		// just trace failed if it's happens
; 2431 : 		pMesh = pTouch->m_BodyMesh.GetMesh();

	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?GetMesh@CMeshDesc@@QAEPAUmmesh_t@@XZ	; CMeshDesc::GetMesh
	mov	DWORD PTR _pMesh$[ebp], eax

; 2432 : 		pHeadNode = pTouch->m_BodyMesh.GetHeadNode();

	mov	ecx, DWORD PTR _pTouch$[ebp]
	add	ecx, 248				; 000000f8H
	call	?GetHeadNode@CMeshDesc@@QAEPAUareanode_s@@XZ ; CMeshDesc::GetHeadNode
	mov	DWORD PTR _pHeadNode$[ebp], eax
$L50363:

; 2434 : 
; 2435 : 	TraceMesh	trm;	// a name like Doom3 :-)

	lea	ecx, DWORD PTR _trm$[ebp]
	call	??0TraceMesh@@QAE@XZ			; TraceMesh::TraceMesh
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 2436 : 
; 2437 : 	trm.SetTraceMesh( pMesh, pHeadNode );

	mov	eax, DWORD PTR _pHeadNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMesh$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _trm$[ebp]
	call	?SetTraceMesh@TraceMesh@@QAEXPAUmmesh_t@@PAUareanode_s@@@Z ; TraceMesh::SetTraceMesh

; 2438 : 	trm.SetupTrace( start, mins, maxs, end, tr );

	mov	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	lea	ecx, DWORD PTR _trm$[ebp]
	call	?SetupTrace@TraceMesh@@QAEXABVVector@@000PAUtrace_s@@@Z ; TraceMesh::SetupTrace

; 2439 : 
; 2440 : 	if( trm.DoTrace())

	lea	ecx, DWORD PTR _trm$[ebp]
	call	?DoTrace@TraceMesh@@QAE_NXZ		; TraceMesh::DoTrace
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L50434

; 2442 : 		if( tr->fraction < 1.0f || tr->startsolid )

	mov	ecx, DWORD PTR _tr$[ebp]
	fld	DWORD PTR [ecx+16]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L50435
	mov	edx, DWORD PTR _tr$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L50434
$L50435:

; 2443 : 			tr->ent = pTouch->edict();

	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [ecx+48], eax
$L50434:

; 2445 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _trm$[ebp]
	call	??1TraceMesh@@QAE@XZ			; TraceMesh::~TraceMesh
$L50354:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$0:
	lea	ecx, DWORD PTR _bounds$50391[ebp]
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	ret	0
__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$1:
	lea	ecx, DWORD PTR _obb$50392[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	ret	0
__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$2:
	lea	ecx, DWORD PTR _absRot$50399[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$3:
	lea	ecx, DWORD PTR $T52609[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	ret	0
__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$4:
	lea	ecx, DWORD PTR _absRot$50414[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__unwindfunclet$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z$5:
	lea	ecx, DWORD PTR _trm$[ebp]
	call	??1TraceMesh@@QAE@XZ			; TraceMesh::~TraceMesh
	ret	0
__ehhandler$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?SweepTest@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@111PAUtrace_s@@@Z ENDP ; CPhysicNovodex::SweepTest
;	COMDAT ?GetHeadNode@CMeshDesc@@QAEPAUareanode_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetHeadNode@CMeshDesc@@QAEPAUareanode_s@@XZ PROC NEAR	; CMeshDesc::GetHeadNode, COMDAT

; 76   : 	_inline areanode_t *GetHeadNode( void ) { return (has_tree) ? &areanodes[0] : NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1352]
	test	ecx, ecx
	je	SHORT $L52628
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	mov	DWORD PTR -8+[ebp], edx
	jmp	SHORT $L52629
$L52628:
	mov	DWORD PTR -8+[ebp], 0
$L52629:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetHeadNode@CMeshDesc@@QAEPAUareanode_s@@XZ ENDP	; CMeshDesc::GetHeadNode
_TEXT	ENDS
;	COMDAT ?GetMesh@CMeshDesc@@QAEPAUmmesh_t@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetMesh@CMeshDesc@@QAEPAUmmesh_t@@XZ PROC NEAR		; CMeshDesc::GetMesh, COMDAT

; 80   : 	_inline mmesh_t *GetMesh() { return &m_mesh; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMesh@CMeshDesc@@QAEPAUmmesh_t@@XZ ENDP		; CMeshDesc::GetMesh
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetModel@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetModel, COMDAT

; 288  : 	const char*	GetModel() { return STRING( pev->model ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetModel
_TEXT	ENDS
;	COMDAT ??0NxVec3@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0NxVec3@@QAE@ABV0@@Z PROC NEAR			; NxVec3::NxVec3, COMDAT

; 416  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 417  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0NxVec3@@QAE@ABV0@@Z ENDP				; NxVec3::NxVec3
_TEXT	ENDS
;	COMDAT ??HNxVec3@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
$T52638 = -16
___$ReturnUdt$ = 8
_this$ = -4
??HNxVec3@@QBE?AV0@ABV0@@Z PROC NEAR			; NxVec3::operator+, COMDAT

; 799  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 	return NxVec3(x + v.x, y + v.y, z + v.z);	// RVO version

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T52638[ebp]
	call	??0NxVec3@@QAE@MMM@Z			; NxVec3::NxVec3
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 801  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HNxVec3@@QBE?AV0@ABV0@@Z ENDP				; NxVec3::operator+
_TEXT	ENDS
;	COMDAT ?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z
_TEXT	SEGMENT
_src$ = 8
_dst$ = 12
_this$ = -4
_x$ = -8
_y$ = -12
_z$ = -16
?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z PROC NEAR	; NxMat33::multiply, COMDAT

; 1390 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1391 : 	NxReal x,y,z;	//so it works if src == dst
; 1392 : 	x = data.s._11 * src.x + data.s._12 * src.y + data.s._13 * src.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _x$[ebp]

; 1393 : 	y = data.s._21 * src.x + data.s._22 * src.y + data.s._23 * src.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx+16]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [ecx+20]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _y$[ebp]

; 1394 : 	z = data.s._31 * src.x + data.s._32 * src.y + data.s._33 * src.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [eax+24]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _src$[ebp]
	fld	DWORD PTR [edx+28]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	fld	DWORD PTR [ecx+32]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _z$[ebp]

; 1395 : 
; 1396 : 	dst.x = x;

	mov	eax, DWORD PTR _dst$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	mov	DWORD PTR [eax], ecx

; 1397 : 	dst.y = y;

	mov	edx, DWORD PTR _dst$[ebp]
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1398 : 	dst.z = z;	

	mov	ecx, DWORD PTR _dst$[ebp]
	mov	edx, DWORD PTR _z$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1399 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z ENDP		; NxMat33::multiply
_TEXT	ENDS
PUBLIC	?add@NxVec3@@QAEXABV1@0@Z			; NxVec3::add
PUBLIC	??XNxVec3@@QAEAAV0@M@Z				; NxVec3::operator*=
;	COMDAT ?getCenter@NxBounds3@@QBEXAAVNxVec3@@@Z
_TEXT	SEGMENT
_center$ = 8
_this$ = -4
?getCenter@NxBounds3@@QBEXAAVNxVec3@@@Z PROC NEAR	; NxBounds3::getCenter, COMDAT

; 301  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 	center.add(min,max);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _center$[ebp]
	call	?add@NxVec3@@QAEXABV1@0@Z		; NxVec3::add

; 303  : 	center *= NxReal(0.5);

	push	1056964608				; 3f000000H
	mov	ecx, DWORD PTR _center$[ebp]
	call	??XNxVec3@@QAEAAV0@M@Z			; NxVec3::operator*=

; 304  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?getCenter@NxBounds3@@QBEXAAVNxVec3@@@Z ENDP		; NxBounds3::getCenter
_TEXT	ENDS
;	COMDAT ?add@NxVec3@@QAEXABV1@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
_this$ = -4
?add@NxVec3@@QAEXABV1@0@Z PROC NEAR			; NxVec3::add, COMDAT

; 630  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 	x = a.x + b.x;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 632  : 	y = a.y + b.y;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 633  : 	z = a.z + b.z;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 634  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?add@NxVec3@@QAEXABV1@0@Z ENDP				; NxVec3::add
_TEXT	ENDS
;	COMDAT ??XNxVec3@@QAEAAV0@M@Z
_TEXT	SEGMENT
_f$ = 8
_this$ = -4
??XNxVec3@@QAEAAV0@M@Z PROC NEAR			; NxVec3::operator*=, COMDAT

; 842  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 	x *= f;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _f$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 844  : 	y *= f;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _f$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 845  : 	z *= f;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _f$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 846  : 	
; 847  : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 848  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??XNxVec3@@QAEAAV0@M@Z ENDP				; NxVec3::operator*=
_TEXT	ENDS
PUBLIC	?subtract@NxVec3@@QAEXABV1@0@Z			; NxVec3::subtract
;	COMDAT ?getExtents@NxBounds3@@QBEXAAVNxVec3@@@Z
_TEXT	SEGMENT
_extents$ = 8
_this$ = -4
?getExtents@NxBounds3@@QBEXAAVNxVec3@@@Z PROC NEAR	; NxBounds3::getExtents, COMDAT

; 312  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 	extents.subtract(max,min);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _extents$[ebp]
	call	?subtract@NxVec3@@QAEXABV1@0@Z		; NxVec3::subtract

; 314  : 	extents *= NxReal(0.5);

	push	1056964608				; 3f000000H
	mov	ecx, DWORD PTR _extents$[ebp]
	call	??XNxVec3@@QAEAAV0@M@Z			; NxVec3::operator*=

; 315  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?getExtents@NxBounds3@@QBEXAAVNxVec3@@@Z ENDP		; NxBounds3::getExtents
_TEXT	ENDS
;	COMDAT ?subtract@NxVec3@@QAEXABV1@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
_this$ = -4
?subtract@NxVec3@@QAEXABV1@0@Z PROC NEAR		; NxVec3::subtract, COMDAT

; 638  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 639  : 	x = a.x - b.x;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 640  : 	y = a.y - b.y;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 641  : 	z = a.z - b.z;

	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 642  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?subtract@NxVec3@@QAEXABV1@0@Z ENDP			; NxVec3::subtract
_TEXT	ENDS
;	COMDAT ??0NxBox@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxBox@@QAE@XZ PROC NEAR				; NxBox::NxBox, COMDAT

; 37   : 	NX_INLINE NxBox()

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0NxMat33@@QAE@XZ			; NxMat33::NxMat33

; 38   : 		{
; 39   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxBox@@QAE@XZ ENDP					; NxBox::NxBox
_TEXT	ENDS
PUBLIC	??0NxMat33@@QAE@ABV0@@Z				; NxMat33::NxMat33
;	COMDAT ??0NxBox@@QAE@ABVNxVec3@@0ABVNxMat33@@@Z
_TEXT	SEGMENT
__center$ = 8
__extents$ = 12
__rot$ = 16
_this$ = -4
??0NxBox@@QAE@ABVNxVec3@@0ABVNxMat33@@@Z PROC NEAR	; NxBox::NxBox, COMDAT

; 49   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __center$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3
	mov	ecx, DWORD PTR __extents$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3
	mov	edx, DWORD PTR __rot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0NxMat33@@QAE@ABV0@@Z			; NxMat33::NxMat33

; 50   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0NxBox@@QAE@ABVNxVec3@@0ABVNxMat33@@@Z ENDP		; NxBox::NxBox
_TEXT	ENDS
;	COMDAT ??0NxMat33@@QAE@ABV0@@Z
_TEXT	SEGMENT
_a$ = 8
_this$ = -4
??0NxMat33@@QAE@ABV0@@Z PROC NEAR			; NxMat33::NxMat33, COMDAT

; 359  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 	data = a.data;

	mov	esi, DWORD PTR _a$[ebp]
	mov	ecx, 9
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd

; 361  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0NxMat33@@QAE@ABV0@@Z ENDP				; NxMat33::NxMat33
_TEXT	ENDS
;	COMDAT ??1NxBox@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1NxBox@@QAE@XZ PROC NEAR				; NxBox::~NxBox, COMDAT

; 56   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1NxBox@@QAE@XZ ENDP					; NxBox::~NxBox
_TEXT	ENDS
;	COMDAT ??0TraceMesh@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0TraceMesh@@QAE@XZ PROC NEAR				; TraceMesh::TraceMesh, COMDAT

; 38   : 	TraceMesh() { mesh = NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0TraceMesh@@QAE@XZ ENDP				; TraceMesh::TraceMesh
_TEXT	ENDS
;	COMDAT ??1TraceMesh@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1TraceMesh@@QAE@XZ PROC NEAR				; TraceMesh::~TraceMesh, COMDAT

; 39   : 	~TraceMesh() {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1TraceMesh@@QAE@XZ ENDP				; TraceMesh::~TraceMesh
_TEXT	ENDS
;	COMDAT ?SetTraceMesh@TraceMesh@@QAEXPAUmmesh_t@@PAUareanode_s@@@Z
_TEXT	SEGMENT
_cached_mesh$ = 8
_tree$ = 12
_this$ = -4
?SetTraceMesh@TraceMesh@@QAEXPAUmmesh_t@@PAUareanode_s@@@Z PROC NEAR ; TraceMesh::SetTraceMesh, COMDAT

; 42   : 	void SetTraceMesh( mmesh_t *cached_mesh, areanode_t *tree ) { mesh = cached_mesh; areanodes = tree; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cached_mesh$[ebp]
	mov	DWORD PTR [eax+108], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tree$[ebp]
	mov	DWORD PTR [edx+104], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetTraceMesh@TraceMesh@@QAEXPAUmmesh_t@@PAUareanode_s@@@Z ENDP ; TraceMesh::SetTraceMesh
_TEXT	ENDS
;	COMDAT ??4NxBox@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??4NxBox@@QAEAAV0@ABV0@@Z PROC NEAR			; NxBox::operator=, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4NxVec3@@QAEABV0@ABV0@@Z		; NxVec3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4NxVec3@@QAEABV0@ABV0@@Z		; NxVec3::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4NxMat33@@QAEABV0@ABV0@@Z		; NxMat33::operator=
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4NxBox@@QAEAAV0@ABV0@@Z ENDP				; NxBox::operator=
_TEXT	ENDS
PUBLIC	??GNxVec3@@QBE?AV0@ABV0@@Z			; NxVec3::operator-
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	__real@4@3ffbcccccd0000000000
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	__real@8@3ffbcccccd0000000000
PUBLIC	?VectorLerp@@YAXABVVector@@M0AAV1@@Z		; VectorLerp
PUBLIC	??0NxSweepQueryHit@@QAE@XZ			; NxSweepQueryHit::NxSweepQueryHit
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
EXTRN	_floor:NEAR
;	COMDAT __real@4@3ffbcccccd0000000000
; File z:\xashxtsrc\server\novodex.cpp
CONST	SEGMENT
__real@4@3ffbcccccd0000000000 DD 03dcccccdr	; 0.1
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT __real@8@3ffbcccccd0000000000
CONST	SEGMENT
__real@8@3ffbcccccd0000000000 DQ 03fb99999a0000000r ; 0.1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z DD 019930520H
	DD	07H
	DD	FLAT:__unwindtable$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$6
xdata$x	ENDS
;	COMDAT ?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_start$ = 12
_end$ = 16
_tr$ = 20
_this$ = -16
_pActor$ = -20
_testBox$ = -80
_pShape$50454 = -84
_shapeType$50455 = -88
_triangle$50456 = -124
_dirs$50458 = -160
_indices$50460 = -164
_verts$50461 = -168
_NbTris$50462 = -172
_pConvexShape$50464 = -176
_cm$50466 = -180
_pTriangleMeshShape$50471 = -184
_trm$50473 = -188
_points$50479 = -284
_ext$50481 = -296
_cnt$50482 = -308
_bounds$50483 = -332
_obb$50484 = -392
_i$50485 = -396
_pBoxShape$50489 = -400
_absRot$50491 = -436
_absPos$50493 = -448
_j$50498 = -452
_i0$50502 = -456
_i1$50503 = -460
_i2$50504 = -464
_k$50505 = -468
_absRot$50514 = -504
_absPos$50516 = -516
_i0$50521 = -520
_i1$50522 = -524
_i2$50523 = -528
_v0$50524 = -540
_v1$50525 = -552
_v2$50526 = -564
_i$50530 = -568
_vecDir$ = -580
_flLength$ = -584
_result$ = -632
_numHits$ = -636
_pHit$ = -640
_flDot$ = -644
_moveDot$ = -648
$T52672 = -660
$T52673 = -696
$T52674 = -708
$T52675 = -720
$T52676 = -780
$T52677 = -792
$T52678 = -804
$T52679 = -816
$T52680 = -828
$T52681 = -840
$T52682 = -852
$T52683 = -864
$T52684 = -876
$T52685 = -888
$T52686 = -900
$T52687 = -912
$T52688 = -924
$T52689 = -936
$T52690 = -948
$T52691 = -960
__$EHRec$ = -12
?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z PROC NEAR ; CPhysicNovodex::SweepEntity, COMDAT

; 2448 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 1036				; 0000040cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2449 : 	// make trace default
; 2450 : 	memset( tr, 0, sizeof( *tr ));

	mov	ecx, 14					; 0000000eH
	xor	eax, eax
	mov	edi, DWORD PTR _tr$[ebp]
	rep stosd

; 2451 : 	tr->flFraction = 1.0f;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [eax+16], 1065353216		; 3f800000H

; 2452 : 	tr->vecEndPos = end;

	mov	ecx, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR _tr$[ebp]
	add	edx, 20					; 00000014H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx

; 2453 : 
; 2454 : 	NxActor *pActor = ActorFromEntity( pEntity );

	mov	edx, DWORD PTR _pEntity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ActorFromEntity@CPhysicNovodex@@AAEPAVNxActor@@PAVCBaseEntity@@@Z ; CPhysicNovodex::ActorFromEntity
	mov	DWORD PTR _pActor$[ebp], eax

; 2455 : 	if( !pActor || pActor->getNbShapes() <= 0 || pEntity->pev->solid == SOLID_NOT )

	cmp	DWORD PTR _pActor$[ebp], 0
	je	SHORT $L50448
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+76]
	test	eax, eax
	jbe	SHORT $L50448
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+268], 0
	jne	SHORT $L50447
$L50448:

; 2456 : 		return; // only dynamic solid objects can be traced

	jmp	$L50445
$L50447:

; 2457 : 
; 2458 : 	NxBox testBox;

	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??0NxBox@@QAE@XZ			; NxBox::NxBox
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2459 : 
; 2460 : 	// setup trace box
; 2461 : 	testBox.center = pEntity->Center();

	lea	edx, DWORD PTR $T52672[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 2462 : 	testBox.rot = pActor->getGlobalOrientation();

	lea	eax, DWORD PTR $T52673[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+44]
	mov	DWORD PTR -964+[ebp], eax
	mov	eax, DWORD PTR -964+[ebp]
	mov	DWORD PTR -968+[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR -968+[ebp]
	push	ecx
	lea	ecx, DWORD PTR _testBox$[ebp+24]
	call	??4NxMat33@@QAEABV0@ABV0@@Z		; NxMat33::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T52673[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33

; 2463 : 	testBox.extents = (pEntity->pev->size * 0.5f);

	push	1056964608				; 3f000000H
	lea	edx, DWORD PTR $T52674[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _testBox$[ebp+12]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 2464 : 
; 2465 : 	// test for stuck entity into another
; 2466 : 	if( start == end )

	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _start$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	$L50453

; 2468 : 		// update cache or build from scratch
; 2469 : 		NxShape *pShape = pActor->getShapes()[0];

	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+80]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pShape$50454[ebp], ecx

; 2470 : 		int shapeType = pShape->getType();

	mov	edx, DWORD PTR _pShape$50454[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pShape$50454[ebp]
	call	DWORD PTR [eax+92]
	mov	DWORD PTR _shapeType$50455[ebp], eax

; 2471 : 		Vector triangle[3], dirs[3];

	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	3
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _triangle$50456[ebp]
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	3
	push	12					; 0000000cH
	lea	edx, DWORD PTR _dirs$50458[ebp]
	push	edx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 2472 : 		const NxU32 *indices;
; 2473 : 		const NxVec3 *verts;
; 2474 : 		NxU32 NbTris;
; 2475 : 
; 2476 : 		if( shapeType == NX_SHAPE_CONVEX )

	cmp	DWORD PTR _shapeType$50455[ebp], 5
	jne	SHORT $L50463

; 2478 : 			NxConvexShape *pConvexShape = (NxConvexShape *)pShape;

	mov	eax, DWORD PTR _pShape$50454[ebp]
	mov	DWORD PTR _pConvexShape$50464[ebp], eax

; 2479 : 			NxConvexMesh& cm = pConvexShape->getConvexMesh();

	mov	ecx, DWORD PTR _pConvexShape$50464[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pConvexShape$50464[ebp]
	call	DWORD PTR [edx+164]
	mov	DWORD PTR _cm$50466[ebp], eax

; 2480 : 
; 2481 : 			NbTris = cm.getCount( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _cm$50466[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cm$50466[ebp]
	call	DWORD PTR [edx+8]
	mov	DWORD PTR _NbTris$50462[ebp], eax

; 2482 : 			indices = (const NxU32 *)cm.getBase( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _cm$50466[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cm$50466[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _indices$50460[ebp], eax

; 2483 : 			verts = (const NxVec3 *)cm.getBase( 0, NX_ARRAY_VERTICES );

	push	1
	push	0
	mov	eax, DWORD PTR _cm$50466[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _cm$50466[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _verts$50461[ebp], eax

; 2485 : 		else if( shapeType == NX_SHAPE_MESH )

	jmp	$L50477
$L50463:
	cmp	DWORD PTR _shapeType$50455[ebp], 6
	jne	SHORT $L50470

; 2487 : 			NxTriangleMeshShape *pTriangleMeshShape = (NxTriangleMeshShape *)pShape;

	mov	eax, DWORD PTR _pShape$50454[ebp]
	mov	DWORD PTR _pTriangleMeshShape$50471[ebp], eax

; 2488 : 			NxTriangleMesh& trm = pTriangleMeshShape->getTriangleMesh();

	mov	ecx, DWORD PTR _pTriangleMeshShape$50471[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTriangleMeshShape$50471[ebp]
	call	DWORD PTR [edx+164]
	mov	DWORD PTR _trm$50473[ebp], eax

; 2489 : 
; 2490 : 			NbTris = trm.getCount( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _trm$50473[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _trm$50473[ebp]
	call	DWORD PTR [edx+8]
	mov	DWORD PTR _NbTris$50462[ebp], eax

; 2491 : 			indices = (const NxU32 *)trm.getBase( 0, NX_ARRAY_TRIANGLES );

	push	0
	push	0
	mov	eax, DWORD PTR _trm$50473[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _trm$50473[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _indices$50460[ebp], eax

; 2492 : 			verts = (const NxVec3 *)trm.getBase( 0, NX_ARRAY_VERTICES );

	push	1
	push	0
	mov	eax, DWORD PTR _trm$50473[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _trm$50473[ebp]
	call	DWORD PTR [edx+16]
	mov	DWORD PTR _verts$50461[ebp], eax

; 2494 : 		else if( shapeType != NX_SHAPE_BOX )

	jmp	SHORT $L50477
$L50470:
	cmp	DWORD PTR _shapeType$50455[ebp], 2
	je	SHORT $L50477

; 2496 : 			// unsupported mesh type, so skip them
; 2497 : 			return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	jmp	$L50445
$L50477:

; 2499 : 
; 2500 : 		if( shapeType == NX_SHAPE_BOX )

	cmp	DWORD PTR _shapeType$50455[ebp], 2
	jne	$L50478

; 2502 : 			NxVec3	points[8];

	push	OFFSET FLAT:??0NxVec3@@QAE@XZ		; NxVec3::NxVec3
	push	8
	push	12					; 0000000cH
	lea	eax, DWORD PTR _points$50479[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 2503 : 			NxVec3	ext, cnt;

	lea	ecx, DWORD PTR _ext$50481[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	lea	ecx, DWORD PTR _cnt$50482[ebp]
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3

; 2504 : 			NxBounds3	bounds;

	lea	ecx, DWORD PTR _bounds$50483[ebp]
	call	??0NxBounds3@@QAE@XZ			; NxBounds3::NxBounds3
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 2505 : 			NxBox	obb;

	lea	ecx, DWORD PTR _obb$50484[ebp]
	call	??0NxBox@@QAE@XZ			; NxBox::NxBox
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 2506 : 
; 2507 : 			for( uint i = 0; i < pActor->getNbShapes(); i++ )

	mov	DWORD PTR _i$50485[ebp], 0
	jmp	SHORT $L50486
$L50487:
	mov	ecx, DWORD PTR _i$50485[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$50485[ebp], ecx
$L50486:
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+76]
	cmp	DWORD PTR _i$50485[ebp], eax
	jae	$L50488

; 2509 : 				NxBoxShape *pBoxShape = (NxBoxShape *)pActor->getShapes()[i];

	mov	ecx, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+80]
	mov	ecx, DWORD PTR _i$50485[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _pBoxShape$50489[ebp], edx

; 2510 : 				NxMat33 absRot = pBoxShape->getGlobalOrientation();

	lea	eax, DWORD PTR _absRot$50491[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBoxShape$50489[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBoxShape$50489[ebp]
	call	DWORD PTR [edx+72]
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 2511 : 				NxVec3 absPos = pBoxShape->getGlobalPosition();

	lea	eax, DWORD PTR $T52675[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBoxShape$50489[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBoxShape$50489[ebp]
	call	DWORD PTR [edx+68]
	push	eax
	lea	ecx, DWORD PTR _absPos$50493[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2512 : 
; 2513 : 				// don't use pBoxShape->getWorldAABB it's caused to broke suspension and deadlocks !!!
; 2514 : 				pBoxShape->getWorldBounds( bounds );

	lea	eax, DWORD PTR _bounds$50483[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBoxShape$50489[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pBoxShape$50489[ebp]
	call	DWORD PTR [edx+16]

; 2515 : 				bounds.getExtents( ext );

	lea	eax, DWORD PTR _ext$50481[ebp]
	push	eax
	lea	ecx, DWORD PTR _bounds$50483[ebp]
	call	?getExtents@NxBounds3@@QBEXAAVNxVec3@@@Z ; NxBounds3::getExtents

; 2516 : 				bounds.getCenter( cnt );

	lea	ecx, DWORD PTR _cnt$50482[ebp]
	push	ecx
	lea	ecx, DWORD PTR _bounds$50483[ebp]
	call	?getCenter@NxBounds3@@QBEXAAVNxVec3@@@Z	; NxBounds3::getCenter

; 2517 : 				obb = NxBox( cnt, ext, absRot );

	lea	edx, DWORD PTR _absRot$50491[ebp]
	push	edx
	lea	eax, DWORD PTR _ext$50481[ebp]
	push	eax
	lea	ecx, DWORD PTR _cnt$50482[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T52676[ebp]
	call	??0NxBox@@QAE@ABVNxVec3@@0ABVNxMat33@@@Z ; NxBox::NxBox
	mov	DWORD PTR -972+[ebp], eax
	mov	edx, DWORD PTR -972+[ebp]
	mov	DWORD PTR -976+[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR -976+[ebp]
	push	eax
	lea	ecx, DWORD PTR _obb$50484[ebp]
	call	??4NxBox@@QAEAAV0@ABV0@@Z		; NxBox::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T52676[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox

; 2518 : 
; 2519 : 				indices = (const NxU32 *)m_pUtils->NxGetBoxTriangles();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1356]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1356]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+28]
	mov	DWORD PTR _indices$50460[ebp], eax

; 2520 : 				m_pUtils->NxComputeBoxPoints( obb, points );

	lea	eax, DWORD PTR _points$50479[ebp]
	push	eax
	lea	ecx, DWORD PTR _obb$50484[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1356]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1356]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+12]

; 2521 : 				verts = (const NxVec3 *)points;

	lea	ecx, DWORD PTR _points$50479[ebp]
	mov	DWORD PTR _verts$50461[ebp], ecx

; 2522 : 
; 2523 : 				for( int j = 0; j < 12; j++ )

	mov	DWORD PTR _j$50498[ebp], 0
	jmp	SHORT $L50499
$L50500:
	mov	edx, DWORD PTR _j$50498[ebp]
	add	edx, 1
	mov	DWORD PTR _j$50498[ebp], edx
$L50499:
	cmp	DWORD PTR _j$50498[ebp], 12		; 0000000cH
	jge	$L50501

; 2525 : 					NxU32 i0 = *indices++;

	mov	eax, DWORD PTR _indices$50460[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i0$50502[ebp], ecx
	mov	edx, DWORD PTR _indices$50460[ebp]
	add	edx, 4
	mov	DWORD PTR _indices$50460[ebp], edx

; 2526 : 					NxU32 i1 = *indices++;

	mov	eax, DWORD PTR _indices$50460[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i1$50503[ebp], ecx
	mov	edx, DWORD PTR _indices$50460[ebp]
	add	edx, 4
	mov	DWORD PTR _indices$50460[ebp], edx

; 2527 : 					NxU32 i2 = *indices++;

	mov	eax, DWORD PTR _indices$50460[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _i2$50504[ebp], ecx
	mov	edx, DWORD PTR _indices$50460[ebp]
	add	edx, 4
	mov	DWORD PTR _indices$50460[ebp], edx

; 2528 : 					triangle[0] = verts[i0];

	mov	eax, DWORD PTR _i0$50502[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _verts$50461[ebp]
	add	ecx, eax
	push	ecx
	lea	ecx, DWORD PTR _triangle$50456[ebp]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2529 : 					triangle[1] = verts[i1];

	mov	edx, DWORD PTR _i1$50503[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _verts$50461[ebp]
	add	eax, edx
	push	eax
	lea	ecx, DWORD PTR _triangle$50456[ebp+12]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2530 : 					triangle[2] = verts[i2];

	mov	ecx, DWORD PTR _i2$50504[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _verts$50461[ebp]
	add	edx, ecx
	push	edx
	lea	ecx, DWORD PTR _triangle$50456[ebp+24]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2531 : 
; 2532 : 					for( int k = 0; k < 3; k++ )

	mov	DWORD PTR _k$50505[ebp], 0
	jmp	SHORT $L50506
$L50507:
	mov	eax, DWORD PTR _k$50505[ebp]
	add	eax, 1
	mov	DWORD PTR _k$50505[ebp], eax
$L50506:
	cmp	DWORD PTR _k$50505[ebp], 3
	jge	$L50508

; 2534 : 						dirs[k] = absPos - triangle[k];

	mov	ecx, DWORD PTR _k$50505[ebp]
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _triangle$50456[ebp+ecx]
	push	edx
	lea	ecx, DWORD PTR $T52677[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	eax, DWORD PTR $T52677[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52678[ebp]
	push	ecx
	lea	ecx, DWORD PTR _absPos$50493[ebp]
	call	??GNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator-
	push	eax
	mov	edx, DWORD PTR _k$50505[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR _dirs$50458[ebp+edx]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2535 : 						triangle[k] += dirs[k] * -2.0f;

	push	-1073741824				; c0000000H
	lea	eax, DWORD PTR $T52679[ebp]
	push	eax
	mov	ecx, DWORD PTR _k$50505[ebp]
	imul	ecx, 12					; 0000000cH
	lea	ecx, DWORD PTR _dirs$50458[ebp+ecx]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	edx, DWORD PTR _k$50505[ebp]
	imul	edx, 12					; 0000000cH
	lea	ecx, DWORD PTR _triangle$50456[ebp+edx]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2536 : 
; 2537 : 						UTIL_TraceLine( triangle[k], triangle[k], ignore_monsters, pEntity->edict(), tr );

	mov	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	mov	ecx, DWORD PTR _k$50505[ebp]
	imul	ecx, 12					; 0000000cH
	lea	edx, DWORD PTR _triangle$50456[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _k$50505[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _triangle$50456[ebp+eax]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2538 : 						if( tr->fStartSolid ) return;	// one of points in solid

	mov	edx, DWORD PTR _tr$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L50512
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _absRot$50491[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _obb$50484[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _bounds$50483[ebp]
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	jmp	$L50445
$L50512:

; 2539 : 					}

	jmp	$L50507
$L50508:

; 2540 : 				}

	jmp	$L50500
$L50501:

; 2541 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _absRot$50491[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	jmp	$L50487
$L50488:

; 2542 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _obb$50484[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _bounds$50483[ebp]
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3

; 2543 : 		else

	jmp	$L50513
$L50478:

; 2545 : 			NxMat33 absRot = pShape->getGlobalOrientation();

	lea	eax, DWORD PTR _absRot$50514[ebp]
	push	eax
	mov	ecx, DWORD PTR _pShape$50454[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pShape$50454[ebp]
	call	DWORD PTR [edx+72]
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 2546 : 			NxVec3 absPos = pShape->getGlobalPosition();

	lea	eax, DWORD PTR $T52680[ebp]
	push	eax
	mov	ecx, DWORD PTR _pShape$50454[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pShape$50454[ebp]
	call	DWORD PTR [edx+68]
	push	eax
	lea	ecx, DWORD PTR _absPos$50516[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3
$L50519:

; 2547 : 
; 2548 : 			// NOTE: we compute triangles in abs coords because player AABB
; 2549 : 			// can't be transformed as done for not axial cases
; 2550 : 			// FIXME: store all meshes as local and use capsule instead of bbox
; 2551 : 			while( NbTris-- )

	mov	eax, DWORD PTR _NbTris$50462[ebp]
	mov	ecx, DWORD PTR _NbTris$50462[ebp]
	sub	ecx, 1
	mov	DWORD PTR _NbTris$50462[ebp], ecx
	test	eax, eax
	je	$L50520

; 2553 : 				NxU32 i0 = *indices++;

	mov	edx, DWORD PTR _indices$50460[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _i0$50521[ebp], eax
	mov	ecx, DWORD PTR _indices$50460[ebp]
	add	ecx, 4
	mov	DWORD PTR _indices$50460[ebp], ecx

; 2554 : 				NxU32 i1 = *indices++;

	mov	edx, DWORD PTR _indices$50460[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _i1$50522[ebp], eax
	mov	ecx, DWORD PTR _indices$50460[ebp]
	add	ecx, 4
	mov	DWORD PTR _indices$50460[ebp], ecx

; 2555 : 				NxU32 i2 = *indices++;

	mov	edx, DWORD PTR _indices$50460[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _i2$50523[ebp], eax
	mov	ecx, DWORD PTR _indices$50460[ebp]
	add	ecx, 4
	mov	DWORD PTR _indices$50460[ebp], ecx

; 2556 : 				NxVec3 v0 = verts[i0];

	mov	edx, DWORD PTR _i0$50521[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _verts$50461[ebp]
	add	eax, edx
	push	eax
	lea	ecx, DWORD PTR _v0$50524[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2557 : 				NxVec3 v1 = verts[i1];

	mov	ecx, DWORD PTR _i1$50522[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _verts$50461[ebp]
	add	edx, ecx
	push	edx
	lea	ecx, DWORD PTR _v1$50525[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2558 : 				NxVec3 v2 = verts[i2];

	mov	eax, DWORD PTR _i2$50523[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _verts$50461[ebp]
	add	ecx, eax
	push	ecx
	lea	ecx, DWORD PTR _v2$50526[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3

; 2559 : 
; 2560 : 				absRot.multiply( v0, v0 );

	lea	edx, DWORD PTR _v0$50524[ebp]
	push	edx
	lea	eax, DWORD PTR _v0$50524[ebp]
	push	eax
	lea	ecx, DWORD PTR _absRot$50514[ebp]
	call	?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z ; NxMat33::multiply

; 2561 : 				absRot.multiply( v1, v1 );

	lea	ecx, DWORD PTR _v1$50525[ebp]
	push	ecx
	lea	edx, DWORD PTR _v1$50525[ebp]
	push	edx
	lea	ecx, DWORD PTR _absRot$50514[ebp]
	call	?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z ; NxMat33::multiply

; 2562 : 				absRot.multiply( v2, v2 );

	lea	eax, DWORD PTR _v2$50526[ebp]
	push	eax
	lea	ecx, DWORD PTR _v2$50526[ebp]
	push	ecx
	lea	ecx, DWORD PTR _absRot$50514[ebp]
	call	?multiply@NxMat33@@QBEXABVNxVec3@@AAV2@@Z ; NxMat33::multiply

; 2563 : 				triangle[0] = v0 + absPos;

	lea	edx, DWORD PTR _absPos$50516[ebp]
	push	edx
	lea	eax, DWORD PTR $T52681[ebp]
	push	eax
	lea	ecx, DWORD PTR _v0$50524[ebp]
	call	??HNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator+
	push	eax
	lea	ecx, DWORD PTR _triangle$50456[ebp]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2564 : 				triangle[1] = v1 + absPos;

	lea	ecx, DWORD PTR _absPos$50516[ebp]
	push	ecx
	lea	edx, DWORD PTR $T52682[ebp]
	push	edx
	lea	ecx, DWORD PTR _v1$50525[ebp]
	call	??HNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator+
	push	eax
	lea	ecx, DWORD PTR _triangle$50456[ebp+12]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2565 : 				triangle[2] = v2 + absPos;

	lea	eax, DWORD PTR _absPos$50516[ebp]
	push	eax
	lea	ecx, DWORD PTR $T52683[ebp]
	push	ecx
	lea	ecx, DWORD PTR _v2$50526[ebp]
	call	??HNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator+
	push	eax
	lea	ecx, DWORD PTR _triangle$50456[ebp+24]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2566 : 
; 2567 : 				for( int i = 0; i < 3; i++ )

	mov	DWORD PTR _i$50530[ebp], 0
	jmp	SHORT $L50531
$L50532:
	mov	edx, DWORD PTR _i$50530[ebp]
	add	edx, 1
	mov	DWORD PTR _i$50530[ebp], edx
$L50531:
	cmp	DWORD PTR _i$50530[ebp], 3
	jge	$L50533

; 2569 : 					dirs[i] = absPos - triangle[i];

	mov	eax, DWORD PTR _i$50530[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _triangle$50456[ebp+eax]
	push	ecx
	lea	ecx, DWORD PTR $T52684[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	lea	edx, DWORD PTR $T52684[ebp]
	push	edx
	lea	eax, DWORD PTR $T52685[ebp]
	push	eax
	lea	ecx, DWORD PTR _absPos$50516[ebp]
	call	??GNxVec3@@QBE?AV0@ABV0@@Z		; NxVec3::operator-
	push	eax
	mov	ecx, DWORD PTR _i$50530[ebp]
	imul	ecx, 12					; 0000000cH
	lea	ecx, DWORD PTR _dirs$50458[ebp+ecx]
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2570 : 					triangle[i] += dirs[i] * -2.0f;

	push	-1073741824				; c0000000H
	lea	edx, DWORD PTR $T52686[ebp]
	push	edx
	mov	eax, DWORD PTR _i$50530[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _dirs$50458[ebp+eax]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _i$50530[ebp]
	imul	ecx, 12					; 0000000cH
	lea	ecx, DWORD PTR _triangle$50456[ebp+ecx]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 2571 : 
; 2572 : 					UTIL_TraceLine( triangle[i], triangle[i], ignore_monsters, pEntity->edict(), tr );

	mov	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	mov	eax, DWORD PTR _i$50530[ebp]
	imul	eax, 12					; 0000000cH
	lea	ecx, DWORD PTR _triangle$50456[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _i$50530[ebp]
	imul	edx, 12					; 0000000cH
	lea	eax, DWORD PTR _triangle$50456[ebp+edx]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2573 : 					if( tr->fStartSolid ) return;	// one of points in solid

	mov	ecx, DWORD PTR _tr$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L50537
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _absRot$50514[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	jmp	$L50445
$L50537:

; 2574 : 				}

	jmp	$L50532
$L50533:

; 2575 : 			}

	jmp	$L50519
$L50520:

; 2576 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _absRot$50514[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
$L50513:

; 2577 : 		return;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	jmp	$L50445
$L50453:

; 2579 : 
; 2580 : 	// compute motion
; 2581 : 	Vector vecDir = end - start;

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	lea	eax, DWORD PTR $T52687[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2582 : 	float flLength = vecDir.Length();

	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLength$[ebp]

; 2583 : 	vecDir = vecDir.Normalize();

	lea	ecx, DWORD PTR $T52688[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$[ebp+8], edx

; 2584 : 	testBox.extents = (pEntity->pev->size * 0.5f);

	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T52689[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _testBox$[ebp+12]
	call	??4NxVec3@@QAEABV0@ABVVector@@@Z	; NxVec3::operator=

; 2585 : 	NxSweepQueryHit result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	??0NxSweepQueryHit@@QAE@XZ		; NxSweepQueryHit::NxSweepQueryHit

; 2586 : 
; 2587 : 	// make a linear sweep through the world
; 2588 : 	pActor->raiseActorFlag( NX_AF_DISABLE_COLLISION );

	push	1
	mov	edx, DWORD PTR _pActor$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [eax+100]

; 2589 : 	int numHits = m_pScene->linearOBBSweep( testBox, vecDir * flLength, NX_SF_STATICS|NX_SF_DYNAMICS, NULL, 1, &result, NULL );

	mov	ecx, DWORD PTR _flLength$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T52691[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T52690[ebp]
	call	??0NxVec3@@QAE@ABVVector@@@Z		; NxVec3::NxVec3
	push	0
	push	-1
	push	0
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	push	1
	push	0
	push	3
	lea	ecx, DWORD PTR $T52690[ebp]
	push	ecx
	lea	edx, DWORD PTR _testBox$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+476]
	mov	DWORD PTR _numHits$[ebp], eax

; 2590 : 	pActor->clearActorFlag( NX_AF_DISABLE_COLLISION );

	push	1
	mov	eax, DWORD PTR _pActor$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActor$[ebp]
	call	DWORD PTR [edx+104]

; 2591 : 	if( !numHits || !result.hitShape || result.t > flLength )

	cmp	DWORD PTR _numHits$[ebp], 0
	je	SHORT $L50548
	cmp	DWORD PTR _result$[ebp+4], 0
	je	SHORT $L50548
	fld	DWORD PTR _result$[ebp]
	fcomp	DWORD PTR _flLength$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L50547
$L50548:

; 2592 : 		return; // no intersection

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	jmp	$L50445
$L50547:

; 2593 : 
; 2594 : 	// compute fraction
; 2595 : 	tr->flFraction = (result.t / flLength);

	fld	DWORD PTR _result$[ebp]
	fdiv	DWORD PTR _flLength$[ebp]
	mov	eax, DWORD PTR _tr$[ebp]
	fstp	DWORD PTR [eax+16]

; 2596 : 	tr->flFraction = bound( 0.0f, tr->flFraction, 1.0f );

	mov	ecx, DWORD PTR _tr$[ebp]
	fld	DWORD PTR [ecx+16]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L52694
	mov	edx, DWORD PTR _tr$[ebp]
	fld	DWORD PTR [edx+16]
	fcomp	DWORD PTR __real@4@3fff8000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L52692
	mov	eax, DWORD PTR _tr$[ebp]
	fld	DWORD PTR [eax+16]
	fstp	DWORD PTR -980+[ebp]
	jmp	SHORT $L52693
$L52692:
	mov	DWORD PTR -980+[ebp], 1065353216	; 3f800000H
$L52693:
	mov	ecx, DWORD PTR -980+[ebp]
	mov	DWORD PTR -984+[ebp], ecx
	jmp	SHORT $L52695
$L52694:
	mov	DWORD PTR -984+[ebp], 0
$L52695:
	mov	edx, DWORD PTR _tr$[ebp]
	mov	eax, DWORD PTR -984+[ebp]
	mov	DWORD PTR [edx+16], eax

; 2597 : 	VectorLerp( start, tr->flFraction, end, tr->vecEndPos );

	mov	ecx, DWORD PTR _tr$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _tr$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	call	?VectorLerp@@YAXABVVector@@M0AAV1@@Z	; VectorLerp
	add	esp, 16					; 00000010H

; 2598 : 
; 2599 : 	CBaseEntity *pHit = EntityFromActor( &result.hitShape->getActor( ));

	mov	eax, DWORD PTR _result$[ebp+4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _result$[ebp+4]
	call	DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityFromActor@CPhysicNovodex@@AAEPAVCBaseEntity@@PAVNxActor@@@Z ; CPhysicNovodex::EntityFromActor
	mov	DWORD PTR _pHit$[ebp], eax

; 2600 : 	if( pHit ) tr->pHit = pHit->edict();

	cmp	DWORD PTR _pHit$[ebp], 0
	je	SHORT $L50550
	mov	ecx, DWORD PTR _pHit$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [ecx+48], eax
$L50550:

; 2601 : 
; 2602 : 	tr->vecPlaneNormal = result.normal;

	lea	edx, DWORD PTR _result$[ebp+36]
	push	edx
	mov	ecx, DWORD PTR _tr$[ebp]
	add	ecx, 36					; 00000024H
	call	??4Vector@@QAEABV0@ABVNxVec3@@@Z	; Vector::operator=

; 2603 : 	tr->flPlaneDist = DotProduct( tr->vecEndPos, tr->vecPlaneNormal );

	mov	eax, DWORD PTR _tr$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _tr$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	mov	edx, DWORD PTR _tr$[ebp]
	fstp	DWORD PTR [edx+32]

; 2604 : 	float flDot = DotProduct( vecDir, tr->vecPlaneNormal );

	mov	eax, DWORD PTR _tr$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _vecDir$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fst	DWORD PTR _flDot$[ebp]

; 2605 : 	float moveDot = Q_round( flDot, 0.1f );

	fdiv	DWORD PTR __real@4@3ffbcccccd0000000000
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	fmul	QWORD PTR __real@8@3ffbcccccd0000000000
	fstp	DWORD PTR _moveDot$[ebp]

; 2606 : 
; 2607 : 	// FIXME: this is incorrect. Find a better method?
; 2608 : 	if(( tr->flFraction < 0.1f ) && ( moveDot < 0.0f ))

	mov	edx, DWORD PTR _tr$[ebp]
	fld	DWORD PTR [edx+16]
	fcomp	DWORD PTR __real@4@3ffbcccccd0000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L50553
	fld	DWORD PTR _moveDot$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L50553

; 2609 : 		tr->fAllSolid = true;

	mov	eax, DWORD PTR _tr$[ebp]
	mov	DWORD PTR [eax], 1
$L50553:

; 2610 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
$L50445:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$0:
	lea	ecx, DWORD PTR _testBox$[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	ret	0
__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$1:
	lea	ecx, DWORD PTR $T52673[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$2:
	lea	ecx, DWORD PTR _bounds$50483[ebp]
	call	??1NxBounds3@@QAE@XZ			; NxBounds3::~NxBounds3
	ret	0
__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$3:
	lea	ecx, DWORD PTR _obb$50484[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	ret	0
__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$4:
	lea	ecx, DWORD PTR _absRot$50491[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$5:
	lea	ecx, DWORD PTR $T52676[ebp]
	call	??1NxBox@@QAE@XZ			; NxBox::~NxBox
	ret	0
__unwindfunclet$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z$6:
	lea	ecx, DWORD PTR _absRot$50514[ebp]
	call	??1NxMat33@@QAE@XZ			; NxMat33::~NxMat33
	ret	0
__ehhandler$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?SweepEntity@CPhysicNovodex@@UAEXPAVCBaseEntity@@ABVVector@@1PAUgametrace_s@@@Z ENDP ; CPhysicNovodex::SweepEntity
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??YVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator+=, COMDAT

; 159  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 161  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 162  : 	}			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T52721 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L25028

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T52721[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L25026
$L25028:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L25026:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?VectorLerp@@YAXABVVector@@M0AAV1@@Z
_TEXT	SEGMENT
_src1$ = 8
_t$ = 12
_src2$ = 16
_dest$ = 20
?VectorLerp@@YAXABVVector@@M0AAV1@@Z PROC NEAR		; VectorLerp, COMDAT

; 293  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 294  : 	dest.x = src1.x + (src2.x - src1.x) * t;

	mov	eax, DWORD PTR _src2$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	fld	DWORD PTR [eax]
	fsub	DWORD PTR [ecx]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _dest$[ebp]
	fstp	DWORD PTR [eax]

; 295  : 	dest.y = src1.y + (src2.y - src1.y) * t;

	mov	ecx, DWORD PTR _src2$[ebp]
	mov	edx, DWORD PTR _src1$[ebp]
	fld	DWORD PTR [ecx+4]
	fsub	DWORD PTR [edx+4]
	fmul	DWORD PTR _t$[ebp]
	mov	eax, DWORD PTR _src1$[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _dest$[ebp]
	fstp	DWORD PTR [ecx+4]

; 296  : 	dest.z = src1.z + (src2.z - src1.z) * t;

	mov	edx, DWORD PTR _src2$[ebp]
	mov	eax, DWORD PTR _src1$[ebp]
	fld	DWORD PTR [edx+8]
	fsub	DWORD PTR [eax+8]
	fmul	DWORD PTR _t$[ebp]
	mov	ecx, DWORD PTR _src1$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _dest$[ebp]
	fstp	DWORD PTR [edx+8]

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VectorLerp@@YAXABVVector@@M0AAV1@@Z ENDP		; VectorLerp
_TEXT	ENDS
;	COMDAT ??GNxVec3@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T52728 = -16
??GNxVec3@@QBE?AV0@ABV0@@Z PROC NEAR			; NxVec3::operator-, COMDAT

; 805  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 806  : 	return NxVec3(x - v.x, y - v.y, z - v.z);	// RVO version

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T52728[ebp]
	call	??0NxVec3@@QAE@MMM@Z			; NxVec3::NxVec3
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0NxVec3@@QAE@ABV0@@Z			; NxVec3::NxVec3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 807  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GNxVec3@@QBE?AV0@ABV0@@Z ENDP				; NxVec3::operator-
_TEXT	ENDS
;	COMDAT ??0NxSweepQueryHit@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0NxSweepQueryHit@@QAE@XZ PROC NEAR			; NxSweepQueryHit::NxSweepQueryHit, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0NxVec3@@QAE@XZ			; NxVec3::NxVec3
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0NxSweepQueryHit@@QAE@XZ ENDP				; NxSweepQueryHit::NxSweepQueryHit
_TEXT	ENDS
;	COMDAT ??0?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::NxArray<NxShapeDesc *,NxAllocatorDefault>, COMDAT

; 73   : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 74   : 																		//nothing
; 75   : 																		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::NxArray<NxShapeDesc *,NxAllocatorDefault>
_TEXT	ENDS
PUBLIC	?deallocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::deallocate
PUBLIC	?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::destroy
;	COMDAT ??1?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::~NxArray<NxShapeDesc *,NxAllocatorDefault>, COMDAT

; 106  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 																		destroy(first, last);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::destroy

; 108  : 																		deallocate(first);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::deallocate

; 109  : 																		first = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 																		last = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 111  : 																		memEnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 112  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::~NxArray<NxShapeDesc *,NxAllocatorDefault>
_TEXT	ENDS
;	COMDAT ?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::size, COMDAT

; 213  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 																		return (unsigned)(last - first);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 215  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::size
_TEXT	ENDS
PUBLIC	?reserve@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::reserve
;	COMDAT ?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z
_TEXT	SEGMENT
_x$ = 8
_this$ = -4
?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack, COMDAT

; 241  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 																		//insert(end(), x);
; 243  : 																		if (memEnd <= last)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	ja	SHORT $L50579

; 245  : 																			reserve((1 + size()) * 2);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::size
	lea	eax, DWORD PTR [eax+eax+2]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reserve@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::reserve
$L50579:

; 247  : 																		*last = x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 248  : 																		last ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 249  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?pushBack@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxShapeDesc@@@Z ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::pushBack
_TEXT	ENDS
PUBLIC	?begin@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::begin
PUBLIC	?end@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::end
;	COMDAT ?clear@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?clear@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::clear, COMDAT

; 294  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 																		destroy(begin(), end());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::end
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::begin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::destroy

; 296  : 																		last = first;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 297  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::clear
_TEXT	ENDS
;	COMDAT ??0?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>, COMDAT

; 73   : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 74   : 																		//nothing
; 75   : 																		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
_TEXT	ENDS
PUBLIC	?deallocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::deallocate
PUBLIC	?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::destroy
;	COMDAT ??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>, COMDAT

; 106  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 																		destroy(first, last);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::destroy

; 108  : 																		deallocate(first);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::deallocate

; 109  : 																		first = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 																		last = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 111  : 																		memEnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 112  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAE@XZ ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>
_TEXT	ENDS
PUBLIC	?pushBack@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::pushBack
;	COMDAT ?push_back@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z
_TEXT	SEGMENT
_x$ = 8
_this$ = -4
?push_back@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::push_back, COMDAT

; 269  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 270  : 																		pushBack(x);

	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushBack@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::pushBack

; 271  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::push_back
_TEXT	ENDS
PUBLIC	?begin@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::begin
PUBLIC	?end@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::end
;	COMDAT ?clear@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?clear@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::clear, COMDAT

; 294  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 																		destroy(begin(), end());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::end
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::begin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::destroy

; 296  : 																		last = first;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 297  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXXZ ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::clear
_TEXT	ENDS
;	COMDAT ??0?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ PROC NEAR ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>, COMDAT

; 73   : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 74   : 																		//nothing
; 75   : 																		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ENDP ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
_TEXT	ENDS
PUBLIC	?deallocate@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@@Z ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::deallocate
PUBLIC	?destroy@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@0@Z ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::destroy
;	COMDAT ??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ PROC NEAR ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>, COMDAT

; 106  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 																		destroy(first, last);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@0@Z ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::destroy

; 108  : 																		deallocate(first);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@@Z ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::deallocate

; 109  : 																		first = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 																		last = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 111  : 																		memEnd = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 112  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@QAE@XZ ENDP ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::~NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>
_TEXT	ENDS
PUBLIC	?capacity@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::capacity
PUBLIC	?copy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@PBQAV2@0PAPAV2@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::copy
PUBLIC	?allocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@I@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::allocate
;	COMDAT ?reserve@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z
_TEXT	SEGMENT
_n$ = 8
_this$ = -4
_s$50623 = -8
?reserve@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::reserve, COMDAT

; 154  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 																		if (capacity() < n)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::capacity
	cmp	eax, DWORD PTR _n$[ebp]
	jae	SHORT $L50622

; 157  : 																			
; 158  : 																			iterator s = allocate(n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@I@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::allocate
	mov	DWORD PTR _s$50623[ebp], eax

; 159  : 																			copy(first, last, s);

	mov	ecx, DWORD PTR _s$50623[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?copy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@PBQAV2@0PAPAV2@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::copy

; 160  : 																			destroy(first, last);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::destroy

; 161  : 																			deallocate(first);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@@Z ; NxArray<NxShapeDesc *,NxAllocatorDefault>::deallocate

; 162  : 																			//if we knew we just have atomics we could just do this:
; 163  : 																			//first = reallocate(n, first);
; 164  : 																			memEnd = s + n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$50623[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 165  : 																			last = s + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxShapeDesc *,NxAllocatorDefault>::size
	mov	ecx, DWORD PTR _s$50623[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 166  : 																			first = s; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _s$50623[ebp]
	mov	DWORD PTR [ecx], edx
$L50622:

; 168  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::reserve
_TEXT	ENDS
;	COMDAT ?begin@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ
_TEXT	SEGMENT
_this$ = -4
?begin@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::begin, COMDAT

; 359  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 																		return first;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 361  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?begin@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::begin
_TEXT	ENDS
;	COMDAT ?end@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ
_TEXT	SEGMENT
_this$ = -4
?end@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::end, COMDAT

; 371  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 372  : 																		return last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 373  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?end@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxShapeDesc@@XZ ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::end
_TEXT	ENDS
PUBLIC	?free@NxAllocatorDefault@@QAEXPAX@Z		; NxAllocatorDefault::free
;	COMDAT ?deallocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
?deallocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@@Z PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::deallocate, COMDAT

; 490  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 491  : 																		if(p)	allocator.free(p);

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $L50630
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?free@NxAllocatorDefault@@QAEXPAX@Z	; NxAllocatorDefault::free
$L50630:

; 492  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?deallocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@@Z ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::deallocate
_TEXT	ENDS
EXTRN	_free:NEAR
;	COMDAT ?free@NxAllocatorDefault@@QAEXPAX@Z
_TEXT	SEGMENT
_memory$ = 8
_this$ = -4
?free@NxAllocatorDefault@@QAEXPAX@Z PROC NEAR		; NxAllocatorDefault::free, COMDAT

; 97   : 			{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 			if(memory)	::free(memory);	// Deleting null ptrs is valid, but still useless

	cmp	DWORD PTR _memory$[ebp], 0
	je	SHORT $L42165
	mov	eax, DWORD PTR _memory$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L42165:

; 99   : 			}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?free@NxAllocatorDefault@@QAEXPAX@Z ENDP		; NxAllocatorDefault::free
_TEXT	ENDS
;	COMDAT ?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z
_TEXT	SEGMENT
_f$ = 8
_l$ = 12
_this$ = -4
?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::destroy, COMDAT

; 495  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 496  : 																		for (; f != l; ++f)

	jmp	SHORT $L50633
$L50634:
	mov	eax, DWORD PTR _f$[ebp]
	add	eax, 4
	mov	DWORD PTR _f$[ebp], eax
$L50633:
	mov	ecx, DWORD PTR _f$[ebp]
	cmp	ecx, DWORD PTR _l$[ebp]
	je	SHORT $L50635

; 498  : 																			f->~ElemType();
; 499  : 																			}

	jmp	SHORT $L50634
$L50635:

; 500  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?destroy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxShapeDesc@@0@Z ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::destroy
_TEXT	ENDS
PUBLIC	?reserve@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::reserve
PUBLIC	?size@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::size
;	COMDAT ?pushBack@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z
_TEXT	SEGMENT
_x$ = 8
_this$ = -4
?pushBack@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::pushBack, COMDAT

; 241  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 242  : 																		//insert(end(), x);
; 243  : 																		if (memEnd <= last)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	ja	SHORT $L50638

; 245  : 																			reserve((1 + size()) * 2);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::size
	lea	eax, DWORD PTR [eax+eax+2]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reserve@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::reserve
$L50638:

; 247  : 																		*last = x;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 248  : 																		last ++;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 249  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?pushBack@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXABQAVNxForceFieldShapeDesc@@@Z ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::pushBack
_TEXT	ENDS
;	COMDAT ?size@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?size@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::size, COMDAT

; 213  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 214  : 																		return (unsigned)(last - first);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 215  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::size
_TEXT	ENDS
;	COMDAT ?begin@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ
_TEXT	SEGMENT
_this$ = -4
?begin@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::begin, COMDAT

; 359  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 360  : 																		return first;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 361  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?begin@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::begin
_TEXT	ENDS
;	COMDAT ?end@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ
_TEXT	SEGMENT
_this$ = -4
?end@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::end, COMDAT

; 371  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 372  : 																		return last;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 373  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?end@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEPAPAVNxForceFieldShapeDesc@@XZ ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::end
_TEXT	ENDS
;	COMDAT ?deallocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
?deallocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@@Z PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::deallocate, COMDAT

; 490  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 491  : 																		if(p)	allocator.free(p);

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $L50645
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?free@NxAllocatorDefault@@QAEXPAX@Z	; NxAllocatorDefault::free
$L50645:

; 492  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?deallocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@@Z ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::deallocate
_TEXT	ENDS
;	COMDAT ?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z
_TEXT	SEGMENT
_f$ = 8
_l$ = 12
_this$ = -4
?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::destroy, COMDAT

; 495  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 496  : 																		for (; f != l; ++f)

	jmp	SHORT $L50648
$L50649:
	mov	eax, DWORD PTR _f$[ebp]
	add	eax, 4
	mov	DWORD PTR _f$[ebp], eax
$L50648:
	mov	ecx, DWORD PTR _f$[ebp]
	cmp	ecx, DWORD PTR _l$[ebp]
	je	SHORT $L50650

; 498  : 																			f->~ElemType();
; 499  : 																			}

	jmp	SHORT $L50649
$L50650:

; 500  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::destroy
_TEXT	ENDS
;	COMDAT ?deallocate@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@@Z
_TEXT	SEGMENT
_p$ = 8
_this$ = -4
?deallocate@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@@Z PROC NEAR ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::deallocate, COMDAT

; 490  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 491  : 																		if(p)	allocator.free(p);

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $L50653
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?free@NxAllocatorDefault@@QAEXPAX@Z	; NxAllocatorDefault::free
$L50653:

; 492  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?deallocate@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@@Z ENDP ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::deallocate
_TEXT	ENDS
;	COMDAT ?destroy@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@0@Z
_TEXT	SEGMENT
_f$ = 8
_l$ = 12
_this$ = -4
?destroy@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@0@Z PROC NEAR ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::destroy, COMDAT

; 495  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 496  : 																		for (; f != l; ++f)

	jmp	SHORT $L50656
$L50657:
	mov	eax, DWORD PTR _f$[ebp]
	add	eax, 4
	mov	DWORD PTR _f$[ebp], eax
$L50656:
	mov	ecx, DWORD PTR _f$[ebp]
	cmp	ecx, DWORD PTR _l$[ebp]
	je	SHORT $L50658

; 498  : 																			f->~ElemType();
; 499  : 																			}

	jmp	SHORT $L50657
$L50658:

; 500  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?destroy@?$NxArray@PAVNxForceFieldShapeGroup@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeGroup@@0@Z ENDP ; NxArray<NxForceFieldShapeGroup *,NxAllocatorDefault>::destroy
_TEXT	ENDS
;	COMDAT ?capacity@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?capacity@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::capacity, COMDAT

; 174  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 																		return (unsigned)(first == 0 ? 0 : memEnd - first);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L52783
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L52784
$L52783:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	mov	DWORD PTR -8+[ebp], eax
$L52784:
	mov	eax, DWORD PTR -8+[ebp]

; 176  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::capacity
_TEXT	ENDS
;	COMDAT ?copy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@PBQAV2@0PAPAV2@@Z
_TEXT	SEGMENT
_f$ = 8
_l$ = 12
_p$ = 16
_this$ = -4
?copy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@PBQAV2@0PAPAV2@@Z PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::copy, COMDAT

; 469  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 																		for (; f != l; ++p, ++f)

	jmp	SHORT $L50683
$L50684:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	add	ecx, 4
	mov	DWORD PTR _f$[ebp], ecx
$L50683:
	mov	edx, DWORD PTR _f$[ebp]
	cmp	edx, DWORD PTR _l$[ebp]
	je	SHORT $L50685

; 471  : 																			*p = *f;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $L50684
$L50685:

; 472  : 																		return p; 

	mov	eax, DWORD PTR _p$[ebp]

; 473  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?copy@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@PBQAV2@0PAPAV2@@Z ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::copy
_TEXT	ENDS
PUBLIC	?mallocDEBUG@NxAllocatorDefault@@QAEPAXIPBDH0W4NxMemoryType@@@Z ; NxAllocatorDefault::mallocDEBUG
PUBLIC	??_C@_08LLLA@ElemType?$AA@			; `string'
PUBLIC	??_C@_0CD@HHAN@z?3?2xashxtsrc?2phys_shared?2nxarray@ ; `string'
;	COMDAT ??_C@_08LLLA@ElemType?$AA@
; File z:\xashxtsrc\phys_shared\nxarray.h
CONST	SEGMENT
??_C@_08LLLA@ElemType?$AA@ DB 'ElemType', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HHAN@z?3?2xashxtsrc?2phys_shared?2nxarray@
CONST	SEGMENT
??_C@_0CD@HHAN@z?3?2xashxtsrc?2phys_shared?2nxarray@ DB 'z:\xashxtsrc\phy'
	DB	's_shared\nxarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ?allocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@I@Z
_TEXT	SEGMENT
_n$ = 8
_this$ = -4
?allocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@I@Z PROC NEAR ; NxArray<NxShapeDesc *,NxAllocatorDefault>::allocate, COMDAT

; 476  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : #ifdef _DEBUG
; 478  : 																		return (ElemType *)allocator.mallocDEBUG(n * sizeof(ElemType), (const char *)__FILE__, __LINE__, "ElemType", NX_MEMORY_Generic_Array_Container);

	push	289					; 00000121H
	push	OFFSET FLAT:??_C@_08LLLA@ElemType?$AA@	; `string'
	push	478					; 000001deH
	push	OFFSET FLAT:??_C@_0CD@HHAN@z?3?2xashxtsrc?2phys_shared?2nxarray@ ; `string'
	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?mallocDEBUG@NxAllocatorDefault@@QAEPAXIPBDH0W4NxMemoryType@@@Z ; NxAllocatorDefault::mallocDEBUG

; 479  : #else
; 480  : 																		return (ElemType *)allocator.malloc(n * sizeof(ElemType), NX_MEMORY_Generic_Array_Container);
; 481  : #endif
; 482  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$NxArray@PAVNxShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxShapeDesc@@I@Z ENDP ; NxArray<NxShapeDesc *,NxAllocatorDefault>::allocate
_TEXT	ENDS
EXTRN	_malloc:NEAR
;	COMDAT ?mallocDEBUG@NxAllocatorDefault@@QAEPAXIPBDH0W4NxMemoryType@@@Z
_TEXT	SEGMENT
_size$ = 8
_this$ = -4
?mallocDEBUG@NxAllocatorDefault@@QAEPAXIPBDH0W4NxMemoryType@@@Z PROC NEAR ; NxAllocatorDefault::mallocDEBUG, COMDAT

; 54   : 			{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			NX_UNREFERENCED_PARAMETER(type);
; 56   : 			NX_UNREFERENCED_PARAMETER(className);
; 57   : #ifdef _DEBUG
; 58   : 	#if defined(WIN32) && NX_DEBUG_MALLOC
; 59   : 			return ::_malloc_dbg(size, _NORMAL_BLOCK, fileName, line);
; 60   : 	#else
; 61   : 			NX_UNREFERENCED_PARAMETER(fileName);
; 62   : 			NX_UNREFERENCED_PARAMETER(line);
; 63   : 	// TODO: insert a Linux Debugger Function
; 64   : 			return ::malloc(size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 65   : 	#endif
; 66   : #else
; 67   : 			NX_UNREFERENCED_PARAMETER(fileName);
; 68   : 			NX_UNREFERENCED_PARAMETER(line);
; 69   : 			NX_UNREFERENCED_PARAMETER(size);
; 70   : 			NX_ASSERT(0);//Don't use debug malloc for release mode code!
; 71   : 			return 0;
; 72   : #endif
; 73   : 			}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?mallocDEBUG@NxAllocatorDefault@@QAEPAXIPBDH0W4NxMemoryType@@@Z ENDP ; NxAllocatorDefault::mallocDEBUG
_TEXT	ENDS
PUBLIC	?capacity@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::capacity
PUBLIC	?copy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@PBQAV2@0PAPAV2@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::copy
PUBLIC	?allocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@I@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::allocate
;	COMDAT ?reserve@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z
_TEXT	SEGMENT
_n$ = 8
_this$ = -4
_s$50694 = -8
?reserve@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::reserve, COMDAT

; 154  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 																		if (capacity() < n)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::capacity
	cmp	eax, DWORD PTR _n$[ebp]
	jae	SHORT $L50693

; 157  : 																			
; 158  : 																			iterator s = allocate(n);

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@I@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::allocate
	mov	DWORD PTR _s$50694[ebp], eax

; 159  : 																			copy(first, last, s);

	mov	ecx, DWORD PTR _s$50694[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?copy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@PBQAV2@0PAPAV2@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::copy

; 160  : 																			destroy(first, last);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@0@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::destroy

; 161  : 																			deallocate(first);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEXPAPAVNxForceFieldShapeDesc@@@Z ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::deallocate

; 162  : 																			//if we knew we just have atomics we could just do this:
; 163  : 																			//first = reallocate(n, first);
; 164  : 																			memEnd = s + n;

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _s$50694[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 165  : 																			last = s + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::size
	mov	ecx, DWORD PTR _s$50694[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 166  : 																			first = s; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _s$50694[ebp]
	mov	DWORD PTR [ecx], edx
$L50693:

; 168  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?reserve@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QAEXI@Z ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::reserve
_TEXT	ENDS
;	COMDAT ?capacity@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4
?capacity@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::capacity, COMDAT

; 174  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 																		return (unsigned)(first == 0 ? 0 : memEnd - first);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L52795
	mov	DWORD PTR -8+[ebp], 0
	jmp	SHORT $L52796
$L52795:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx]
	sar	eax, 2
	mov	DWORD PTR -8+[ebp], eax
$L52796:
	mov	eax, DWORD PTR -8+[ebp]

; 176  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@QBEIXZ ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::capacity
_TEXT	ENDS
;	COMDAT ?copy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@PBQAV2@0PAPAV2@@Z
_TEXT	SEGMENT
_f$ = 8
_l$ = 12
_p$ = 16
_this$ = -4
?copy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@PBQAV2@0PAPAV2@@Z PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::copy, COMDAT

; 469  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 																		for (; f != l; ++p, ++f)

	jmp	SHORT $L50700
$L50701:
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 4
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _f$[ebp]
	add	ecx, 4
	mov	DWORD PTR _f$[ebp], ecx
$L50700:
	mov	edx, DWORD PTR _f$[ebp]
	cmp	edx, DWORD PTR _l$[ebp]
	je	SHORT $L50702

; 471  : 																			*p = *f;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR _f$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $L50701
$L50702:

; 472  : 																		return p; 

	mov	eax, DWORD PTR _p$[ebp]

; 473  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?copy@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@PBQAV2@0PAPAV2@@Z ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::copy
_TEXT	ENDS
;	COMDAT ?allocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@I@Z
_TEXT	SEGMENT
_n$ = 8
_this$ = -4
?allocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@I@Z PROC NEAR ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::allocate, COMDAT

; 476  : 																		{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : #ifdef _DEBUG
; 478  : 																		return (ElemType *)allocator.mallocDEBUG(n * sizeof(ElemType), (const char *)__FILE__, __LINE__, "ElemType", NX_MEMORY_Generic_Array_Container);

	push	289					; 00000121H
	push	OFFSET FLAT:??_C@_08LLLA@ElemType?$AA@	; `string'
	push	478					; 000001deH
	push	OFFSET FLAT:??_C@_0CD@HHAN@z?3?2xashxtsrc?2phys_shared?2nxarray@ ; `string'
	mov	eax, DWORD PTR _n$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?mallocDEBUG@NxAllocatorDefault@@QAEPAXIPBDH0W4NxMemoryType@@@Z ; NxAllocatorDefault::mallocDEBUG

; 479  : #else
; 480  : 																		return (ElemType *)allocator.malloc(n * sizeof(ElemType), NX_MEMORY_Generic_Array_Container);
; 481  : #endif
; 482  : 																		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$NxArray@PAVNxForceFieldShapeDesc@@VNxAllocatorDefault@@@@AAEPAPAVNxForceFieldShapeDesc@@I@Z ENDP ; NxArray<NxForceFieldShapeDesc *,NxAllocatorDefault>::allocate
_TEXT	ENDS
END
