	TITLE	Z:\XashXTSRC\server\weapons.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MFBM@sprites?1laserbeam?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@NEIH@MaxAmmoCarry?$CI?$CJ?5doesn?8t?5recognize@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@NMAB@z?3?2xashxtsrc?2server?2weapons?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@CLAC@giAmmoIndex?5?$DM?5MAX_AMMO_SLOTS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AddAmmoNameToAmmoRegistry@@YAXPBD@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CG@DDME@NULL?5Ent?5in?5UTIL_PrecacheOtherWe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IMIN@item_suit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CIMM@item_battery?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HJKP@item_antidote?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GMKO@item_security?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ODAO@item_longjump?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PHLB@weapon_shotgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FHCF@ammo_buckshot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NAIF@weapon_crowbar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NFGM@weapon_axe?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MPPM@ammo_9mmclip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JNOE@weapon_9mmAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HEPA@ammo_9mmAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NPOO@weapon_357?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BGGJ@ammo_357?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DDMO@weapon_gauss?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MILI@ammo_gaussclip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OCEH@weapon_rpg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BIME@ammo_rpgclip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HAEF@weapon_crossbow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OFDM@ammo_crossbow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IOMI@weapon_egon?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLON@weapon_tripmine?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JCMM@weapon_satchel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGIA@weapon_handgrenade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@ODHC@weapon_snark?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@CILK@weapon_hornetgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KMAI@weaponbox?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@KGNL@sprites?1zerogxplode?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@MLBD@sprites?1WXplo1?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HPGE@sprites?1steam1?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FLIJ@sprites?1bubble?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJF@sprites?1bloodspray?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KCPC@sprites?1blood?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FKKF@sprites?1laserdot?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@EKBB@models?1grenade?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KPF@sprites?1explode1?4spr?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHCE@weapons?1debris1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHEL@weapons?1debris2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHGO@weapons?1debris3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OKPC@weapons?1grenade_hit1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KJN@weapons?1grenade_hit2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KKLI@weapons?1grenade_hit3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MANB@items?1weapondrop1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PKCE@CBasePlayerItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NFLA@m_pPlayer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MHLP@m_pNext?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KMBF@m_iId?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DFGG@DestroyItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HNLH@DefaultTouch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HMCL@FallThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@BEMF@Materialize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@JILK@AttemptToMaterialize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BICG@CBasePlayerWeapon?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@ENP@m_flNextPrimaryAttack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@LOCF@m_flNextSecondaryAttack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONPI@m_iPrimaryAmmoType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEDC@m_iSecondaryAmmoType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OKJD@m_iClip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MHCP@m_iDefaultAmmo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@FCIG@items?1suitchargeok1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@LDNI@Respawn?5failed?5to?5create?5?$CFs?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@FDHL@items?1gunpickup2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCKL@items?19mmclip1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@NHFC@weapons?1357_cock1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NDAH@CBasePlayerAmmo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MHAM@CWeaponBox?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FKCE@m_rgAmmo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KBMA@m_rgiszAmmo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CBH@m_cAmmoTypes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04INPC@Kill?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@DJFG@models?1w_weaponbox?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@LAJG@WeaponBox?5too?5full?$CB?5only?5?$CFd?5ammo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LEBC@NULL?5String?5in?5PackAmmo?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IJKC@out?5of?5named?5ammo?5slots?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HOPO@primary?3?5?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@GBAP@idle?5?5?5?3?5?5?$CFf?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KPBB@m_finre?3?5?5?$CFi?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@ONLB@m_iclip?3?5?5?$CFi?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MFKO@CLaserSpot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06NAJJ@Revive?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FNBF@laser_spot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pszAmmo1@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iMaxAmmo1@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pszAmmo2@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iMaxAmmo2@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iMaxClip@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iFlags@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CLaserSpot@@EAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Link@CGraph@@QAEAAVCLink@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NodeLink@CGraph@@QAEAAVCLink@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MaxAmmoCarry@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearMultiDamage@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpawnBlood@@YAXVVector@@HM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DamageDecal@@YAHPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DecalGunshot@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EjectBrass@@YAXABVVector@@0MHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddAmmoNameToAmmoRegistry@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_PrecacheOtherWeapon@@YAXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?W_Precache@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBasePlayerItem@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBasePlayerItem@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBasePlayerWeapon@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBasePlayerWeapon@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetObjectCollisionBox@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FallInit@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FallThink@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Materialize@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AttemptToMaterialize@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckRespawn@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBasePlayerItem@@UAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanAttack@@YAHMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ItemPostFrame@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyItem@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToPlayer@CBasePlayerItem@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Drop@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Kill@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Holster@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AttachToPlayer@CBasePlayerItem@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddDuplicate@CBasePlayerWeapon@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToPlayer@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateClientData@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendWeaponAnim@CBasePlayerWeapon@@UAEXHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPrimaryAmmo@CBasePlayerWeapon@@QAEHHPADHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddSecondaryAmmo@CBasePlayerWeapon@@QAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsUseable@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanDeploy@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefaultDeploy@CBasePlayerWeapon@@QAEHPAD0H0HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefaultReload@CBasePlayerWeapon@@QAEHHHMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayEmptySound@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetEmptySound@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrimaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SecondaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Holster@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBasePlayerAmmo@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBasePlayerAmmo@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBasePlayerAmmo@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBasePlayerAmmo@@UAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Materialize@CBasePlayerAmmo@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractClipAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RetireWeapon@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CWeaponBox@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CWeaponBox@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E51
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CWeaponBox@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CWeaponBox@@EAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CWeaponBox@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Kill@CWeaponBox@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CWeaponBox@@EAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackAmmo@CWeaponBox@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CWeaponBox@@AAEHHPADHPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CWeaponBox@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetObjectCollisionBox@CWeaponBox@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrintState@CBasePlayerWeapon@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CLaserSpot@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CLaserSpot@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E56
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E57
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSpot@CLaserSpot@@SAPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E61
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CLaserSpot@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Suspend@CLaserSpot@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Revive@CLaserSpot@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CLaserSpot@@EAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCWeaponBox@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCWeaponBox@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCWeaponBox@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCWeaponBox@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCLaserSpot@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCLaserSpot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCLaserSpot@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCLaserSpot@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseAnimating@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBasePlayerItem@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CLaserSpot@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWeaponBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCLaserSpot@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CLaserSpot@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CWeaponBox@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCWeaponBox@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A	; CBasePlayerAmmo::m_DataMap
PUBLIC	?g_sModelIndexLaser@@3FA			; g_sModelIndexLaser
PUBLIC	?g_pModelNameLaser@@3PBDB			; g_pModelNameLaser
PUBLIC	?g_sModelIndexLaserDot@@3FA			; g_sModelIndexLaserDot
PUBLIC	?g_sModelIndexFireball@@3FA			; g_sModelIndexFireball
PUBLIC	?g_sModelIndexSmoke@@3FA			; g_sModelIndexSmoke
PUBLIC	?g_sModelIndexWExplosion@@3FA			; g_sModelIndexWExplosion
PUBLIC	?g_sModelIndexBubbles@@3FA			; g_sModelIndexBubbles
PUBLIC	?g_sModelIndexBloodDrop@@3FA			; g_sModelIndexBloodDrop
PUBLIC	?g_sModelIndexBloodSpray@@3FA			; g_sModelIndexBloodSpray
PUBLIC	?gMultiDamage@@3UMULTIDAMAGE@@A			; gMultiDamage
PUBLIC	??_C@_0L@MFKO@CLaserSpot?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CLaserSpot_DataDescInit@@3PAUdatamap_s@@A ; CLaserSpot_DataDescInit::g_DataMapHolder
PUBLIC	?m_DataMap@CWeaponBox@@2Udatamap_s@@A		; CWeaponBox::m_DataMap
PUBLIC	?m_DataMap@CLaserSpot@@2Udatamap_s@@A		; CLaserSpot::m_DataMap
PUBLIC	??_C@_0BG@MFBM@sprites?1laserbeam?4spr?$AA@	; `string'
PUBLIC	?giAmmoIndex@@3HA				; giAmmoIndex
PUBLIC	??_C@_0BA@PKCE@CBasePlayerItem?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CBasePlayerItem_DataDescInit@@3PAUdatamap_s@@A ; CBasePlayerItem_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_09NFLA@m_pPlayer?$AA@			; `string'
PUBLIC	??_C@_07MHLP@m_pNext?$AA@			; `string'
PUBLIC	??_C@_05KMBF@m_iId?$AA@				; `string'
PUBLIC	??_C@_0BC@BICG@CBasePlayerWeapon?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CBasePlayerWeapon_DataDescInit@@3PAUdatamap_s@@A ; CBasePlayerWeapon_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0BG@ENP@m_flNextPrimaryAttack?$AA@	; `string'
PUBLIC	??_C@_0BI@LOCF@m_flNextSecondaryAttack?$AA@	; `string'
PUBLIC	??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@		; `string'
PUBLIC	??_C@_0BD@ONPI@m_iPrimaryAmmoType?$AA@		; `string'
PUBLIC	??_C@_0BF@FEDC@m_iSecondaryAmmoType?$AA@	; `string'
PUBLIC	??_C@_07OKJD@m_iClip?$AA@			; `string'
PUBLIC	??_C@_0P@MHCP@m_iDefaultAmmo?$AA@		; `string'
PUBLIC	?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A	; CBasePlayerItem::m_DataMap
PUBLIC	??_C@_0BA@NDAH@CBasePlayerAmmo?$AA@		; `string'
PUBLIC	?g_DataMapHolder@CBasePlayerAmmo_DataDescInit@@3PAUdatamap_s@@A ; CBasePlayerAmmo_DataDescInit::g_DataMapHolder
PUBLIC	?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A	; CBasePlayerItem::ItemInfoArray
PUBLIC	?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A	; CBasePlayerItem::AmmoInfoArray
PUBLIC	?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A	; CBasePlayerWeapon::m_DataMap
PUBLIC	??_C@_0L@MHAM@CWeaponBox?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CWeaponBox_DataDescInit@@3PAUdatamap_s@@A ; CWeaponBox_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_08FKCE@m_rgAmmo?$AA@			; `string'
PUBLIC	??_C@_0M@KBMA@m_rgiszAmmo?$AA@			; `string'
PUBLIC	??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@		; `string'
PUBLIC	??_C@_0N@CBH@m_cAmmoTypes?$AA@			; `string'
_BSS	SEGMENT
?g_sModelIndexLaser@@3FA DW 01H DUP (?)			; g_sModelIndexLaser
	ALIGN	4

?g_sModelIndexLaserDot@@3FA DW 01H DUP (?)		; g_sModelIndexLaserDot
	ALIGN	4

?g_sModelIndexFireball@@3FA DW 01H DUP (?)		; g_sModelIndexFireball
	ALIGN	4

?g_sModelIndexSmoke@@3FA DW 01H DUP (?)			; g_sModelIndexSmoke
	ALIGN	4

?g_sModelIndexWExplosion@@3FA DW 01H DUP (?)		; g_sModelIndexWExplosion
	ALIGN	4

?g_sModelIndexBubbles@@3FA DW 01H DUP (?)		; g_sModelIndexBubbles
	ALIGN	4

?g_sModelIndexBloodDrop@@3FA DW 01H DUP (?)		; g_sModelIndexBloodDrop
	ALIGN	4

?g_sModelIndexBloodSpray@@3FA DW 01H DUP (?)		; g_sModelIndexBloodSpray
	ALIGN	4

?gMultiDamage@@3UMULTIDAMAGE@@A DB 0cH DUP (?)		; gMultiDamage
?g_DataMapHolder@CLaserSpot_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CLaserSpot_DataDescInit::g_DataMapHolder
?giAmmoIndex@@3HA DD 01H DUP (?)			; giAmmoIndex
?g_DataMapHolder@CBasePlayerItem_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBasePlayerItem_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CBasePlayerWeapon_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBasePlayerWeapon_DataDescInit::g_DataMapHolder
?g_DataMapHolder@CBasePlayerAmmo_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBasePlayerAmmo_DataDescInit::g_DataMapHolder
?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A DB 0b00H DUP (?) ; CBasePlayerItem::ItemInfoArray
?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A DQ 020H DUP (?) ; CBasePlayerItem::AmmoInfoArray
?g_DataMapHolder@CWeaponBox_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CWeaponBox_DataDescInit::g_DataMapHolder
_BSS	ENDS
_DATA	SEGMENT
?g_pModelNameLaser@@3PBDB DD FLAT:??_C@_0BG@MFBM@sprites?1laserbeam?4spr?$AA@ ; g_pModelNameLaser
	ORG $+4
?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A DD 00H	; CBasePlayerItem::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BA@PKCE@CBasePlayerItem?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S35	DD	FLAT:_$E34
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_09NFLA@m_pPlayer?$AA@
	DD	0718H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_07MHLP@m_pNext?$AA@
	DD	071cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_05KMBF@m_iId?$AA@
	DD	0720H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+116
?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A DD 00H	; CBasePlayerWeapon::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BC@BICG@CBasePlayerWeapon?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S40	DD	FLAT:_$E39
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BG@ENP@m_flNextPrimaryAttack?$AA@
	DD	0734H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BI@LOCF@m_flNextSecondaryAttack?$AA@
	DD	0738H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@
	DD	073cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BD@ONPI@m_iPrimaryAmmoType?$AA@
	DD	0740H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BF@FEDC@m_iSecondaryAmmoType?$AA@
	DD	0744H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_07OKJD@m_iClip?$AA@
	DD	0748H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@MHCP@m_iDefaultAmmo?$AA@
	DD	0758H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A DD 00H	; CBasePlayerAmmo::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BA@NDAH@CBasePlayerAmmo?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S45	DD	FLAT:_$E44
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	012H
	ORG $+44
_DATA	ENDS
CRT$XCU	SEGMENT
_$S50	DD	FLAT:_$E49
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CWeaponBox@@2Udatamap_s@@A DD 00H		; CWeaponBox::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0L@MHAM@CWeaponBox?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S53	DD	FLAT:_$E52
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08FKCE@m_rgAmmo?$AA@
	DD	077cH
	DW	020H
	DW	02H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0M@KBMA@m_rgiszAmmo?$AA@
	DD	06fcH
	DW	020H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@
	DD	06e4H
	DW	06H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0N@CBH@m_cAmmoTypes?$AA@
	DD	07fcH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+20
?m_DataMap@CLaserSpot@@2Udatamap_s@@A DD 00H		; CLaserSpot::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0L@MFKO@CLaserSpot?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S58	DD	FLAT:_$E57
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	012H
	ORG $+20
_DATA	ENDS
CRT$XCU	SEGMENT
_$S63	DD	FLAT:_$E62
CRT$XCU	ENDS
;	COMDAT ??_C@_0BG@MFBM@sprites?1laserbeam?4spr?$AA@
CONST	SEGMENT
??_C@_0BG@MFBM@sprites?1laserbeam?4spr?$AA@ DB 'sprites/laserbeam.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PKCE@CBasePlayerItem?$AA@
CONST	SEGMENT
??_C@_0BA@PKCE@CBasePlayerItem?$AA@ DB 'CBasePlayerItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NFLA@m_pPlayer?$AA@
CONST	SEGMENT
??_C@_09NFLA@m_pPlayer?$AA@ DB 'm_pPlayer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHLP@m_pNext?$AA@
CONST	SEGMENT
??_C@_07MHLP@m_pNext?$AA@ DB 'm_pNext', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KMBF@m_iId?$AA@
CONST	SEGMENT
??_C@_05KMBF@m_iId?$AA@ DB 'm_iId', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BICG@CBasePlayerWeapon?$AA@
CONST	SEGMENT
??_C@_0BC@BICG@CBasePlayerWeapon?$AA@ DB 'CBasePlayerWeapon', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ENP@m_flNextPrimaryAttack?$AA@
CONST	SEGMENT
??_C@_0BG@ENP@m_flNextPrimaryAttack?$AA@ DB 'm_flNextPrimaryAttack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LOCF@m_flNextSecondaryAttack?$AA@
CONST	SEGMENT
??_C@_0BI@LOCF@m_flNextSecondaryAttack?$AA@ DB 'm_flNextSecondaryAttack', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@
CONST	SEGMENT
??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@ DB 'm_flTimeWeaponIdle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@ONPI@m_iPrimaryAmmoType?$AA@
CONST	SEGMENT
??_C@_0BD@ONPI@m_iPrimaryAmmoType?$AA@ DB 'm_iPrimaryAmmoType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FEDC@m_iSecondaryAmmoType?$AA@
CONST	SEGMENT
??_C@_0BF@FEDC@m_iSecondaryAmmoType?$AA@ DB 'm_iSecondaryAmmoType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OKJD@m_iClip?$AA@
CONST	SEGMENT
??_C@_07OKJD@m_iClip?$AA@ DB 'm_iClip', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHCP@m_iDefaultAmmo?$AA@
CONST	SEGMENT
??_C@_0P@MHCP@m_iDefaultAmmo?$AA@ DB 'm_iDefaultAmmo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NDAH@CBasePlayerAmmo?$AA@
CONST	SEGMENT
??_C@_0BA@NDAH@CBasePlayerAmmo?$AA@ DB 'CBasePlayerAmmo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MHAM@CWeaponBox?$AA@
CONST	SEGMENT
??_C@_0L@MHAM@CWeaponBox?$AA@ DB 'CWeaponBox', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FKCE@m_rgAmmo?$AA@
CONST	SEGMENT
??_C@_08FKCE@m_rgAmmo?$AA@ DB 'm_rgAmmo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KBMA@m_rgiszAmmo?$AA@
CONST	SEGMENT
??_C@_0M@KBMA@m_rgiszAmmo?$AA@ DB 'm_rgiszAmmo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@
CONST	SEGMENT
??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@ DB 'm_rgpPlayerItems', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBH@m_cAmmoTypes?$AA@
CONST	SEGMENT
??_C@_0N@CBH@m_cAmmoTypes?$AA@ DB 'm_cAmmoTypes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MFKO@CLaserSpot?$AA@
CONST	SEGMENT
??_C@_0L@MFKO@CLaserSpot?$AA@ DB 'CLaserSpot', 00H	; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?MaxAmmoCarry@@YAHH@Z				; MaxAmmoCarry
PUBLIC	??_C@_0CI@NEIH@MaxAmmoCarry?$CI?$CJ?5doesn?8t?5recognize@ ; `string'
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_0CI@NEIH@MaxAmmoCarry?$CI?$CJ?5doesn?8t?5recognize@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0CI@NEIH@MaxAmmoCarry?$CI?$CJ?5doesn?8t?5recognize@ DB 'MaxAmmoCarr'
	DB	'y() doesn''t recognize ''%s''!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?MaxAmmoCarry@@YAHH@Z
_TEXT	SEGMENT
_iszName$ = 8
_i$ = -4
?MaxAmmoCarry@@YAHH@Z PROC NEAR				; MaxAmmoCarry, COMDAT

; 64   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 65   : 	for ( int i = 0;  i < MAX_WEAPONS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39128
$L39129:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39128:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jge	$L39130

; 67   : 		if ( CBasePlayerItem::ItemInfoArray[i].pszAmmo1 && !strcmp( STRING(iszName), CBasePlayerItem::ItemInfoArray[i].pszAmmo1 ) )

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	cmp	DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+8], 0
	je	SHORT $L39131
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[edx+8]
	push	eax
	mov	ecx, DWORD PTR _iszName$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39131

; 68   : 			return CBasePlayerItem::ItemInfoArray[i].iMaxAmmo1;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[edx+12]
	jmp	SHORT $L39126
$L39131:

; 69   : 		if ( CBasePlayerItem::ItemInfoArray[i].pszAmmo2 && !strcmp( STRING(iszName), CBasePlayerItem::ItemInfoArray[i].pszAmmo2 ) )

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 44					; 0000002cH
	cmp	DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[eax+16], 0
	je	SHORT $L39132
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+16]
	push	edx
	mov	eax, DWORD PTR _iszName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39132

; 70   : 			return CBasePlayerItem::ItemInfoArray[i].iMaxAmmo2;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+20]
	jmp	SHORT $L39126
$L39132:

; 71   : 	}

	jmp	$L39129
$L39130:

; 72   : 
; 73   : 	ALERT( at_console, "MaxAmmoCarry() doesn't recognize '%s'!\n", STRING( iszName ) );

	mov	edx, DWORD PTR _iszName$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CI@NEIH@MaxAmmoCarry?$CI?$CJ?5doesn?8t?5recognize@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 74   : 	return -1;

	or	eax, -1
$L39126:

; 75   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MaxAmmoCarry@@YAHH@Z ENDP				; MaxAmmoCarry
_TEXT	ENDS
PUBLIC	?ClearMultiDamage@@YAXXZ			; ClearMultiDamage
EXTRN	__fltused:NEAR
;	COMDAT ?ClearMultiDamage@@YAXXZ
_TEXT	SEGMENT
?ClearMultiDamage@@YAXXZ PROC NEAR			; ClearMultiDamage, COMDAT

; 92   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 93   : 	gMultiDamage.pEntity = NULL;

	mov	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A, 0

; 94   : 	gMultiDamage.amount	= 0;

	mov	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+4, 0

; 95   : 	gMultiDamage.type = 0;

	mov	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+8, 0

; 96   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearMultiDamage@@YAXXZ ENDP				; ClearMultiDamage
_TEXT	ENDS
PUBLIC	?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z		; ApplyMultiDamage
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
;	COMDAT ?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pevAttacker$ = 12
_vecSpot1$ = -12
_vecDir$ = -24
_tr$ = -80
?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z PROC NEAR	; ApplyMultiDamage, COMDAT

; 106  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi

; 107  : 	Vector		vecSpot1;//where blood comes from

	lea	ecx, DWORD PTR _vecSpot1$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 108  : 	Vector		vecDir;//direction blood should go

	lea	ecx, DWORD PTR _vecDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 109  : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 110  : 
; 111  : 	if ( !gMultiDamage.pEntity )

	cmp	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A, 0
	jne	SHORT $L39144

; 112  : 		return;

	jmp	SHORT $L39140
$L39144:

; 113  : 
; 114  : 	gMultiDamage.pEntity->TakeDamage(pevInflictor, pevAttacker, gMultiDamage.amount, gMultiDamage.type );

	mov	eax, DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+8
	push	eax
	mov	ecx, DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+4
	push	ecx
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevInflictor$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A
	call	DWORD PTR [edx+96]
$L39140:

; 115  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z ENDP		; ApplyMultiDamage
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z ; AddMultiDamage
;	COMDAT ?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pEntity$ = 12
_flDamage$ = 16
_bitsDamageType$ = 20
?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z PROC NEAR ; AddMultiDamage, COMDAT

; 122  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 123  : 	if ( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L39153

; 124  : 		return;

	jmp	SHORT $L39152
$L39153:

; 125  : 
; 126  : 	gMultiDamage.type |= bitsDamageType;

	mov	eax, DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+8
	or	eax, DWORD PTR _bitsDamageType$[ebp]
	mov	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+8, eax

; 127  : 
; 128  : 	if ( pEntity != gMultiDamage.pEntity )

	mov	ecx, DWORD PTR _pEntity$[ebp]
	cmp	ecx, DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A
	je	SHORT $L39154

; 130  : 		ApplyMultiDamage(pevInflictor,pevInflictor); // UNDONE: wrong attacker!

	mov	edx, DWORD PTR _pevInflictor$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevInflictor$[ebp]
	push	eax
	call	?ApplyMultiDamage@@YAXPAUentvars_s@@0@Z	; ApplyMultiDamage
	add	esp, 8

; 131  : 		gMultiDamage.pEntity	= pEntity;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A, ecx

; 132  : 		gMultiDamage.amount		= 0;

	mov	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+4, 0
$L39154:

; 134  : 
; 135  : 	gMultiDamage.amount += flDamage;

	fld	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+4
	fadd	DWORD PTR _flDamage$[ebp]
	fstp	DWORD PTR ?gMultiDamage@@3UMULTIDAMAGE@@A+4
$L39152:

; 136  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z ENDP ; AddMultiDamage
_TEXT	ENDS
PUBLIC	?SpawnBlood@@YAXVVector@@HM@Z			; SpawnBlood
EXTRN	?UTIL_BloodDrips@@YAXABVVector@@0HH@Z:NEAR	; UTIL_BloodDrips
EXTRN	__ftol:NEAR
EXTRN	?g_vecAttackDir@@3VVector@@A:BYTE		; g_vecAttackDir
;	COMDAT ?SpawnBlood@@YAXVVector@@HM@Z
_TEXT	SEGMENT
_vecSpot$ = 8
_bloodColor$ = 20
_flDamage$ = 24
?SpawnBlood@@YAXVVector@@HM@Z PROC NEAR			; SpawnBlood, COMDAT

; 144  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 145  : 	UTIL_BloodDrips( vecSpot, g_vecAttackDir, bloodColor, (int)flDamage );

	fld	DWORD PTR _flDamage$[ebp]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _bloodColor$[ebp]
	push	eax
	push	OFFSET FLAT:?g_vecAttackDir@@3VVector@@A ; g_vecAttackDir
	lea	ecx, DWORD PTR _vecSpot$[ebp]
	push	ecx
	call	?UTIL_BloodDrips@@YAXABVVector@@0HH@Z	; UTIL_BloodDrips
	add	esp, 16					; 00000010H

; 146  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SpawnBlood@@YAXVVector@@HM@Z ENDP			; SpawnBlood
_TEXT	ENDS
PUBLIC	?DamageDecal@@YAHPAVCBaseEntity@@H@Z		; DamageDecal
;	COMDAT ?DamageDecal@@YAHPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_pEntity$ = 8
_bitsDamageType$ = 12
?DamageDecal@@YAHPAVCBaseEntity@@H@Z PROC NEAR		; DamageDecal, COMDAT

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 151  : 	if ( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L39165

; 152  : 		return (DECAL_GUNSHOT1 + RANDOM_LONG(0,4));

	push	4
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	jmp	SHORT $L39164
$L39165:

; 153  : 
; 154  : 	return pEntity->DamageDecal( bitsDamageType );

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+176]
$L39164:

; 155  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DamageDecal@@YAHPAVCBaseEntity@@H@Z ENDP		; DamageDecal
_TEXT	ENDS
PUBLIC	?DecalGunshot@@YAXPAUgametrace_s@@H@Z		; DecalGunshot
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
EXTRN	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z:NEAR	; UTIL_DecalTrace
EXTRN	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z:NEAR ; UTIL_StudioDecalTrace
EXTRN	?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z:NEAR ; UTIL_GunshotDecalTrace
EXTRN	?UTIL_IsValidEntity@@YAHPAUedict_s@@@Z:NEAR	; UTIL_IsValidEntity
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
;	COMDAT ?DecalGunshot@@YAXPAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pTrace$ = 8
_iBulletType$ = 12
_pev$ = -4
_pEntity$39173 = -8
_pEntity$39185 = -12
?DecalGunshot@@YAXPAUgametrace_s@@H@Z PROC NEAR		; DecalGunshot, COMDAT

; 158  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 159  : 	// Is the entity valid
; 160  : 	if ( !UTIL_IsValidEntity( pTrace->pHit ) )

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?UTIL_IsValidEntity@@YAHPAUedict_s@@@Z	; UTIL_IsValidEntity
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39170

; 161  : 		return;

	jmp	$L39169
$L39170:

; 162  : 
; 163  : 	entvars_t *pev = VARS(pTrace->pHit);

	mov	edx, DWORD PTR _pTrace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax

; 164  : 
; 165  : 	if( UTIL_GetModelType( pev->modelindex ) == mod_brush )

	mov	ecx, DWORD PTR _pev$[ebp]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	jne	$L39172

; 167  : 		CBaseEntity *pEntity = NULL;

	mov	DWORD PTR _pEntity$39173[ebp], 0

; 168  : 		// Decal the wall with a gunshot
; 169  : 		if ( !FNullEnt(pTrace->pHit) )

	mov	eax, DWORD PTR _pTrace$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39174

; 170  : 			pEntity = CBaseEntity::Instance(pTrace->pHit);

	mov	edx, DWORD PTR _pTrace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$39173[ebp], eax
$L39174:

; 173  : 		{

	mov	ecx, DWORD PTR _iBulletType$[ebp]
	mov	DWORD PTR -16+[ebp], ecx
	cmp	DWORD PTR -16+[ebp], 5
	je	SHORT $L39181
	cmp	DWORD PTR -16+[ebp], 8
	je	SHORT $L39180

; 174  : 		case BULLET_PLAYER_9MM:
; 175  : 		case BULLET_MONSTER_9MM:
; 176  : 		case BULLET_PLAYER_MP5:
; 177  : 		case BULLET_MONSTER_MP5:
; 178  : 		case BULLET_PLAYER_BUCKSHOT:
; 179  : 		case BULLET_PLAYER_357:
; 180  : 		default:
; 181  : 			// smoke and decal
; 182  : 			UTIL_GunshotDecalTrace( pTrace, DamageDecal( pEntity, DMG_BULLET ) );

	push	2
	mov	edx, DWORD PTR _pEntity$39173[ebp]
	push	edx
	call	?DamageDecal@@YAHPAVCBaseEntity@@H@Z	; DamageDecal
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _pTrace$[ebp]
	push	eax
	call	?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_GunshotDecalTrace
	add	esp, 8

; 183  : 			break;

	jmp	SHORT $L39176
$L39180:

; 184  : 		case BULLET_MONSTER_12MM:
; 185  : 			// smoke and decal
; 186  : 			UTIL_GunshotDecalTrace( pTrace, DamageDecal( pEntity, DMG_BULLET ) );

	push	2
	mov	ecx, DWORD PTR _pEntity$39173[ebp]
	push	ecx
	call	?DamageDecal@@YAHPAVCBaseEntity@@H@Z	; DamageDecal
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _pTrace$[ebp]
	push	edx
	call	?UTIL_GunshotDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_GunshotDecalTrace
	add	esp, 8

; 187  : 			break;

	jmp	SHORT $L39176
$L39181:

; 188  : 		case BULLET_PLAYER_CROWBAR:
; 189  : 			// wall decal
; 190  : 			UTIL_DecalTrace( pTrace, DamageDecal( pEntity, DMG_CLUB ) );

	push	128					; 00000080H
	mov	eax, DWORD PTR _pEntity$39173[ebp]
	push	eax
	call	?DamageDecal@@YAHPAVCBaseEntity@@H@Z	; DamageDecal
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pTrace$[ebp]
	push	ecx
	call	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_DecalTrace
	add	esp, 8
$L39176:

; 194  : 	else if( pev->flags & ( FL_MONSTER|FL_CLIENT ) || pev->solid == SOLID_CUSTOM )

	jmp	$L39188
$L39172:
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 40					; 00000028H
	test	eax, eax
	jne	SHORT $L39184
	mov	ecx, DWORD PTR _pev$[ebp]
	cmp	DWORD PTR [ecx+268], 5
	jne	$L39188
$L39184:

; 196  : 		CBaseEntity *pEntity = NULL;

	mov	DWORD PTR _pEntity$39185[ebp], 0

; 197  : 		// Decal the model with a blood
; 198  : 		if ( !FNullEnt(pTrace->pHit) )

	mov	edx, DWORD PTR _pTrace$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39186

; 199  : 			pEntity = CBaseEntity::Instance(pTrace->pHit);

	mov	ecx, DWORD PTR _pTrace$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$39185[ebp], eax
$L39186:

; 202  : 		{

	mov	eax, DWORD PTR _iBulletType$[ebp]
	mov	DWORD PTR -20+[ebp], eax
	cmp	DWORD PTR -20+[ebp], 5
	je	SHORT $L39193
	cmp	DWORD PTR -20+[ebp], 8
	je	SHORT $L39192

; 203  : 		case BULLET_PLAYER_9MM:
; 204  : 		case BULLET_MONSTER_9MM:
; 205  : 		case BULLET_PLAYER_MP5:
; 206  : 		case BULLET_MONSTER_MP5:
; 207  : 		case BULLET_PLAYER_BUCKSHOT:
; 208  : 		case BULLET_PLAYER_357:
; 209  : 		default:
; 210  : 			// smoke and decal
; 211  : 			UTIL_StudioDecalTrace( pTrace, DamageDecal( pEntity, DMG_BULLET ));

	push	0
	push	2
	mov	ecx, DWORD PTR _pEntity$39185[ebp]
	push	ecx
	call	?DamageDecal@@YAHPAVCBaseEntity@@H@Z	; DamageDecal
	add	esp, 8
	push	eax
	mov	edx, DWORD PTR _pTrace$[ebp]
	push	edx
	call	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z ; UTIL_StudioDecalTrace
	add	esp, 12					; 0000000cH

; 212  : 			break;

	jmp	SHORT $L39188
$L39192:

; 213  : 		case BULLET_MONSTER_12MM:
; 214  : 			// smoke and decal
; 215  : 			UTIL_StudioDecalTrace( pTrace, DamageDecal( pEntity, DMG_BULLET ));

	push	0
	push	2
	mov	eax, DWORD PTR _pEntity$39185[ebp]
	push	eax
	call	?DamageDecal@@YAHPAVCBaseEntity@@H@Z	; DamageDecal
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pTrace$[ebp]
	push	ecx
	call	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z ; UTIL_StudioDecalTrace
	add	esp, 12					; 0000000cH

; 216  : 			break;

	jmp	SHORT $L39188
$L39193:

; 217  : 		case BULLET_PLAYER_CROWBAR:
; 218  : 			// wall decal
; 219  : 			UTIL_StudioDecalTrace( pTrace, DamageDecal( pEntity, DMG_CLUB ));

	push	0
	push	128					; 00000080H
	mov	edx, DWORD PTR _pEntity$39185[ebp]
	push	edx
	call	?DamageDecal@@YAHPAVCBaseEntity@@H@Z	; DamageDecal
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _pTrace$[ebp]
	push	eax
	call	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z ; UTIL_StudioDecalTrace
	add	esp, 12					; 0000000cH
$L39188:
$L39169:

; 223  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DecalGunshot@@YAXPAUgametrace_s@@H@Z ENDP		; DecalGunshot
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L40856
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40856
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L40857
$L40856:
	mov	DWORD PTR -4+[ebp], 1
$L40857:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	?EjectBrass@@YAXABVVector@@0MHH@Z		; EjectBrass
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
;	COMDAT ?EjectBrass@@YAXABVVector@@0MHH@Z
_TEXT	SEGMENT
_vecOrigin$ = 8
_vecVelocity$ = 12
_rotation$ = 16
_model$ = 20
_soundtype$ = 24
?EjectBrass@@YAXABVVector@@0MHH@Z PROC NEAR		; EjectBrass, COMDAT

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 232  : 	// FIX: when the player shoots, their gun isn't in the same position as it is on the model other players see.
; 233  : 
; 234  : 	MESSAGE_BEGIN( MSG_PVS, SVC_TEMPENTITY, vecOrigin );

	push	0
	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	push	23					; 00000017H
	push	4
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 235  : 		WRITE_BYTE( TE_MODEL);

	push	106					; 0000006aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 236  : 		WRITE_COORD( vecOrigin.x);

	mov	eax, DWORD PTR _vecOrigin$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 237  : 		WRITE_COORD( vecOrigin.y);

	mov	edx, DWORD PTR _vecOrigin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 238  : 		WRITE_COORD( vecOrigin.z);

	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 239  : 		WRITE_COORD( vecVelocity.x);

	mov	eax, DWORD PTR _vecVelocity$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 240  : 		WRITE_COORD( vecVelocity.y);

	mov	edx, DWORD PTR _vecVelocity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 241  : 		WRITE_COORD( vecVelocity.z);

	mov	ecx, DWORD PTR _vecVelocity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 242  : 		WRITE_ANGLE( rotation );

	mov	eax, DWORD PTR _rotation$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+208
	add	esp, 4

; 243  : 		WRITE_SHORT( model );

	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 244  : 		WRITE_BYTE ( soundtype);

	mov	edx, DWORD PTR _soundtype$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 245  : 		WRITE_BYTE ( 25 );// 2.5 seconds

	push	25					; 00000019H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 246  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EjectBrass@@YAXABVVector@@0MHH@Z ENDP			; EjectBrass
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	?AddAmmoNameToAmmoRegistry@@YAXPBD@Z		; AddAmmoNameToAmmoRegistry
PUBLIC	?__LINE__Var@?1??AddAmmoNameToAmmoRegistry@@YAXPBD@Z@4FA ; `AddAmmoNameToAmmoRegistry'::`2'::__LINE__Var
PUBLIC	??_C@_0CA@NMAB@z?3?2xashxtsrc?2server?2weapons?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0BN@CLAC@giAmmoIndex?5?$DM?5MAX_AMMO_SLOTS?$AA@ ; `string'
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	_stricmp:NEAR
;	COMDAT ?__LINE__Var@?1??AddAmmoNameToAmmoRegistry@@YAXPBD@Z@4FA
; File z:\xashxtsrc\server\weapons.cpp
_DATA	SEGMENT
?__LINE__Var@?1??AddAmmoNameToAmmoRegistry@@YAXPBD@Z@4FA DW 0fdH ; `AddAmmoNameToAmmoRegistry'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0CA@NMAB@z?3?2xashxtsrc?2server?2weapons?4cpp?$AA@
CONST	SEGMENT
??_C@_0CA@NMAB@z?3?2xashxtsrc?2server?2weapons?4cpp?$AA@ DB 'z:\xashxtsrc'
	DB	'\server\weapons.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CLAC@giAmmoIndex?5?$DM?5MAX_AMMO_SLOTS?$AA@
CONST	SEGMENT
??_C@_0BN@CLAC@giAmmoIndex?5?$DM?5MAX_AMMO_SLOTS?$AA@ DB 'giAmmoIndex < M'
	DB	'AX_AMMO_SLOTS', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddAmmoNameToAmmoRegistry@@YAXPBD@Z
_TEXT	SEGMENT
_szAmmoname$ = 8
_i$ = -4
?AddAmmoNameToAmmoRegistry@@YAXPBD@Z PROC NEAR		; AddAmmoNameToAmmoRegistry, COMDAT

; 253  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 254  : 	// make sure it's not already in the registry
; 255  : 	for ( int i = 0; i < MAX_AMMO_SLOTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39206
$L39207:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39206:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L39208

; 257  : 		if ( !CBasePlayerItem::AmmoInfoArray[i].pszName)

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A[ecx*8], 0
	jne	SHORT $L39209

; 258  : 			continue;

	jmp	SHORT $L39207
$L39209:

; 259  : 
; 260  : 		if ( stricmp( CBasePlayerItem::AmmoInfoArray[i].pszName, szAmmoname ) == 0 )

	mov	edx, DWORD PTR _szAmmoname$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR ?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A[eax*8]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39210

; 261  : 			return; // ammo already in registry, just quite

	jmp	SHORT $L39204
$L39210:

; 262  : 	}

	jmp	SHORT $L39207
$L39208:

; 263  : 
; 264  : 
; 265  : 	giAmmoIndex++;

	mov	edx, DWORD PTR ?giAmmoIndex@@3HA	; giAmmoIndex
	add	edx, 1
	mov	DWORD PTR ?giAmmoIndex@@3HA, edx	; giAmmoIndex

; 266  : 	ASSERT( giAmmoIndex < MAX_AMMO_SLOTS );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??AddAmmoNameToAmmoRegistry@@YAXPBD@Z@4FA ; `AddAmmoNameToAmmoRegistry'::`2'::__LINE__Var
	add	eax, 13					; 0000000dH
	push	eax
	push	OFFSET FLAT:??_C@_0CA@NMAB@z?3?2xashxtsrc?2server?2weapons?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BN@CLAC@giAmmoIndex?5?$DM?5MAX_AMMO_SLOTS?$AA@ ; `string'
	xor	ecx, ecx
	cmp	DWORD PTR ?giAmmoIndex@@3HA, 32		; giAmmoIndex, 00000020H
	setl	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 267  : 	if ( giAmmoIndex >= MAX_AMMO_SLOTS )

	cmp	DWORD PTR ?giAmmoIndex@@3HA, 32		; giAmmoIndex, 00000020H
	jl	SHORT $L39214

; 268  : 		giAmmoIndex = 0;

	mov	DWORD PTR ?giAmmoIndex@@3HA, 0		; giAmmoIndex
$L39214:

; 269  : 
; 270  : 	CBasePlayerItem::AmmoInfoArray[giAmmoIndex].pszName = szAmmoname;

	mov	edx, DWORD PTR ?giAmmoIndex@@3HA	; giAmmoIndex
	mov	eax, DWORD PTR _szAmmoname$[ebp]
	mov	DWORD PTR ?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A[edx*8], eax

; 271  : 	CBasePlayerItem::AmmoInfoArray[giAmmoIndex].iId = giAmmoIndex;   // yes, this info is redundant

	mov	ecx, DWORD PTR ?giAmmoIndex@@3HA	; giAmmoIndex
	mov	edx, DWORD PTR ?giAmmoIndex@@3HA	; giAmmoIndex
	mov	DWORD PTR ?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A[ecx*8+4], edx
$L39204:

; 272  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AddAmmoNameToAmmoRegistry@@YAXPBD@Z ENDP		; AddAmmoNameToAmmoRegistry
_TEXT	ENDS
PUBLIC	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z		; UTIL_PrecacheOtherWeapon
PUBLIC	??_C@_0CG@DDME@NULL?5Ent?5in?5UTIL_PrecacheOtherWe@ ; `string'
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z:NEAR ; CreateEntityByName
EXTRN	_memset:NEAR
;	COMDAT ??_C@_0CG@DDME@NULL?5Ent?5in?5UTIL_PrecacheOtherWe@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0CG@DDME@NULL?5Ent?5in?5UTIL_PrecacheOtherWe@ DB 'NULL Ent in UTIL_'
	DB	'PrecacheOtherWeapon', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?UTIL_PrecacheOtherWeapon@@YAXPBD@Z
_TEXT	SEGMENT
_szClassname$ = 8
_pEntity$ = -4
_II$ = -48
?UTIL_PrecacheOtherWeapon@@YAXPBD@Z PROC NEAR		; UTIL_PrecacheOtherWeapon, COMDAT

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 278  : 	CBaseEntity *pEntity = CreateEntityByName( szClassname );

	push	0
	mov	eax, DWORD PTR _szClassname$[ebp]
	push	eax
	call	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CreateEntityByName
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax

; 279  : 
; 280  : 	if( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L39219

; 282  : 		ALERT ( at_console, "NULL Ent in UTIL_PrecacheOtherWeapon\n" );

	push	OFFSET FLAT:??_C@_0CG@DDME@NULL?5Ent?5in?5UTIL_PrecacheOtherWe@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 283  : 		return;

	jmp	$L39217
$L39219:

; 287  : 	pEntity->Precache( );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+8]

; 288  : 	memset( &II, 0, sizeof II );

	push	44					; 0000002cH
	push	0
	lea	eax, DWORD PTR _II$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 289  : 
; 290  : 	if ( ((CBasePlayerItem*)pEntity)->GetItemInfo( &II ) )

	lea	ecx, DWORD PTR _II$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+352]
	test	eax, eax
	je	SHORT $L39223

; 292  : 		CBasePlayerItem::ItemInfoArray[II.iId] = II;

	mov	edi, DWORD PTR _II$[ebp+32]
	imul	edi, 44					; 0000002cH
	add	edi, OFFSET FLAT:?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A ; CBasePlayerItem::ItemInfoArray
	mov	ecx, 11					; 0000000bH
	lea	esi, DWORD PTR _II$[ebp]
	rep movsd

; 293  : 
; 294  : 		if ( II.pszAmmo1 && *II.pszAmmo1 )

	cmp	DWORD PTR _II$[ebp+8], 0
	je	SHORT $L39224
	mov	ecx, DWORD PTR _II$[ebp+8]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L39224

; 296  : 			AddAmmoNameToAmmoRegistry( II.pszAmmo1 );

	mov	eax, DWORD PTR _II$[ebp+8]
	push	eax
	call	?AddAmmoNameToAmmoRegistry@@YAXPBD@Z	; AddAmmoNameToAmmoRegistry
	add	esp, 4
$L39224:

; 298  : 
; 299  : 		if ( II.pszAmmo2 && *II.pszAmmo2 )

	cmp	DWORD PTR _II$[ebp+16], 0
	je	SHORT $L39225
	mov	ecx, DWORD PTR _II$[ebp+16]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L39225

; 301  : 			AddAmmoNameToAmmoRegistry( II.pszAmmo2 );

	mov	eax, DWORD PTR _II$[ebp+16]
	push	eax
	call	?AddAmmoNameToAmmoRegistry@@YAXPBD@Z	; AddAmmoNameToAmmoRegistry
	add	esp, 4
$L39225:

; 303  : 
; 304  : 		memset( &II, 0, sizeof II );

	push	44					; 0000002cH
	push	0
	lea	ecx, DWORD PTR _II$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$L39223:

; 306  : 
; 307  : 	REMOVE_ENTITY(pEntity->edict());

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+88
	add	esp, 4
$L39217:

; 308  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_PrecacheOtherWeapon@@YAXPBD@Z ENDP		; UTIL_PrecacheOtherWeapon
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?W_Precache@@YAXXZ				; W_Precache
PUBLIC	??_C@_09IMIN@item_suit?$AA@			; `string'
PUBLIC	??_C@_0N@CIMM@item_battery?$AA@			; `string'
PUBLIC	??_C@_0O@HJKP@item_antidote?$AA@		; `string'
PUBLIC	??_C@_0O@GMKO@item_security?$AA@		; `string'
PUBLIC	??_C@_0O@ODAO@item_longjump?$AA@		; `string'
PUBLIC	??_C@_0P@PHLB@weapon_shotgun?$AA@		; `string'
PUBLIC	??_C@_0O@FHCF@ammo_buckshot?$AA@		; `string'
PUBLIC	??_C@_0P@NAIF@weapon_crowbar?$AA@		; `string'
PUBLIC	??_C@_0L@NFGM@weapon_axe?$AA@			; `string'
PUBLIC	??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@		; `string'
PUBLIC	??_C@_0N@MPPM@ammo_9mmclip?$AA@			; `string'
PUBLIC	??_C@_0N@JNOE@weapon_9mmAR?$AA@			; `string'
PUBLIC	??_C@_0L@HEPA@ammo_9mmAR?$AA@			; `string'
PUBLIC	??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@		; `string'
PUBLIC	??_C@_0L@NPOO@weapon_357?$AA@			; `string'
PUBLIC	??_C@_08BGGJ@ammo_357?$AA@			; `string'
PUBLIC	??_C@_0N@DDMO@weapon_gauss?$AA@			; `string'
PUBLIC	??_C@_0P@MILI@ammo_gaussclip?$AA@		; `string'
PUBLIC	??_C@_0L@OCEH@weapon_rpg?$AA@			; `string'
PUBLIC	??_C@_0N@BIME@ammo_rpgclip?$AA@			; `string'
PUBLIC	??_C@_0BA@HAEF@weapon_crossbow?$AA@		; `string'
PUBLIC	??_C@_0O@OFDM@ammo_crossbow?$AA@		; `string'
PUBLIC	??_C@_0M@IOMI@weapon_egon?$AA@			; `string'
PUBLIC	??_C@_0BA@LLON@weapon_tripmine?$AA@		; `string'
PUBLIC	??_C@_0P@JCMM@weapon_satchel?$AA@		; `string'
PUBLIC	??_C@_0BD@HGIA@weapon_handgrenade?$AA@		; `string'
PUBLIC	??_C@_0N@ODHC@weapon_snark?$AA@			; `string'
PUBLIC	??_C@_0BB@CILK@weapon_hornetgun?$AA@		; `string'
PUBLIC	??_C@_09KMAI@weaponbox?$AA@			; `string'
PUBLIC	??_C@_0BI@KGNL@sprites?1zerogxplode?4spr?$AA@	; `string'
PUBLIC	??_C@_0BD@MLBD@sprites?1WXplo1?4spr?$AA@	; `string'
PUBLIC	??_C@_0BD@HPGE@sprites?1steam1?4spr?$AA@	; `string'
PUBLIC	??_C@_0BD@FLIJ@sprites?1bubble?4spr?$AA@	; `string'
PUBLIC	??_C@_0BH@PJF@sprites?1bloodspray?4spr?$AA@	; `string'
PUBLIC	??_C@_0BC@KCPC@sprites?1blood?4spr?$AA@		; `string'
PUBLIC	??_C@_0BF@FKKF@sprites?1laserdot?4spr?$AA@	; `string'
PUBLIC	??_C@_0BD@EKBB@models?1grenade?4mdl?$AA@	; `string'
PUBLIC	??_C@_0BF@KPF@sprites?1explode1?4spr?$AA@	; `string'
PUBLIC	??_C@_0BE@BHCE@weapons?1debris1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@PHEL@weapons?1debris2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@FHGO@weapons?1debris3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BJ@OKPC@weapons?1grenade_hit1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BJ@KJN@weapons?1grenade_hit2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BJ@KKLI@weapons?1grenade_hit3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@MANB@items?1weapondrop1?4wav?$AA@	; `string'
EXTRN	?UTIL_PrecacheOther@@YAXPBD@Z:NEAR		; UTIL_PrecacheOther
EXTRN	?g_pGameRules@@3PAVCGameRules@@A:DWORD		; g_pGameRules
;	COMDAT ??_C@_09IMIN@item_suit?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_09IMIN@item_suit?$AA@ DB 'item_suit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIMM@item_battery?$AA@
CONST	SEGMENT
??_C@_0N@CIMM@item_battery?$AA@ DB 'item_battery', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HJKP@item_antidote?$AA@
CONST	SEGMENT
??_C@_0O@HJKP@item_antidote?$AA@ DB 'item_antidote', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GMKO@item_security?$AA@
CONST	SEGMENT
??_C@_0O@GMKO@item_security?$AA@ DB 'item_security', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ODAO@item_longjump?$AA@
CONST	SEGMENT
??_C@_0O@ODAO@item_longjump?$AA@ DB 'item_longjump', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PHLB@weapon_shotgun?$AA@
CONST	SEGMENT
??_C@_0P@PHLB@weapon_shotgun?$AA@ DB 'weapon_shotgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHCF@ammo_buckshot?$AA@
CONST	SEGMENT
??_C@_0O@FHCF@ammo_buckshot?$AA@ DB 'ammo_buckshot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NAIF@weapon_crowbar?$AA@
CONST	SEGMENT
??_C@_0P@NAIF@weapon_crowbar?$AA@ DB 'weapon_crowbar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFGM@weapon_axe?$AA@
CONST	SEGMENT
??_C@_0L@NFGM@weapon_axe?$AA@ DB 'weapon_axe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@
CONST	SEGMENT
??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@ DB 'weapon_9mmhandgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MPPM@ammo_9mmclip?$AA@
CONST	SEGMENT
??_C@_0N@MPPM@ammo_9mmclip?$AA@ DB 'ammo_9mmclip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JNOE@weapon_9mmAR?$AA@
CONST	SEGMENT
??_C@_0N@JNOE@weapon_9mmAR?$AA@ DB 'weapon_9mmAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HEPA@ammo_9mmAR?$AA@
CONST	SEGMENT
??_C@_0L@HEPA@ammo_9mmAR?$AA@ DB 'ammo_9mmAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@
CONST	SEGMENT
??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@ DB 'ammo_ARgrenades', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPOO@weapon_357?$AA@
CONST	SEGMENT
??_C@_0L@NPOO@weapon_357?$AA@ DB 'weapon_357', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BGGJ@ammo_357?$AA@
CONST	SEGMENT
??_C@_08BGGJ@ammo_357?$AA@ DB 'ammo_357', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DDMO@weapon_gauss?$AA@
CONST	SEGMENT
??_C@_0N@DDMO@weapon_gauss?$AA@ DB 'weapon_gauss', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MILI@ammo_gaussclip?$AA@
CONST	SEGMENT
??_C@_0P@MILI@ammo_gaussclip?$AA@ DB 'ammo_gaussclip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCEH@weapon_rpg?$AA@
CONST	SEGMENT
??_C@_0L@OCEH@weapon_rpg?$AA@ DB 'weapon_rpg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIME@ammo_rpgclip?$AA@
CONST	SEGMENT
??_C@_0N@BIME@ammo_rpgclip?$AA@ DB 'ammo_rpgclip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HAEF@weapon_crossbow?$AA@
CONST	SEGMENT
??_C@_0BA@HAEF@weapon_crossbow?$AA@ DB 'weapon_crossbow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OFDM@ammo_crossbow?$AA@
CONST	SEGMENT
??_C@_0O@OFDM@ammo_crossbow?$AA@ DB 'ammo_crossbow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IOMI@weapon_egon?$AA@
CONST	SEGMENT
??_C@_0M@IOMI@weapon_egon?$AA@ DB 'weapon_egon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LLON@weapon_tripmine?$AA@
CONST	SEGMENT
??_C@_0BA@LLON@weapon_tripmine?$AA@ DB 'weapon_tripmine', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JCMM@weapon_satchel?$AA@
CONST	SEGMENT
??_C@_0P@JCMM@weapon_satchel?$AA@ DB 'weapon_satchel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGIA@weapon_handgrenade?$AA@
CONST	SEGMENT
??_C@_0BD@HGIA@weapon_handgrenade?$AA@ DB 'weapon_handgrenade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ODHC@weapon_snark?$AA@
CONST	SEGMENT
??_C@_0N@ODHC@weapon_snark?$AA@ DB 'weapon_snark', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CILK@weapon_hornetgun?$AA@
CONST	SEGMENT
??_C@_0BB@CILK@weapon_hornetgun?$AA@ DB 'weapon_hornetgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KMAI@weaponbox?$AA@
CONST	SEGMENT
??_C@_09KMAI@weaponbox?$AA@ DB 'weaponbox', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KGNL@sprites?1zerogxplode?4spr?$AA@
CONST	SEGMENT
??_C@_0BI@KGNL@sprites?1zerogxplode?4spr?$AA@ DB 'sprites/zerogxplode.spr'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MLBD@sprites?1WXplo1?4spr?$AA@
CONST	SEGMENT
??_C@_0BD@MLBD@sprites?1WXplo1?4spr?$AA@ DB 'sprites/WXplo1.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HPGE@sprites?1steam1?4spr?$AA@
CONST	SEGMENT
??_C@_0BD@HPGE@sprites?1steam1?4spr?$AA@ DB 'sprites/steam1.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FLIJ@sprites?1bubble?4spr?$AA@
CONST	SEGMENT
??_C@_0BD@FLIJ@sprites?1bubble?4spr?$AA@ DB 'sprites/bubble.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PJF@sprites?1bloodspray?4spr?$AA@
CONST	SEGMENT
??_C@_0BH@PJF@sprites?1bloodspray?4spr?$AA@ DB 'sprites/bloodspray.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KCPC@sprites?1blood?4spr?$AA@
CONST	SEGMENT
??_C@_0BC@KCPC@sprites?1blood?4spr?$AA@ DB 'sprites/blood.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FKKF@sprites?1laserdot?4spr?$AA@
CONST	SEGMENT
??_C@_0BF@FKKF@sprites?1laserdot?4spr?$AA@ DB 'sprites/laserdot.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EKBB@models?1grenade?4mdl?$AA@
CONST	SEGMENT
??_C@_0BD@EKBB@models?1grenade?4mdl?$AA@ DB 'models/grenade.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KPF@sprites?1explode1?4spr?$AA@
CONST	SEGMENT
??_C@_0BF@KPF@sprites?1explode1?4spr?$AA@ DB 'sprites/explode1.spr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BHCE@weapons?1debris1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BHCE@weapons?1debris1?4wav?$AA@ DB 'weapons/debris1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PHEL@weapons?1debris2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@PHEL@weapons?1debris2?4wav?$AA@ DB 'weapons/debris2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FHGO@weapons?1debris3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@FHGO@weapons?1debris3?4wav?$AA@ DB 'weapons/debris3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OKPC@weapons?1grenade_hit1?4wav?$AA@
CONST	SEGMENT
??_C@_0BJ@OKPC@weapons?1grenade_hit1?4wav?$AA@ DB 'weapons/grenade_hit1.w'
	DB	'av', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KJN@weapons?1grenade_hit2?4wav?$AA@
CONST	SEGMENT
??_C@_0BJ@KJN@weapons?1grenade_hit2?4wav?$AA@ DB 'weapons/grenade_hit2.wa'
	DB	'v', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KKLI@weapons?1grenade_hit3?4wav?$AA@
CONST	SEGMENT
??_C@_0BJ@KKLI@weapons?1grenade_hit3?4wav?$AA@ DB 'weapons/grenade_hit3.w'
	DB	'av', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@
CONST	SEGMENT
??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@ DB 'weapons/bullet_hit1.wav'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@
CONST	SEGMENT
??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@ DB 'weapons/bullet_hit2.wav'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MANB@items?1weapondrop1?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@MANB@items?1weapondrop1?4wav?$AA@ DB 'items/weapondrop1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?W_Precache@@YAXXZ
_TEXT	SEGMENT
?W_Precache@@YAXXZ PROC NEAR				; W_Precache, COMDAT

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 313  : 	memset( CBasePlayerItem::ItemInfoArray, 0, sizeof(CBasePlayerItem::ItemInfoArray) );

	push	2816					; 00000b00H
	push	0
	push	OFFSET FLAT:?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A ; CBasePlayerItem::ItemInfoArray
	call	_memset
	add	esp, 12					; 0000000cH

; 314  : 	memset( CBasePlayerItem::AmmoInfoArray, 0, sizeof(CBasePlayerItem::AmmoInfoArray) );

	push	256					; 00000100H
	push	0
	push	OFFSET FLAT:?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A ; CBasePlayerItem::AmmoInfoArray
	call	_memset
	add	esp, 12					; 0000000cH

; 315  : 	giAmmoIndex = 0;

	mov	DWORD PTR ?giAmmoIndex@@3HA, 0		; giAmmoIndex

; 316  : 
; 317  : 	// custom items...
; 318  : 
; 319  : 	// common world objects
; 320  : 	UTIL_PrecacheOther( "item_suit" );

	push	OFFSET FLAT:??_C@_09IMIN@item_suit?$AA@	; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 321  : 	UTIL_PrecacheOther( "item_battery" );

	push	OFFSET FLAT:??_C@_0N@CIMM@item_battery?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 322  : 	UTIL_PrecacheOther( "item_antidote" );

	push	OFFSET FLAT:??_C@_0O@HJKP@item_antidote?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 323  : 	UTIL_PrecacheOther( "item_security" );

	push	OFFSET FLAT:??_C@_0O@GMKO@item_security?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 324  : 	UTIL_PrecacheOther( "item_longjump" );

	push	OFFSET FLAT:??_C@_0O@ODAO@item_longjump?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 325  : 
; 326  : 	// shotgun
; 327  : 	UTIL_PrecacheOtherWeapon( "weapon_shotgun" );

	push	OFFSET FLAT:??_C@_0P@PHLB@weapon_shotgun?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 328  : 	UTIL_PrecacheOther( "ammo_buckshot" );

	push	OFFSET FLAT:??_C@_0O@FHCF@ammo_buckshot?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 329  : 
; 330  : 	// crowbar
; 331  : 	UTIL_PrecacheOtherWeapon( "weapon_crowbar" );

	push	OFFSET FLAT:??_C@_0P@NAIF@weapon_crowbar?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 332  : 
; 333  : 	// axe
; 334  : 	UTIL_PrecacheOtherWeapon( "weapon_axe" );

	push	OFFSET FLAT:??_C@_0L@NFGM@weapon_axe?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 335  : 
; 336  : 	//chainsaw
; 337  : 	//UTIL_PrecacheOtherWeapon( "weapon_chainsaw" );
; 338  : 
; 339  : 	// glock
; 340  : 	UTIL_PrecacheOtherWeapon( "weapon_9mmhandgun" );

	push	OFFSET FLAT:??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 341  : 	UTIL_PrecacheOther( "ammo_9mmclip" );

	push	OFFSET FLAT:??_C@_0N@MPPM@ammo_9mmclip?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 342  : 
; 343  : 	// mp5
; 344  : 	UTIL_PrecacheOtherWeapon( "weapon_9mmAR" );

	push	OFFSET FLAT:??_C@_0N@JNOE@weapon_9mmAR?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 345  : 	UTIL_PrecacheOther( "ammo_9mmAR" );

	push	OFFSET FLAT:??_C@_0L@HEPA@ammo_9mmAR?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 346  : 	UTIL_PrecacheOther( "ammo_ARgrenades" );

	push	OFFSET FLAT:??_C@_0BA@OEBJ@ammo_ARgrenades?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 347  : 
; 348  : 	// python
; 349  : 	UTIL_PrecacheOtherWeapon( "weapon_357" );

	push	OFFSET FLAT:??_C@_0L@NPOO@weapon_357?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 350  : 	UTIL_PrecacheOther( "ammo_357" );

	push	OFFSET FLAT:??_C@_08BGGJ@ammo_357?$AA@	; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 351  : 
; 352  : 	// gauss
; 353  : 	UTIL_PrecacheOtherWeapon( "weapon_gauss" );

	push	OFFSET FLAT:??_C@_0N@DDMO@weapon_gauss?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 354  : 	UTIL_PrecacheOther( "ammo_gaussclip" );

	push	OFFSET FLAT:??_C@_0P@MILI@ammo_gaussclip?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 355  : 
; 356  : 	// rpg
; 357  : 	UTIL_PrecacheOtherWeapon( "weapon_rpg" );

	push	OFFSET FLAT:??_C@_0L@OCEH@weapon_rpg?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 358  : 	UTIL_PrecacheOther( "ammo_rpgclip" );

	push	OFFSET FLAT:??_C@_0N@BIME@ammo_rpgclip?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 359  : 
; 360  : 	// crossbow
; 361  : 	UTIL_PrecacheOtherWeapon( "weapon_crossbow" );

	push	OFFSET FLAT:??_C@_0BA@HAEF@weapon_crossbow?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 362  : 	UTIL_PrecacheOther( "ammo_crossbow" );

	push	OFFSET FLAT:??_C@_0O@OFDM@ammo_crossbow?$AA@ ; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4

; 363  : 
; 364  : 	// egon
; 365  : 	UTIL_PrecacheOtherWeapon( "weapon_egon" );

	push	OFFSET FLAT:??_C@_0M@IOMI@weapon_egon?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 366  : 
; 367  : 	// tripmine
; 368  : 	UTIL_PrecacheOtherWeapon( "weapon_tripmine" );

	push	OFFSET FLAT:??_C@_0BA@LLON@weapon_tripmine?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 369  : 
; 370  : 	// satchel charge
; 371  : 	UTIL_PrecacheOtherWeapon( "weapon_satchel" );

	push	OFFSET FLAT:??_C@_0P@JCMM@weapon_satchel?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 372  : 
; 373  : 	// hand grenade
; 374  : 	UTIL_PrecacheOtherWeapon("weapon_handgrenade");

	push	OFFSET FLAT:??_C@_0BD@HGIA@weapon_handgrenade?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 375  : 
; 376  : 	// squeak grenade
; 377  : 	UTIL_PrecacheOtherWeapon( "weapon_snark" );

	push	OFFSET FLAT:??_C@_0N@ODHC@weapon_snark?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 378  : 
; 379  : 	// hornetgun
; 380  : 	UTIL_PrecacheOtherWeapon( "weapon_hornetgun" );

	push	OFFSET FLAT:??_C@_0BB@CILK@weapon_hornetgun?$AA@ ; `string'
	call	?UTIL_PrecacheOtherWeapon@@YAXPBD@Z	; UTIL_PrecacheOtherWeapon
	add	esp, 4

; 381  : 
; 382  : 	if ( g_pGameRules->IsDeathmatch() )

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+28]
	test	eax, eax
	je	SHORT $L39257

; 384  : 		UTIL_PrecacheOther( "weaponbox" );// container for dropped deathmatch weapons

	push	OFFSET FLAT:??_C@_09KMAI@weaponbox?$AA@	; `string'
	call	?UTIL_PrecacheOther@@YAXPBD@Z		; UTIL_PrecacheOther
	add	esp, 4
$L39257:

; 386  : 
; 387  : 	g_sModelIndexFireball = PRECACHE_MODEL ("sprites/zerogxplode.spr");// fireball

	push	OFFSET FLAT:??_C@_0BI@KGNL@sprites?1zerogxplode?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexFireball@@3FA, ax ; g_sModelIndexFireball

; 388  : 	g_sModelIndexWExplosion = PRECACHE_MODEL ("sprites/WXplo1.spr");// underwater fireball

	push	OFFSET FLAT:??_C@_0BD@MLBD@sprites?1WXplo1?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexWExplosion@@3FA, ax ; g_sModelIndexWExplosion

; 389  : 	g_sModelIndexSmoke = PRECACHE_MODEL ("sprites/steam1.spr");// smoke

	push	OFFSET FLAT:??_C@_0BD@HPGE@sprites?1steam1?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexSmoke@@3FA, ax	; g_sModelIndexSmoke

; 390  : 	g_sModelIndexBubbles = PRECACHE_MODEL ("sprites/bubble.spr");//bubbles

	push	OFFSET FLAT:??_C@_0BD@FLIJ@sprites?1bubble?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexBubbles@@3FA, ax	; g_sModelIndexBubbles

; 391  : 	g_sModelIndexBloodSpray = PRECACHE_MODEL ("sprites/bloodspray.spr"); // initial blood

	push	OFFSET FLAT:??_C@_0BH@PJF@sprites?1bloodspray?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexBloodSpray@@3FA, ax ; g_sModelIndexBloodSpray

; 392  : 	g_sModelIndexBloodDrop = PRECACHE_MODEL ("sprites/blood.spr"); // splattered blood

	push	OFFSET FLAT:??_C@_0BC@KCPC@sprites?1blood?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexBloodDrop@@3FA, ax ; g_sModelIndexBloodDrop

; 393  : 
; 394  : 	g_sModelIndexLaser = PRECACHE_MODEL( (char *)g_pModelNameLaser );

	mov	eax, DWORD PTR ?g_pModelNameLaser@@3PBDB ; g_pModelNameLaser
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexLaser@@3FA, ax	; g_sModelIndexLaser

; 395  : 	g_sModelIndexLaserDot = PRECACHE_MODEL("sprites/laserdot.spr");

	push	OFFSET FLAT:??_C@_0BF@FKKF@sprites?1laserdot?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4
	mov	WORD PTR ?g_sModelIndexLaserDot@@3FA, ax ; g_sModelIndexLaserDot

; 396  : 
; 397  : 
; 398  : 	// used by explosions
; 399  : 	PRECACHE_MODEL ("models/grenade.mdl");

	push	OFFSET FLAT:??_C@_0BD@EKBB@models?1grenade?4mdl?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 400  : 	PRECACHE_MODEL ("sprites/explode1.spr");

	push	OFFSET FLAT:??_C@_0BF@KPF@sprites?1explode1?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 401  : 
; 402  : 	PRECACHE_SOUND ("weapons/debris1.wav");// explosion aftermaths

	push	OFFSET FLAT:??_C@_0BE@BHCE@weapons?1debris1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 403  : 	PRECACHE_SOUND ("weapons/debris2.wav");// explosion aftermaths

	push	OFFSET FLAT:??_C@_0BE@PHEL@weapons?1debris2?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 404  : 	PRECACHE_SOUND ("weapons/debris3.wav");// explosion aftermaths

	push	OFFSET FLAT:??_C@_0BE@FHGO@weapons?1debris3?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 405  : 
; 406  : 	PRECACHE_SOUND ("weapons/grenade_hit1.wav");//grenade

	push	OFFSET FLAT:??_C@_0BJ@OKPC@weapons?1grenade_hit1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 407  : 	PRECACHE_SOUND ("weapons/grenade_hit2.wav");//grenade

	push	OFFSET FLAT:??_C@_0BJ@KJN@weapons?1grenade_hit2?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 408  : 	PRECACHE_SOUND ("weapons/grenade_hit3.wav");//grenade

	push	OFFSET FLAT:??_C@_0BJ@KKLI@weapons?1grenade_hit3?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 409  : 
; 410  : 	PRECACHE_SOUND ("weapons/bullet_hit1.wav");	// hit by bullet

	push	OFFSET FLAT:??_C@_0BI@JLBM@weapons?1bullet_hit1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 411  : 	PRECACHE_SOUND ("weapons/bullet_hit2.wav");	// hit by bullet

	push	OFFSET FLAT:??_C@_0BI@HLHD@weapons?1bullet_hit2?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 412  : 
; 413  : 	PRECACHE_SOUND ("items/weapondrop1.wav");// weapon falls to the ground

	push	OFFSET FLAT:??_C@_0BG@MANB@items?1weapondrop1?4wav?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+4
	add	esp, 4

; 414  : 
; 415  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?W_Precache@@YAXXZ ENDP					; W_Precache
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBasePlayerItem@@UAEPAUdatamap_s@@XZ ; CBasePlayerItem::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBasePlayerItem@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBasePlayerItem@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBasePlayerItem::GetDataDescMap, COMDAT

; 417  : BEGIN_DATADESC( CBasePlayerItem )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A ; CBasePlayerItem::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBasePlayerItem@@UAEPAUdatamap_s@@XZ ENDP ; CBasePlayerItem::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBaseAnimating@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CBasePlayerItem@@SAPAUdatamap_s@@XZ	; CBasePlayerItem::GetBaseMap
;	COMDAT ?GetBaseMap@CBasePlayerItem@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBasePlayerItem@@SAPAUdatamap_s@@XZ PROC NEAR ; CBasePlayerItem::GetBaseMap, COMDAT

; 417  : BEGIN_DATADESC( CBasePlayerItem )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseAnimating@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBasePlayerItem@@SAPAUdatamap_s@@XZ ENDP	; CBasePlayerItem::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT
_$E34	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E33
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E34	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z ; DataMapInit
;	COMDAT _$E33
_TEXT	SEGMENT
_$E33	PROC NEAR					; COMDAT

; 417  : BEGIN_DATADESC( CBasePlayerItem )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBasePlayerItem_DataDescInit@@3PAUdatamap_s@@A, eax ; CBasePlayerItem_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E33	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	??_C@_0M@DFGG@DestroyItem?$AA@			; `string'
PUBLIC	??_C@_0N@HNLH@DefaultTouch?$AA@			; `string'
PUBLIC	??_C@_09HMCL@FallThink?$AA@			; `string'
PUBLIC	??_C@_0M@BEMF@Materialize?$AA@			; `string'
PUBLIC	??_C@_0BF@JILK@AttemptToMaterialize?$AA@	; `string'
PUBLIC	?DestroyItem@CBasePlayerItem@@QAEXXZ		; CBasePlayerItem::DestroyItem
PUBLIC	?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerItem::DefaultTouch
PUBLIC	?FallThink@CBasePlayerItem@@QAEXXZ		; CBasePlayerItem::FallThink
PUBLIC	?Materialize@CBasePlayerItem@@QAEXXZ		; CBasePlayerItem::Materialize
PUBLIC	?AttemptToMaterialize@CBasePlayerItem@@QAEXXZ	; CBasePlayerItem::AttemptToMaterialize
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@DFGG@DestroyItem?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0M@DFGG@DestroyItem?$AA@ DB 'DestroyItem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HNLH@DefaultTouch?$AA@
CONST	SEGMENT
??_C@_0N@HNLH@DefaultTouch?$AA@ DB 'DefaultTouch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMCL@FallThink?$AA@
CONST	SEGMENT
??_C@_09HMCL@FallThink?$AA@ DB 'FallThink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BEMF@Materialize?$AA@
CONST	SEGMENT
??_C@_0M@BEMF@Materialize?$AA@ DB 'Materialize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JILK@AttemptToMaterialize?$AA@
CONST	SEGMENT
??_C@_0BF@JILK@AttemptToMaterialize?$AA@ DB 'AttemptToMaterialize', 00H ; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z PROC NEAR ; DataMapInit, COMDAT

; 417  : BEGIN_DATADESC( CBasePlayerItem )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39322
	mov	cl, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BA@PKCE@CBasePlayerItem?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E37
	call	_atexit
	add	esp, 4
$L39322:
	call	?GetBaseMap@CBasePlayerItem@@SAPAUdatamap_s@@XZ ; CBasePlayerItem::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A+12, eax

; 418  : 	DEFINE_FIELD( m_pPlayer, FIELD_CLASSPTR ),
; 419  : 	DEFINE_FIELD( m_pNext, FIELD_CLASSPTR ),
; 420  : 	DEFINE_FIELD( m_iId, FIELD_INTEGER ),
; 421  : 	DEFINE_FUNCTION( DestroyItem ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L39335
	mov	al, BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S36@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0M@DFGG@DestroyItem?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+100, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+104, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+108, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+110, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+112, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+116, OFFSET FLAT:?DestroyItem@CBasePlayerItem@@QAEXXZ ; CBasePlayerItem::DestroyItem

; 422  : 	DEFINE_FUNCTION( DefaultTouch ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+120, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0N@HNLH@DefaultTouch?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+124, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+128, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+132, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+134, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+136, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+140, OFFSET FLAT:?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerItem::DefaultTouch

; 423  : 	DEFINE_FUNCTION( FallThink ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+144, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09HMCL@FallThink?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+148, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+152, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+156, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+158, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+160, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+164, OFFSET FLAT:?FallThink@CBasePlayerItem@@QAEXXZ ; CBasePlayerItem::FallThink

; 424  : 	DEFINE_FUNCTION( Materialize ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+168, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0M@BEMF@Materialize?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+172, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+176, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+180, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+182, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+184, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+188, OFFSET FLAT:?Materialize@CBasePlayerItem@@QAEXXZ ; CBasePlayerItem::Materialize

; 425  : 	DEFINE_FUNCTION( AttemptToMaterialize ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+192, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0BF@JILK@AttemptToMaterialize?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+196, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+200, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+204, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+206, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+208, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+212, OFFSET FLAT:?AttemptToMaterialize@CBasePlayerItem@@QAEXXZ ; CBasePlayerItem::AttemptToMaterialize
$L39335:

; 426  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L39351
	mov	DWORD PTR ?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A+4, 8
	mov	DWORD PTR ?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39352
$L39351:
	mov	DWORD PTR ?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4PAUtypedescription_s@@A
$L39352:
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A ; CBasePlayerItem::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z ENDP ; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
$T40899 = -12
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T40899[ebp], eax
	mov	ecx, DWORD PTR $T40899[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E37
_TEXT	SEGMENT
_$E37	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerItem@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E37	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
_i$ = -20
$T40904 = -24
__$EHRec$ = -12
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T40904[ebp], edx
	mov	eax, DWORD PTR $T40904[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?GetDataDescMap@CBasePlayerWeapon@@UAEPAUdatamap_s@@XZ ; CBasePlayerWeapon::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBasePlayerWeapon@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBasePlayerWeapon@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBasePlayerWeapon::GetDataDescMap, COMDAT

; 428  : BEGIN_DATADESC( CBasePlayerWeapon )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A ; CBasePlayerWeapon::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBasePlayerWeapon@@UAEPAUdatamap_s@@XZ ENDP ; CBasePlayerWeapon::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBasePlayerItem@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CBasePlayerWeapon@@SAPAUdatamap_s@@XZ ; CBasePlayerWeapon::GetBaseMap
;	COMDAT ?GetBaseMap@CBasePlayerWeapon@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBasePlayerWeapon@@SAPAUdatamap_s@@XZ PROC NEAR ; CBasePlayerWeapon::GetBaseMap, COMDAT

; 428  : BEGIN_DATADESC( CBasePlayerWeapon )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBasePlayerItem@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBasePlayerWeapon@@SAPAUdatamap_s@@XZ ENDP	; CBasePlayerWeapon::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E38
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z ; DataMapInit
;	COMDAT _$E38
_TEXT	SEGMENT
_$E38	PROC NEAR					; COMDAT

; 428  : BEGIN_DATADESC( CBasePlayerWeapon )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBasePlayerWeapon_DataDescInit@@3PAUdatamap_s@@A, eax ; CBasePlayerWeapon_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E38	ENDP
_TEXT	ENDS
_BSS	SEGMENT
	ALIGN	4

_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z PROC NEAR ; DataMapInit, COMDAT

; 428  : BEGIN_DATADESC( CBasePlayerWeapon )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39393
	mov	cl, BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S41@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BC@BICG@CBasePlayerWeapon?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E42
	call	_atexit
	add	esp, 4
$L39393:
	call	?GetBaseMap@CBasePlayerWeapon@@SAPAUdatamap_s@@XZ ; CBasePlayerWeapon::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A+12, eax

; 429  : 	DEFINE_FIELD( m_flNextPrimaryAttack, FIELD_TIME ),
; 430  : 	DEFINE_FIELD( m_flNextSecondaryAttack, FIELD_TIME ),
; 431  : 	DEFINE_FIELD( m_flTimeWeaponIdle, FIELD_TIME ),
; 432  : 	DEFINE_FIELD( m_iPrimaryAmmoType, FIELD_INTEGER ),
; 433  : 	DEFINE_FIELD( m_iSecondaryAmmoType, FIELD_INTEGER ),
; 434  : 	DEFINE_FIELD( m_iClip, FIELD_INTEGER ),
; 435  : 	DEFINE_FIELD( m_iDefaultAmmo, FIELD_INTEGER ),
; 436  : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L39418
	mov	DWORD PTR ?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A+4, 7
	mov	DWORD PTR ?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39419
$L39418:
	mov	DWORD PTR ?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4PAUtypedescription_s@@A
$L39419:
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayerWeapon@@2Udatamap_s@@A ; CBasePlayerWeapon::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerWeapon@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	?SetObjectCollisionBox@CBasePlayerItem@@UAEXXZ	; CBasePlayerItem::SetObjectCollisionBox
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
;	COMDAT ?SetObjectCollisionBox@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
$T40930 = -16
$T40931 = -28
$T40932 = -40
$T40933 = -52
?SetObjectCollisionBox@CBasePlayerItem@@UAEXXZ PROC NEAR ; CBasePlayerItem::SetObjectCollisionBox, COMDAT

; 439  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 440  : 	pev->absmin = GetAbsOrigin() + Vector(-24, -24, 0);

	push	0
	push	-1044381696				; c1c00000H
	push	-1044381696				; c1c00000H
	lea	ecx, DWORD PTR $T40930[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T40931[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 441  : 	pev->absmax = GetAbsOrigin() + Vector(24, 24, 16);

	push	1098907648				; 41800000H
	push	1103101952				; 41c00000H
	push	1103101952				; 41c00000H
	lea	ecx, DWORD PTR $T40932[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T40933[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 208				; 000000d0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 442  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetObjectCollisionBox@CBasePlayerItem@@UAEXXZ ENDP	; CBasePlayerItem::SetObjectCollisionBox
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40938 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40938[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	?FallInit@CBasePlayerItem@@QAEXXZ		; CBasePlayerItem::FallInit
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
PUBLIC	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet
PUBLIC	__real@8@3ffbccccccccccccd000
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT __real@8@3ffbccccccccccccd000
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT ?FallInit@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?FallInit@CBasePlayerItem@@QAEXXZ PROC NEAR		; CBasePlayerItem::FallInit, COMDAT

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 	pev->movetype = MOVETYPE_TOSS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 6

; 451  : 	pev->solid = SOLID_BBOX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 2

; 452  : 
; 453  : 	UTIL_SetSize(pev, g_vecZero, g_vecZero );//pointsize until it lands on the ground.

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 454  : 
; 455  : 	SetTouch( DefaultTouch );

	push	OFFSET FLAT:??_C@_0N@HNLH@DefaultTouch?$AA@ ; `string'
	push	OFFSET FLAT:?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerItem::DefaultTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 456  : 	SetThink( FallThink );

	push	OFFSET FLAT:??_C@_09HMCL@FallThink?$AA@	; `string'
	push	OFFSET FLAT:?FallThink@CBasePlayerItem@@QAEXXZ ; CBasePlayerItem::FallThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 457  : 
; 458  : 	pev->nextthink = gpGlobals->time + 0.1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FallInit@CBasePlayerItem@@QAEXXZ ENDP			; CBasePlayerItem::FallInit
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z PROC NEAR ; CBaseEntity::TouchSet, COMDAT

; 567  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 568  : 		m_pfnTouch = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1748], ecx

; 569  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnTouch)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1748]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 570  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 571  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ENDP ; CBaseEntity::TouchSet
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
;	COMDAT ?FallThink@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pitch$39443 = -8
_angles$39445 = -20
?FallThink@CBasePlayerItem@@QAEXXZ PROC NEAR		; CBasePlayerItem::FallThink, COMDAT

; 469  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 	pev->nextthink = gpGlobals->time + 0.1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 471  : 
; 472  : 	if ( pev->flags & FL_ONGROUND )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	$L39441

; 474  : 		// clatter if we have an owner (i.e., dropped by someone)
; 475  : 		// don't clatter if the gun is waiting to respawn (if it's waiting, it is invisible!)
; 476  : 		if ( !FNullEnt( pev->owner ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+408]
	push	edx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39442

; 478  : 			int pitch = 95 + RANDOM_LONG(0,29);

	push	29					; 0000001dH
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	add	eax, 95					; 0000005fH
	mov	DWORD PTR _pitch$39443[ebp], eax

; 479  : 			EMIT_SOUND_DYN(ENT(pev), CHAN_VOICE, "items/weapondrop1.wav", 1, ATTN_NORM, 0, pitch);

	mov	eax, DWORD PTR _pitch$39443[ebp]
	push	eax
	push	0
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BG@MANB@items?1weapondrop1?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH
$L39442:

; 481  : 
; 482  : 		Vector angles = GetLocalAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _angles$39445[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 483  : 
; 484  : 		// lie flat
; 485  : 		angles.x = 0;

	mov	DWORD PTR _angles$39445[ebp], 0

; 486  : 		angles.z = 0;

	mov	DWORD PTR _angles$39445[ebp+8], 0

; 487  : 
; 488  : 		SetLocalAngles( angles );

	lea	eax, DWORD PTR _angles$39445[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 489  : 
; 490  : 		Materialize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Materialize@CBasePlayerItem@@QAEXXZ	; CBasePlayerItem::Materialize
$L39441:

; 492  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FallThink@CBasePlayerItem@@QAEXXZ ENDP			; CBasePlayerItem::FallThink
_TEXT	ENDS
PUBLIC	??_C@_0BI@FCIG@items?1suitchargeok1?4wav?$AA@	; `string'
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT ??_C@_0BI@FCIG@items?1suitchargeok1?4wav?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BI@FCIG@items?1suitchargeok1?4wav?$AA@ DB 'items/suitchargeok1.wav'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ?Materialize@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Materialize@CBasePlayerItem@@QAEXXZ PROC NEAR		; CBasePlayerItem::Materialize, COMDAT

; 498  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 499  : 	if ( pev->effects & EF_NODRAW )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	SHORT $L39450

; 501  : 		// changing from invisible state to visible.
; 502  : 		EMIT_SOUND_DYN( ENT(pev), CHAN_WEAPON, "items/suitchargeok1.wav", 1, ATTN_NORM, 0, 150 );

	push	150					; 00000096H
	push	0
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BI@FCIG@items?1suitchargeok1?4wav?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 503  : 		pev->effects &= ~EF_NODRAW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx

; 504  : 		pev->effects |= EF_MUZZLEFLASH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
$L39450:

; 506  : 
; 507  : 	pev->solid = SOLID_TRIGGER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 1

; 508  : 
; 509  : 	RelinkEntity( TRUE ); // link into world.

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 510  : 	SetTouch (DefaultTouch);

	push	OFFSET FLAT:??_C@_0N@HNLH@DefaultTouch?$AA@ ; `string'
	push	OFFSET FLAT:?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerItem::DefaultTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 511  : 	SetThink (NULL);

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 512  : 
; 513  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Materialize@CBasePlayerItem@@QAEXXZ ENDP		; CBasePlayerItem::Materialize
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?AttemptToMaterialize@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_time$ = -8
?AttemptToMaterialize@CBasePlayerItem@@QAEXXZ PROC NEAR	; CBasePlayerItem::AttemptToMaterialize, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	float time = g_pGameRules->FlWeaponTryRespawn( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+132]
	fstp	DWORD PTR _time$[ebp]

; 522  : 
; 523  : 	if ( time == 0 )

	fld	DWORD PTR _time$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39463

; 525  : 		Materialize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Materialize@CBasePlayerItem@@QAEXXZ	; CBasePlayerItem::Materialize

; 526  : 		return;

	jmp	SHORT $L39461
$L39463:

; 528  : 
; 529  : 	pev->nextthink = gpGlobals->time + time;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _time$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]
$L39461:

; 530  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AttemptToMaterialize@CBasePlayerItem@@QAEXXZ ENDP	; CBasePlayerItem::AttemptToMaterialize
_TEXT	ENDS
PUBLIC	?CheckRespawn@CBasePlayerItem@@QAEXXZ		; CBasePlayerItem::CheckRespawn
;	COMDAT ?CheckRespawn@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckRespawn@CBasePlayerItem@@QAEXXZ PROC NEAR		; CBasePlayerItem::CheckRespawn, COMDAT

; 537  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 539  : 	{

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+124]
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L39472
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L39473
	jmp	SHORT $L39469
$L39472:

; 540  : 	case GR_WEAPON_RESPAWN_YES:
; 541  : 		Respawn();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+292]
$L39473:
$L39469:

; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckRespawn@CBasePlayerItem@@QAEXXZ ENDP		; CBasePlayerItem::CheckRespawn
_TEXT	ENDS
PUBLIC	??_C@_0BO@LDNI@Respawn?5failed?5to?5create?5?$CFs?$CB?6?$AA@ ; `string'
PUBLIC	?Respawn@CBasePlayerItem@@UAEPAVCBaseEntity@@XZ	; CBasePlayerItem::Respawn
EXTRN	?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z:NEAR	; UTIL_DropToFloor
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z:NEAR ; CBaseEntity::Create
;	COMDAT ??_C@_0BO@LDNI@Respawn?5failed?5to?5create?5?$CFs?$CB?6?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BO@LDNI@Respawn?5failed?5to?5create?5?$CFs?$CB?6?$AA@ DB 'Respawn '
	DB	'failed to create %s!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?Respawn@CBasePlayerItem@@UAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
$T40965 = -20
_this$ = -4
_pNewWeapon$ = -8
?Respawn@CBasePlayerItem@@UAEPAVCBaseEntity@@XZ PROC NEAR ; CBasePlayerItem::Respawn, COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 	// make a copy of this weapon that is invisible and inaccessible to players (no touch function). The weapon spawn/respawn code
; 556  : 	// will decide when to make the weapon visible and touchable.
; 557  : 	CBaseEntity *pNewWeapon = CBaseEntity::Create( (char *)STRING( pev->classname ), g_pGameRules->VecWeaponRespawnSpot( this ), GetAbsAngles(), pev->owner );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+408]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40965[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+136]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pNewWeapon$[ebp], eax

; 558  : 
; 559  : 	if ( pNewWeapon )

	cmp	DWORD PTR _pNewWeapon$[ebp], 0
	je	SHORT $L39481

; 561  : 		pNewWeapon->pev->effects |= EF_NODRAW;// invisible for now

	mov	ecx, DWORD PTR _pNewWeapon$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _pNewWeapon$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax

; 562  : 		pNewWeapon->SetTouch( NULL );// no touch

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _pNewWeapon$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 563  : 		pNewWeapon->SetThink( AttemptToMaterialize );

	push	OFFSET FLAT:??_C@_0BF@JILK@AttemptToMaterialize?$AA@ ; `string'
	push	OFFSET FLAT:?AttemptToMaterialize@CBasePlayerItem@@QAEXXZ ; CBasePlayerItem::AttemptToMaterialize
	mov	ecx, DWORD PTR _pNewWeapon$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 564  : 
; 565  : 		UTIL_DropToFloor( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_DropToFloor@@YAHPAVCBaseEntity@@@Z ; UTIL_DropToFloor
	add	esp, 4

; 566  : 
; 567  : 		// not a typo! We want to know when the weapon the player just picked up should respawn! This new entity we created is the replacement,
; 568  : 		// but when it should respawn is based on conditions belonging to the weapon that was taken.
; 569  : 		pNewWeapon->pev->nextthink = g_pGameRules->FlWeaponRespawnTime( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+128]
	mov	ecx, DWORD PTR _pNewWeapon$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 571  : 	else

	jmp	SHORT $L39486
$L39481:

; 573  : 		ALERT ( at_console, "Respawn failed to create %s!\n", STRING( pev->classname ) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BO@LDNI@Respawn?5failed?5to?5create?5?$CFs?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L39486:

; 575  : 
; 576  : 	return pNewWeapon;

	mov	eax, DWORD PTR _pNewWeapon$[ebp]

; 577  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBasePlayerItem@@UAEPAVCBaseEntity@@XZ ENDP	; CBasePlayerItem::Respawn
_TEXT	ENDS
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	??_C@_0BF@FDHL@items?1gunpickup2?4wav?$AA@	; `string'
EXTRN	?gEvilImpulse101@@3HA:DWORD			; gEvilImpulse101
EXTRN	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z:NEAR ; CBaseDelay::SUB_UseTargets
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ??_C@_0BF@FDHL@items?1gunpickup2?4wav?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BF@FDHL@items?1gunpickup2?4wav?$AA@ DB 'items/gunpickup2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
_pPlayer$ = -8
?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CBasePlayerItem::DefaultTouch, COMDAT

; 580  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 581  : 	// if it's not a player, ignore
; 582  : 	if ( !pOther->IsPlayer() )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L39492

; 583  : 		return;

	jmp	$L39491
$L39492:

; 584  : 
; 585  : 	CBasePlayer *pPlayer = (CBasePlayer *)pOther;

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	DWORD PTR _pPlayer$[ebp], eax

; 586  : 
; 587  : 	// can I have this?
; 588  : 	if ( !g_pGameRules->CanHavePlayerItem( pPlayer, this ) )

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+116]
	test	eax, eax
	jne	SHORT $L39495

; 590  : 		if ( gEvilImpulse101 )

	cmp	DWORD PTR ?gEvilImpulse101@@3HA, 0	; gEvilImpulse101
	je	SHORT $L39496

; 592  : 			UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L39496:

; 594  : 		return;

	jmp	SHORT $L39491
$L39495:

; 596  : 
; 597  : 	if (pOther->AddPlayerItem( this ))

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOther$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [eax+148]
	test	eax, eax
	je	SHORT $L39497

; 599  : 		AttachToPlayer( pPlayer );

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+392]

; 600  : 		EMIT_SOUND(ENT(pPlayer->pev), CHAN_ITEM, "items/gunpickup2.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@FDHL@items?1gunpickup2?4wav?$AA@ ; `string'
	push	3
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L39497:

; 602  : 
; 603  : 	SUB_UseTargets( pOther, USE_TOGGLE, 0 ); // UNDONE: when should this happen?

	push	0
	push	0
	push	3
	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SUB_UseTargets@CBaseDelay@@QAEXPAVCBaseEntity@@W4USE_TYPE@@MH@Z ; CBaseDelay::SUB_UseTargets
$L39491:

; 604  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DefaultTouch@CBasePlayerItem@@QAEXPAVCBaseEntity@@@Z ENDP ; CBasePlayerItem::DefaultTouch
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
PUBLIC	?CanAttack@@YAHMMH@Z				; CanAttack
;	COMDAT ?CanAttack@@YAHMMH@Z
_TEXT	SEGMENT
_attack_time$ = 8
_curtime$ = 12
?CanAttack@@YAHMMH@Z PROC NEAR				; CanAttack, COMDAT

; 607  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 608  : 	return ( attack_time <= curtime ) ? TRUE : FALSE;

	fld	DWORD PTR _attack_time$[ebp]
	fcomp	DWORD PTR _curtime$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40972
	mov	DWORD PTR -4+[ebp], 1
	jmp	SHORT $L40973
$L40972:
	mov	DWORD PTR -4+[ebp], 0
$L40973:
	mov	eax, DWORD PTR -4+[ebp]

; 609  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CanAttack@@YAHMMH@Z ENDP				; CanAttack
_TEXT	ENDS
PUBLIC	__real@8@3ffd9999999999999800
PUBLIC	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ		; CBasePlayerItem::pszAmmo1
PUBLIC	?pszAmmo2@CBasePlayerItem@@QAEPBDXZ		; CBasePlayerItem::pszAmmo2
PUBLIC	?iMaxClip@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iMaxClip
PUBLIC	?iFlags@CBasePlayerItem@@QAEHXZ			; CBasePlayerItem::iFlags
PUBLIC	?ItemPostFrame@CBasePlayerWeapon@@UAEXXZ	; CBasePlayerWeapon::ItemPostFrame
;	COMDAT __real@8@3ffd9999999999999800
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
__real@8@3ffd9999999999999800 DQ 03fd3333333333333r ; 0.3
CONST	ENDS
;	COMDAT ?ItemPostFrame@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_j$39510 = -8
?ItemPostFrame@CBasePlayerWeapon@@UAEXXZ PROC NEAR	; CBasePlayerWeapon::ItemPostFrame, COMDAT

; 612  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 	if ((m_fInReload) && ( m_pPlayer->m_flNextAttack <= gpGlobals->time ))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1876], 0
	je	$L39509
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+2308]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L39509

; 615  : 		// complete the reload.
; 616  : 		int j = Q_min( iMaxClip() - m_iClip, m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxClip@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxClip
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+1864]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+1856]
	cmp	eax, DWORD PTR [ecx+edx*4+3508]
	jge	SHORT $L40976
	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxClip@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxClip
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+1864]
	mov	DWORD PTR -12+[ebp], eax
	jmp	SHORT $L40977
$L40976:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	mov	eax, DWORD PTR [eax+edx*4+3508]
	mov	DWORD PTR -12+[ebp], eax
$L40977:
	mov	ecx, DWORD PTR -12+[ebp]
	mov	DWORD PTR _j$39510[ebp], ecx

; 617  : 
; 618  : 		// Add them to the clip
; 619  : 		m_iClip += j;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1864]
	add	eax, DWORD PTR _j$39510[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1864], eax

; 620  : 		m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] -= j;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	mov	eax, DWORD PTR [eax+edx*4+3508]
	sub	eax, DWORD PTR _j$39510[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1816]
	mov	DWORD PTR [ecx+edx*4+3508], eax

; 621  : 
; 622  : 		m_fInReload = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1876], 0
$L39509:

; 624  : 
; 625  : 	if ((m_pPlayer->pev->button & IN_ATTACK2) && CanAttack( m_flNextSecondaryAttack, gpGlobals->time, UseDecrement() ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 2048				; 00000800H
	test	eax, eax
	je	$L39511
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]
	push	eax
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1848]
	push	eax
	call	?CanAttack@@YAHMMH@Z			; CanAttack
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L39511

; 627  : 		if ( pszAmmo2() && !m_pPlayer->m_rgAmmo[SecondaryAmmoIndex()] )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo2@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo2
	test	eax, eax
	je	SHORT $L39512
	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+400]
	cmp	DWORD PTR [esi+eax*4+3508], 0
	jne	SHORT $L39512

; 629  : 			m_fFireOnEmpty = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1832], 1
$L39512:

; 631  : 
; 632  : 		SecondaryAttack();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+448]

; 633  : 		m_pPlayer->pev->button &= ~IN_ATTACK2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ch, -9					; fffffff7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+384], ecx

; 635  : 	else if ((m_pPlayer->pev->button & IN_ATTACK) && CanAttack( m_flNextPrimaryAttack, gpGlobals->time, UseDecrement() ) )

	jmp	$L39521
$L39511:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 1
	test	eax, eax
	je	$L39514
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]
	push	eax
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1844]
	push	eax
	call	?CanAttack@@YAHMMH@Z			; CanAttack
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L39514

; 637  : 		if ( (m_iClip == 0 && pszAmmo1()) || (iMaxClip() == -1 && !m_pPlayer->m_rgAmmo[PrimaryAmmoIndex()] ) )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1864], 0
	jne	SHORT $L39517
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	test	eax, eax
	jne	SHORT $L39516
$L39517:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxClip@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxClip
	cmp	eax, -1
	jne	SHORT $L39515
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+1816]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+396]
	cmp	DWORD PTR [esi+eax*4+3508], 0
	jne	SHORT $L39515
$L39516:

; 639  : 			m_fFireOnEmpty = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1832], 1
$L39515:

; 641  : 
; 642  : 		PrimaryAttack();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+444]

; 644  : 	else if ( m_pPlayer->pev->button & IN_RELOAD && iMaxClip() != WEAPON_NOCLIP && !m_fInReload )

	jmp	$L39521
$L39514:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 8192				; 00002000H
	test	eax, eax
	je	SHORT $L39519
	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxClip@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxClip
	cmp	eax, -1
	je	SHORT $L39519
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1876], 0
	jne	SHORT $L39519

; 646  : 		// reload when reload is pressed, or if no buttons are down and weapon is empty.
; 647  : 		Reload();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+452]

; 649  : 	else if ( !(m_pPlayer->pev->button & (IN_ATTACK|IN_ATTACK2) ) )

	jmp	$L39521
$L39519:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 2049				; 00000801H
	test	ecx, ecx
	jne	$L39521

; 651  : 		// no fire buttons down
; 652  : 
; 653  : 		m_fFireOnEmpty = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1832], 0

; 654  : 
; 655  : 		if ( !IsUseable() && m_flNextPrimaryAttack < ( UseDecrement() ? 0.0 : gpGlobals->time ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+440]
	test	eax, eax
	jne	$L39522
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]
	test	eax, eax
	je	SHORT $L40978
	mov	DWORD PTR -20+[ebp], 0
	mov	DWORD PTR -20+[ebp+4], 0
	jmp	SHORT $L40979
$L40978:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -20+[ebp]
$L40979:
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1844]
	fcomp	QWORD PTR -20+[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39522

; 657  : 			// weapon isn't useable, switch.
; 658  : 			if ( !(iFlags() & ITEM_FLAG_NOAUTOSWITCHEMPTY) && g_pGameRules->GetNextBestWeapon( m_pPlayer, this ) )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?iFlags@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iFlags
	and	eax, 4
	test	eax, eax
	jne	SHORT $L39523
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+20]
	test	eax, eax
	je	SHORT $L39523

; 660  : 				m_flNextPrimaryAttack = ( UseDecrement() ? 0.0 : gpGlobals->time ) + 0.3;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]
	test	eax, eax
	je	SHORT $L40980
	mov	DWORD PTR -28+[ebp], 0
	mov	DWORD PTR -28+[ebp+4], 0
	jmp	SHORT $L40981
$L40980:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -28+[ebp]
$L40981:
	fld	QWORD PTR -28+[ebp]
	fadd	QWORD PTR __real@8@3ffd9999999999999800
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+1844]

; 661  : 				return;

	jmp	$L39508
$L39523:

; 664  : 		else

	jmp	SHORT $L39525
$L39522:

; 666  : 			// weapon is useable. Reload if empty and weapon has waited as long as it has to after firing
; 667  : 			if ( m_iClip == 0 && !(iFlags() & ITEM_FLAG_NOAUTORELOAD) && m_flNextPrimaryAttack < ( UseDecrement() ? 0.0 : gpGlobals->time ) )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1864], 0
	jne	SHORT $L39525
	mov	ecx, DWORD PTR _this$[ebp]
	call	?iFlags@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iFlags
	and	eax, 2
	test	eax, eax
	jne	SHORT $L39525
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]
	test	eax, eax
	je	SHORT $L40982
	mov	DWORD PTR -36+[ebp], 0
	mov	DWORD PTR -36+[ebp+4], 0
	jmp	SHORT $L40983
$L40982:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fstp	QWORD PTR -36+[ebp]
$L40983:
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1844]
	fcomp	QWORD PTR -36+[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39525

; 669  : 				Reload();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+452]

; 670  : 				return;

	jmp	SHORT $L39508
$L39525:

; 673  : 
; 674  : 		WeaponIdle( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+456]

; 675  : 		return;

	jmp	SHORT $L39508
$L39521:

; 677  : 
; 678  : 	// catch all
; 679  : 	if ( ShouldWeaponIdle() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+464]
	test	eax, eax
	je	SHORT $L39526

; 681  : 		WeaponIdle();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+456]
$L39526:
$L39508:

; 683  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ItemPostFrame@CBasePlayerWeapon@@UAEXXZ ENDP		; CBasePlayerWeapon::ItemPostFrame
_TEXT	ENDS
;	COMDAT ?pszAmmo1@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?pszAmmo1@CBasePlayerItem@@QAEPBDXZ PROC NEAR		; CBasePlayerItem::pszAmmo1, COMDAT

; 276  : 	const char	*pszAmmo1( void )	{ return ItemInfoArray[ m_iId ].pszAmmo1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pszAmmo1@CBasePlayerItem@@QAEPBDXZ ENDP		; CBasePlayerItem::pszAmmo1
_TEXT	ENDS
;	COMDAT ?pszAmmo2@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?pszAmmo2@CBasePlayerItem@@QAEPBDXZ PROC NEAR		; CBasePlayerItem::pszAmmo2, COMDAT

; 278  : 	const char	*pszAmmo2( void )	{ return ItemInfoArray[ m_iId ].pszAmmo2; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+16]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pszAmmo2@CBasePlayerItem@@QAEPBDXZ ENDP		; CBasePlayerItem::pszAmmo2
_TEXT	ENDS
;	COMDAT ?iMaxClip@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?iMaxClip@CBasePlayerItem@@QAEHXZ PROC NEAR		; CBasePlayerItem::iMaxClip, COMDAT

; 281  : 	int		iMaxClip( void )	{ return ItemInfoArray[ m_iId ].iMaxClip; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?iMaxClip@CBasePlayerItem@@QAEHXZ ENDP			; CBasePlayerItem::iMaxClip
_TEXT	ENDS
;	COMDAT ?iFlags@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?iFlags@CBasePlayerItem@@QAEHXZ PROC NEAR		; CBasePlayerItem::iFlags, COMDAT

; 283  : 	int		iFlags( void )	{ return ItemInfoArray[ m_iId ].iFlags; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+36]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?iFlags@CBasePlayerItem@@QAEHXZ ENDP			; CBasePlayerItem::iFlags
_TEXT	ENDS
;	COMDAT ?DestroyItem@CBasePlayerItem@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DestroyItem@CBasePlayerItem@@QAEXXZ PROC NEAR		; CBasePlayerItem::DestroyItem, COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 687  : 	if ( m_pPlayer )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1816], 0
	je	SHORT $L39531

; 689  : 		// if attached to a player, remove.
; 690  : 		m_pPlayer->RemovePlayerItem( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1816]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1816]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+152]
$L39531:

; 692  : 
; 693  : 	Kill( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+388]

; 694  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyItem@CBasePlayerItem@@QAEXXZ ENDP		; CBasePlayerItem::DestroyItem
_TEXT	ENDS
PUBLIC	?AddToPlayer@CBasePlayerItem@@UAEHPAVCBasePlayer@@@Z ; CBasePlayerItem::AddToPlayer
;	COMDAT ?AddToPlayer@CBasePlayerItem@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
?AddToPlayer@CBasePlayerItem@@UAEHPAVCBasePlayer@@@Z PROC NEAR ; CBasePlayerItem::AddToPlayer, COMDAT

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 698  : 	m_pPlayer = pPlayer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+1816], ecx

; 699  : 
; 700  : 	return TRUE;

	mov	eax, 1

; 701  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToPlayer@CBasePlayerItem@@UAEHPAVCBasePlayer@@@Z ENDP ; CBasePlayerItem::AddToPlayer
_TEXT	ENDS
PUBLIC	??_C@_0L@KHDH@SUB_Remove?$AA@			; `string'
PUBLIC	?Drop@CBasePlayerItem@@UAEXXZ			; CBasePlayerItem::Drop
EXTRN	?SUB_Remove@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_Remove
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0L@KHDH@SUB_Remove?$AA@ DB 'SUB_Remove', 00H	; `string'
CONST	ENDS
;	COMDAT ?Drop@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Drop@CBasePlayerItem@@UAEXXZ PROC NEAR			; CBasePlayerItem::Drop, COMDAT

; 704  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 705  : 	SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 706  : 	SetThink(SUB_Remove);

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 707  : 	pev->nextthink = gpGlobals->time + .1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 708  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Drop@CBasePlayerItem@@UAEXXZ ENDP			; CBasePlayerItem::Drop
_TEXT	ENDS
PUBLIC	?Kill@CBasePlayerItem@@UAEXXZ			; CBasePlayerItem::Kill
;	COMDAT ?Kill@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Kill@CBasePlayerItem@@UAEXXZ PROC NEAR			; CBasePlayerItem::Kill, COMDAT

; 711  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 712  : 	SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 713  : 	SetThink(SUB_Remove);

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 714  : 	pev->nextthink = gpGlobals->time + .1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 715  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Kill@CBasePlayerItem@@UAEXXZ ENDP			; CBasePlayerItem::Kill
_TEXT	ENDS
PUBLIC	?Holster@CBasePlayerItem@@UAEXXZ		; CBasePlayerItem::Holster
;	COMDAT ?Holster@CBasePlayerItem@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Holster@CBasePlayerItem@@UAEXXZ PROC NEAR		; CBasePlayerItem::Holster, COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 719  : 	m_pPlayer->pev->viewmodel = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+188], 0

; 720  : 	m_pPlayer->pev->weaponmodel = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+192], 0

; 721  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Holster@CBasePlayerItem@@UAEXXZ ENDP			; CBasePlayerItem::Holster
_TEXT	ENDS
PUBLIC	?AttachToPlayer@CBasePlayerItem@@UAEXPAVCBasePlayer@@@Z ; CBasePlayerItem::AttachToPlayer
EXTRN	?SetParent@CBaseEntity@@QAEXHH@Z:NEAR		; CBaseEntity::SetParent
;	COMDAT ?AttachToPlayer@CBasePlayerItem@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
?AttachToPlayer@CBasePlayerItem@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBasePlayerItem::AttachToPlayer, COMDAT

; 724  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 	pev->movetype = MOVETYPE_FOLLOW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 12			; 0000000cH

; 726  : 	pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 727  : 	pev->aiment = pPlayer->edict();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+404], eax

; 728  : 	pev->effects = EF_NODRAW; // ??

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], 128		; 00000080H

; 729  : 	pev->modelindex = 0;// server won't send down to clients if modelindex == 0

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+180], 0

; 730  : 	pev->model = iStringNull;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+184], 0

; 731  : 	pev->owner = pPlayer->edict();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+408], eax

; 732  : 	pev->nextthink = gpGlobals->time + .1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 733  : 
; 734  : 	SetParent( NULL );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@CBaseEntity@@QAEXHH@Z	; CBaseEntity::SetParent

; 735  : 	SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 736  : 	SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 737  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AttachToPlayer@CBasePlayerItem@@UAEXPAVCBasePlayer@@@Z ENDP ; CBasePlayerItem::AttachToPlayer
_TEXT	ENDS
PUBLIC	?AddDuplicate@CBasePlayerWeapon@@UAEHPAVCBasePlayerItem@@@Z ; CBasePlayerWeapon::AddDuplicate
;	COMDAT ?AddDuplicate@CBasePlayerWeapon@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pOriginal$ = 8
_this$ = -4
?AddDuplicate@CBasePlayerWeapon@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBasePlayerWeapon::AddDuplicate, COMDAT

; 741  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 742  : 	if ( m_iDefaultAmmo )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1880], 0
	je	SHORT $L39568

; 744  : 		return ExtractAmmo( (CBasePlayerWeapon *)pOriginal );

	mov	ecx, DWORD PTR _pOriginal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+416]
	jmp	SHORT $L39570
$L39568:

; 748  : 		// a dead player dropped this.
; 749  : 		return ExtractClipAmmo( (CBasePlayerWeapon *)pOriginal );

	mov	ecx, DWORD PTR _pOriginal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+420]
$L39570:

; 751  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddDuplicate@CBasePlayerWeapon@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBasePlayerWeapon::AddDuplicate
_TEXT	ENDS
PUBLIC	?AddWeapon@CBaseMonster@@QAEXH@Z		; CBaseMonster::AddWeapon
PUBLIC	?AddToPlayer@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z ; CBasePlayerWeapon::AddToPlayer
EXTRN	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z:NEAR	; CBasePlayer::GetAmmoIndex
;	COMDAT ?AddToPlayer@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
_bResult$ = -8
?AddToPlayer@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z PROC NEAR ; CBasePlayerWeapon::AddToPlayer, COMDAT

; 755  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 756  : 	int bResult = CBasePlayerItem::AddToPlayer( pPlayer );

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddToPlayer@CBasePlayerItem@@UAEHPAVCBasePlayer@@@Z ; CBasePlayerItem::AddToPlayer
	mov	DWORD PTR _bResult$[ebp], eax

; 757  : 
; 758  : 	pPlayer->AddWeapon( m_iId );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1824]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 759  : 
; 760  : 	if ( !m_iPrimaryAmmoType )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1856], 0
	jne	SHORT $L39577

; 762  : 		m_iPrimaryAmmoType = pPlayer->GetAmmoIndex( pszAmmo1() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	push	eax
	call	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z	; CBasePlayer::GetAmmoIndex
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax

; 763  : 		m_iSecondaryAmmoType = pPlayer->GetAmmoIndex( pszAmmo2() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo2@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo2
	push	eax
	call	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z	; CBasePlayer::GetAmmoIndex
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1860], eax
$L39577:

; 765  : 
; 766  : 
; 767  : 	if (bResult)

	cmp	DWORD PTR _bResult$[ebp], 0
	je	SHORT $L39578

; 768  : 		return AddWeapon( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+424]
	jmp	SHORT $L39575
$L39578:

; 769  : 	return FALSE;

	xor	eax, eax
$L39575:

; 770  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToPlayer@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z ENDP ; CBasePlayerWeapon::AddToPlayer
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?AddWeapon@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::AddWeapon, COMDAT

; 143  : 	void		AddWeapon( int weaponnum ) { SetBits( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	or	edx, eax
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	sar	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+2348], dl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddWeapon@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::AddWeapon
_TEXT	ENDS
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z	; MESSAGE_BEGIN
PUBLIC	?UpdateClientData@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z ; CBasePlayerWeapon::UpdateClientData
EXTRN	?gmsgCurWeapon@@3HA:DWORD			; gmsgCurWeapon
;	COMDAT ?UpdateClientData@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
_bSend$ = -8
_state$ = -12
?UpdateClientData@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z PROC NEAR ; CBasePlayerWeapon::UpdateClientData, COMDAT

; 773  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 774  : 	BOOL bSend = FALSE;

	mov	DWORD PTR _bSend$[ebp], 0

; 775  : 	int state = 0;

	mov	DWORD PTR _state$[ebp], 0

; 776  : 	if ( pPlayer->m_pActiveItem == this )

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $L39587

; 778  : 		if ( pPlayer->m_fOnTarget )

	mov	edx, DWORD PTR _pPlayer$[ebp]
	cmp	DWORD PTR [edx+3776], 0
	je	SHORT $L39586

; 779  : 			state = WEAPON_IS_ONTARGET;

	mov	DWORD PTR _state$[ebp], 64		; 00000040H

; 780  : 		else

	jmp	SHORT $L39587
$L39586:

; 781  : 			state = 1;

	mov	DWORD PTR _state$[ebp], 1
$L39587:

; 783  : 
; 784  : 	// Forcing send of all data!
; 785  : 	if ( !pPlayer->m_fWeapon )

	mov	eax, DWORD PTR _pPlayer$[ebp]
	cmp	DWORD PTR [eax+2860], 0
	jne	SHORT $L39588

; 787  : 		bSend = TRUE;

	mov	DWORD PTR _bSend$[ebp], 1
$L39588:

; 792  : 		 this == pPlayer->m_pClientActiveItem )

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [ecx+2980]
	je	SHORT $L39590
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [eax+2984]
	jne	SHORT $L39591
$L39590:

; 794  : 		if ( pPlayer->m_pActiveItem != pPlayer->m_pClientActiveItem )

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	cmp	ecx, DWORD PTR [eax+2984]
	je	SHORT $L39591

; 796  : 			bSend = TRUE;

	mov	DWORD PTR _bSend$[ebp], 1
$L39591:

; 802  : 		 state != m_iClientWeaponState ||
; 803  : 		 pPlayer->m_iFOV != pPlayer->m_iClientFOV )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1864]
	cmp	ecx, DWORD PTR [eax+1868]
	jne	SHORT $L39593
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _state$[ebp]
	cmp	eax, DWORD PTR [edx+1872]
	jne	SHORT $L39593
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [ecx+2936]
	cmp	eax, DWORD PTR [edx+2940]
	je	SHORT $L39592
$L39593:

; 805  : 		bSend = TRUE;

	mov	DWORD PTR _bSend$[ebp], 1
$L39592:

; 807  : 
; 808  : 	if ( bSend )

	cmp	DWORD PTR _bSend$[ebp], 0
	je	SHORT $L39594

; 810  : 		MESSAGE_BEGIN( MSG_ONE, gmsgCurWeapon, NULL, pPlayer->pev );

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgCurWeapon@@3HA	; gmsgCurWeapon
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 811  : 			WRITE_BYTE( state );

	mov	ecx, DWORD PTR _state$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 812  : 			WRITE_BYTE( m_iId );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1824]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 813  : 			WRITE_BYTE( m_iClip );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1864]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 814  : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 815  : 
; 816  : 		m_iClientClip = m_iClip;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1864]
	mov	DWORD PTR [eax+1868], edx

; 817  : 		m_iClientWeaponState = state;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [eax+1872], ecx

; 818  : 		pPlayer->m_fWeapon = TRUE;

	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [edx+2860], 1
$L39594:

; 820  : 
; 821  : 	if ( m_pNext )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 0
	je	SHORT $L39595

; 822  : 		m_pNext->UpdateClientData( pPlayer );

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1820]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1820]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+404]
$L39595:

; 823  : 
; 824  : 	return 1;

	mov	eax, 1

; 825  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateClientData@CBasePlayerWeapon@@UAEHPAVCBasePlayer@@@Z ENDP ; CBasePlayerWeapon::UpdateClientData
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ent$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 188  : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin, entvars_t *ent ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 189  : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ENT(ent));

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	?SendWeaponAnim@CBasePlayerWeapon@@UAEXHHH@Z	; CBasePlayerWeapon::SendWeaponAnim
;	COMDAT ?SendWeaponAnim@CBasePlayerWeapon@@UAEXHHH@Z
_TEXT	SEGMENT
_iAnim$ = 8
_skiplocal$ = 12
_this$ = -4
?SendWeaponAnim@CBasePlayerWeapon@@UAEXHHH@Z PROC NEAR	; CBasePlayerWeapon::SendWeaponAnim, COMDAT

; 829  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 830  : 	if ( UseDecrement() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]
	test	eax, eax
	je	SHORT $L39602

; 831  : 		skiplocal = 1;

	mov	DWORD PTR _skiplocal$[ebp], 1

; 832  : 	else

	jmp	SHORT $L39603
$L39602:

; 833  : 		skiplocal = 0;

	mov	DWORD PTR _skiplocal$[ebp], 0
$L39603:

; 834  : 
; 835  : 	m_pPlayer->pev->weaponanim = iAnim;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _iAnim$[ebp]
	mov	DWORD PTR [edx+536], eax

; 836  : 
; 837  : 	MESSAGE_BEGIN( MSG_ONE, SVC_WEAPONANIM, NULL, m_pPlayer->pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	push	35					; 00000023H
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 838  : 		WRITE_BYTE( iAnim );						// sequence number

	mov	ecx, DWORD PTR _iAnim$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 839  : 		WRITE_BYTE( pev->body );					// weaponmodel bodygroup.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+276]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 840  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 841  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SendWeaponAnim@CBasePlayerWeapon@@UAEXHHH@Z ENDP	; CBasePlayerWeapon::SendWeaponAnim
_TEXT	ENDS
PUBLIC	??_C@_0BD@DCKL@items?19mmclip1?4wav?$AA@	; `string'
PUBLIC	?AddPrimaryAmmo@CBasePlayerWeapon@@QAEHHPADHH@Z	; CBasePlayerWeapon::AddPrimaryAmmo
EXTRN	?HasPlayerItem@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z:NEAR ; CBasePlayer::HasPlayerItem
;	COMDAT ??_C@_0BD@DCKL@items?19mmclip1?4wav?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BD@DCKL@items?19mmclip1?4wav?$AA@ DB 'items/9mmclip1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?AddPrimaryAmmo@CBasePlayerWeapon@@QAEHHPADHH@Z
_TEXT	SEGMENT
_iCount$ = 8
_szName$ = 12
_iMaxClip$ = 16
_iMaxCarry$ = 20
_this$ = -4
_iIdAmmo$ = -8
_i$39615 = -12
?AddPrimaryAmmo@CBasePlayerWeapon@@QAEHHPADHH@Z PROC NEAR ; CBasePlayerWeapon::AddPrimaryAmmo, COMDAT

; 844  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 845  : 	int iIdAmmo;
; 846  : 
; 847  : 	if (iMaxClip < 1)

	cmp	DWORD PTR _iMaxClip$[ebp], 1
	jge	SHORT $L39612

; 849  : 		m_iClip = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1864], -1

; 850  : 		iIdAmmo = m_pPlayer->GiveAmmo( iCount, szName, iMaxCarry );

	mov	ecx, DWORD PTR _iMaxCarry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szName$[ebp]
	push	edx
	mov	eax, DWORD PTR _iCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+156]
	mov	DWORD PTR _iIdAmmo$[ebp], eax

; 852  : 	else if (m_iClip == 0)

	jmp	$L39616
$L39612:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1864], 0
	jne	SHORT $L39614

; 854  : 		int i;
; 855  : 		i = Q_min( m_iClip + iCount, iMaxClip ) - m_iClip;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1864]
	add	edx, DWORD PTR _iCount$[ebp]
	cmp	edx, DWORD PTR _iMaxClip$[ebp]
	jge	SHORT $L41020
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1864]
	add	ecx, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR -16+[ebp], ecx
	jmp	SHORT $L41021
$L41020:
	mov	edx, DWORD PTR _iMaxClip$[ebp]
	mov	DWORD PTR -16+[ebp], edx
$L41021:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR -16+[ebp]
	sub	ecx, DWORD PTR [eax+1864]
	mov	DWORD PTR _i$39615[ebp], ecx

; 856  : 		m_iClip += i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1864]
	add	eax, DWORD PTR _i$39615[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1864], eax

; 857  : 		iIdAmmo = m_pPlayer->GiveAmmo( iCount - i, szName, iMaxCarry );

	mov	edx, DWORD PTR _iMaxCarry$[ebp]
	push	edx
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iCount$[ebp]
	sub	ecx, DWORD PTR _i$39615[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1816]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+1816]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+156]
	mov	DWORD PTR _iIdAmmo$[ebp], eax

; 859  : 	else

	jmp	SHORT $L39616
$L39614:

; 861  : 		iIdAmmo = m_pPlayer->GiveAmmo( iCount, szName, iMaxCarry );

	mov	ecx, DWORD PTR _iMaxCarry$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szName$[ebp]
	push	edx
	mov	eax, DWORD PTR _iCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+156]
	mov	DWORD PTR _iIdAmmo$[ebp], eax
$L39616:

; 863  : 
; 864  : 	// m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] = iMaxCarry; // hack for testing
; 865  : 
; 866  : 	if (iIdAmmo > 0)

	cmp	DWORD PTR _iIdAmmo$[ebp], 0
	jle	SHORT $L39618

; 868  : 		m_iPrimaryAmmoType = iIdAmmo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iIdAmmo$[ebp]
	mov	DWORD PTR [eax+1856], ecx

; 869  : 		if (m_pPlayer->HasPlayerItem( this ) )

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	call	?HasPlayerItem@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::HasPlayerItem
	test	eax, eax
	je	SHORT $L39618

; 871  : 			// play the "got ammo" sound only if we gave some ammo to a player that already had this gun.
; 872  : 			// if the player is just getting this gun for the first time, DefaultTouch will play the "picked up gun" sound for us.
; 873  : 			EMIT_SOUND(ENT(pev), CHAN_ITEM, "items/9mmclip1.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BD@DCKL@items?19mmclip1?4wav?$AA@ ; `string'
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L39618:

; 876  : 
; 877  : 	return iIdAmmo > 0 ? TRUE : FALSE;

	xor	eax, eax
	cmp	DWORD PTR _iIdAmmo$[ebp], 0
	setg	al

; 878  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AddPrimaryAmmo@CBasePlayerWeapon@@QAEHHPADHH@Z ENDP	; CBasePlayerWeapon::AddPrimaryAmmo
_TEXT	ENDS
PUBLIC	?AddSecondaryAmmo@CBasePlayerWeapon@@QAEHHPADH@Z ; CBasePlayerWeapon::AddSecondaryAmmo
;	COMDAT ?AddSecondaryAmmo@CBasePlayerWeapon@@QAEHHPADH@Z
_TEXT	SEGMENT
_iCount$ = 8
_szName$ = 12
_iMax$ = 16
_this$ = -4
_iIdAmmo$ = -8
?AddSecondaryAmmo@CBasePlayerWeapon@@QAEHHPADH@Z PROC NEAR ; CBasePlayerWeapon::AddSecondaryAmmo, COMDAT

; 882  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 883  : 	int iIdAmmo;
; 884  : 
; 885  : 	iIdAmmo = m_pPlayer->GiveAmmo( iCount, szName, iMax );

	mov	eax, DWORD PTR _iMax$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+156]
	mov	DWORD PTR _iIdAmmo$[ebp], eax

; 886  : 
; 887  : 	//m_pPlayer->m_rgAmmo[m_iSecondaryAmmoType] = iMax; // hack for testing
; 888  : 
; 889  : 	if (iIdAmmo > 0)

	cmp	DWORD PTR _iIdAmmo$[ebp], 0
	jle	SHORT $L39628

; 891  : 		m_iSecondaryAmmoType = iIdAmmo;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iIdAmmo$[ebp]
	mov	DWORD PTR [eax+1860], ecx

; 892  : 		EMIT_SOUND(ENT(pev), CHAN_ITEM, "items/9mmclip1.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BD@DCKL@items?19mmclip1?4wav?$AA@ ; `string'
	push	3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L39628:

; 894  : 	return iIdAmmo > 0 ? TRUE : FALSE;

	xor	eax, eax
	cmp	DWORD PTR _iIdAmmo$[ebp], 0
	setg	al

; 895  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AddSecondaryAmmo@CBasePlayerWeapon@@QAEHHPADH@Z ENDP	; CBasePlayerWeapon::AddSecondaryAmmo
_TEXT	ENDS
PUBLIC	?iMaxAmmo1@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iMaxAmmo1
PUBLIC	?IsUseable@CBasePlayerWeapon@@UAEHXZ		; CBasePlayerWeapon::IsUseable
;	COMDAT ?IsUseable@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsUseable@CBasePlayerWeapon@@UAEHXZ PROC NEAR		; CBasePlayerWeapon::IsUseable, COMDAT

; 904  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 905  : 	if ( m_iClip <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1864], 0
	jg	SHORT $L39635

; 907  : 		if ( m_pPlayer->m_rgAmmo[ PrimaryAmmoIndex() ] <= 0 && iMaxAmmo1() != -1 )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+396]
	cmp	DWORD PTR [esi+eax*4+3508], 0
	jg	SHORT $L39635
	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxAmmo1@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxAmmo1
	cmp	eax, -1
	je	SHORT $L39635

; 909  : 			// clip is empty (or nonexistant) and the player has no more ammo of this type.
; 910  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L39633
$L39635:

; 913  : 
; 914  : 	return TRUE;

	mov	eax, 1
$L39633:

; 915  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsUseable@CBasePlayerWeapon@@UAEHXZ ENDP		; CBasePlayerWeapon::IsUseable
_TEXT	ENDS
;	COMDAT ?iMaxAmmo1@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?iMaxAmmo1@CBasePlayerItem@@QAEHXZ PROC NEAR		; CBasePlayerItem::iMaxAmmo1, COMDAT

; 277  : 	int		iMaxAmmo1( void )	{ return ItemInfoArray[ m_iId ].iMaxAmmo1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+12]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?iMaxAmmo1@CBasePlayerItem@@QAEHXZ ENDP			; CBasePlayerItem::iMaxAmmo1
_TEXT	ENDS
PUBLIC	?CanDeploy@CBasePlayerWeapon@@UAEHXZ		; CBasePlayerWeapon::CanDeploy
;	COMDAT ?CanDeploy@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
_bHasAmmo$ = -8
?CanDeploy@CBasePlayerWeapon@@UAEHXZ PROC NEAR		; CBasePlayerWeapon::CanDeploy, COMDAT

; 918  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 919  : 	BOOL bHasAmmo = 0;

	mov	DWORD PTR _bHasAmmo$[ebp], 0

; 920  : 
; 921  : 	if ( !pszAmmo1() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	test	eax, eax
	jne	SHORT $L39641

; 923  : 		// this weapon doesn't use ammo, can always deploy.
; 924  : 		return TRUE;

	mov	eax, 1
	jmp	$L39639
$L39641:

; 926  : 
; 927  : 	if ( pszAmmo1() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	test	eax, eax
	je	SHORT $L39642

; 929  : 		bHasAmmo |= (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] != 0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	xor	edx, edx
	cmp	DWORD PTR [ecx+eax*4+3508], 0
	setne	dl
	mov	eax, DWORD PTR _bHasAmmo$[ebp]
	or	eax, edx
	mov	DWORD PTR _bHasAmmo$[ebp], eax
$L39642:

; 931  : 	if ( pszAmmo2() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo2@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo2
	test	eax, eax
	je	SHORT $L39643

; 933  : 		bHasAmmo |= (m_pPlayer->m_rgAmmo[m_iSecondaryAmmoType] != 0);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1860]
	xor	eax, eax
	cmp	DWORD PTR [edx+ecx*4+3508], 0
	setne	al
	mov	ecx, DWORD PTR _bHasAmmo$[ebp]
	or	ecx, eax
	mov	DWORD PTR _bHasAmmo$[ebp], ecx
$L39643:

; 935  : 	if (m_iClip > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1864], 0
	jle	SHORT $L39644

; 937  : 		bHasAmmo |= 1;

	mov	eax, DWORD PTR _bHasAmmo$[ebp]
	or	al, 1
	mov	DWORD PTR _bHasAmmo$[ebp], eax
$L39644:

; 939  : 	if (!bHasAmmo)

	cmp	DWORD PTR _bHasAmmo$[ebp], 0
	jne	SHORT $L39645

; 941  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39639
$L39645:

; 943  : 
; 944  : 	return TRUE;

	mov	eax, 1
$L39639:

; 945  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CanDeploy@CBasePlayerWeapon@@UAEHXZ ENDP		; CBasePlayerWeapon::CanDeploy
_TEXT	ENDS
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	?DefaultDeploy@CBasePlayerWeapon@@QAEHPAD0H0HH@Z ; CBasePlayerWeapon::DefaultDeploy
EXTRN	_strcpy:NEAR
;	COMDAT __real@8@3ffe8000000000000000
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?DefaultDeploy@CBasePlayerWeapon@@QAEHPAD0H0HH@Z
_TEXT	SEGMENT
_szViewModel$ = 8
_szWeaponModel$ = 12
_iAnim$ = 16
_szAnimExt$ = 20
_skiplocal$ = 24
_body$ = 28
_this$ = -4
?DefaultDeploy@CBasePlayerWeapon@@QAEHPAD0H0HH@Z PROC NEAR ; CBasePlayerWeapon::DefaultDeploy, COMDAT

; 948  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 949  : 	if (!CanDeploy( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+356]
	test	eax, eax
	jne	SHORT $L39655

; 950  : 		return FALSE;

	xor	eax, eax
	jmp	$L39654
$L39655:

; 951  : 
; 952  : 	m_pPlayer->pev->viewmodel = MAKE_STRING(szViewModel);

	mov	eax, DWORD PTR _szViewModel$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+188], eax

; 953  : 	m_pPlayer->pev->weaponmodel = MAKE_STRING(szWeaponModel);

	mov	edx, DWORD PTR _szWeaponModel$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+192], eax

; 954  : 	strcpy( m_pPlayer->m_szAnimExtention, szAnimExt );

	mov	edx, DWORD PTR _szAnimExt$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	add	ecx, 3820				; 00000eecH
	push	ecx
	call	_strcpy
	add	esp, 8

; 955  : 	SendWeaponAnim( iAnim, skiplocal, body );

	mov	edx, DWORD PTR _body$[ebp]
	push	edx
	mov	eax, DWORD PTR _skiplocal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iAnim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+436]

; 956  : 
; 957  : 	m_pPlayer->m_flNextAttack = gpGlobals->time + 0.5;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffe8000000000000000
	fst	DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	fstp	DWORD PTR [eax+2308]

; 958  : 	m_flTimeWeaponIdle = gpGlobals->time + 1.0;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1852]

; 959  : 
; 960  : 	return TRUE;

	mov	eax, 1
$L39654:

; 961  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DefaultDeploy@CBasePlayerWeapon@@QAEHPAD0H0HH@Z ENDP	; CBasePlayerWeapon::DefaultDeploy
_TEXT	ENDS
PUBLIC	__real@4@4000c000000000000000
PUBLIC	?DefaultReload@CBasePlayerWeapon@@QAEHHHMH@Z	; CBasePlayerWeapon::DefaultReload
;	COMDAT __real@4@4000c000000000000000
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT ?DefaultReload@CBasePlayerWeapon@@QAEHHHMH@Z
_TEXT	SEGMENT
_iClipSize$ = 8
_iAnim$ = 12
_fDelay$ = 16
_this$ = -4
_j$ = -8
?DefaultReload@CBasePlayerWeapon@@QAEHHHMH@Z PROC NEAR	; CBasePlayerWeapon::DefaultReload, COMDAT

; 965  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 	if (m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType] <= 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	cmp	DWORD PTR [ecx+eax*4+3508], 0
	jg	SHORT $L39663

; 967  : 		return FALSE;

	xor	eax, eax
	jmp	$L39662
$L39663:

; 968  : 
; 969  : 	int j = Q_min(iClipSize - m_iClip, m_pPlayer->m_rgAmmo[m_iPrimaryAmmoType]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iClipSize$[ebp]
	sub	edx, DWORD PTR [ecx+1864]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1856]
	cmp	edx, DWORD PTR [ecx+eax*4+3508]
	jge	SHORT $L41038
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iClipSize$[ebp]
	sub	edx, DWORD PTR [ecx+1864]
	mov	DWORD PTR -12+[ebp], edx
	jmp	SHORT $L41039
$L41038:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	mov	ecx, DWORD PTR [ecx+eax*4+3508]
	mov	DWORD PTR -12+[ebp], ecx
$L41039:
	mov	edx, DWORD PTR -12+[ebp]
	mov	DWORD PTR _j$[ebp], edx

; 970  : 
; 971  : 	if (j == 0)

	cmp	DWORD PTR _j$[ebp], 0
	jne	SHORT $L39665

; 972  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39662
$L39665:

; 973  : 
; 974  : 	m_pPlayer->m_flNextAttack = gpGlobals->time + fDelay;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _fDelay$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	fstp	DWORD PTR [edx+2308]

; 975  : 
; 976  : 	//!!UNDONE -- reload sound goes here !!!
; 977  : 	SendWeaponAnim( iAnim, UseDecrement() ? 1 : 0 );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]
	neg	eax
	sbb	eax, eax
	neg	eax
	push	eax
	mov	eax, DWORD PTR _iAnim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+436]

; 978  : 
; 979  : 	m_fInReload = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1876], 1

; 980  : 
; 981  : 	m_flTimeWeaponIdle = gpGlobals->time + 3;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@4000c000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+1852]

; 982  : 	return TRUE;

	mov	eax, 1
$L39662:

; 983  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DefaultReload@CBasePlayerWeapon@@QAEHHHMH@Z ENDP	; CBasePlayerWeapon::DefaultReload
_TEXT	ENDS
PUBLIC	??_C@_0BG@NHFC@weapons?1357_cock1?4wav?$AA@	; `string'
PUBLIC	?PlayEmptySound@CBasePlayerWeapon@@UAEHXZ	; CBasePlayerWeapon::PlayEmptySound
;	COMDAT ??_C@_0BG@NHFC@weapons?1357_cock1?4wav?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BG@NHFC@weapons?1357_cock1?4wav?$AA@ DB 'weapons/357_cock1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?PlayEmptySound@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?PlayEmptySound@CBasePlayerWeapon@@UAEHXZ PROC NEAR	; CBasePlayerWeapon::PlayEmptySound, COMDAT

; 986  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 	if (m_iPlayEmptySound)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1828], 0
	je	SHORT $L39670

; 989  : 		EMIT_SOUND(ENT(m_pPlayer->pev), CHAN_WEAPON, "weapons/357_cock1.wav", 0.8, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BG@NHFC@weapons?1357_cock1?4wav?$AA@ ; `string'
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 990  : 		m_iPlayEmptySound = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1828], 0

; 991  : 		return 0;

	xor	eax, eax
	jmp	SHORT $L39669
$L39670:

; 993  : 	return 0;

	xor	eax, eax
$L39669:

; 994  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayEmptySound@CBasePlayerWeapon@@UAEHXZ ENDP		; CBasePlayerWeapon::PlayEmptySound
_TEXT	ENDS
PUBLIC	?ResetEmptySound@CBasePlayerWeapon@@UAEXXZ	; CBasePlayerWeapon::ResetEmptySound
;	COMDAT ?ResetEmptySound@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetEmptySound@CBasePlayerWeapon@@UAEXXZ PROC NEAR	; CBasePlayerWeapon::ResetEmptySound, COMDAT

; 997  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 998  : 	m_iPlayEmptySound = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1828], 1

; 999  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetEmptySound@CBasePlayerWeapon@@UAEXXZ ENDP		; CBasePlayerWeapon::ResetEmptySound
_TEXT	ENDS
PUBLIC	?PrimaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ	; CBasePlayerWeapon::PrimaryAmmoIndex
;	COMDAT ?PrimaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?PrimaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ PROC NEAR	; CBasePlayerWeapon::PrimaryAmmoIndex, COMDAT

; 1004 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1005 : 	return m_iPrimaryAmmoType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1856]

; 1006 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrimaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ ENDP	; CBasePlayerWeapon::PrimaryAmmoIndex
_TEXT	ENDS
PUBLIC	?SecondaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ	; CBasePlayerWeapon::SecondaryAmmoIndex
;	COMDAT ?SecondaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?SecondaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ PROC NEAR	; CBasePlayerWeapon::SecondaryAmmoIndex, COMDAT

; 1011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1012 : 	return -1;

	or	eax, -1

; 1013 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SecondaryAmmoIndex@CBasePlayerWeapon@@UAEHXZ ENDP	; CBasePlayerWeapon::SecondaryAmmoIndex
_TEXT	ENDS
PUBLIC	?Holster@CBasePlayerWeapon@@UAEXXZ		; CBasePlayerWeapon::Holster
;	COMDAT ?Holster@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Holster@CBasePlayerWeapon@@UAEXXZ PROC NEAR		; CBasePlayerWeapon::Holster, COMDAT

; 1016 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1017 : 	m_fInReload = FALSE; // cancel any reload in progress.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1876], 0

; 1018 : 	m_pPlayer->pev->viewmodel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+188], 0

; 1019 : 	m_pPlayer->pev->weaponmodel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+192], 0

; 1020 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Holster@CBasePlayerWeapon@@UAEXXZ ENDP			; CBasePlayerWeapon::Holster
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBasePlayerAmmo@@UAEPAUdatamap_s@@XZ ; CBasePlayerAmmo::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBasePlayerAmmo@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBasePlayerAmmo@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBasePlayerAmmo::GetDataDescMap, COMDAT

; 1022 : BEGIN_DATADESC( CBasePlayerAmmo )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A ; CBasePlayerAmmo::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBasePlayerAmmo@@UAEPAUdatamap_s@@XZ ENDP ; CBasePlayerAmmo::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CBasePlayerAmmo@@SAPAUdatamap_s@@XZ	; CBasePlayerAmmo::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CBasePlayerAmmo@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBasePlayerAmmo@@SAPAUdatamap_s@@XZ PROC NEAR ; CBasePlayerAmmo::GetBaseMap, COMDAT

; 1022 : BEGIN_DATADESC( CBasePlayerAmmo )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBasePlayerAmmo@@SAPAUdatamap_s@@XZ ENDP	; CBasePlayerAmmo::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E44
_TEXT	SEGMENT
_$E44	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E43
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E44	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z ; DataMapInit
;	COMDAT _$E43
_TEXT	SEGMENT
_$E43	PROC NEAR					; COMDAT

; 1022 : BEGIN_DATADESC( CBasePlayerAmmo )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBasePlayerAmmo_DataDescInit@@3PAUdatamap_s@@A, eax ; CBasePlayerAmmo_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E43	ENDP
_TEXT	ENDS
PUBLIC	?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerAmmo::DefaultTouch
PUBLIC	?Materialize@CBasePlayerAmmo@@QAEXXZ		; CBasePlayerAmmo::Materialize
_BSS	SEGMENT
	ALIGN	4

_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1022 : BEGIN_DATADESC( CBasePlayerAmmo )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39728
	mov	cl, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BA@NDAH@CBasePlayerAmmo?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E47
	call	_atexit
	add	esp, 4
$L39728:
	call	?GetBaseMap@CBasePlayerAmmo@@SAPAUdatamap_s@@XZ ; CBasePlayerAmmo::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A+12, eax

; 1023 : 	DEFINE_FUNCTION( DefaultTouch ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L39732
	mov	al, BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S46@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0N@HNLH@DefaultTouch?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+28, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+32, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+36, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+38, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+40, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+44, OFFSET FLAT:?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerAmmo::DefaultTouch

; 1024 : 	DEFINE_FUNCTION( Materialize ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+48, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0M@BEMF@Materialize?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+52, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+56, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+60, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+62, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+64, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+68, OFFSET FLAT:?Materialize@CBasePlayerAmmo@@QAEXXZ ; CBasePlayerAmmo::Materialize
$L39732:

; 1025 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L39737
	mov	DWORD PTR ?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A+4, 2
	mov	DWORD PTR ?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39738
$L39737:
	mov	DWORD PTR ?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4PAUtypedescription_s@@A
$L39738:
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayerAmmo@@2Udatamap_s@@A ; CBasePlayerAmmo::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayerAmmo@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E47	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CBasePlayerAmmo@@UAEXXZ			; CBasePlayerAmmo::Spawn
;	COMDAT ?Spawn@CBasePlayerAmmo@@UAEXXZ
_TEXT	SEGMENT
$T41066 = -16
$T41067 = -28
_this$ = -4
?Spawn@CBasePlayerAmmo@@UAEXXZ PROC NEAR		; CBasePlayerAmmo::Spawn, COMDAT

; 1028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 	pev->movetype = MOVETYPE_TOSS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 6

; 1030 : 	pev->solid = SOLID_TRIGGER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 1

; 1031 : 	UTIL_SetSize(pev, Vector(-16, -16, 0), Vector(16, 16, 16));

	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T41066[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	0
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T41067[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1032 : 
; 1033 : 	SetTouch( DefaultTouch );

	push	OFFSET FLAT:??_C@_0N@HNLH@DefaultTouch?$AA@ ; `string'
	push	OFFSET FLAT:?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerAmmo::DefaultTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1034 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBasePlayerAmmo@@UAEXXZ ENDP			; CBasePlayerAmmo::Spawn
_TEXT	ENDS
PUBLIC	?Respawn@CBasePlayerAmmo@@UAEPAVCBaseEntity@@XZ	; CBasePlayerAmmo::Respawn
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT ?Respawn@CBasePlayerAmmo@@UAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
$T41070 = -16
_this$ = -4
?Respawn@CBasePlayerAmmo@@UAEPAVCBaseEntity@@XZ PROC NEAR ; CBasePlayerAmmo::Respawn, COMDAT

; 1037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1038 : 	pev->effects |= EF_NODRAW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 1039 : 	SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1040 : 
; 1041 : 	UTIL_SetOrigin( this, g_pGameRules->VecAmmoRespawnSpot( this ) );// move to wherever I'm supposed to repawn.

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR $T41070[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+176]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1042 : 
; 1043 : 	SetThink( Materialize );

	push	OFFSET FLAT:??_C@_0M@BEMF@Materialize?$AA@ ; `string'
	push	OFFSET FLAT:?Materialize@CBasePlayerAmmo@@QAEXXZ ; CBasePlayerAmmo::Materialize
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1044 : 	pev->nextthink = g_pGameRules->FlAmmoRespawnTime( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+172]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 1045 : 
; 1046 : 	return this;

	mov	eax, DWORD PTR _this$[ebp]

; 1047 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBasePlayerAmmo@@UAEPAVCBaseEntity@@XZ ENDP	; CBasePlayerAmmo::Respawn
_TEXT	ENDS
;	COMDAT ?Materialize@CBasePlayerAmmo@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Materialize@CBasePlayerAmmo@@QAEXXZ PROC NEAR		; CBasePlayerAmmo::Materialize, COMDAT

; 1050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1051 : 	if ( pev->effects & EF_NODRAW )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	and	edx, 128				; 00000080H
	test	edx, edx
	je	SHORT $L39761

; 1053 : 		// changing from invisible state to visible.
; 1054 : 		EMIT_SOUND_DYN( ENT(pev), CHAN_WEAPON, "items/suitchargeok1.wav", 1, ATTN_NORM, 0, 150 );

	push	150					; 00000096H
	push	0
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BI@FCIG@items?1suitchargeok1?4wav?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 1055 : 		pev->effects &= ~EF_NODRAW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	and	cl, 127					; 0000007fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx

; 1056 : 		pev->effects |= EF_MUZZLEFLASH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	al, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
$L39761:

; 1058 : 
; 1059 : 	SetTouch( DefaultTouch );

	push	OFFSET FLAT:??_C@_0N@HNLH@DefaultTouch?$AA@ ; `string'
	push	OFFSET FLAT:?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z ; CBasePlayerAmmo::DefaultTouch
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1060 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Materialize@CBasePlayerAmmo@@QAEXXZ ENDP		; CBasePlayerAmmo::Materialize
_TEXT	ENDS
;	COMDAT ?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CBasePlayerAmmo::DefaultTouch, COMDAT

; 1063 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1064 : 	if ( !pOther->IsPlayer() )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L39769

; 1066 : 		return;

	jmp	$L39768
$L39769:

; 1068 : 
; 1069 : 	if (AddAmmo( pOther ))

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+340]
	test	eax, eax
	je	SHORT $L39770

; 1071 : 		if ( g_pGameRules->AmmoShouldRespawn( this ) == GR_AMMO_RESPAWN_YES )

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+168]
	cmp	eax, 3
	jne	SHORT $L39771

; 1073 : 			Respawn();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+292]

; 1075 : 		else

	jmp	SHORT $L39772
$L39771:

; 1077 : 			SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1078 : 			SetThink(SUB_Remove);

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1079 : 			pev->nextthink = gpGlobals->time + .1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -8+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]
$L39772:

; 1082 : 	else if( gEvilImpulse101 )

	jmp	SHORT $L39778
$L39770:
	cmp	DWORD PTR ?gEvilImpulse101@@3HA, 0	; gEvilImpulse101
	je	SHORT $L39778

; 1084 : 		// evil impulse 101 hack, kill always
; 1085 : 		UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L39778:
$L39768:

; 1087 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DefaultTouch@CBasePlayerAmmo@@QAEXPAVCBaseEntity@@@Z ENDP ; CBasePlayerAmmo::DefaultTouch
_TEXT	ENDS
PUBLIC	?iMaxAmmo2@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iMaxAmmo2
PUBLIC	?ExtractAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z	; CBasePlayerWeapon::ExtractAmmo
;	COMDAT ?ExtractAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z
_TEXT	SEGMENT
_pWeapon$ = 8
_this$ = -4
_iReturn$ = -8
?ExtractAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z PROC NEAR	; CBasePlayerWeapon::ExtractAmmo, COMDAT

; 1098 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1099 : 	int			iReturn;
; 1100 : 
; 1101 : 	if ( pszAmmo1() != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	test	eax, eax
	je	SHORT $L39784

; 1103 : 		// blindly call with m_iDefaultAmmo. It's either going to be a value or zero. If it is zero,
; 1104 : 		// we only get the ammo in the weapon's clip, which is what we want.
; 1105 : 		iReturn = pWeapon->AddPrimaryAmmo( m_iDefaultAmmo, (char *)pszAmmo1(), iMaxClip(), iMaxAmmo1() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxAmmo1@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxAmmo1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxClip@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxClip
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1880]
	push	ecx
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?AddPrimaryAmmo@CBasePlayerWeapon@@QAEHHPADHH@Z ; CBasePlayerWeapon::AddPrimaryAmmo
	mov	DWORD PTR _iReturn$[ebp], eax

; 1106 : 		m_iDefaultAmmo = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1880], 0
$L39784:

; 1108 : 
; 1109 : 	if ( pszAmmo2() != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo2@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo2
	test	eax, eax
	je	SHORT $L39786

; 1111 : 		iReturn = pWeapon->AddSecondaryAmmo( 0, (char *)pszAmmo2(), iMaxAmmo2() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxAmmo2@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxAmmo2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo2@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo2
	push	eax
	push	0
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?AddSecondaryAmmo@CBasePlayerWeapon@@QAEHHPADH@Z ; CBasePlayerWeapon::AddSecondaryAmmo
	mov	DWORD PTR _iReturn$[ebp], eax
$L39786:

; 1113 : 
; 1114 : 	return iReturn;

	mov	eax, DWORD PTR _iReturn$[ebp]

; 1115 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtractAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z ENDP	; CBasePlayerWeapon::ExtractAmmo
_TEXT	ENDS
;	COMDAT ?iMaxAmmo2@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?iMaxAmmo2@CBasePlayerItem@@QAEHXZ PROC NEAR		; CBasePlayerItem::iMaxAmmo2, COMDAT

; 279  : 	int		iMaxAmmo2( void )	{ return ItemInfoArray[ m_iId ].iMaxAmmo2; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?iMaxAmmo2@CBasePlayerItem@@QAEHXZ ENDP			; CBasePlayerItem::iMaxAmmo2
_TEXT	ENDS
PUBLIC	?ExtractClipAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z	; CBasePlayerWeapon::ExtractClipAmmo
;	COMDAT ?ExtractClipAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z
_TEXT	SEGMENT
_pWeapon$ = 8
_this$ = -4
_iAmmo$ = -8
?ExtractClipAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z PROC NEAR ; CBasePlayerWeapon::ExtractClipAmmo, COMDAT

; 1121 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1122 : 	int			iAmmo;
; 1123 : 
; 1124 : 	if ( m_iClip == WEAPON_NOCLIP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1864], -1
	jne	SHORT $L39793

; 1126 : 		iAmmo = 0;// guns with no clips always come empty if they are second-hand

	mov	DWORD PTR _iAmmo$[ebp], 0

; 1128 : 	else

	jmp	SHORT $L39794
$L39793:

; 1130 : 		iAmmo = m_iClip;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1864]
	mov	DWORD PTR _iAmmo$[ebp], edx
$L39794:

; 1132 : 
; 1133 : 	return pWeapon->m_pPlayer->GiveAmmo( iAmmo, (char *)pszAmmo1(), iMaxAmmo1() ); // , &m_iPrimaryAmmoType

	mov	ecx, DWORD PTR _this$[ebp]
	call	?iMaxAmmo1@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iMaxAmmo1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	push	eax
	mov	eax, DWORD PTR _iAmmo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	mov	ecx, DWORD PTR [ecx+1816]
	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+156]

; 1134 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ExtractClipAmmo@CBasePlayerWeapon@@UAEHPAV1@@Z ENDP	; CBasePlayerWeapon::ExtractClipAmmo
_TEXT	ENDS
PUBLIC	?RetireWeapon@CBasePlayerWeapon@@UAEXXZ		; CBasePlayerWeapon::RetireWeapon
;	COMDAT ?RetireWeapon@CBasePlayerWeapon@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RetireWeapon@CBasePlayerWeapon@@UAEXXZ PROC NEAR	; CBasePlayerWeapon::RetireWeapon, COMDAT

; 1140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1141 : 	// first, no viewmodel at all.
; 1142 : 	m_pPlayer->pev->viewmodel = iStringNull;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+188], 0

; 1143 : 	m_pPlayer->pev->weaponmodel = iStringNull;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+192], 0

; 1144 : 	//m_pPlayer->pev->viewmodelindex = NULL;
; 1145 : 
; 1146 : 	g_pGameRules->GetNextBestWeapon( m_pPlayer, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+20]

; 1147 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RetireWeapon@CBasePlayerWeapon@@UAEXXZ ENDP		; CBasePlayerWeapon::RetireWeapon
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT
_$E49	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E48
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E49	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCWeaponBox@@@@QAE@PBD@Z	; CEntityFactory<CWeaponBox>::CEntityFactory<CWeaponBox>
_BSS	SEGMENT
	ALIGN	4

_weaponbox DD	01H DUP (?)
_BSS	ENDS
;	COMDAT _$E48
_TEXT	SEGMENT
_$E48	PROC NEAR					; COMDAT

; 1153 : LINK_ENTITY_TO_CLASS( weaponbox, CWeaponBox );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_09KMAI@weaponbox?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_weaponbox
	call	??0?$CEntityFactory@VCWeaponBox@@@@QAE@PBD@Z ; CEntityFactory<CWeaponBox>::CEntityFactory<CWeaponBox>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E48	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CWeaponBox@@UAEPAUdatamap_s@@XZ	; CWeaponBox::GetDataDescMap
;	COMDAT ?GetDataDescMap@CWeaponBox@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CWeaponBox@@UAEPAUdatamap_s@@XZ PROC NEAR ; CWeaponBox::GetDataDescMap, COMDAT

; 1155 : BEGIN_DATADESC( CWeaponBox )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CWeaponBox@@2Udatamap_s@@A ; CWeaponBox::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CWeaponBox@@UAEPAUdatamap_s@@XZ ENDP	; CWeaponBox::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CWeaponBox@@SAPAUdatamap_s@@XZ	; CWeaponBox::GetBaseMap
;	COMDAT ?GetBaseMap@CWeaponBox@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CWeaponBox@@SAPAUdatamap_s@@XZ PROC NEAR	; CWeaponBox::GetBaseMap, COMDAT

; 1155 : BEGIN_DATADESC( CWeaponBox )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CWeaponBox@@SAPAUdatamap_s@@XZ ENDP		; CWeaponBox::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E52
_TEXT	SEGMENT
_$E52	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E51
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E52	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z	; DataMapInit
;	COMDAT _$E51
_TEXT	SEGMENT
_$E51	PROC NEAR					; COMDAT

; 1155 : BEGIN_DATADESC( CWeaponBox )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CWeaponBox_DataDescInit@@3PAUdatamap_s@@A, eax ; CWeaponBox_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E51	ENDP
_TEXT	ENDS
PUBLIC	?Kill@CWeaponBox@@QAEXXZ			; CWeaponBox::Kill
PUBLIC	??_C@_04INPC@Kill?$AA@				; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04INPC@Kill?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_04INPC@Kill?$AA@ DB 'Kill', 00H			; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1155 : BEGIN_DATADESC( CWeaponBox )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39862
	mov	cl, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0L@MHAM@CWeaponBox?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E55
	call	_atexit
	add	esp, 4
$L39862:
	call	?GetBaseMap@CWeaponBox@@SAPAUdatamap_s@@XZ ; CWeaponBox::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CWeaponBox@@2Udatamap_s@@A+12, eax

; 1156 : 	DEFINE_ARRAY( m_rgAmmo, FIELD_INTEGER, MAX_AMMO_SLOTS ),
; 1157 : 	DEFINE_ARRAY( m_rgiszAmmo, FIELD_STRING, MAX_AMMO_SLOTS ),
; 1158 : 	DEFINE_ARRAY( m_rgpPlayerItems, FIELD_CLASSPTR, MAX_ITEM_TYPES ),
; 1159 : 	DEFINE_FIELD( m_cAmmoTypes, FIELD_INTEGER ),
; 1160 : 	DEFINE_FUNCTION( Kill ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L39878
	mov	al, BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S54@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_04INPC@Kill?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A+124, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A+128, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A+132, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A+134, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A+136, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A+140, OFFSET FLAT:?Kill@CWeaponBox@@QAEXXZ ; CWeaponBox::Kill
$L39878:

; 1161 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L39882
	mov	DWORD PTR ?m_DataMap@CWeaponBox@@2Udatamap_s@@A+4, 5
	mov	DWORD PTR ?m_DataMap@CWeaponBox@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39883
$L39882:
	mov	DWORD PTR ?m_DataMap@CWeaponBox@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CWeaponBox@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4PAUtypedescription_s@@A
$L39883:
	mov	eax, OFFSET FLAT:?m_DataMap@CWeaponBox@@2Udatamap_s@@A ; CWeaponBox::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT
_$E55	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCWeaponBox@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E55	ENDP
_TEXT	ENDS
PUBLIC	?Precache@CWeaponBox@@EAEXXZ			; CWeaponBox::Precache
PUBLIC	??_C@_0BH@DJFG@models?1w_weaponbox?4mdl?$AA@	; `string'
;	COMDAT ??_C@_0BH@DJFG@models?1w_weaponbox?4mdl?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BH@DJFG@models?1w_weaponbox?4mdl?$AA@ DB 'models/w_weaponbox.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ?Precache@CWeaponBox@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CWeaponBox@@EAEXXZ PROC NEAR			; CWeaponBox::Precache, COMDAT

; 1167 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1168 : 	PRECACHE_MODEL("models/w_weaponbox.mdl");

	push	OFFSET FLAT:??_C@_0BH@DJFG@models?1w_weaponbox?4mdl?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 1169 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CWeaponBox@@EAEXXZ ENDP			; CWeaponBox::Precache
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	?KeyValue@CWeaponBox@@EAEXPAUKeyValueData_s@@@Z	; CWeaponBox::KeyValue
PUBLIC	?PackAmmo@CWeaponBox@@QAEHHH@Z			; CWeaponBox::PackAmmo
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
PUBLIC	??_C@_0CP@LAJG@WeaponBox?5too?5full?$CB?5only?5?$CFd?5ammo@ ; `string'
EXTRN	_atoi:NEAR
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LAJG@WeaponBox?5too?5full?$CB?5only?5?$CFd?5ammo@
CONST	SEGMENT
??_C@_0CP@LAJG@WeaponBox?5too?5full?$CB?5only?5?$CFd?5ammo@ DB 'WeaponBox'
	DB	' too full! only %d ammotypes allowed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CWeaponBox@@EAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CWeaponBox@@EAEXPAUKeyValueData_s@@@Z PROC NEAR ; CWeaponBox::KeyValue, COMDAT

; 1174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1175 : 	// get support for spirit field too
; 1176 : 	if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39895
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39894
$L39895:

; 1178 : 		m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 1179 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1181 : 	else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L39906
$L39894:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L39897

; 1184 : 		{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L39902
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L39903
	jmp	SHORT $L39899
$L39902:

; 1185 : 		case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L39899
$L39903:

; 1186 : 		case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L39899:

; 1189 : 	else if ( m_cAmmoTypes < MAX_AMMO_SLOTS )

	jmp	SHORT $L39906
$L39897:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2044], 32		; 00000020H
	jge	SHORT $L39905

; 1191 : 		PackAmmo( ALLOC_STRING(pkvd->szKeyName), atoi(pkvd->szValue) );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_atoi
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PackAmmo@CWeaponBox@@QAEHHH@Z		; CWeaponBox::PackAmmo

; 1192 : 		m_cAmmoTypes++;// count this new ammo type.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2044]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2044], edx

; 1193 : 
; 1194 : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 1196 : 	else

	jmp	SHORT $L39906
$L39905:

; 1198 : 		ALERT ( at_console, "WeaponBox too full! only %d ammotypes allowed\n", MAX_AMMO_SLOTS );

	push	32					; 00000020H
	push	OFFSET FLAT:??_C@_0CP@LAJG@WeaponBox?5too?5full?$CB?5only?5?$CFd?5ammo@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L39906:

; 1200 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CWeaponBox@@EAEXPAUKeyValueData_s@@@Z ENDP	; CWeaponBox::KeyValue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?Spawn@CWeaponBox@@EAEXXZ			; CWeaponBox::Spawn
;	COMDAT ?Spawn@CWeaponBox@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CWeaponBox@@EAEXXZ PROC NEAR			; CWeaponBox::Spawn, COMDAT

; 1206 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1207 : 	Precache( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 1208 : 
; 1209 : 	pev->movetype = MOVETYPE_TOSS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 6

; 1210 : 	pev->solid = SOLID_TRIGGER;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 1

; 1211 : 
; 1212 : 	UTIL_SetSize( pev, g_vecZero, g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 1213 : 
; 1214 : 	SET_MODEL( ENT(pev), "models/w_weaponbox.mdl");

	push	OFFSET FLAT:??_C@_0BH@DJFG@models?1w_weaponbox?4mdl?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1215 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CWeaponBox@@EAEXXZ ENDP				; CWeaponBox::Spawn
_TEXT	ENDS
;	COMDAT ?Kill@CWeaponBox@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pWeapon$ = -8
_i$ = -12
?Kill@CWeaponBox@@QAEXXZ PROC NEAR			; CWeaponBox::Kill, COMDAT

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1223 : 	CBasePlayerItem *pWeapon;
; 1224 : 	int i;
; 1225 : 
; 1226 : 	// destroy the weapons
; 1227 : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39918
$L39919:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39918:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L39920

; 1229 : 		pWeapon = m_rgpPlayerItems[ i ];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1764]
	mov	DWORD PTR _pWeapon$[ebp], eax
$L39922:

; 1230 : 
; 1231 : 		while ( pWeapon )

	cmp	DWORD PTR _pWeapon$[ebp], 0
	je	SHORT $L39923

; 1233 : 			pWeapon->SetThink(SUB_Remove);

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1234 : 			pWeapon->pev->nextthink = gpGlobals->time + 0.1;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -16+[ebp]
	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]

; 1235 : 			pWeapon = pWeapon->m_pNext;

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	mov	edx, DWORD PTR [ecx+1820]
	mov	DWORD PTR _pWeapon$[ebp], edx

; 1236 : 		}

	jmp	SHORT $L39922
$L39923:

; 1237 : 	}

	jmp	SHORT $L39919
$L39920:

; 1238 : 
; 1239 : 	// remove the box
; 1240 : 	UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 1241 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Kill@CWeaponBox@@QAEXXZ ENDP				; CWeaponBox::Kill
_TEXT	ENDS
PUBLIC	?Touch@CWeaponBox@@EAEXPAVCBaseEntity@@@Z	; CWeaponBox::Touch
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
;	COMDAT ?Touch@CWeaponBox@@EAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pItem$39945 = -16
_pOther$ = 8
_this$ = -4
_pPlayer$ = -8
_i$ = -12
?Touch@CWeaponBox@@EAEXPAVCBaseEntity@@@Z PROC NEAR	; CWeaponBox::Touch, COMDAT

; 1248 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1249 : 	if ( !(pev->flags & FL_ONGROUND ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	jne	SHORT $L39930

; 1251 : 		return;

	jmp	$L39929
$L39930:

; 1253 : 
; 1254 : 	if ( !pOther->IsPlayer() )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L39931

; 1256 : 		// only players may touch a weaponbox.
; 1257 : 		return;

	jmp	$L39929
$L39931:

; 1259 : 
; 1260 : 	if ( !pOther->IsAlive() )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L39932

; 1262 : 		// no dead guys.
; 1263 : 		return;

	jmp	$L39929
$L39932:

; 1265 : 
; 1266 : 	CBasePlayer *pPlayer = (CBasePlayer *)pOther;

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	DWORD PTR _pPlayer$[ebp], eax

; 1267 : 	int i;
; 1268 : 
; 1269 : // dole out ammo
; 1270 : 	for ( i = 0 ; i < MAX_AMMO_SLOTS ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39936
$L39937:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39936:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$L39938

; 1272 : 		if ( !FStringNull( m_rgiszAmmo[ i ] ) )

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+1788]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39939

; 1274 : 			// there's some ammo of this type.
; 1275 : 			pPlayer->GiveAmmo( m_rgAmmo[ i ], (char *)STRING( m_rgiszAmmo[ i ] ), MaxAmmoCarry( m_rgiszAmmo[ i ] ) );

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+1788]
	push	ecx
	call	?MaxAmmoCarry@@YAHH@Z			; MaxAmmoCarry
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+1788]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+1916]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	DWORD PTR [eax+156]

; 1276 : 
; 1277 : 			//ALERT ( at_console, "Gave %d rounds of %s\n", m_rgAmmo[i], STRING(m_rgiszAmmo[i]) );
; 1278 : 
; 1279 : 			// now empty the ammo from the weaponbox since we just gave it to the player
; 1280 : 			m_rgiszAmmo[ i ] = iStringNull;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+1788], 0

; 1281 : 			m_rgAmmo[ i ] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1916], 0
$L39939:

; 1283 : 	}

	jmp	$L39937
$L39938:

; 1284 : 
; 1285 : // go through my weapons and try to give the usable ones to the player.
; 1286 : // it's important the the player be given ammo first, so the weapons code doesn't refuse
; 1287 : // to deploy a better weapon that the player may pick up because he has no ammo for it.
; 1288 : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39941
$L39942:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L39941:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L39943

; 1290 : 		if ( m_rgpPlayerItems[ i ] )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+1764], 0
	je	SHORT $L39948
$L39947:

; 1292 : 			CBasePlayerItem *pItem;
; 1293 : 
; 1294 : 			// have at least one weapon in this slot
; 1295 : 			while ( m_rgpPlayerItems[ i ] )

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+1764], 0
	je	SHORT $L39948

; 1297 : 				//ALERT ( at_console, "trying to give %s\n", STRING( m_rgpPlayerItems[ i ]->pev->classname ) );
; 1298 : 
; 1299 : 				pItem = m_rgpPlayerItems[ i ];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1764]
	mov	DWORD PTR _pItem$39945[ebp], eax

; 1300 : 				m_rgpPlayerItems[ i ] = m_rgpPlayerItems[ i ]->m_pNext;// unlink this weapon from the box

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1764]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1820]
	mov	DWORD PTR [edx+ecx*4+1764], eax

; 1301 : 
; 1302 : 				if ( pPlayer->AddPlayerItem( pItem ) )

	mov	ecx, DWORD PTR _pItem$39945[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	DWORD PTR [eax+148]
	test	eax, eax
	je	SHORT $L39949

; 1304 : 					pItem->AttachToPlayer( pPlayer );

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pItem$39945[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pItem$39945[ebp]
	call	DWORD PTR [eax+392]
$L39949:

; 1306 : 			}

	jmp	SHORT $L39947
$L39948:

; 1308 : 	}

	jmp	$L39942
$L39943:

; 1309 : 
; 1310 : 	EMIT_SOUND( pOther->edict(), CHAN_ITEM, "items/gunpickup2.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@FDHL@items?1gunpickup2?4wav?$AA@ ; `string'
	push	3
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1311 : 	SetTouch(NULL);

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1312 : 	UTIL_Remove(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L39929:

; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CWeaponBox@@EAEXPAVCBaseEntity@@@Z ENDP		; CWeaponBox::Touch
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
PUBLIC	?HasWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z ; CWeaponBox::HasWeapon
PUBLIC	?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z ; CWeaponBox::PackWeapon
;	COMDAT ?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8
_this$ = -4
_iWeaponSlot$ = -8
?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CWeaponBox::PackWeapon, COMDAT

; 1319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 	// is one of these weapons already packed in this box?
; 1321 : 	if ( HasWeapon( pWeapon ) )

	mov	eax, DWORD PTR _pWeapon$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z ; CWeaponBox::HasWeapon
	test	eax, eax
	je	SHORT $L39957

; 1323 : 		return FALSE;// box can only hold one of each weapon type

	xor	eax, eax
	jmp	$L39956
$L39957:

; 1325 : 
; 1326 : 	if ( pWeapon->m_pPlayer )

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	cmp	DWORD PTR [ecx+1816], 0
	je	SHORT $L39959

; 1328 : 		if ( !pWeapon->m_pPlayer->RemovePlayerItem( pWeapon ) )

	mov	edx, DWORD PTR _pWeapon$[ebp]
	push	edx
	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+152]
	test	eax, eax
	jne	SHORT $L39959

; 1330 : 			// failed to unhook the weapon from the player!
; 1331 : 			return FALSE;

	xor	eax, eax
	jmp	$L39956
$L39959:

; 1334 : 
; 1335 : 	int iWeaponSlot = pWeapon->iItemSlot();

	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	DWORD PTR [edx+412]
	mov	DWORD PTR _iWeaponSlot$[ebp], eax

; 1336 : 
; 1337 : 	if ( m_rgpPlayerItems[ iWeaponSlot ] )

	mov	eax, DWORD PTR _iWeaponSlot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+1764], 0
	je	SHORT $L39961

; 1339 : 		// there's already one weapon in this slot, so link this into the slot's column
; 1340 : 		pWeapon->m_pNext = m_rgpPlayerItems[ iWeaponSlot ];

	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR _iWeaponSlot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+1764]
	mov	DWORD PTR [edx+1820], eax

; 1341 : 		m_rgpPlayerItems[ iWeaponSlot ] = pWeapon;

	mov	ecx, DWORD PTR _iWeaponSlot$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	DWORD PTR [edx+ecx*4+1764], eax

; 1343 : 	else

	jmp	SHORT $L39962
$L39961:

; 1345 : 		// first weapon we have for this slot
; 1346 : 		m_rgpPlayerItems[ iWeaponSlot ] = pWeapon;

	mov	ecx, DWORD PTR _iWeaponSlot$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	DWORD PTR [edx+ecx*4+1764], eax

; 1347 : 		pWeapon->m_pNext = NULL;

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	mov	DWORD PTR [ecx+1820], 0
$L39962:

; 1349 : 
; 1350 : 	pWeapon->pev->spawnflags |= SF_NORESPAWN;// never respawn

	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+416], ecx

; 1351 : 	pWeapon->pev->movetype = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 0

; 1352 : 	pWeapon->pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 1353 : 	pWeapon->pev->effects = EF_NODRAW;

	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], 128		; 00000080H

; 1354 : 	pWeapon->pev->modelindex = 0;

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+180], 0

; 1355 : 	pWeapon->pev->model = iStringNull;

	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+184], 0

; 1356 : 	pWeapon->pev->owner = edict();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+408], eax

; 1357 : 	pWeapon->SetThink( NULL );// crowbar may be trying to swing again, etc.

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1358 : 	pWeapon->SetTouch( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?TouchSet@CBaseEntity@@QAEP81@AEXPAV1@@ZP81@AEX0@ZPAD@Z ; CBaseEntity::TouchSet

; 1359 : 	pWeapon->m_pPlayer = NULL;

	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	DWORD PTR [edx+1816], 0

; 1360 : 
; 1361 : 	//ALERT ( at_console, "packed %s\n", STRING(pWeapon->pev->classname) );
; 1362 : 
; 1363 : 	return TRUE;

	mov	eax, 1
$L39956:

; 1364 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z ENDP	; CWeaponBox::PackWeapon
_TEXT	ENDS
PUBLIC	??_C@_0BK@LEBC@NULL?5String?5in?5PackAmmo?$CB?6?$AA@ ; `string'
PUBLIC	?GiveAmmo@CWeaponBox@@AAEHHPADHPAH@Z		; CWeaponBox::GiveAmmo
;	COMDAT ??_C@_0BK@LEBC@NULL?5String?5in?5PackAmmo?$CB?6?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BK@LEBC@NULL?5String?5in?5PackAmmo?$CB?6?$AA@ DB 'NULL String in P'
	DB	'ackAmmo!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?PackAmmo@CWeaponBox@@QAEHHH@Z
_TEXT	SEGMENT
_iszName$ = 8
_iCount$ = 12
_this$ = -4
_iMaxCarry$ = -8
?PackAmmo@CWeaponBox@@QAEHHH@Z PROC NEAR		; CWeaponBox::PackAmmo, COMDAT

; 1370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1371 : 	int iMaxCarry;
; 1372 : 
; 1373 : 	if ( FStringNull( iszName ) )

	mov	eax, DWORD PTR _iszName$[ebp]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L39973

; 1375 : 		// error here
; 1376 : 		ALERT ( at_console, "NULL String in PackAmmo!\n" );

	push	OFFSET FLAT:??_C@_0BK@LEBC@NULL?5String?5in?5PackAmmo?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1377 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39971
$L39973:

; 1379 : 
; 1380 : 	iMaxCarry = MaxAmmoCarry( iszName );

	mov	ecx, DWORD PTR _iszName$[ebp]
	push	ecx
	call	?MaxAmmoCarry@@YAHH@Z			; MaxAmmoCarry
	add	esp, 4
	mov	DWORD PTR _iMaxCarry$[ebp], eax

; 1381 : 
; 1382 : 	if ( iMaxCarry != -1 && iCount > 0 )

	cmp	DWORD PTR _iMaxCarry$[ebp], -1
	je	SHORT $L39975
	cmp	DWORD PTR _iCount$[ebp], 0
	jle	SHORT $L39975

; 1384 : 		//ALERT ( at_console, "Packed %d rounds of %s\n", iCount, STRING(iszName) );
; 1385 : 		GiveAmmo( iCount, (char *)STRING( iszName ), iMaxCarry );

	push	0
	mov	edx, DWORD PTR _iMaxCarry$[ebp]
	push	edx
	mov	eax, DWORD PTR _iszName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _iCount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveAmmo@CWeaponBox@@AAEHHPADHPAH@Z	; CWeaponBox::GiveAmmo

; 1386 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L39971
$L39975:

; 1388 : 
; 1389 : 	return FALSE;

	xor	eax, eax
$L39971:

; 1390 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PackAmmo@CWeaponBox@@QAEHHH@Z ENDP			; CWeaponBox::PackAmmo
_TEXT	ENDS
PUBLIC	??_C@_0BJ@IJKC@out?5of?5named?5ammo?5slots?6?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@IJKC@out?5of?5named?5ammo?5slots?6?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0BJ@IJKC@out?5of?5named?5ammo?5slots?6?$AA@ DB 'out of named ammo s'
	DB	'lots', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?GiveAmmo@CWeaponBox@@AAEHHPADHPAH@Z
_TEXT	SEGMENT
_iCount$ = 8
_szName$ = 12
_iMax$ = 16
_pIndex$ = 20
_this$ = -4
_i$ = -8
_iAdd$39990 = -12
?GiveAmmo@CWeaponBox@@AAEHHPADHPAH@Z PROC NEAR		; CWeaponBox::GiveAmmo, COMDAT

; 1396 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1397 : 	int i;
; 1398 : 
; 1399 : 	for (i = 1; i < MAX_AMMO_SLOTS && !FStringNull( m_rgiszAmmo[i] ); i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L39985
$L39986:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39985:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$L39987
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1788]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	$L39987

; 1401 : 		if (stricmp( szName, STRING( m_rgiszAmmo[i])) == 0)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1788]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L39988

; 1403 : 			if (pIndex)

	cmp	DWORD PTR _pIndex$[ebp], 0
	je	SHORT $L39989

; 1404 : 				*pIndex = i;

	mov	edx, DWORD PTR _pIndex$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax
$L39989:

; 1405 : 
; 1406 : 			int iAdd = Q_min( iCount, iMax - m_rgAmmo[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iMax$[ebp]
	sub	eax, DWORD PTR [edx+ecx*4+1916]
	cmp	DWORD PTR _iCount$[ebp], eax
	jge	SHORT $L41119
	mov	ecx, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR -16+[ebp], ecx
	jmp	SHORT $L41120
$L41119:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iMax$[ebp]
	sub	ecx, DWORD PTR [eax+edx*4+1916]
	mov	DWORD PTR -16+[ebp], ecx
$L41120:
	mov	edx, DWORD PTR -16+[ebp]
	mov	DWORD PTR _iAdd$39990[ebp], edx

; 1407 : 			if (iCount == 0 || iAdd > 0)

	cmp	DWORD PTR _iCount$[ebp], 0
	je	SHORT $L39992
	cmp	DWORD PTR _iAdd$39990[ebp], 0
	jle	SHORT $L39991
$L39992:

; 1409 : 				m_rgAmmo[i] += iAdd;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1916]
	add	edx, DWORD PTR _iAdd$39990[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+1916], edx

; 1410 : 
; 1411 : 				return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L39983
$L39991:

; 1413 : 			return -1;

	or	eax, -1
	jmp	SHORT $L39983
$L39988:

; 1415 : 	}

	jmp	$L39986
$L39987:

; 1416 : 	if (i < MAX_AMMO_SLOTS)

	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L39993

; 1418 : 		if (pIndex)

	cmp	DWORD PTR _pIndex$[ebp], 0
	je	SHORT $L39994

; 1419 : 			*pIndex = i;

	mov	edx, DWORD PTR _pIndex$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx], eax
$L39994:

; 1420 : 
; 1421 : 		m_rgiszAmmo[i] = MAKE_STRING( szName );

	mov	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+1788], eax

; 1422 : 		m_rgAmmo[i] = iCount;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR [eax+edx*4+1916], ecx

; 1423 : 
; 1424 : 		return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L39983
$L39993:

; 1426 : 	ALERT( at_console, "out of named ammo slots\n");

	push	OFFSET FLAT:??_C@_0BJ@IJKC@out?5of?5named?5ammo?5slots?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1427 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$L39983:

; 1428 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GiveAmmo@CWeaponBox@@AAEHHPADHPAH@Z ENDP		; CWeaponBox::GiveAmmo
_TEXT	ENDS
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
;	COMDAT ?HasWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pCheckItem$ = 8
_this$ = -4
_pItem$ = -8
?HasWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CWeaponBox::HasWeapon, COMDAT

; 1435 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1436 : 	CBasePlayerItem *pItem = m_rgpPlayerItems[pCheckItem->iItemSlot()];

	mov	eax, DWORD PTR _pCheckItem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pCheckItem$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+1764]
	mov	DWORD PTR _pItem$[ebp], edx
$L40002:

; 1437 : 
; 1438 : 	while (pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	je	SHORT $L40003

; 1440 : 		if (FClassnameIs( pItem->pev, STRING( pCheckItem->pev->classname) ))

	mov	eax, DWORD PTR _pCheckItem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pItem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L40004

; 1442 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L39999
$L40004:

; 1444 : 		pItem = pItem->m_pNext;

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx+1820]
	mov	DWORD PTR _pItem$[ebp], eax

; 1445 : 	}

	jmp	SHORT $L40002
$L40003:

; 1446 : 
; 1447 : 	return FALSE;

	xor	eax, eax
$L39999:

; 1448 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z ENDP	; CWeaponBox::HasWeapon
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L41127
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41127
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L41128
$L41127:
	mov	DWORD PTR -4+[ebp], 1
$L41128:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	?IsEmpty@CWeaponBox@@AAEHXZ			; CWeaponBox::IsEmpty
;	COMDAT ?IsEmpty@CWeaponBox@@AAEHXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?IsEmpty@CWeaponBox@@AAEHXZ PROC NEAR			; CWeaponBox::IsEmpty, COMDAT

; 1454 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1455 : 	int i;
; 1456 : 
; 1457 : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40010
$L40011:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40010:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L40012

; 1459 : 		if ( m_rgpPlayerItems[ i ] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+1764], 0
	je	SHORT $L40013

; 1461 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L40008
$L40013:

; 1463 : 	}

	jmp	SHORT $L40011
$L40012:

; 1464 : 
; 1465 : 	for ( i = 0 ; i < MAX_AMMO_SLOTS ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40014
$L40015:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40014:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L40016

; 1467 : 		if ( !FStringNull( m_rgiszAmmo[ i ] ) )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+1788]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40017

; 1469 : 			// still have a bit of this type of ammo
; 1470 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L40008
$L40017:

; 1472 : 	}

	jmp	SHORT $L40015
$L40016:

; 1473 : 
; 1474 : 	return TRUE;

	mov	eax, 1
$L40008:

; 1475 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsEmpty@CWeaponBox@@AAEHXZ ENDP			; CWeaponBox::IsEmpty
_TEXT	ENDS
PUBLIC	?SetObjectCollisionBox@CWeaponBox@@EAEXXZ	; CWeaponBox::SetObjectCollisionBox
;	COMDAT ?SetObjectCollisionBox@CWeaponBox@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
$T41135 = -16
$T41136 = -28
$T41137 = -40
$T41138 = -52
?SetObjectCollisionBox@CWeaponBox@@EAEXXZ PROC NEAR	; CWeaponBox::SetObjectCollisionBox, COMDAT

; 1480 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 	pev->absmin = GetAbsOrigin() + Vector(-16, -16, 0);

	push	0
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T41135[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T41136[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1482 : 	pev->absmax = GetAbsOrigin() + Vector( 16, 16, 16);

	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T41137[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T41138[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 208				; 000000d0H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1483 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetObjectCollisionBox@CWeaponBox@@EAEXXZ ENDP		; CWeaponBox::SetObjectCollisionBox
_TEXT	ENDS
PUBLIC	??_C@_0O@HOPO@primary?3?5?5?$CFf?6?$AA@		; `string'
PUBLIC	??_C@_0O@GBAP@idle?5?5?5?3?5?5?$CFf?6?$AA@	; `string'
PUBLIC	??_C@_0O@KPBB@m_finre?3?5?5?$CFi?6?$AA@		; `string'
PUBLIC	??_C@_0O@ONLB@m_iclip?3?5?5?$CFi?6?$AA@		; `string'
PUBLIC	?PrintState@CBasePlayerWeapon@@QAEXXZ		; CBasePlayerWeapon::PrintState
;	COMDAT ??_C@_0O@HOPO@primary?3?5?5?$CFf?6?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0O@HOPO@primary?3?5?5?$CFf?6?$AA@ DB 'primary:  %f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GBAP@idle?5?5?5?3?5?5?$CFf?6?$AA@
CONST	SEGMENT
??_C@_0O@GBAP@idle?5?5?5?3?5?5?$CFf?6?$AA@ DB 'idle   :  %f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KPBB@m_finre?3?5?5?$CFi?6?$AA@
CONST	SEGMENT
??_C@_0O@KPBB@m_finre?3?5?5?$CFi?6?$AA@ DB 'm_finre:  %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@ONLB@m_iclip?3?5?5?$CFi?6?$AA@
CONST	SEGMENT
??_C@_0O@ONLB@m_iclip?3?5?5?$CFi?6?$AA@ DB 'm_iclip:  %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?PrintState@CBasePlayerWeapon@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrintState@CBasePlayerWeapon@@QAEXXZ PROC NEAR		; CBasePlayerWeapon::PrintState, COMDAT

; 1486 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1487 : 	ALERT( at_console, "primary:  %f\n", m_flNextPrimaryAttack );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1844]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0O@HOPO@primary?3?5?5?$CFf?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1488 : 	ALERT( at_console, "idle   :  %f\n", m_flTimeWeaponIdle );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+1852]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	push	OFFSET FLAT:??_C@_0O@GBAP@idle?5?5?5?3?5?5?$CFf?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1489 : 
; 1490 : //	ALERT( at_console, "nextrl :  %f\n", m_flNextReload );
; 1491 : //	ALERT( at_console, "nextpum:  %f\n", m_flPumpTime );
; 1492 : 
; 1493 : //	ALERT( at_console, "m_frt  :  %f\n", m_fReloadTime );
; 1494 : 	ALERT( at_console, "m_finre:  %i\n", m_fInReload );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1876]
	push	eax
	push	OFFSET FLAT:??_C@_0O@KPBB@m_finre?3?5?5?$CFi?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1495 : //	ALERT( at_console, "m_finsr:  %i\n", m_fInSpecialReload );
; 1496 : 
; 1497 : 	ALERT( at_console, "m_iclip:  %i\n", m_iClip );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1864]
	push	edx
	push	OFFSET FLAT:??_C@_0O@ONLB@m_iclip?3?5?5?$CFi?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1498 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintState@CBasePlayerWeapon@@QAEXXZ ENDP		; CBasePlayerWeapon::PrintState
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CLaserSpot@@UAEPAUdatamap_s@@XZ	; CLaserSpot::GetDataDescMap
;	COMDAT ?GetDataDescMap@CLaserSpot@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CLaserSpot@@UAEPAUdatamap_s@@XZ PROC NEAR ; CLaserSpot::GetDataDescMap, COMDAT

; 1502 : BEGIN_DATADESC( CLaserSpot )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CLaserSpot@@2Udatamap_s@@A ; CLaserSpot::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CLaserSpot@@UAEPAUdatamap_s@@XZ ENDP	; CLaserSpot::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CLaserSpot@@SAPAUdatamap_s@@XZ	; CLaserSpot::GetBaseMap
;	COMDAT ?GetBaseMap@CLaserSpot@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CLaserSpot@@SAPAUdatamap_s@@XZ PROC NEAR	; CLaserSpot::GetBaseMap, COMDAT

; 1502 : BEGIN_DATADESC( CLaserSpot )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CLaserSpot@@SAPAUdatamap_s@@XZ ENDP		; CLaserSpot::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E57
_TEXT	SEGMENT
_$E57	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E56
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E57	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z	; DataMapInit
;	COMDAT _$E56
_TEXT	SEGMENT
_$E56	PROC NEAR					; COMDAT

; 1502 : BEGIN_DATADESC( CLaserSpot )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CLaserSpot_DataDescInit@@3PAUdatamap_s@@A, eax ; CLaserSpot_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E56	ENDP
_TEXT	ENDS
PUBLIC	??_C@_06NAJJ@Revive?$AA@			; `string'
PUBLIC	?Revive@CLaserSpot@@QAEXXZ			; CLaserSpot::Revive
_BSS	SEGMENT
	ALIGN	4

_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S59@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_06NAJJ@Revive?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_06NAJJ@Revive?$AA@ DB 'Revive', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1502 : BEGIN_DATADESC( CLaserSpot )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S59@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L40072
	mov	cl, BYTE PTR _?$S59@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S59@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0L@MFKO@CLaserSpot?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E60
	call	_atexit
	add	esp, 4
$L40072:
	call	?GetBaseMap@CLaserSpot@@SAPAUdatamap_s@@XZ ; CLaserSpot::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CLaserSpot@@2Udatamap_s@@A+12, eax

; 1503 : 	DEFINE_FUNCTION( Revive ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S59@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L40076
	mov	al, BYTE PTR _?$S59@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S59@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_06NAJJ@Revive?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A+28, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A+32, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A+36, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A+38, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A+40, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A+44, OFFSET FLAT:?Revive@CLaserSpot@@QAEXXZ ; CLaserSpot::Revive
$L40076:

; 1504 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L40080
	mov	DWORD PTR ?m_DataMap@CLaserSpot@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CLaserSpot@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L40081
$L40080:
	mov	DWORD PTR ?m_DataMap@CLaserSpot@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CLaserSpot@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4PAUtypedescription_s@@A
$L40081:
	mov	eax, OFFSET FLAT:?m_DataMap@CLaserSpot@@2Udatamap_s@@A ; CLaserSpot::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E60
_TEXT	SEGMENT
_$E60	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCLaserSpot@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E60	ENDP
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z		; GetClassPtr
PUBLIC	??_C@_0L@FNBF@laser_spot?$AA@			; `string'
PUBLIC	?CreateSpot@CLaserSpot@@SAPAV1@XZ		; CLaserSpot::CreateSpot
;	COMDAT ??_C@_0L@FNBF@laser_spot?$AA@
; File z:\xashxtsrc\server\weapons.cpp
CONST	SEGMENT
??_C@_0L@FNBF@laser_spot?$AA@ DB 'laser_spot', 00H	; `string'
CONST	ENDS
;	COMDAT ?CreateSpot@CLaserSpot@@SAPAV1@XZ
_TEXT	SEGMENT
_pSpot$ = -4
?CreateSpot@CLaserSpot@@SAPAV1@XZ PROC NEAR		; CLaserSpot::CreateSpot, COMDAT

; 1507 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1508 : 	CLaserSpot *pSpot = GetClassPtr( (CLaserSpot *)NULL );

	push	0
	call	?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pSpot$[ebp], eax

; 1509 : 	pSpot->Spawn();

	mov	eax, DWORD PTR _pSpot$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pSpot$[ebp]
	call	DWORD PTR [edx+4]

; 1510 : 
; 1511 : 	pSpot->pev->classname = MAKE_STRING("laser_spot");

	push	OFFSET FLAT:??_C@_0L@FNBF@laser_spot?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _pSpot$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 1512 : 
; 1513 : 	return pSpot;

	mov	eax, DWORD PTR _pSpot$[ebp]

; 1514 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CreateSpot@CLaserSpot@@SAPAV1@XZ ENDP			; CLaserSpot::CreateSpot
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT
_$E62	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E61
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E62	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCLaserSpot@@@@QAE@PBD@Z	; CEntityFactory<CLaserSpot>::CEntityFactory<CLaserSpot>
_BSS	SEGMENT
	ALIGN	4

_laser_spot DD	01H DUP (?)
_BSS	ENDS
;	COMDAT _$E61
_TEXT	SEGMENT
_$E61	PROC NEAR					; COMDAT

; 1518 : LINK_ENTITY_TO_CLASS( laser_spot, CLaserSpot );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0L@FNBF@laser_spot?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_laser_spot
	call	??0?$CEntityFactory@VCLaserSpot@@@@QAE@PBD@Z ; CEntityFactory<CLaserSpot>::CEntityFactory<CLaserSpot>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E61	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CLaserSpot@@EAEXXZ			; CLaserSpot::Spawn
;	COMDAT ?Spawn@CLaserSpot@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CLaserSpot@@EAEXXZ PROC NEAR			; CLaserSpot::Spawn, COMDAT

; 1521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1522 : 	Precache( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 1523 : 	pev->movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0

; 1524 : 	pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 1525 : 
; 1526 : 	pev->rendermode = kRenderGlow;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+328], 3

; 1527 : 	pev->renderfx = kRenderFxNoDissipation;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+348], 14			; 0000000eH

; 1528 : 	pev->renderamt = 255;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+332], 1132396544		; 437f0000H

; 1529 : 
; 1530 : 	SET_MODEL(edict(), "sprites/laserdot.spr");

	push	OFFSET FLAT:??_C@_0BF@FKKF@sprites?1laserdot?4spr?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 1531 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CLaserSpot@@EAEXXZ ENDP				; CLaserSpot::Spawn
_TEXT	ENDS
PUBLIC	?Suspend@CLaserSpot@@QAEXM@Z			; CLaserSpot::Suspend
;	COMDAT ?Suspend@CLaserSpot@@QAEXM@Z
_TEXT	SEGMENT
_flSuspendTime$ = 8
_this$ = -4
?Suspend@CLaserSpot@@QAEXM@Z PROC NEAR			; CLaserSpot::Suspend, COMDAT

; 1537 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1538 : 	pev->effects |= EF_NODRAW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 1539 : 
; 1540 : 	SetThink( Revive );

	push	OFFSET FLAT:??_C@_06NAJJ@Revive?$AA@	; `string'
	push	OFFSET FLAT:?Revive@CLaserSpot@@QAEXXZ	; CLaserSpot::Revive
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1541 : 	pev->nextthink = gpGlobals->time + flSuspendTime;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _flSuspendTime$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]

; 1542 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Suspend@CLaserSpot@@QAEXM@Z ENDP			; CLaserSpot::Suspend
_TEXT	ENDS
;	COMDAT ?Revive@CLaserSpot@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Revive@CLaserSpot@@QAEXXZ PROC NEAR			; CLaserSpot::Revive, COMDAT

; 1548 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1549 : 	pev->effects &= ~EF_NODRAW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	and	dl, 127					; 0000007fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 1550 : 
; 1551 : 	SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 1552 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Revive@CLaserSpot@@QAEXXZ ENDP				; CLaserSpot::Revive
_TEXT	ENDS
PUBLIC	?Precache@CLaserSpot@@EAEXXZ			; CLaserSpot::Precache
;	COMDAT ?Precache@CLaserSpot@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CLaserSpot@@EAEXXZ PROC NEAR			; CLaserSpot::Precache, COMDAT

; 1555 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1556 : 	PRECACHE_MODEL("sprites/laserdot.spr");

	push	OFFSET FLAT:??_C@_0BF@FKKF@sprites?1laserdot?4spr?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 1557 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CLaserSpot@@EAEXXZ ENDP			; CLaserSpot::Precache
_TEXT	ENDS
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
PUBLIC	?Create@?$CEntityFactory@VCWeaponBox@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CWeaponBox>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCWeaponBox@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CWeaponBox>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCWeaponBox@@@@UAEIXZ ; CEntityFactory<CWeaponBox>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCWeaponBox@@@@6B@		; CEntityFactory<CWeaponBox>::`vftable'
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCWeaponBox@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCWeaponBox@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCWeaponBox@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CWeaponBox>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCWeaponBox@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCWeaponBox@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCWeaponBox@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCWeaponBox@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CWeaponBox>::CEntityFactory<CWeaponBox>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCWeaponBox@@@@6B@ ; CEntityFactory<CWeaponBox>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCWeaponBox@@@@QAE@PBD@Z ENDP	; CEntityFactory<CWeaponBox>::CEntityFactory<CWeaponBox>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCWeaponBox@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCWeaponBox@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CWeaponBox>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCWeaponBox@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CWeaponBox>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCWeaponBox@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCWeaponBox@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CWeaponBox>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCWeaponBox@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CWeaponBox>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCWeaponBox@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCWeaponBox@@@@UAEIXZ PROC NEAR ; CEntityFactory<CWeaponBox>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2048				; 00000800H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCWeaponBox@@@@UAEIXZ ENDP ; CEntityFactory<CWeaponBox>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCLaserSpot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CLaserSpot>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCLaserSpot@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CLaserSpot>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCLaserSpot@@@@UAEIXZ ; CEntityFactory<CLaserSpot>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCLaserSpot@@@@6B@		; CEntityFactory<CLaserSpot>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCLaserSpot@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCLaserSpot@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCLaserSpot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CLaserSpot>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCLaserSpot@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCLaserSpot@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCLaserSpot@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCLaserSpot@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CLaserSpot>::CEntityFactory<CLaserSpot>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCLaserSpot@@@@6B@ ; CEntityFactory<CLaserSpot>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCLaserSpot@@@@QAE@PBD@Z ENDP	; CEntityFactory<CLaserSpot>::CEntityFactory<CLaserSpot>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCLaserSpot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCLaserSpot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CLaserSpot>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCLaserSpot@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CLaserSpot>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCLaserSpot@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCLaserSpot@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CLaserSpot>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCLaserSpot@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CLaserSpot>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCLaserSpot@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCLaserSpot@@@@UAEIXZ PROC NEAR ; CEntityFactory<CLaserSpot>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCLaserSpot@@@@UAEIXZ ENDP ; CEntityFactory<CLaserSpot>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41209
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41209
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41209
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41209:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseAnimating@@2Udatamap_s@@A:BYTE	; CBaseAnimating::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseAnimating@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseAnimating@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseAnimating@@2Udatamap_s@@A ; CBaseAnimating::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseAnimating@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBasePlayerItem@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBasePlayerItem@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBasePlayerItem@@2Udatamap_s@@A ; CBasePlayerItem::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBasePlayerItem@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseEntity@@2Udatamap_s@@A:BYTE	; CBaseEntity::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseEntity@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CLaserSpot@@QAE@XZ				; CLaserSpot::CLaserSpot
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z
_TEXT	SEGMENT
_a$ = 8
$T41218 = -20
$T41219 = -24
_pev$ = -16
__$EHRec$ = -12
?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z PROC NEAR	; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40199

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40199:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L40201

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41219[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41219[ebp], 0
	je	SHORT $L41220
	mov	ecx, DWORD PTR $T41219[ebp]
	call	??0CLaserSpot@@QAE@XZ			; CLaserSpot::CLaserSpot
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41221
$L41220:
	mov	DWORD PTR -28+[ebp], 0
$L41221:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41218[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41218[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40201:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41219[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCLaserSpot@@PAV1@@Z ENDP		; GetClassPtr
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CWeaponBox@@QAE@XZ				; CWeaponBox::CWeaponBox
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41235 = -20
$T41236 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40210

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40210:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L40212

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2048					; 00000800H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41236[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41236[ebp], 0
	je	SHORT $L41237
	mov	ecx, DWORD PTR $T41236[ebp]
	call	??0CWeaponBox@@QAE@XZ			; CWeaponBox::CWeaponBox
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41238
$L41237:
	mov	DWORD PTR -28+[ebp], 0
$L41238:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41235[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41235[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40212:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41236[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCWeaponBox@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z
_TEXT	SEGMENT
_newEnt$ = 8
_className$ = 12
_pev$ = -16
$T41250 = -20
$T41251 = -24
__$EHRec$ = -12
?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L40221

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L40221:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L40223

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T41251[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41251[ebp], 0
	je	SHORT $L41252
	mov	ecx, DWORD PTR $T41251[ebp]
	call	??0CLaserSpot@@QAE@XZ			; CLaserSpot::CLaserSpot
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L41253
$L41252:
	mov	DWORD PTR -28+[ebp], 0
$L41253:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T41250[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T41250[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L40223:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41251[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCLaserSpot@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?ObjectCaps@CLaserSpot@@EAEHXZ			; CLaserSpot::ObjectCaps
PUBLIC	??_7CLaserSpot@@6B@				; CLaserSpot::`vftable'
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CLaserSpot@@6B@
CONST	SEGMENT
??_7CLaserSpot@@6B@ DD FLAT:?GetDataDescMap@CLaserSpot@@UAEPAUdatamap_s@@XZ ; CLaserSpot::`vftable'
	DD	FLAT:?Spawn@CLaserSpot@@EAEXXZ
	DD	FLAT:?Precache@CLaserSpot@@EAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CLaserSpot@@EAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CLaserSpot@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CLaserSpot@@QAE@XZ PROC NEAR				; CLaserSpot::CLaserSpot, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CLaserSpot@@6B@ ; CLaserSpot::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CLaserSpot@@QAE@XZ ENDP				; CLaserSpot::CLaserSpot
_TEXT	ENDS
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41324
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41324
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41324
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41325
$L41324:
	mov	DWORD PTR -8+[ebp], 0
$L41325:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L41342
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41342
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41343
$L41342:
	mov	DWORD PTR -8+[ebp], 0
$L41343:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L41350
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L41351
$L41350:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41351
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41352
$L41351:
	mov	DWORD PTR -8+[ebp], 0
$L41352:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41401 = -16
$T41402 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T41402[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T41401[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T41405 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T41405[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41408 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T41408[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41411 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T41411[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T41414 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T41414[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CLaserSpot@@EAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CLaserSpot@@EAEHXZ PROC NEAR		; CLaserSpot::ObjectCaps, COMDAT

; 467  : 	int ObjectCaps( void ) { return FCAP_DONT_SAVE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, -2147483648			; 80000000H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CLaserSpot@@EAEHXZ ENDP			; CLaserSpot::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CWeaponBox@@6B@				; CWeaponBox::`vftable'
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
;	COMDAT ??_7CWeaponBox@@6B@
CONST	SEGMENT
??_7CWeaponBox@@6B@ DD FLAT:?GetDataDescMap@CWeaponBox@@UAEPAUdatamap_s@@XZ ; CWeaponBox::`vftable'
	DD	FLAT:?Spawn@CWeaponBox@@EAEXXZ
	DD	FLAT:?Precache@CWeaponBox@@EAEXXZ
	DD	FLAT:?KeyValue@CWeaponBox@@EAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CWeaponBox@@EAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CWeaponBox@@EAEXPAVCBaseEntity@@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CWeaponBox@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CWeaponBox@@QAE@XZ PROC NEAR				; CWeaponBox::CWeaponBox, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CWeaponBox@@6B@ ; CWeaponBox::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CWeaponBox@@QAE@XZ ENDP				; CWeaponBox::CWeaponBox
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41445
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41445
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41445
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41445:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L41446
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41446
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41446:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L41451
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41451:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L40265

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L40265:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41456
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41456:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41457
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41457:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41460
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41460:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41467
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L41467
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41468
$L41467:
	mov	DWORD PTR -8+[ebp], 0
$L41468:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40298:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40299

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40298
$L40299:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40308

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L40308:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41475
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L41475
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L41475
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41475:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40317
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40317

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40317:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T41478 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T41478[ebp], eax
	cmp	DWORD PTR $T41478[ebp], 0
	je	SHORT $L41479
	mov	ecx, DWORD PTR $T41478[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T41478[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L41480
$L41479:
	mov	DWORD PTR -8+[ebp], 0
$L41480:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41485
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L41485
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41486
$L41485:
	mov	DWORD PTR -8+[ebp], 0
$L41486:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40331

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40332

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40332:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40331:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L41495
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41495:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40346

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L41496
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41496:

; 567  : 		return;

	jmp	$L40343
$L40346:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40366

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L40358
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L40358

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L40366
$L40358:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L40362

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L41497
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41497:

; 589  : 				return;

	jmp	$L40343
$L40362:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40366

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L40362
$L40366:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L40369

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41498
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41498:

; 603  : 	else

	jmp	SHORT $L41499
$L40369:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41499
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41499:
$L40343:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
