	TITLE	Z:\XashXTSRC\server\multiplay_gamerules.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FCJP@servercfgfile?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPHH@Executing?5dedicated?5server?5confi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KDJI@exec?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MPCH@lservercfgfile?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@DHKO@Executing?5listen?5server?5config?5f@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KANF@mp_chattime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02JAFN@?$CFi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PCGH@unconnected?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@LCMN@?$CFs?5has?5joined?5the?5game?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LHJL@model?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@KKEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5entered?5the?5gam@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@MOM@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5entered?5the?5gam@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FGI@game_playerleave?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@KLEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5disconnected?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@KABK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5disconnected?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@PFFH@game_player_equip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NAIF@weapon_crowbar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03IEOM@9mm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@FKMG@game_playerdie?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAEO@game_playerkill?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JCMM@weapon_satchel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MOPF@world?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EPOB@tau_cannon?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HCIF@gluon?5gun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BHGE@weapon_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NIHN@monster_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05CEIF@func_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MANP@egon?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MFIA@gauss?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@HNOP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@EGBI@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@FGHG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@OIKA@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@LJPG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@MJNO@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MGMF@minplayers?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OGIK@maxplayers?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@JIAD@Skipping?5?$CFs?5from?5mapcycle?0?5not?5a@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FCOA@?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BFEK@hldm1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MLDJ@mapcyclefile?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@PBEP@z?3?2xashxtsrc?2server?2multiplay_ga@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@ICCI@mapcfile?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@KJNK@Unable?5to?5load?5map?5cycle?5file?5?$CFs@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PDME@item?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@CCFN@CHANGE?5LEVEL?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FEGG@PLAYER?5COUNT?3?5?5min?5?$CFi?5max?5?$CFi?5cur@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GLI@RULES?3?5?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PDPP@motdfile?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NNNB@hostname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pszName@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iWeight@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iFlags@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTeamplay@CGameRules@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGameDescription@CGameRules@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateGameMode@CGameRules@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FPlayerCanTakeDamage@CGameRules@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldAutoAim@CGameRules@@UAEHPAVCBasePlayer@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllowAutoTargetCrosshair@CGameRules@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientCommand@CGameRules@@UAEHPAVCBasePlayer@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientUserInfoChanged@CGameRules@@UAEXPAVCBasePlayer@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlHEVChargerRechargeTime@CGameRules@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTeamIndex@CGameRules@@UAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIndexedTeamName@CGameRules@@UAEPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidTeam@CGameRules@@UAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangePlayerTeam@CGameRules@@UAEXPAVCBasePlayer@@PBDHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDefaultPlayerTeam@CGameRules@@UAEPBDPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayTextureSounds@CGameRules@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayFootstepSounds@CGameRules@@UAEHPAVCBasePlayer@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndMultiplayerGame@CGameRules@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTeamID@CHalfLifeMultiplay@@UAEPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayTextureSounds@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndMultiplayerGame@CHalfLifeMultiplay@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHalfLifeMultiplay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGameRules@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientCommand@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RefreshSkillData@CHalfLifeMultiplay@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CHalfLifeMultiplay@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMultiplayer@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDeathmatch@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCoOp@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FShouldSwitchWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextBestWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientConnected@CHalfLifeMultiplay@@UAEHPAUedict_s@@PBD1QAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateGameMode@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitHUD@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClientDisconnected@CHalfLifeMultiplay@@UAEXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlPlayerFallDamage@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FPlayerCanTakeDamage@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerThink@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerSpawn@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FPlayerCanRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlPlayerSpawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllowAutoTargetCrosshair@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IPointsForKill@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerKilled@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerGotWeapon@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlWeaponRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlWeaponTryRespawn@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecWeaponRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WeaponShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanHavePlayerItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanHaveItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerGotItem@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ItemShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlItemRespawnTime@CHalfLifeMultiplay@@UAEMPAVCItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecItemRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerGotAmmo@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAllowedToSpawn@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AmmoShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlAmmoRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecAmmoRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlHealthChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlHEVChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeadPlayerWeapons@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeadPlayerAmmo@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPlayerSpawnSpot@CHalfLifeMultiplay@@UAEPAUedict_s@@PAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerRelationship@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayFootstepSounds@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FAllowFlashlight@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FAllowMonsters@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GoToIntermission@CHalfLifeMultiplay@@MAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyMapCycle@@YAXPAUmapcycle_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReloadMapCycleFile@@YAHPADPAUmapcycle_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CountPlayers@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCommandString@@YAXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeLevel@CHalfLifeMultiplay@@MAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendMOTDToClient@CHalfLifeMultiplay@@IAEXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CHalfLifeMultiplay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CGameRules@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?g_flIntermissionStartTime@@3MA			; g_flIntermissionStartTime
_BSS	SEGMENT
?g_flIntermissionStartTime@@3MA DD 01H DUP (?)		; g_flIntermissionStartTime
_BSS	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?ShouldAutoAim@CGameRules@@UAEHPAVCBasePlayer@@PAUedict_s@@@Z ; CGameRules::ShouldAutoAim
PUBLIC	?ClientUserInfoChanged@CGameRules@@UAEXPAVCBasePlayer@@PAD@Z ; CGameRules::ClientUserInfoChanged
PUBLIC	?GetTeamIndex@CGameRules@@UAEHPBD@Z		; CGameRules::GetTeamIndex
PUBLIC	?GetIndexedTeamName@CGameRules@@UAEPBDH@Z	; CGameRules::GetIndexedTeamName
PUBLIC	?IsValidTeam@CGameRules@@UAEHPBD@Z		; CGameRules::IsValidTeam
PUBLIC	?ChangePlayerTeam@CGameRules@@UAEXPAVCBasePlayer@@PBDHH@Z ; CGameRules::ChangePlayerTeam
PUBLIC	?SetDefaultPlayerTeam@CGameRules@@UAEPBDPAVCBasePlayer@@@Z ; CGameRules::SetDefaultPlayerTeam
PUBLIC	??0CGameRules@@QAE@XZ				; CGameRules::CGameRules
PUBLIC	??0CHalfLifeMultiplay@@QAE@XZ			; CHalfLifeMultiplay::CHalfLifeMultiplay
PUBLIC	?Think@CHalfLifeMultiplay@@UAEXXZ		; CHalfLifeMultiplay::Think
PUBLIC	?RefreshSkillData@CHalfLifeMultiplay@@UAEXXZ	; CHalfLifeMultiplay::RefreshSkillData
PUBLIC	?IsAllowedToSpawn@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@@Z ; CHalfLifeMultiplay::IsAllowedToSpawn
PUBLIC	?FAllowFlashlight@CHalfLifeMultiplay@@UAEHXZ	; CHalfLifeMultiplay::FAllowFlashlight
PUBLIC	?FShouldSwitchWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::FShouldSwitchWeapon
PUBLIC	?GetNextBestWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::GetNextBestWeapon
PUBLIC	?IsMultiplayer@CHalfLifeMultiplay@@UAEHXZ	; CHalfLifeMultiplay::IsMultiplayer
PUBLIC	?IsDeathmatch@CHalfLifeMultiplay@@UAEHXZ	; CHalfLifeMultiplay::IsDeathmatch
PUBLIC	?IsCoOp@CHalfLifeMultiplay@@UAEHXZ		; CHalfLifeMultiplay::IsCoOp
PUBLIC	?ClientConnected@CHalfLifeMultiplay@@UAEHPAUedict_s@@PBD1QAD@Z ; CHalfLifeMultiplay::ClientConnected
PUBLIC	?InitHUD@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::InitHUD
PUBLIC	?ClientDisconnected@CHalfLifeMultiplay@@UAEXPAUedict_s@@@Z ; CHalfLifeMultiplay::ClientDisconnected
PUBLIC	?UpdateGameMode@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::UpdateGameMode
PUBLIC	?FlPlayerFallDamage@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::FlPlayerFallDamage
PUBLIC	?FPlayerCanTakeDamage@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z ; CHalfLifeMultiplay::FPlayerCanTakeDamage
PUBLIC	?PlayerSpawn@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::PlayerSpawn
PUBLIC	?PlayerThink@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::PlayerThink
PUBLIC	?FPlayerCanRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::FPlayerCanRespawn
PUBLIC	?FlPlayerSpawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::FlPlayerSpawnTime
PUBLIC	?GetPlayerSpawnSpot@CHalfLifeMultiplay@@UAEPAUedict_s@@PAVCBasePlayer@@@Z ; CHalfLifeMultiplay::GetPlayerSpawnSpot
PUBLIC	?AllowAutoTargetCrosshair@CHalfLifeMultiplay@@UAEHXZ ; CHalfLifeMultiplay::AllowAutoTargetCrosshair
PUBLIC	?ClientCommand@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PBD@Z ; CHalfLifeMultiplay::ClientCommand
PUBLIC	?IPointsForKill@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@0@Z ; CHalfLifeMultiplay::IPointsForKill
PUBLIC	?PlayerKilled@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z ; CHalfLifeMultiplay::PlayerKilled
PUBLIC	?DeathNotice@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z ; CHalfLifeMultiplay::DeathNotice
PUBLIC	?PlayerGotWeapon@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::PlayerGotWeapon
PUBLIC	?CanHavePlayerItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::CanHavePlayerItem
PUBLIC	?WeaponShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::WeaponShouldRespawn
PUBLIC	?FlWeaponRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::FlWeaponRespawnTime
PUBLIC	?FlWeaponTryRespawn@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::FlWeaponTryRespawn
PUBLIC	?VecWeaponRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerItem@@@Z ; CHalfLifeMultiplay::VecWeaponRespawnSpot
PUBLIC	?CanHaveItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCItem@@@Z ; CHalfLifeMultiplay::CanHaveItem
PUBLIC	?PlayerGotItem@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCItem@@@Z ; CHalfLifeMultiplay::PlayerGotItem
PUBLIC	?ItemShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCItem@@@Z ; CHalfLifeMultiplay::ItemShouldRespawn
PUBLIC	?FlItemRespawnTime@CHalfLifeMultiplay@@UAEMPAVCItem@@@Z ; CHalfLifeMultiplay::FlItemRespawnTime
PUBLIC	?VecItemRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCItem@@@Z ; CHalfLifeMultiplay::VecItemRespawnSpot
PUBLIC	?PlayerGotAmmo@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PADH@Z ; CHalfLifeMultiplay::PlayerGotAmmo
PUBLIC	?AmmoShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerAmmo@@@Z ; CHalfLifeMultiplay::AmmoShouldRespawn
PUBLIC	?FlAmmoRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerAmmo@@@Z ; CHalfLifeMultiplay::FlAmmoRespawnTime
PUBLIC	?VecAmmoRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerAmmo@@@Z ; CHalfLifeMultiplay::VecAmmoRespawnSpot
PUBLIC	?FlHealthChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ ; CHalfLifeMultiplay::FlHealthChargerRechargeTime
PUBLIC	?FlHEVChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ ; CHalfLifeMultiplay::FlHEVChargerRechargeTime
PUBLIC	?DeadPlayerWeapons@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::DeadPlayerWeapons
PUBLIC	?DeadPlayerAmmo@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z ; CHalfLifeMultiplay::DeadPlayerAmmo
PUBLIC	?GetTeamID@CHalfLifeMultiplay@@UAEPBDPAVCBaseEntity@@@Z ; CHalfLifeMultiplay::GetTeamID
PUBLIC	?PlayerRelationship@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@0@Z ; CHalfLifeMultiplay::PlayerRelationship
PUBLIC	?PlayTextureSounds@CHalfLifeMultiplay@@UAEHXZ	; CHalfLifeMultiplay::PlayTextureSounds
PUBLIC	?PlayFootstepSounds@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@M@Z ; CHalfLifeMultiplay::PlayFootstepSounds
PUBLIC	?FAllowMonsters@CHalfLifeMultiplay@@UAEHXZ	; CHalfLifeMultiplay::FAllowMonsters
PUBLIC	?EndMultiplayerGame@CHalfLifeMultiplay@@UAEXXZ	; CHalfLifeMultiplay::EndMultiplayerGame
PUBLIC	?ChangeLevel@CHalfLifeMultiplay@@MAEXXZ		; CHalfLifeMultiplay::ChangeLevel
PUBLIC	?GoToIntermission@CHalfLifeMultiplay@@MAEXXZ	; CHalfLifeMultiplay::GoToIntermission
PUBLIC	??_7CHalfLifeMultiplay@@6B@			; CHalfLifeMultiplay::`vftable'
PUBLIC	??_C@_0O@FCJP@servercfgfile?$AA@		; `string'
PUBLIC	??_C@_0CI@DPHH@Executing?5dedicated?5server?5confi@ ; `string'
PUBLIC	??_C@_08KDJI@exec?5?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0P@MPCH@lservercfgfile?$AA@		; `string'
PUBLIC	??_C@_0CF@DHKO@Executing?5listen?5server?5config?5f@ ; `string'
PUBLIC	?IsTeamplay@CGameRules@@UAEHXZ			; CGameRules::IsTeamplay
PUBLIC	?GetGameDescription@CGameRules@@UAEPBDXZ	; CGameRules::GetGameDescription
EXTRN	?CanHaveAmmo@CGameRules@@UAEHPAVCBasePlayer@@PBDH@Z:NEAR ; CGameRules::CanHaveAmmo
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	__fltused:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_7CHalfLifeMultiplay@@6B@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_7CHalfLifeMultiplay@@6B@ DD FLAT:?RefreshSkillData@CHalfLifeMultiplay@@UAEXXZ ; CHalfLifeMultiplay::`vftable'
	DD	FLAT:?Think@CHalfLifeMultiplay@@UAEXXZ
	DD	FLAT:?IsAllowedToSpawn@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FAllowFlashlight@CHalfLifeMultiplay@@UAEHXZ
	DD	FLAT:?FShouldSwitchWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
	DD	FLAT:?GetNextBestWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
	DD	FLAT:?IsMultiplayer@CHalfLifeMultiplay@@UAEHXZ
	DD	FLAT:?IsDeathmatch@CHalfLifeMultiplay@@UAEHXZ
	DD	FLAT:?IsTeamplay@CGameRules@@UAEHXZ
	DD	FLAT:?IsCoOp@CHalfLifeMultiplay@@UAEHXZ
	DD	FLAT:?GetGameDescription@CGameRules@@UAEPBDXZ
	DD	FLAT:?ClientConnected@CHalfLifeMultiplay@@UAEHPAUedict_s@@PBD1QAD@Z
	DD	FLAT:?InitHUD@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?ClientDisconnected@CHalfLifeMultiplay@@UAEXPAUedict_s@@@Z
	DD	FLAT:?UpdateGameMode@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?FlPlayerFallDamage@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z
	DD	FLAT:?FPlayerCanTakeDamage@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z
	DD	FLAT:?ShouldAutoAim@CGameRules@@UAEHPAVCBasePlayer@@PAUedict_s@@@Z
	DD	FLAT:?PlayerSpawn@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?PlayerThink@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?FPlayerCanRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
	DD	FLAT:?FlPlayerSpawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z
	DD	FLAT:?GetPlayerSpawnSpot@CHalfLifeMultiplay@@UAEPAUedict_s@@PAVCBasePlayer@@@Z
	DD	FLAT:?AllowAutoTargetCrosshair@CHalfLifeMultiplay@@UAEHXZ
	DD	FLAT:?ClientCommand@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PBD@Z
	DD	FLAT:?ClientUserInfoChanged@CGameRules@@UAEXPAVCBasePlayer@@PAD@Z
	DD	FLAT:?IPointsForKill@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@0@Z
	DD	FLAT:?PlayerKilled@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z
	DD	FLAT:?DeathNotice@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z
	DD	FLAT:?CanHavePlayerItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
	DD	FLAT:?PlayerGotWeapon@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
	DD	FLAT:?WeaponShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?FlWeaponRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z
	DD	FLAT:?FlWeaponTryRespawn@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z
	DD	FLAT:?VecWeaponRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerItem@@@Z
	DD	FLAT:?CanHaveItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCItem@@@Z
	DD	FLAT:?PlayerGotItem@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCItem@@@Z
	DD	FLAT:?ItemShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCItem@@@Z
	DD	FLAT:?FlItemRespawnTime@CHalfLifeMultiplay@@UAEMPAVCItem@@@Z
	DD	FLAT:?VecItemRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCItem@@@Z
	DD	FLAT:?CanHaveAmmo@CGameRules@@UAEHPAVCBasePlayer@@PBDH@Z
	DD	FLAT:?PlayerGotAmmo@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PADH@Z
	DD	FLAT:?AmmoShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerAmmo@@@Z
	DD	FLAT:?FlAmmoRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerAmmo@@@Z
	DD	FLAT:?VecAmmoRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerAmmo@@@Z
	DD	FLAT:?FlHealthChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ
	DD	FLAT:?FlHEVChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ
	DD	FLAT:?DeadPlayerWeapons@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
	DD	FLAT:?DeadPlayerAmmo@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
	DD	FLAT:?GetTeamID@CHalfLifeMultiplay@@UAEPBDPAVCBaseEntity@@@Z
	DD	FLAT:?PlayerRelationship@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@0@Z
	DD	FLAT:?GetTeamIndex@CGameRules@@UAEHPBD@Z
	DD	FLAT:?GetIndexedTeamName@CGameRules@@UAEPBDH@Z
	DD	FLAT:?IsValidTeam@CGameRules@@UAEHPBD@Z
	DD	FLAT:?ChangePlayerTeam@CGameRules@@UAEXPAVCBasePlayer@@PBDHH@Z
	DD	FLAT:?SetDefaultPlayerTeam@CGameRules@@UAEPBDPAVCBasePlayer@@@Z
	DD	FLAT:?PlayTextureSounds@CHalfLifeMultiplay@@UAEHXZ
	DD	FLAT:?PlayFootstepSounds@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@M@Z
	DD	FLAT:?FAllowMonsters@CHalfLifeMultiplay@@UAEHXZ
	DD	FLAT:?EndMultiplayerGame@CHalfLifeMultiplay@@UAEXXZ
	DD	FLAT:?ChangeLevel@CHalfLifeMultiplay@@MAEXXZ
	DD	FLAT:?GoToIntermission@CHalfLifeMultiplay@@MAEXXZ
CONST	ENDS
;	COMDAT ??_C@_0O@FCJP@servercfgfile?$AA@
CONST	SEGMENT
??_C@_0O@FCJP@servercfgfile?$AA@ DB 'servercfgfile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPHH@Executing?5dedicated?5server?5confi@
CONST	SEGMENT
??_C@_0CI@DPHH@Executing?5dedicated?5server?5confi@ DB 'Executing dedicat'
	DB	'ed server config file', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDJI@exec?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_08KDJI@exec?5?$CFs?6?$AA@ DB 'exec %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MPCH@lservercfgfile?$AA@
CONST	SEGMENT
??_C@_0P@MPCH@lservercfgfile?$AA@ DB 'lservercfgfile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DHKO@Executing?5listen?5server?5config?5f@
CONST	SEGMENT
??_C@_0CF@DHKO@Executing?5listen?5server?5config?5f@ DB 'Executing listen'
	DB	' server config file', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??0CHalfLifeMultiplay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
_servercfgfile$38531 = -8
_szCommand$38535 = -264
_lservercfgfile$38539 = -268
_szCommand$38543 = -524
??0CHalfLifeMultiplay@@QAE@XZ PROC NEAR			; CHalfLifeMultiplay::CHalfLifeMultiplay, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 588				; 0000024cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CGameRules@@QAE@XZ			; CGameRules::CGameRules
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CHalfLifeMultiplay@@6B@ ; CHalfLifeMultiplay::`vftable'

; 51   : 	RefreshSkillData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RefreshSkillData@CHalfLifeMultiplay@@UAEXXZ ; CHalfLifeMultiplay::RefreshSkillData

; 52   : 	m_flIntermissionEndTime = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 53   : 	g_flIntermissionStartTime = 0;

	mov	DWORD PTR ?g_flIntermissionStartTime@@3MA, 0

; 54   : 	
; 55   : 	// 11/8/98
; 56   : 	// Modified by YWB:  Server .cfg file is now a cvar, so that 
; 57   : 	//  server ops can run multiple game servers, with different server .cfg files,
; 58   : 	//  from a single installed directory.
; 59   : 	// Mapcyclefile is already a cvar.
; 60   : 
; 61   : 	// 3/31/99
; 62   : 	// Added lservercfg file cvar, since listen and dedicated servers should not
; 63   : 	// share a single config file. (sjb)
; 64   : 	if ( IS_DEDICATED_SERVER() )

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+460
	test	eax, eax
	je	SHORT $L38530

; 66   : 		// dedicated server
; 67   : 		char *servercfgfile = (char *)CVAR_GET_STRING( "servercfgfile" );

	push	OFFSET FLAT:??_C@_0O@FCJP@servercfgfile?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+232
	add	esp, 4
	mov	DWORD PTR _servercfgfile$38531[ebp], eax

; 68   : 
; 69   : 		if ( servercfgfile && servercfgfile[0] )

	cmp	DWORD PTR _servercfgfile$38531[ebp], 0
	je	SHORT $L38534
	mov	edx, DWORD PTR _servercfgfile$38531[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L38534

; 71   : 			char szCommand[256];
; 72   : 			
; 73   : 			ALERT( at_console, "Executing dedicated server config file\n" );

	push	OFFSET FLAT:??_C@_0CI@DPHH@Executing?5dedicated?5server?5confi@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 74   : 			sprintf( szCommand, "exec %s\n", servercfgfile );

	mov	ecx, DWORD PTR _servercfgfile$38531[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08KDJI@exec?5?$CFs?6?$AA@ ; `string'
	lea	edx, DWORD PTR _szCommand$38535[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 75   : 			SERVER_COMMAND( szCommand );

	lea	eax, DWORD PTR _szCommand$38535[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+156
	add	esp, 4
$L38534:

; 78   : 	else

	jmp	SHORT $L38542
$L38530:

; 80   : 		// listen server
; 81   : 		char *lservercfgfile = (char *)CVAR_GET_STRING( "lservercfgfile" );

	push	OFFSET FLAT:??_C@_0P@MPCH@lservercfgfile?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+232
	add	esp, 4
	mov	DWORD PTR _lservercfgfile$38539[ebp], eax

; 82   : 
; 83   : 		if ( lservercfgfile && lservercfgfile[0] )

	cmp	DWORD PTR _lservercfgfile$38539[ebp], 0
	je	SHORT $L38542
	mov	ecx, DWORD PTR _lservercfgfile$38539[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L38542

; 85   : 			char szCommand[256];
; 86   : 			
; 87   : 			ALERT( at_console, "Executing listen server config file\n" );

	push	OFFSET FLAT:??_C@_0CF@DHKO@Executing?5listen?5server?5config?5f@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 88   : 			sprintf( szCommand, "exec %s\n", lservercfgfile );

	mov	eax, DWORD PTR _lservercfgfile$38539[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08KDJI@exec?5?$CFs?6?$AA@ ; `string'
	lea	ecx, DWORD PTR _szCommand$38543[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 89   : 			SERVER_COMMAND( szCommand );

	lea	edx, DWORD PTR _szCommand$38543[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+156
	add	esp, 4
$L38542:

; 92   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CHalfLifeMultiplay@@QAE@XZ ENDP			; CHalfLifeMultiplay::CHalfLifeMultiplay
_TEXT	ENDS
;	COMDAT ?IsTeamplay@CGameRules@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTeamplay@CGameRules@@UAEHXZ PROC NEAR		; CGameRules::IsTeamplay, COMDAT

; 73   : 	virtual BOOL IsTeamplay( void ) { return FALSE; };// is this deathmatch game being played with team rules?

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTeamplay@CGameRules@@UAEHXZ ENDP			; CGameRules::IsTeamplay
_TEXT	ENDS
PUBLIC	??_C@_09OKKL@Half?9Life?$AA@			; `string'
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
; File z:\xashxtsrc\server\gamerules.h
CONST	SEGMENT
??_C@_09OKKL@Half?9Life?$AA@ DB 'Half-Life', 00H	; `string'
CONST	ENDS
;	COMDAT ?GetGameDescription@CGameRules@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetGameDescription@CGameRules@@UAEPBDXZ PROC NEAR	; CGameRules::GetGameDescription, COMDAT

; 75   : 	virtual const char *GetGameDescription( void ) { return "Half-Life"; }  // this is the game name that gets seen in the server browser

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_09OKKL@Half?9Life?$AA@ ; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGameDescription@CGameRules@@UAEPBDXZ ENDP		; CGameRules::GetGameDescription
_TEXT	ENDS
;	COMDAT ?ShouldAutoAim@CGameRules@@UAEHPAVCBasePlayer@@PAUedict_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?ShouldAutoAim@CGameRules@@UAEHPAVCBasePlayer@@PAUedict_s@@@Z PROC NEAR ; CGameRules::ShouldAutoAim, COMDAT

; 86   : 	virtual BOOL ShouldAutoAim( CBasePlayer *pPlayer, edict_t *target ) { return TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShouldAutoAim@CGameRules@@UAEHPAVCBasePlayer@@PAUedict_s@@@Z ENDP ; CGameRules::ShouldAutoAim
_TEXT	ENDS
;	COMDAT ?ClientUserInfoChanged@CGameRules@@UAEXPAVCBasePlayer@@PAD@Z
_TEXT	SEGMENT
_this$ = -4
?ClientUserInfoChanged@CGameRules@@UAEXPAVCBasePlayer@@PAD@Z PROC NEAR ; CGameRules::ClientUserInfoChanged, COMDAT

; 97   : 	virtual void ClientUserInfoChanged( CBasePlayer *pPlayer, char *infobuffer ) {}		// the player has changed userinfo;  can change it now

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ClientUserInfoChanged@CGameRules@@UAEXPAVCBasePlayer@@PAD@Z ENDP ; CGameRules::ClientUserInfoChanged
_TEXT	ENDS
;	COMDAT ?GetTeamIndex@CGameRules@@UAEHPBD@Z
_TEXT	SEGMENT
_this$ = -4
?GetTeamIndex@CGameRules@@UAEHPBD@Z PROC NEAR		; CGameRules::GetTeamIndex, COMDAT

; 145  : 	virtual int GetTeamIndex( const char *pTeamName ) { return -1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTeamIndex@CGameRules@@UAEHPBD@Z ENDP		; CGameRules::GetTeamIndex
_TEXT	ENDS
PUBLIC	??_C@_00A@?$AA@					; `string'
;	COMDAT ??_C@_00A@?$AA@
; File z:\xashxtsrc\server\gamerules.h
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ?GetIndexedTeamName@CGameRules@@UAEPBDH@Z
_TEXT	SEGMENT
_this$ = -4
?GetIndexedTeamName@CGameRules@@UAEPBDH@Z PROC NEAR	; CGameRules::GetIndexedTeamName, COMDAT

; 146  : 	virtual const char *GetIndexedTeamName( int teamIndex ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetIndexedTeamName@CGameRules@@UAEPBDH@Z ENDP		; CGameRules::GetIndexedTeamName
_TEXT	ENDS
;	COMDAT ?IsValidTeam@CGameRules@@UAEHPBD@Z
_TEXT	SEGMENT
_this$ = -4
?IsValidTeam@CGameRules@@UAEHPBD@Z PROC NEAR		; CGameRules::IsValidTeam, COMDAT

; 147  : 	virtual BOOL IsValidTeam( const char *pTeamName ) { return TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidTeam@CGameRules@@UAEHPBD@Z ENDP			; CGameRules::IsValidTeam
_TEXT	ENDS
;	COMDAT ?ChangePlayerTeam@CGameRules@@UAEXPAVCBasePlayer@@PBDHH@Z
_TEXT	SEGMENT
_this$ = -4
?ChangePlayerTeam@CGameRules@@UAEXPAVCBasePlayer@@PBDHH@Z PROC NEAR ; CGameRules::ChangePlayerTeam, COMDAT

; 148  : 	virtual void ChangePlayerTeam( CBasePlayer *pPlayer, const char *pTeamName, BOOL bKill, BOOL bGib ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ChangePlayerTeam@CGameRules@@UAEXPAVCBasePlayer@@PBDHH@Z ENDP ; CGameRules::ChangePlayerTeam
_TEXT	ENDS
;	COMDAT ?SetDefaultPlayerTeam@CGameRules@@UAEPBDPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?SetDefaultPlayerTeam@CGameRules@@UAEPBDPAVCBasePlayer@@@Z PROC NEAR ; CGameRules::SetDefaultPlayerTeam, COMDAT

; 149  : 	virtual const char *SetDefaultPlayerTeam( CBasePlayer *pPlayer ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDefaultPlayerTeam@CGameRules@@UAEPBDPAVCBasePlayer@@@Z ENDP ; CGameRules::SetDefaultPlayerTeam
_TEXT	ENDS
;	COMDAT ?GetTeamID@CHalfLifeMultiplay@@UAEPBDPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?GetTeamID@CHalfLifeMultiplay@@UAEPBDPAVCBaseEntity@@@Z PROC NEAR ; CHalfLifeMultiplay::GetTeamID, COMDAT

; 340  : 	virtual const char *GetTeamID( CBaseEntity *pEntity ) {return "";}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetTeamID@CHalfLifeMultiplay@@UAEPBDPAVCBaseEntity@@@Z ENDP ; CHalfLifeMultiplay::GetTeamID
_TEXT	ENDS
;	COMDAT ?PlayTextureSounds@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?PlayTextureSounds@CHalfLifeMultiplay@@UAEHXZ PROC NEAR	; CHalfLifeMultiplay::PlayTextureSounds, COMDAT

; 343  : 	virtual BOOL PlayTextureSounds( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayTextureSounds@CHalfLifeMultiplay@@UAEHXZ ENDP	; CHalfLifeMultiplay::PlayTextureSounds
_TEXT	ENDS
;	COMDAT ?EndMultiplayerGame@CHalfLifeMultiplay@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?EndMultiplayerGame@CHalfLifeMultiplay@@UAEXXZ PROC NEAR ; CHalfLifeMultiplay::EndMultiplayerGame, COMDAT

; 350  : 	virtual void EndMultiplayerGame( void ) { GoToIntermission(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+244]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EndMultiplayerGame@CHalfLifeMultiplay@@UAEXXZ ENDP	; CHalfLifeMultiplay::EndMultiplayerGame
_TEXT	ENDS
PUBLIC	?UpdateGameMode@CGameRules@@UAEXPAVCBasePlayer@@@Z ; CGameRules::UpdateGameMode
PUBLIC	?FPlayerCanTakeDamage@CGameRules@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z ; CGameRules::FPlayerCanTakeDamage
PUBLIC	?AllowAutoTargetCrosshair@CGameRules@@UAEHXZ	; CGameRules::AllowAutoTargetCrosshair
PUBLIC	?ClientCommand@CGameRules@@UAEHPAVCBasePlayer@@PBD@Z ; CGameRules::ClientCommand
PUBLIC	?FlHEVChargerRechargeTime@CGameRules@@UAEMXZ	; CGameRules::FlHEVChargerRechargeTime
PUBLIC	?PlayTextureSounds@CGameRules@@UAEHXZ		; CGameRules::PlayTextureSounds
PUBLIC	?PlayFootstepSounds@CGameRules@@UAEHPAVCBasePlayer@@M@Z ; CGameRules::PlayFootstepSounds
PUBLIC	?EndMultiplayerGame@CGameRules@@UAEXXZ		; CGameRules::EndMultiplayerGame
PUBLIC	??_7CGameRules@@6B@				; CGameRules::`vftable'
EXTRN	?GetPlayerSpawnSpot@CGameRules@@UAEPAUedict_s@@PAVCBasePlayer@@@Z:NEAR ; CGameRules::GetPlayerSpawnSpot
EXTRN	?CanHavePlayerItem@CGameRules@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z:NEAR ; CGameRules::CanHavePlayerItem
EXTRN	__purecall:NEAR
EXTRN	?RefreshSkillData@CGameRules@@UAEXXZ:NEAR	; CGameRules::RefreshSkillData
;	COMDAT ??_7CGameRules@@6B@
CONST	SEGMENT
??_7CGameRules@@6B@ DD FLAT:?RefreshSkillData@CGameRules@@UAEXXZ ; CGameRules::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?IsTeamplay@CGameRules@@UAEHXZ
	DD	FLAT:__purecall
	DD	FLAT:?GetGameDescription@CGameRules@@UAEPBDXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?UpdateGameMode@CGameRules@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:__purecall
	DD	FLAT:?FPlayerCanTakeDamage@CGameRules@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z
	DD	FLAT:?ShouldAutoAim@CGameRules@@UAEHPAVCBasePlayer@@PAUedict_s@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?GetPlayerSpawnSpot@CGameRules@@UAEPAUedict_s@@PAVCBasePlayer@@@Z
	DD	FLAT:?AllowAutoTargetCrosshair@CGameRules@@UAEHXZ
	DD	FLAT:?ClientCommand@CGameRules@@UAEHPAVCBasePlayer@@PBD@Z
	DD	FLAT:?ClientUserInfoChanged@CGameRules@@UAEXPAVCBasePlayer@@PAD@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?CanHavePlayerItem@CGameRules@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?CanHaveAmmo@CGameRules@@UAEHPAVCBasePlayer@@PBDH@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?FlHEVChargerRechargeTime@CGameRules@@UAEMXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?GetTeamIndex@CGameRules@@UAEHPBD@Z
	DD	FLAT:?GetIndexedTeamName@CGameRules@@UAEPBDH@Z
	DD	FLAT:?IsValidTeam@CGameRules@@UAEHPBD@Z
	DD	FLAT:?ChangePlayerTeam@CGameRules@@UAEXPAVCBasePlayer@@PBDHH@Z
	DD	FLAT:?SetDefaultPlayerTeam@CGameRules@@UAEPBDPAVCBasePlayer@@@Z
	DD	FLAT:?PlayTextureSounds@CGameRules@@UAEHXZ
	DD	FLAT:?PlayFootstepSounds@CGameRules@@UAEHPAVCBasePlayer@@M@Z
	DD	FLAT:__purecall
	DD	FLAT:?EndMultiplayerGame@CGameRules@@UAEXXZ
CONST	ENDS
;	COMDAT ??0CGameRules@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CGameRules@@QAE@XZ PROC NEAR				; CGameRules::CGameRules, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CGameRules@@6B@ ; CGameRules::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CGameRules@@QAE@XZ ENDP				; CGameRules::CGameRules
_TEXT	ENDS
;	COMDAT ?UpdateGameMode@CGameRules@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?UpdateGameMode@CGameRules@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CGameRules::UpdateGameMode, COMDAT

; 81   : 	virtual void UpdateGameMode( CBasePlayer *pPlayer ) {}  // the client needs to be informed of the current game mode

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateGameMode@CGameRules@@UAEXPAVCBasePlayer@@@Z ENDP	; CGameRules::UpdateGameMode
_TEXT	ENDS
;	COMDAT ?FPlayerCanTakeDamage@CGameRules@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?FPlayerCanTakeDamage@CGameRules@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z PROC NEAR ; CGameRules::FPlayerCanTakeDamage, COMDAT

; 85   : 	virtual BOOL  FPlayerCanTakeDamage( CBasePlayer *pPlayer, CBaseEntity *pAttacker ) {return TRUE;};// can this player take damage from this attacker?

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FPlayerCanTakeDamage@CGameRules@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z ENDP ; CGameRules::FPlayerCanTakeDamage
_TEXT	ENDS
;	COMDAT ?AllowAutoTargetCrosshair@CGameRules@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?AllowAutoTargetCrosshair@CGameRules@@UAEHXZ PROC NEAR	; CGameRules::AllowAutoTargetCrosshair, COMDAT

; 95   : 	virtual BOOL AllowAutoTargetCrosshair( void ) { return TRUE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllowAutoTargetCrosshair@CGameRules@@UAEHXZ ENDP	; CGameRules::AllowAutoTargetCrosshair
_TEXT	ENDS
;	COMDAT ?ClientCommand@CGameRules@@UAEHPAVCBasePlayer@@PBD@Z
_TEXT	SEGMENT
_this$ = -4
?ClientCommand@CGameRules@@UAEHPAVCBasePlayer@@PBD@Z PROC NEAR ; CGameRules::ClientCommand, COMDAT

; 96   : 	virtual BOOL ClientCommand( CBasePlayer *pPlayer, const char *pcmd ) { return FALSE; };  // handles the user commands;  returns TRUE if command handled properly

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ClientCommand@CGameRules@@UAEHPAVCBasePlayer@@PBD@Z ENDP ; CGameRules::ClientCommand
_TEXT	ENDS
PUBLIC	__real@4@00000000000000000000
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\gamerules.h
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?FlHEVChargerRechargeTime@CGameRules@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?FlHEVChargerRechargeTime@CGameRules@@UAEMXZ PROC NEAR	; CGameRules::FlHEVChargerRechargeTime, COMDAT

; 134  : 	virtual float FlHEVChargerRechargeTime( void ) { return 0; }// how long until a depleted HealthCharger recharges itself?

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlHEVChargerRechargeTime@CGameRules@@UAEMXZ ENDP	; CGameRules::FlHEVChargerRechargeTime
_TEXT	ENDS
;	COMDAT ?PlayTextureSounds@CGameRules@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?PlayTextureSounds@CGameRules@@UAEHXZ PROC NEAR		; CGameRules::PlayTextureSounds, COMDAT

; 152  : 	virtual BOOL PlayTextureSounds( void ) { return TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayTextureSounds@CGameRules@@UAEHXZ ENDP		; CGameRules::PlayTextureSounds
_TEXT	ENDS
;	COMDAT ?PlayFootstepSounds@CGameRules@@UAEHPAVCBasePlayer@@M@Z
_TEXT	SEGMENT
_this$ = -4
?PlayFootstepSounds@CGameRules@@UAEHPAVCBasePlayer@@M@Z PROC NEAR ; CGameRules::PlayFootstepSounds, COMDAT

; 153  : 	virtual BOOL PlayFootstepSounds( CBasePlayer *pl, float fvol ) { return TRUE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PlayFootstepSounds@CGameRules@@UAEHPAVCBasePlayer@@M@Z ENDP ; CGameRules::PlayFootstepSounds
_TEXT	ENDS
;	COMDAT ?EndMultiplayerGame@CGameRules@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?EndMultiplayerGame@CGameRules@@UAEXXZ PROC NEAR	; CGameRules::EndMultiplayerGame, COMDAT

; 159  : 	virtual void EndMultiplayerGame( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EndMultiplayerGame@CGameRules@@UAEXXZ ENDP		; CGameRules::EndMultiplayerGame
_TEXT	ENDS
;	COMDAT ?ClientCommand@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PBD@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_pcmd$ = 12
_this$ = -4
?ClientCommand@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PBD@Z PROC NEAR ; CHalfLifeMultiplay::ClientCommand, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 	return CGameRules::ClientCommand(pPlayer, pcmd);

	mov	eax, DWORD PTR _pcmd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClientCommand@CGameRules@@UAEHPAVCBasePlayer@@PBD@Z ; CGameRules::ClientCommand

; 97   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ClientCommand@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PBD@Z ENDP ; CHalfLifeMultiplay::ClientCommand
_TEXT	ENDS
EXTRN	?gSkillData@@3Uskilldata_t@@A:BYTE		; gSkillData
;	COMDAT ?RefreshSkillData@CHalfLifeMultiplay@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RefreshSkillData@CHalfLifeMultiplay@@UAEXXZ PROC NEAR	; CHalfLifeMultiplay::RefreshSkillData, COMDAT

; 102  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 103  : // load all default values
; 104  : 	CGameRules::RefreshSkillData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RefreshSkillData@CGameRules@@UAEXXZ	; CGameRules::RefreshSkillData

; 105  : 
; 106  : // override some values for multiplay.
; 107  : 
; 108  : 	// suitcharger
; 109  : 	gSkillData.suitchargerCapacity = 30;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+280, 1106247680 ; 41f00000H

; 110  : 
; 111  : 	// Crowbar whack
; 112  : 	gSkillData.plrDmgCrowbar = 25;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+200, 1103626240 ; 41c80000H

; 113  : 
; 114  : 	// Glock Round
; 115  : 	gSkillData.plrDmg9MM = 12;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+204, 1094713344 ; 41400000H

; 116  : 
; 117  : 	// 357 Round
; 118  : 	gSkillData.plrDmg357 = 40;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+208, 1109393408 ; 42200000H

; 119  : 
; 120  : 	// MP5 Round
; 121  : 	gSkillData.plrDmgMP5 = 12;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+212, 1094713344 ; 41400000H

; 122  : 
; 123  : 	// M203 grenade
; 124  : 	gSkillData.plrDmgM203Grenade = 100;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+216, 1120403456 ; 42c80000H

; 125  : 
; 126  : 	// Shotgun buckshot
; 127  : 	gSkillData.plrDmgBuckshot = 20;// fewer pellets in deathmatch

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+220, 1101004800 ; 41a00000H

; 128  : 
; 129  : 	// Crossbow
; 130  : 	gSkillData.plrDmgCrossbowClient = 20;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+224, 1101004800 ; 41a00000H

; 131  : 
; 132  : 	// RPG
; 133  : 	gSkillData.plrDmgRPG = 120;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+232, 1123024896 ; 42f00000H

; 134  : 
; 135  : 	// Egon
; 136  : 	gSkillData.plrDmgEgonWide = 20;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+244, 1101004800 ; 41a00000H

; 137  : 	gSkillData.plrDmgEgonNarrow = 10;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+240, 1092616192 ; 41200000H

; 138  : 
; 139  : 	// Hand Grendade
; 140  : 	gSkillData.plrDmgHandGrenade = 100;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+252, 1120403456 ; 42c80000H

; 141  : 
; 142  : 	// Satchel Charge
; 143  : 	gSkillData.plrDmgSatchel = 120;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+256, 1123024896 ; 42f00000H

; 144  : 
; 145  : 	// Tripmine
; 146  : 	gSkillData.plrDmgTripmine = 150;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+260, 1125515264 ; 43160000H

; 147  : 
; 148  : 	// hornet
; 149  : 	gSkillData.plrDmgHornet = 10;

	mov	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+248, 1092616192 ; 41200000H

; 150  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RefreshSkillData@CHalfLifeMultiplay@@UAEXXZ ENDP	; CHalfLifeMultiplay::RefreshSkillData
_TEXT	ENDS
PUBLIC	??_C@_0M@KANF@mp_chattime?$AA@			; `string'
PUBLIC	??_C@_01FBAH@1?$AA@				; `string'
PUBLIC	??_C@_02JAFN@?$CFi?$AA@				; `string'
PUBLIC	__real@4@4005f000000000000000
PUBLIC	__real@4@4004f000000000000000
EXTRN	?UTIL_VarArgs@@YAPADPADZZ:NEAR			; UTIL_VarArgs
EXTRN	?UTIL_dtos1@@YAPADH@Z:NEAR			; UTIL_dtos1
EXTRN	?fraglimit@@3Ucvar_s@@A:BYTE			; fraglimit
EXTRN	?timelimit@@3Ucvar_s@@A:BYTE			; timelimit
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?g_fGameOver@@3HA:DWORD				; g_fGameOver
EXTRN	?timeleft@@3Ucvar_s@@A:BYTE			; timeleft
EXTRN	?fragsleft@@3Ucvar_s@@A:BYTE			; fragsleft
EXTRN	?mp_chattime@@3Ucvar_s@@A:BYTE			; mp_chattime
EXTRN	__ftol:NEAR
EXTRN	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z:NEAR	; UTIL_PlayerByIndex
_BSS	SEGMENT
_?last_frags@?1??Think@CHalfLifeMultiplay@@UAEXXZ@4HA DD 01H DUP (?)
_?last_time@?1??Think@CHalfLifeMultiplay@@UAEXXZ@4HA DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@KANF@mp_chattime?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_0M@KANF@mp_chattime?$AA@ DB 'mp_chattime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT
??_C@_01FBAH@1?$AA@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JAFN@?$CFi?$AA@
CONST	SEGMENT
??_C@_02JAFN@?$CFi?$AA@ DB '%i', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4@4005f000000000000000
CONST	SEGMENT
__real@4@4005f000000000000000 DD 042f00000r	; 120
CONST	ENDS
;	COMDAT __real@4@4004f000000000000000
CONST	SEGMENT
__real@4@4004f000000000000000 DD 042700000r	; 60
CONST	ENDS
;	COMDAT ?Think@CHalfLifeMultiplay@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_frags_remaining$ = -8
_time_remaining$ = -12
_time$38571 = -16
_flTimeLimit$ = -20
_flFragLimit$ = -24
_bestfrags$38586 = -28
_remain$38587 = -32
_i$38588 = -36
_pPlayer$38592 = -40
?Think@CHalfLifeMultiplay@@UAEXXZ PROC NEAR		; CHalfLifeMultiplay::Think, COMDAT

; 162  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 	///// Check game rules /////
; 164  : 	static int last_frags;
; 165  : 	static int last_time;
; 166  : 
; 167  : 	int frags_remaining = 0;

	mov	DWORD PTR _frags_remaining$[ebp], 0

; 168  : 	int time_remaining = 0;

	mov	DWORD PTR _time_remaining$[ebp], 0

; 169  : 
; 170  : 	if ( g_fGameOver )   // someone else quit the game already

	cmp	DWORD PTR ?g_fGameOver@@3HA, 0		; g_fGameOver
	je	$L38570

; 172  : 		// bounds check
; 173  : 		int time = (int)CVAR_GET_FLOAT( "mp_chattime" );

	push	OFFSET FLAT:??_C@_0M@KANF@mp_chattime?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	call	__ftol
	mov	DWORD PTR _time$38571[ebp], eax

; 174  : 		if ( time < 1 )

	cmp	DWORD PTR _time$38571[ebp], 1
	jge	SHORT $L38574

; 175  : 			CVAR_SET_STRING( "mp_chattime", "1" );

	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0M@KANF@mp_chattime?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+240
	add	esp, 8

; 176  : 		else if ( time > MAX_INTERMISSION_TIME )

	jmp	SHORT $L38577
$L38574:
	cmp	DWORD PTR _time$38571[ebp], 120		; 00000078H
	jle	SHORT $L38577

; 177  : 			CVAR_SET_STRING( "mp_chattime", UTIL_dtos1( MAX_INTERMISSION_TIME ) );

	push	120					; 00000078H
	call	?UTIL_dtos1@@YAPADH@Z			; UTIL_dtos1
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0M@KANF@mp_chattime?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+240
	add	esp, 8
$L38577:

; 178  : 
; 179  : 		m_flIntermissionEndTime = g_flIntermissionStartTime + mp_chattime.value;

	fld	DWORD PTR ?g_flIntermissionStartTime@@3MA ; g_flIntermissionStartTime
	fadd	DWORD PTR ?mp_chattime@@3Ucvar_s@@A+12
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 180  : 
; 181  : 		// check to see if we should change levels now
; 182  : 		if ( m_flIntermissionEndTime < gpGlobals->time )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+4]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38579

; 185  : 				|| ( ( g_flIntermissionStartTime + MAX_INTERMISSION_TIME ) < gpGlobals->time) ) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L38580
	fld	DWORD PTR ?g_flIntermissionStartTime@@3MA ; g_flIntermissionStartTime
	fadd	DWORD PTR __real@4@4005f000000000000000
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38579
$L38580:

; 186  : 				ChangeLevel(); // intermission is over

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+240]
$L38579:

; 188  : 
; 189  : 		return;

	jmp	$L38563
$L38570:

; 191  : 
; 192  : 	float flTimeLimit = timelimit.value * 60;

	fld	DWORD PTR ?timelimit@@3Ucvar_s@@A+12
	fmul	DWORD PTR __real@4@4004f000000000000000
	fstp	DWORD PTR _flTimeLimit$[ebp]

; 193  : 	float flFragLimit = fraglimit.value;

	mov	ecx, DWORD PTR ?fraglimit@@3Ucvar_s@@A+12
	mov	DWORD PTR _flFragLimit$[ebp], ecx

; 194  : 
; 195  : 	time_remaining = (int)(flTimeLimit ? ( flTimeLimit - gpGlobals->time ) : 0);

	fld	DWORD PTR _flTimeLimit$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39645
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _flTimeLimit$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR -44+[ebp]
	jmp	SHORT $L39646
$L39645:
	mov	DWORD PTR -44+[ebp], 0
$L39646:
	fld	DWORD PTR -44+[ebp]
	call	__ftol
	mov	DWORD PTR _time_remaining$[ebp], eax

; 196  : 	
; 197  : 	if ( flTimeLimit != 0 && gpGlobals->time >= flTimeLimit )

	fld	DWORD PTR _flTimeLimit$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38584
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR _flTimeLimit$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38584

; 199  : 		GoToIntermission();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+244]

; 200  : 		return;

	jmp	$L38563
$L38584:

; 202  : 
; 203  : 	if ( flFragLimit )

	fld	DWORD PTR _flFragLimit$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L38585

; 205  : 		int bestfrags = 9999;

	mov	DWORD PTR _bestfrags$38586[ebp], 9999	; 0000270fH

; 206  : 		int remain;
; 207  : 
; 208  : 		// check if any player is over the frag limit
; 209  : 		for ( int i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$38588[ebp], 1
	jmp	SHORT $L38589
$L38590:
	mov	eax, DWORD PTR _i$38588[ebp]
	add	eax, 1
	mov	DWORD PTR _i$38588[ebp], eax
$L38589:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$38588[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L38591

; 211  : 			CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$38588[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$38592[ebp], eax

; 212  : 
; 213  : 			if ( pPlayer && pPlayer->pev->frags >= flFragLimit )

	cmp	DWORD PTR _pPlayer$38592[ebp], 0
	je	SHORT $L38593
	mov	ecx, DWORD PTR _pPlayer$38592[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+356]
	fcomp	DWORD PTR _flFragLimit$[ebp]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L38593

; 215  : 				GoToIntermission();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+244]

; 216  : 				return;

	jmp	$L38563
$L38593:

; 218  : 
; 219  : 
; 220  : 			if ( pPlayer )

	cmp	DWORD PTR _pPlayer$38592[ebp], 0
	je	SHORT $L38595

; 222  : 				remain = flFragLimit - pPlayer->pev->frags;

	mov	eax, DWORD PTR _pPlayer$38592[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR _flFragLimit$[ebp]
	fsub	DWORD PTR [ecx+356]
	call	__ftol
	mov	DWORD PTR _remain$38587[ebp], eax

; 223  : 				if ( remain < bestfrags )

	mov	edx, DWORD PTR _remain$38587[ebp]
	cmp	edx, DWORD PTR _bestfrags$38586[ebp]
	jge	SHORT $L38595

; 225  : 					bestfrags = remain;

	mov	eax, DWORD PTR _remain$38587[ebp]
	mov	DWORD PTR _bestfrags$38586[ebp], eax
$L38595:

; 228  : 
; 229  : 		}

	jmp	$L38590
$L38591:

; 230  : 		frags_remaining = bestfrags;

	mov	ecx, DWORD PTR _bestfrags$38586[ebp]
	mov	DWORD PTR _frags_remaining$[ebp], ecx
$L38585:

; 232  : 
; 233  : 	// Updates when frags change
; 234  : 	if ( frags_remaining != last_frags )

	mov	edx, DWORD PTR _frags_remaining$[ebp]
	cmp	edx, DWORD PTR _?last_frags@?1??Think@CHalfLifeMultiplay@@UAEXXZ@4HA
	je	SHORT $L38596

; 236  : 		g_engfuncs.pfnCvar_DirectSet( &fragsleft, UTIL_VarArgs( "%i", frags_remaining ) );

	mov	eax, DWORD PTR _frags_remaining$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02JAFN@?$CFi?$AA@	; `string'
	call	?UTIL_VarArgs@@YAPADPADZZ		; UTIL_VarArgs
	add	esp, 8
	push	eax
	push	OFFSET FLAT:?fragsleft@@3Ucvar_s@@A	; fragsleft
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+548
	add	esp, 8
$L38596:

; 238  : 
; 239  : 	// Updates once per second
; 240  : 	if ( timeleft.value != last_time )

	fild	DWORD PTR _?last_time@?1??Think@CHalfLifeMultiplay@@UAEXXZ@4HA
	fcomp	DWORD PTR ?timeleft@@3Ucvar_s@@A+12
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L38598

; 242  : 		g_engfuncs.pfnCvar_DirectSet( &timeleft, UTIL_VarArgs( "%i", time_remaining ) );

	mov	ecx, DWORD PTR _time_remaining$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02JAFN@?$CFi?$AA@	; `string'
	call	?UTIL_VarArgs@@YAPADPADZZ		; UTIL_VarArgs
	add	esp, 8
	push	eax
	push	OFFSET FLAT:?timeleft@@3Ucvar_s@@A	; timeleft
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+548
	add	esp, 8
$L38598:

; 244  : 
; 245  : 	last_frags = frags_remaining;

	mov	edx, DWORD PTR _frags_remaining$[ebp]
	mov	DWORD PTR _?last_frags@?1??Think@CHalfLifeMultiplay@@UAEXXZ@4HA, edx

; 246  : 	last_time  = time_remaining;

	mov	eax, DWORD PTR _time_remaining$[ebp]
	mov	DWORD PTR _?last_time@?1??Think@CHalfLifeMultiplay@@UAEXXZ@4HA, eax
$L38563:

; 247  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CHalfLifeMultiplay@@UAEXXZ ENDP			; CHalfLifeMultiplay::Think
_TEXT	ENDS
;	COMDAT ?IsMultiplayer@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMultiplayer@CHalfLifeMultiplay@@UAEHXZ PROC NEAR	; CHalfLifeMultiplay::IsMultiplayer, COMDAT

; 253  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 254  : 	return TRUE;

	mov	eax, 1

; 255  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMultiplayer@CHalfLifeMultiplay@@UAEHXZ ENDP		; CHalfLifeMultiplay::IsMultiplayer
_TEXT	ENDS
;	COMDAT ?IsDeathmatch@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsDeathmatch@CHalfLifeMultiplay@@UAEHXZ PROC NEAR	; CHalfLifeMultiplay::IsDeathmatch, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 261  : 	return TRUE;

	mov	eax, 1

; 262  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDeathmatch@CHalfLifeMultiplay@@UAEHXZ ENDP		; CHalfLifeMultiplay::IsDeathmatch
_TEXT	ENDS
;	COMDAT ?IsCoOp@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCoOp@CHalfLifeMultiplay@@UAEHXZ PROC NEAR		; CHalfLifeMultiplay::IsCoOp, COMDAT

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 268  : 	return gpGlobals->coop;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+24]
	call	__ftol

; 269  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCoOp@CHalfLifeMultiplay@@UAEHXZ ENDP			; CHalfLifeMultiplay::IsCoOp
_TEXT	ENDS
PUBLIC	?iWeight@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iWeight
;	COMDAT ?FShouldSwitchWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_pWeapon$ = 12
_this$ = -4
?FShouldSwitchWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::FShouldSwitchWeapon, COMDAT

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 275  : 	if ( !pWeapon->CanDeploy() )

	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	DWORD PTR [edx+356]
	test	eax, eax
	jne	SHORT $L38616

; 277  : 		// that weapon can't deploy anyway.
; 278  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38615
$L38616:

; 280  : 
; 281  : 	if ( !pPlayer->m_pActiveItem )

	mov	eax, DWORD PTR _pPlayer$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	jne	SHORT $L38617

; 283  : 		// player doesn't have an active item!
; 284  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38615
$L38617:

; 286  : 
; 287  : 	if ( !pPlayer->m_pActiveItem->CanHolster() )

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+364]
	test	eax, eax
	jne	SHORT $L38618

; 289  : 		// can't put away the active item.
; 290  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38615
$L38618:

; 292  : 
; 293  : 	if ( pWeapon->iWeight() > pPlayer->m_pActiveItem->iWeight() )

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?iWeight@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iWeight
	mov	esi, eax
	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	call	?iWeight@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iWeight
	cmp	esi, eax
	jle	SHORT $L38619

; 295  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L38615
$L38619:

; 297  : 
; 298  : 	return FALSE;

	xor	eax, eax
$L38615:

; 299  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FShouldSwitchWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::FShouldSwitchWeapon
_TEXT	ENDS
EXTRN	?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A:BYTE ; CBasePlayerItem::ItemInfoArray
;	COMDAT ?iWeight@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?iWeight@CBasePlayerItem@@QAEHXZ PROC NEAR		; CBasePlayerItem::iWeight, COMDAT

; 274  : 	int		iWeight( void )	{ return ItemInfoArray[ m_iId ].iWeight; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+40]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?iWeight@CBasePlayerItem@@QAEHXZ ENDP			; CBasePlayerItem::iWeight
_TEXT	ENDS
EXTRN	?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z:NEAR ; CBasePlayer::SwitchWeapon
;	COMDAT ?GetNextBestWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_pCurrentWeapon$ = 12
_this$ = -4
_pCheck$ = -8
_pBest$ = -12
_iBestWeight$ = -16
_i$ = -20
?GetNextBestWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::GetNextBestWeapon, COMDAT

; 302  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 303  : 	CBasePlayerItem *pCheck;
; 304  : 	CBasePlayerItem *pBest;// this will be used in the event that we don't find a weapon in the same category.
; 305  : 	int iBestWeight;
; 306  : 	int i;
; 307  : 
; 308  : 	iBestWeight = -1;// no weapon lower than -1 can be autoswitched to

	mov	DWORD PTR _iBestWeight$[ebp], -1

; 309  : 	pBest = NULL;

	mov	DWORD PTR _pBest$[ebp], 0

; 310  : 
; 311  : 	if ( !pCurrentWeapon->CanHolster() )

	mov	eax, DWORD PTR _pCurrentWeapon$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pCurrentWeapon$[ebp]
	call	DWORD PTR [edx+364]
	test	eax, eax
	jne	SHORT $L38629

; 313  : 		// can't put this gun away right now, so can't switch.
; 314  : 		return FALSE;

	xor	eax, eax
	jmp	$L38624
$L38629:

; 316  : 
; 317  : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L38630
$L38631:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L38630:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$L38632

; 319  : 		pCheck = pPlayer->m_rgpPlayerItems[ i ];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pPlayer$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+2956]
	mov	DWORD PTR _pCheck$[ebp], eax
$L38634:

; 320  : 
; 321  : 		while ( pCheck )

	cmp	DWORD PTR _pCheck$[ebp], 0
	je	$L38635

; 323  : 			if ( pCheck->iWeight() > -1 && pCheck->iWeight() == pCurrentWeapon->iWeight() && pCheck != pCurrentWeapon )

	mov	ecx, DWORD PTR _pCheck$[ebp]
	call	?iWeight@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iWeight
	cmp	eax, -1
	jle	SHORT $L38636
	mov	ecx, DWORD PTR _pCheck$[ebp]
	call	?iWeight@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iWeight
	mov	esi, eax
	mov	ecx, DWORD PTR _pCurrentWeapon$[ebp]
	call	?iWeight@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iWeight
	cmp	esi, eax
	jne	SHORT $L38636
	mov	ecx, DWORD PTR _pCheck$[ebp]
	cmp	ecx, DWORD PTR _pCurrentWeapon$[ebp]
	je	SHORT $L38636

; 325  : 				// this weapon is from the same category. 
; 326  : 				if ( pCheck->CanDeploy() )

	mov	edx, DWORD PTR _pCheck$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pCheck$[ebp]
	call	DWORD PTR [eax+356]
	test	eax, eax
	je	SHORT $L38638

; 328  : 					if ( pPlayer->SwitchWeapon( pCheck ) )

	mov	ecx, DWORD PTR _pCheck$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::SwitchWeapon
	test	eax, eax
	je	SHORT $L38638

; 330  : 						return TRUE;

	mov	eax, 1
	jmp	SHORT $L38624
$L38638:

; 334  : 			else if ( pCheck->iWeight() > iBestWeight && pCheck != pCurrentWeapon )// don't reselect the weapon we're trying to get rid of

	jmp	SHORT $L38641
$L38636:
	mov	ecx, DWORD PTR _pCheck$[ebp]
	call	?iWeight@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iWeight
	cmp	eax, DWORD PTR _iBestWeight$[ebp]
	jle	SHORT $L38641
	mov	edx, DWORD PTR _pCheck$[ebp]
	cmp	edx, DWORD PTR _pCurrentWeapon$[ebp]
	je	SHORT $L38641

; 336  : 				//ALERT ( at_console, "Considering %s\n", STRING( pCheck->pev->classname ) );
; 337  : 				// we keep updating the 'best' weapon just in case we can't find a weapon of the same weight
; 338  : 				// that the player was using. This will end up leaving the player with his heaviest-weighted 
; 339  : 				// weapon. 
; 340  : 				if ( pCheck->CanDeploy() )

	mov	eax, DWORD PTR _pCheck$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pCheck$[ebp]
	call	DWORD PTR [edx+356]
	test	eax, eax
	je	SHORT $L38641

; 342  : 					// if this weapon is useable, flag it as the best
; 343  : 					iBestWeight = pCheck->iWeight();

	mov	ecx, DWORD PTR _pCheck$[ebp]
	call	?iWeight@CBasePlayerItem@@QAEHXZ	; CBasePlayerItem::iWeight
	mov	DWORD PTR _iBestWeight$[ebp], eax

; 344  : 					pBest = pCheck;

	mov	eax, DWORD PTR _pCheck$[ebp]
	mov	DWORD PTR _pBest$[ebp], eax
$L38641:

; 347  : 
; 348  : 			pCheck = pCheck->m_pNext;

	mov	ecx, DWORD PTR _pCheck$[ebp]
	mov	edx, DWORD PTR [ecx+1820]
	mov	DWORD PTR _pCheck$[ebp], edx

; 349  : 		}

	jmp	$L38634
$L38635:

; 350  : 	}

	jmp	$L38631
$L38632:

; 351  : 
; 352  : 	// if we make it here, we've checked all the weapons and found no useable 
; 353  : 	// weapon in the same catagory as the current weapon. 
; 354  : 	
; 355  : 	// if pBest is null, we didn't find ANYTHING. Shouldn't be possible- should always 
; 356  : 	// at least get the crowbar, but ya never know.
; 357  : 	if ( !pBest )

	cmp	DWORD PTR _pBest$[ebp], 0
	jne	SHORT $L38642

; 359  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38624
$L38642:

; 361  : 
; 362  : 	pPlayer->SwitchWeapon( pBest );

	mov	eax, DWORD PTR _pBest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::SwitchWeapon

; 363  : 
; 364  : 	return TRUE;

	mov	eax, 1
$L38624:

; 365  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetNextBestWeapon@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::GetNextBestWeapon
_TEXT	ENDS
;	COMDAT ?ClientConnected@CHalfLifeMultiplay@@UAEHPAUedict_s@@PBD1QAD@Z
_TEXT	SEGMENT
_this$ = -4
?ClientConnected@CHalfLifeMultiplay@@UAEHPAUedict_s@@PBD1QAD@Z PROC NEAR ; CHalfLifeMultiplay::ClientConnected, COMDAT

; 370  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 371  : 	return TRUE;

	mov	eax, 1

; 372  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ClientConnected@CHalfLifeMultiplay@@UAEHPAUedict_s@@PBD1QAD@Z ENDP ; CHalfLifeMultiplay::ClientConnected
_TEXT	ENDS
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?gmsgGameMode@@3HA:DWORD			; gmsgGameMode
;	COMDAT ?UpdateGameMode@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
?UpdateGameMode@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::UpdateGameMode, COMDAT

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 379  : 	MESSAGE_BEGIN( MSG_ONE, gmsgGameMode, NULL, pPlayer->edict() );

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	eax, DWORD PTR ?gmsgGameMode@@3HA	; gmsgGameMode
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 380  : 		WRITE_BYTE( 0 );  // game mode none

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 381  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UpdateGameMode@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::UpdateGameMode
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?SendMOTDToClient@CHalfLifeMultiplay@@IAEXPAUedict_s@@@Z ; CHalfLifeMultiplay::SendMOTDToClient
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
PUBLIC	??_C@_0M@PCGH@unconnected?$AA@			; `string'
PUBLIC	??_C@_0BI@LCMN@?$CFs?5has?5joined?5the?5game?6?$AA@ ; `string'
PUBLIC	??_C@_05LHJL@model?$AA@				; `string'
PUBLIC	??_C@_0CD@KKEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5entered?5the?5gam@ ; `string'
PUBLIC	??_C@_0CD@MOM@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5entered?5the?5gam@ ; `string'
EXTRN	?UTIL_ClientPrintAll@@YAXHPBD0000@Z:NEAR	; UTIL_ClientPrintAll
EXTRN	?UTIL_LogPrintf@@YAXPADZZ:NEAR			; UTIL_LogPrintf
EXTRN	?gmsgScoreInfo@@3HA:DWORD			; gmsgScoreInfo
EXTRN	?g_teamplay@@3HA:DWORD				; g_teamplay
;	COMDAT ??_C@_0M@PCGH@unconnected?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_0M@PCGH@unconnected?$AA@ DB 'unconnected', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LCMN@?$CFs?5has?5joined?5the?5game?6?$AA@
CONST	SEGMENT
??_C@_0BI@LCMN@?$CFs?5has?5joined?5the?5game?6?$AA@ DB '%s has joined the'
	DB	' game', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05LHJL@model?$AA@
CONST	SEGMENT
??_C@_05LHJL@model?$AA@ DB 'model', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KKEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5entered?5the?5gam@
CONST	SEGMENT
??_C@_0CD@KKEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5entered?5the?5gam@ DB '"'
	DB	'%s<%i><%s><%s>" entered the game', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MOM@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5entered?5the?5gam@
CONST	SEGMENT
??_C@_0CD@MOM@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5entered?5the?5gam@ DB '"'
	DB	'%s<%i><%s><%i>" entered the game', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?InitHUD@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pl$ = 8
_this$ = -4
_i$ = -8
_plr$38671 = -12
?InitHUD@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::InitHUD, COMDAT

; 385  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 	// notify other clients of player joining the game
; 387  : 	UTIL_ClientPrintAll( HUD_PRINTNOTIFY, UTIL_VarArgs( "%s has joined the game\n", 
; 388  : 		( pl->pev->netname && STRING(pl->pev->netname)[0] != 0 ) ? STRING(pl->pev->netname) : "unconnected" ) );

	mov	eax, DWORD PTR _pl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+464], 0
	je	SHORT $L39676
	mov	edx, DWORD PTR _pl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $L39676
	mov	eax, DWORD PTR _pl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR -16+[ebp], eax
	jmp	SHORT $L39677
$L39676:
	mov	DWORD PTR -16+[ebp], OFFSET FLAT:??_C@_0M@PCGH@unconnected?$AA@ ; `string'
$L39677:
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR -16+[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BI@LCMN@?$CFs?5has?5joined?5the?5game?6?$AA@ ; `string'
	call	?UTIL_VarArgs@@YAPADPADZZ		; UTIL_VarArgs
	add	esp, 8
	push	eax
	push	1
	call	?UTIL_ClientPrintAll@@YAXHPBD0000@Z	; UTIL_ClientPrintAll
	add	esp, 24					; 00000018H

; 389  : 
; 390  : 	// team match?
; 391  : 	if ( g_teamplay )

	cmp	DWORD PTR ?g_teamplay@@3HA, 0		; g_teamplay
	je	SHORT $L38662

; 393  : 		UTIL_LogPrintf( "\"%s<%i><%s><%s>\" entered the game\n",  
; 394  : 			STRING( pl->pev->netname ), 
; 395  : 			GETPLAYERUSERID( pl->edict() ),
; 396  : 			GETPLAYERAUTHID( pl->edict() ),
; 397  : 			g_engfuncs.pfnInfoKeyValue( g_engfuncs.pfnGetInfoKeyBuffer( pl->edict() ), "model" ) );

	push	OFFSET FLAT:??_C@_05LHJL@model?$AA@	; `string'
	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+424
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CD@KKEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5entered?5the?5gam@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 20					; 00000014H

; 399  : 	else

	jmp	SHORT $L38665
$L38662:

; 401  : 		UTIL_LogPrintf( "\"%s<%i><%s><%i>\" entered the game\n",  
; 402  : 			STRING( pl->pev->netname ), 
; 403  : 			GETPLAYERUSERID( pl->edict() ),
; 404  : 			GETPLAYERAUTHID( pl->edict() ),
; 405  : 			GETPLAYERUSERID( pl->edict() ) );

	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CD@MOM@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5entered?5the?5gam@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 20					; 00000014H
$L38665:

; 407  : 
; 408  : 	UpdateGameMode( pl );

	mov	ecx, DWORD PTR _pl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+56]

; 409  : 
; 410  : 	// sending just one score makes the hud scoreboard active;  otherwise
; 411  : 	// it is just disabled for single play
; 412  : 	MESSAGE_BEGIN( MSG_ONE, gmsgScoreInfo, NULL, pl->edict() );

	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgScoreInfo@@3HA	; gmsgScoreInfo
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 413  : 		WRITE_BYTE( ENTINDEX(pl->edict()) );

	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 414  : 		WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 415  : 		WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 416  : 		WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 417  : 		WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 418  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 419  : 
; 420  : 	SendMOTDToClient( pl->edict() );

	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendMOTDToClient@CHalfLifeMultiplay@@IAEXPAUedict_s@@@Z ; CHalfLifeMultiplay::SendMOTDToClient

; 421  : 
; 422  : 	// loop through all active players and send their score info to the new client
; 423  : 	for ( int i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L38668
$L38669:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L38668:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+144]
	jg	$L38670

; 425  : 		CBasePlayer *plr = (CBasePlayer *)UTIL_PlayerByIndex( i );

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _plr$38671[ebp], eax

; 426  : 
; 427  : 		if( plr )

	cmp	DWORD PTR _plr$38671[ebp], 0
	je	$L38673

; 429  : 			MESSAGE_BEGIN( MSG_ONE, gmsgScoreInfo, NULL, pl->edict() );

	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	eax, DWORD PTR ?gmsgScoreInfo@@3HA	; gmsgScoreInfo
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 430  : 				WRITE_BYTE( i ); // client number

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 431  : 				WRITE_SHORT( plr->pev->frags );

	mov	edx, DWORD PTR _plr$38671[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+356]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 432  : 				WRITE_SHORT( plr->m_iDeaths );

	mov	ecx, DWORD PTR _plr$38671[ebp]
	mov	edx, DWORD PTR [ecx+3780]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 433  : 				WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 434  : 				WRITE_SHORT( GetTeamIndex( plr->m_szTeamName ) + 1 );

	mov	eax, DWORD PTR _plr$38671[ebp]
	add	eax, 3804				; 00000edcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	add	eax, 1
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 435  : 			MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L38673:

; 437  : 	}

	jmp	$L38669
$L38670:

; 438  : 
; 439  : 	if ( g_fGameOver )

	cmp	DWORD PTR ?g_fGameOver@@3HA, 0		; g_fGameOver
	je	SHORT $L38674

; 441  : 		MESSAGE_BEGIN( MSG_ONE, SVC_INTERMISSION, NULL, pl->edict() );

	mov	ecx, DWORD PTR _pl$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	push	30					; 0000001eH
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 442  : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L38674:

; 444  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?InitHUD@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::InitHUD
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
?ENTINDEX@@YAHPAUedict_s@@@Z PROC NEAR			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
PUBLIC	??_C@_0BB@FGI@game_playerleave?$AA@		; `string'
PUBLIC	??_C@_0BP@KLEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5disconnected?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@KABK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5disconnected?6?$AA@ ; `string'
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
EXTRN	?RemoveAllItems@CBasePlayer@@QAEXHH@Z:NEAR	; CBasePlayer::RemoveAllItems
EXTRN	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ??_C@_0BB@FGI@game_playerleave?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_0BB@FGI@game_playerleave?$AA@ DB 'game_playerleave', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KLEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5disconnected?6?$AA@
CONST	SEGMENT
??_C@_0BP@KLEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5disconnected?6?$AA@ DB '"'
	DB	'%s<%i><%s><%s>" disconnected', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KABK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5disconnected?6?$AA@
CONST	SEGMENT
??_C@_0BP@KABK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5disconnected?6?$AA@ DB '"'
	DB	'%s<%i><%s><%i>" disconnected', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?ClientDisconnected@CHalfLifeMultiplay@@UAEXPAUedict_s@@@Z
_TEXT	SEGMENT
_pClient$ = 8
_this$ = -4
_pPlayer$38680 = -8
?ClientDisconnected@CHalfLifeMultiplay@@UAEXPAUedict_s@@@Z PROC NEAR ; CHalfLifeMultiplay::ClientDisconnected, COMDAT

; 449  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 	if ( pClient )

	cmp	DWORD PTR _pClient$[ebp], 0
	je	$L38682

; 452  : 		CBasePlayer *pPlayer = (CBasePlayer *)CBaseEntity::Instance( pClient );

	mov	eax, DWORD PTR _pClient$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pPlayer$38680[ebp], eax

; 453  : 
; 454  : 		if ( pPlayer )

	cmp	DWORD PTR _pPlayer$38680[ebp], 0
	je	$L38682

; 456  : 			UTIL_FireTargets( "game_playerleave", pPlayer, pPlayer, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$38680[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@FGI@game_playerleave?$AA@ ; `string'
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 457  : 
; 458  : 			// team match?
; 459  : 			if ( g_teamplay )

	cmp	DWORD PTR ?g_teamplay@@3HA, 0		; g_teamplay
	je	SHORT $L38684

; 461  : 				UTIL_LogPrintf( "\"%s<%i><%s><%s>\" disconnected\n",  
; 462  : 					STRING( pPlayer->pev->netname ), 
; 463  : 					GETPLAYERUSERID( pPlayer->edict() ),
; 464  : 					GETPLAYERAUTHID( pPlayer->edict() ),
; 465  : 					g_engfuncs.pfnInfoKeyValue( g_engfuncs.pfnGetInfoKeyBuffer( pPlayer->edict() ), "model" ) );

	push	OFFSET FLAT:??_C@_05LHJL@model?$AA@	; `string'
	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+424
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pPlayer$38680[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BP@KLEL@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5disconnected?6?$AA@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 20					; 00000014H

; 467  : 			else

	jmp	SHORT $L38686
$L38684:

; 469  : 				UTIL_LogPrintf( "\"%s<%i><%s><%i>\" disconnected\n",  
; 470  : 					STRING( pPlayer->pev->netname ), 
; 471  : 					GETPLAYERUSERID( pPlayer->edict() ),
; 472  : 					GETPLAYERAUTHID( pPlayer->edict() ),
; 473  : 					GETPLAYERUSERID( pPlayer->edict() ) );

	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pPlayer$38680[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BP@KABK@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5disconnected?6?$AA@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 20					; 00000014H
$L38686:

; 475  : 
; 476  : 			pPlayer->RemoveAllItems( TRUE );// destroy all of the players weapons and items

	push	1
	push	1
	mov	ecx, DWORD PTR _pPlayer$38680[ebp]
	call	?RemoveAllItems@CBasePlayer@@QAEXHH@Z	; CBasePlayer::RemoveAllItems
$L38682:

; 479  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ClientDisconnected@CHalfLifeMultiplay@@UAEXPAUedict_s@@@Z ENDP ; CHalfLifeMultiplay::ClientDisconnected
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	__real@4@40089100000000000000
PUBLIC	__real@4@4005c800000000000000
PUBLIC	__real@4@4007de00000000000000
PUBLIC	__real@4@4002a000000000000000
EXTRN	?falldamage@@3Ucvar_s@@A:BYTE			; falldamage
;	COMDAT __real@4@40089100000000000000
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
__real@4@40089100000000000000 DD 044110000r	; 580
CONST	ENDS
;	COMDAT __real@4@4005c800000000000000
CONST	SEGMENT
__real@4@4005c800000000000000 DD 042c80000r	; 100
CONST	ENDS
;	COMDAT __real@4@4007de00000000000000
CONST	SEGMENT
__real@4@4007de00000000000000 DD 043de0000r	; 444
CONST	ENDS
;	COMDAT __real@4@4002a000000000000000
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT ?FlPlayerFallDamage@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
_iFallDamage$ = -8
?FlPlayerFallDamage@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::FlPlayerFallDamage, COMDAT

; 484  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 485  : 	int iFallDamage = (int)falldamage.value;

	fld	DWORD PTR ?falldamage@@3Ucvar_s@@A+12
	call	__ftol
	mov	DWORD PTR _iFallDamage$[ebp], eax

; 488  : 	{

	mov	eax, DWORD PTR _iFallDamage$[ebp]
	mov	DWORD PTR -12+[ebp], eax
	cmp	DWORD PTR -12+[ebp], 1
	je	SHORT $L38698
	jmp	SHORT $L38700
$L38698:

; 489  : 	case 1://progressive
; 490  : 		pPlayer->m_flFallVelocity -= PLAYER_MAX_SAFE_FALL_SPEED;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	fld	DWORD PTR [ecx+2456]
	fsub	DWORD PTR __real@4@40089100000000000000
	mov	edx, DWORD PTR _pPlayer$[ebp]
	fstp	DWORD PTR [edx+2456]

; 491  : 		return pPlayer->m_flFallVelocity * DAMAGE_FOR_FALL_SPEED;

	mov	eax, DWORD PTR _pPlayer$[ebp]
	fld	DWORD PTR [eax+2456]
	fmul	DWORD PTR __real@4@4005c800000000000000
	fdiv	DWORD PTR __real@4@4007de00000000000000
	jmp	SHORT $L38695
$L38700:

; 492  : 		break;
; 493  : 	default:
; 494  : 	case 0:// fixed
; 495  : 		return 10;

	fld	DWORD PTR __real@4@4002a000000000000000
$L38695:

; 498  : } 

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FlPlayerFallDamage@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::FlPlayerFallDamage
_TEXT	ENDS
;	COMDAT ?FPlayerCanTakeDamage@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?FPlayerCanTakeDamage@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z PROC NEAR ; CHalfLifeMultiplay::FPlayerCanTakeDamage, COMDAT

; 503  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 504  : 	return TRUE;

	mov	eax, 1

; 505  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FPlayerCanTakeDamage@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBaseEntity@@@Z ENDP ; CHalfLifeMultiplay::FPlayerCanTakeDamage
_TEXT	ENDS
;	COMDAT ?PlayerThink@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
?PlayerThink@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::PlayerThink, COMDAT

; 510  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 511  : 	if ( g_fGameOver )

	cmp	DWORD PTR ?g_fGameOver@@3HA, 0		; g_fGameOver
	je	SHORT $L38710

; 513  : 		// check for button presses
; 514  : 		if ( pPlayer->m_afButtonPressed & ( IN_DUCK | IN_ATTACK | IN_ATTACK2 | IN_USE | IN_JUMP ) )

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+2436]
	and	ecx, 2087				; 00000827H
	test	ecx, ecx
	je	SHORT $L38711

; 515  : 			m_iEndIntermissionButtonHit = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 1
$L38711:

; 516  : 
; 517  : 		// clear attack/use commands from player
; 518  : 		pPlayer->m_afButtonPressed = 0;

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+2436], 0

; 519  : 		pPlayer->pev->button = 0;

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+384], 0

; 520  : 		pPlayer->m_afButtonReleased = 0;

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	DWORD PTR [eax+2440], 0
$L38710:

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PlayerThink@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::PlayerThink
_TEXT	ENDS
PUBLIC	??_C@_0BC@PFFH@game_player_equip?$AA@		; `string'
PUBLIC	??_C@_0P@NAIF@weapon_crowbar?$AA@		; `string'
PUBLIC	??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@		; `string'
PUBLIC	??_C@_03IEOM@9mm?$AA@				; `string'
PUBLIC	?AddWeapon@CBaseMonster@@QAEXH@Z		; CBaseMonster::AddWeapon
EXTRN	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z:NEAR	; CBasePlayer::GiveNamedItem
EXTRN	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByClassname
;	COMDAT ??_C@_0BC@PFFH@game_player_equip?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_0BC@PFFH@game_player_equip?$AA@ DB 'game_player_equip', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NAIF@weapon_crowbar?$AA@
CONST	SEGMENT
??_C@_0P@NAIF@weapon_crowbar?$AA@ DB 'weapon_crowbar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@
CONST	SEGMENT
??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@ DB 'weapon_9mmhandgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03IEOM@9mm?$AA@
CONST	SEGMENT
??_C@_03IEOM@9mm?$AA@ DB '9mm', 00H			; `string'
CONST	ENDS
;	COMDAT ?PlayerSpawn@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
_addDefault$ = -8
_pWeaponEntity$ = -12
?PlayerSpawn@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::PlayerSpawn, COMDAT

; 527  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 528  : 	BOOL		addDefault;
; 529  : 	CBaseEntity	*pWeaponEntity = NULL;

	mov	DWORD PTR _pWeaponEntity$[ebp], 0

; 530  : 
; 531  : 	pPlayer->AddWeapon( WEAPON_SUIT );

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 532  : 	
; 533  : 	addDefault = TRUE;

	mov	DWORD PTR _addDefault$[ebp], 1
$L38719:

; 534  : 
; 535  : 	while ( pWeaponEntity = UTIL_FindEntityByClassname( pWeaponEntity, "game_player_equip" ))

	push	OFFSET FLAT:??_C@_0BC@PFFH@game_player_equip?$AA@ ; `string'
	mov	eax, DWORD PTR _pWeaponEntity$[ebp]
	push	eax
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pWeaponEntity$[ebp], eax
	cmp	DWORD PTR _pWeaponEntity$[ebp], 0
	je	SHORT $L38720

; 537  : 		pWeaponEntity->Touch( pPlayer );

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pWeaponEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pWeaponEntity$[ebp]
	call	DWORD PTR [eax+280]

; 538  : 		addDefault = FALSE;

	mov	DWORD PTR _addDefault$[ebp], 0

; 539  : 	}

	jmp	SHORT $L38719
$L38720:

; 540  : 
; 541  : 	if ( addDefault )

	cmp	DWORD PTR _addDefault$[ebp], 0
	je	SHORT $L38722

; 543  : 		pPlayer->GiveNamedItem( "weapon_crowbar" );

	push	OFFSET FLAT:??_C@_0P@NAIF@weapon_crowbar?$AA@ ; `string'
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 544  : 		pPlayer->GiveNamedItem( "weapon_9mmhandgun" );

	push	OFFSET FLAT:??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@ ; `string'
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 545  : 		pPlayer->GiveAmmo( 68, "9mm", _9MM_MAX_CARRY );// 4 full reloads

	push	240					; 000000f0H
	push	OFFSET FLAT:??_C@_03IEOM@9mm?$AA@	; `string'
	push	68					; 00000044H
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	DWORD PTR [edx+156]
$L38722:

; 547  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PlayerSpawn@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::PlayerSpawn
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?AddWeapon@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::AddWeapon, COMDAT

; 143  : 	void		AddWeapon( int weaponnum ) { SetBits( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	or	edx, eax
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	sar	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+2348], dl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddWeapon@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::AddWeapon
_TEXT	ENDS
;	COMDAT ?FPlayerCanRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?FPlayerCanRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::FPlayerCanRespawn, COMDAT

; 552  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 553  : 	return TRUE;

	mov	eax, 1

; 554  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FPlayerCanRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::FPlayerCanRespawn
_TEXT	ENDS
;	COMDAT ?FlPlayerSpawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?FlPlayerSpawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::FlPlayerSpawnTime, COMDAT

; 559  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 560  : 	return gpGlobals->time;//now!

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]

; 561  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FlPlayerSpawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::FlPlayerSpawnTime
_TEXT	ENDS
EXTRN	?aimcrosshair@@3Ucvar_s@@A:BYTE			; aimcrosshair
;	COMDAT ?AllowAutoTargetCrosshair@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?AllowAutoTargetCrosshair@CHalfLifeMultiplay@@UAEHXZ PROC NEAR ; CHalfLifeMultiplay::AllowAutoTargetCrosshair, COMDAT

; 564  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 565  : 	return ( aimcrosshair.value != 0 );

	fld	DWORD PTR ?aimcrosshair@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39712
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39713
$L39712:
	mov	DWORD PTR -8+[ebp], 0
$L39713:
	mov	eax, DWORD PTR -8+[ebp]

; 566  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AllowAutoTargetCrosshair@CHalfLifeMultiplay@@UAEHXZ ENDP ; CHalfLifeMultiplay::AllowAutoTargetCrosshair
_TEXT	ENDS
;	COMDAT ?IPointsForKill@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@0@Z
_TEXT	SEGMENT
_this$ = -4
?IPointsForKill@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@0@Z PROC NEAR ; CHalfLifeMultiplay::IPointsForKill, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 574  : 	return 1;

	mov	eax, 1

; 575  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?IPointsForKill@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@0@Z ENDP ; CHalfLifeMultiplay::IPointsForKill
_TEXT	ENDS
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	??_C@_0P@FKMG@game_playerdie?$AA@		; `string'
PUBLIC	??_C@_0BA@PAEO@game_playerkill?$AA@		; `string'
PUBLIC	??_C@_0P@JCMM@weapon_satchel?$AA@		; `string'
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
EXTRN	?DeactivateSatchels@@YAXPAVCBasePlayer@@@Z:NEAR	; DeactivateSatchels
EXTRN	?HasNamedPlayerItem@CBasePlayer@@QAEHPBD@Z:NEAR	; CBasePlayer::HasNamedPlayerItem
;	COMDAT ??_C@_0P@FKMG@game_playerdie?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_0P@FKMG@game_playerdie?$AA@ DB 'game_playerdie', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAEO@game_playerkill?$AA@
CONST	SEGMENT
??_C@_0BA@PAEO@game_playerkill?$AA@ DB 'game_playerkill', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JCMM@weapon_satchel?$AA@
CONST	SEGMENT
??_C@_0P@JCMM@weapon_satchel?$AA@ DB 'weapon_satchel', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@3fff8000000000000000
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?PlayerKilled@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z
_TEXT	SEGMENT
_pVictim$ = 8
_pKiller$ = 12
_pInflictor$ = 16
_this$ = -4
_peKiller$ = -8
_ktmp$ = -12
_ep$ = -16
_PK$38761 = -20
?PlayerKilled@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z PROC NEAR ; CHalfLifeMultiplay::PlayerKilled, COMDAT

; 582  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 583  : 	DeathNotice( pVictim, pKiller, pInflictor );

	mov	eax, DWORD PTR _pInflictor$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pKiller$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pVictim$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]

; 584  : 
; 585  : 	pVictim->m_iDeaths += 1;

	mov	eax, DWORD PTR _pVictim$[ebp]
	mov	ecx, DWORD PTR [eax+3780]
	add	ecx, 1
	mov	edx, DWORD PTR _pVictim$[ebp]
	mov	DWORD PTR [edx+3780], ecx

; 586  : 
; 587  : 
; 588  : 	UTIL_FireTargets( "game_playerdie", pVictim, pVictim, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _pVictim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0P@FKMG@game_playerdie?$AA@ ; `string'
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 589  : 	CBasePlayer *peKiller = NULL;

	mov	DWORD PTR _peKiller$[ebp], 0

; 590  : 	CBaseEntity *ktmp = CBaseEntity::Instance( pKiller );

	mov	edx, DWORD PTR _pKiller$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _ktmp$[ebp], eax

; 591  : 	if ( ktmp && (ktmp->Classify() == CLASS_PLAYER) )

	cmp	DWORD PTR _ktmp$[ebp], 0
	je	SHORT $L38752
	mov	eax, DWORD PTR _ktmp$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ktmp$[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 2
	jne	SHORT $L38752

; 592  : 		peKiller = (CBasePlayer*)ktmp;

	mov	eax, DWORD PTR _ktmp$[ebp]
	mov	DWORD PTR _peKiller$[ebp], eax
$L38752:

; 593  : 
; 594  : 	if ( pVictim->pev == pKiller )  

	mov	ecx, DWORD PTR _pVictim$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _pKiller$[ebp]
	jne	SHORT $L38754

; 596  : 		pKiller->frags -= 1;

	mov	eax, DWORD PTR _pKiller$[ebp]
	fld	DWORD PTR [eax+356]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _pKiller$[ebp]
	fstp	DWORD PTR [ecx+356]

; 598  : 	else if ( ktmp && ktmp->IsPlayer() )

	jmp	SHORT $L38758
$L38754:
	cmp	DWORD PTR _ktmp$[ebp], 0
	je	SHORT $L38756
	mov	edx, DWORD PTR _ktmp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _ktmp$[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	je	SHORT $L38756

; 600  : 		// if a player dies in a deathmatch game and the killer is a client, award the killer some points
; 601  : 		pKiller->frags += IPointsForKill( peKiller, pVictim );

	mov	ecx, DWORD PTR _pVictim$[ebp]
	push	ecx
	mov	edx, DWORD PTR _peKiller$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+104]
	mov	DWORD PTR -24+[ebp], eax
	fild	DWORD PTR -24+[ebp]
	mov	eax, DWORD PTR _pKiller$[ebp]
	fadd	DWORD PTR [eax+356]
	mov	ecx, DWORD PTR _pKiller$[ebp]
	fstp	DWORD PTR [ecx+356]

; 602  : 		
; 603  : 		UTIL_FireTargets( "game_playerkill", ktmp, ktmp, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _ktmp$[ebp]
	push	edx
	mov	eax, DWORD PTR _ktmp$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BA@PAEO@game_playerkill?$AA@ ; `string'
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 605  : 	else

	jmp	SHORT $L38758
$L38756:

; 607  : 		pKiller->frags -= 1;

	mov	ecx, DWORD PTR _pKiller$[ebp]
	fld	DWORD PTR [ecx+356]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _pKiller$[ebp]
	fstp	DWORD PTR [edx+356]
$L38758:

; 609  : 
; 610  : 	// update the scores
; 611  : 	// killed scores
; 612  : 	MESSAGE_BEGIN( MSG_ALL, gmsgScoreInfo );

	push	0
	push	0
	mov	eax, DWORD PTR ?gmsgScoreInfo@@3HA	; gmsgScoreInfo
	push	eax
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 613  : 		WRITE_BYTE( ENTINDEX(pVictim->edict()) );

	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 614  : 		WRITE_SHORT( pVictim->pev->frags );

	mov	ecx, DWORD PTR _pVictim$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+356]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 615  : 		WRITE_SHORT( pVictim->m_iDeaths );

	mov	eax, DWORD PTR _pVictim$[ebp]
	mov	ecx, DWORD PTR [eax+3780]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 616  : 		WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 617  : 		WRITE_SHORT( GetTeamIndex( pVictim->m_szTeamName ) + 1 );

	mov	edx, DWORD PTR _pVictim$[ebp]
	add	edx, 3804				; 00000edcH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	add	eax, 1
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 618  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 619  : 
; 620  : 	// killers score, if it's a player
; 621  : 	CBaseEntity *ep = CBaseEntity::Instance( pKiller );

	mov	eax, DWORD PTR _pKiller$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _ep$[ebp], eax

; 622  : 	if ( ep && ep->Classify() == CLASS_PLAYER )

	cmp	DWORD PTR _ep$[ebp], 0
	je	$L38760
	mov	ecx, DWORD PTR _ep$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ep$[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 2
	jne	$L38760

; 624  : 		CBasePlayer *PK = (CBasePlayer*)ep;

	mov	eax, DWORD PTR _ep$[ebp]
	mov	DWORD PTR _PK$38761[ebp], eax

; 625  : 
; 626  : 		MESSAGE_BEGIN( MSG_ALL, gmsgScoreInfo );

	push	0
	push	0
	mov	ecx, DWORD PTR ?gmsgScoreInfo@@3HA	; gmsgScoreInfo
	push	ecx
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 627  : 			WRITE_BYTE( ENTINDEX(PK->edict()) );

	mov	ecx, DWORD PTR _PK$38761[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 628  : 			WRITE_SHORT( PK->pev->frags );

	mov	edx, DWORD PTR _PK$38761[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+356]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 629  : 			WRITE_SHORT( PK->m_iDeaths );

	mov	ecx, DWORD PTR _PK$38761[ebp]
	mov	edx, DWORD PTR [ecx+3780]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 630  : 			WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 631  : 			WRITE_SHORT( GetTeamIndex( PK->m_szTeamName) + 1 );

	mov	eax, DWORD PTR _PK$38761[ebp]
	add	eax, 3804				; 00000edcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	add	eax, 1
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 632  : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 633  : 
; 634  : 		// let the killer paint another decal as soon as he'd like.
; 635  : 		PK->m_flNextDecalTime = gpGlobals->time;

	mov	eax, DWORD PTR _PK$38761[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+3800], edx
$L38760:

; 637  : 
; 638  : 	if ( pVictim->HasNamedPlayerItem("weapon_satchel") )

	push	OFFSET FLAT:??_C@_0P@JCMM@weapon_satchel?$AA@ ; `string'
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?HasNamedPlayerItem@CBasePlayer@@QAEHPBD@Z ; CBasePlayer::HasNamedPlayerItem
	test	eax, eax
	je	SHORT $L38763

; 640  : 		DeactivateSatchels( pVictim );

	mov	eax, DWORD PTR _pVictim$[ebp]
	push	eax
	call	?DeactivateSatchels@@YAXPAVCBasePlayer@@@Z ; DeactivateSatchels
	add	esp, 4
$L38763:

; 642  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?PlayerKilled@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z ENDP ; CHalfLifeMultiplay::PlayerKilled
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC NEAR ; CBaseEntity::Instance, COMDAT

; 533  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
PUBLIC	?pszName@CBasePlayerItem@@QAEPBDXZ		; CBasePlayerItem::pszName
PUBLIC	??_C@_05MOPF@world?$AA@				; `string'
PUBLIC	??_C@_0L@EPOB@tau_cannon?$AA@			; `string'
PUBLIC	??_C@_09HCIF@gluon?5gun?$AA@			; `string'
PUBLIC	??_C@_07BHGE@weapon_?$AA@			; `string'
PUBLIC	??_C@_08NIHN@monster_?$AA@			; `string'
PUBLIC	??_C@_05CEIF@func_?$AA@				; `string'
PUBLIC	??_C@_04MANP@egon?$AA@				; `string'
PUBLIC	??_C@_05MFIA@gauss?$AA@				; `string'
PUBLIC	??_C@_0CO@HNOP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@ ; `string'
PUBLIC	??_C@_0CO@EGBI@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@ ; `string'
PUBLIC	??_C@_0DE@FGHG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@ ; `string'
PUBLIC	??_C@_0DE@OIKA@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@ ; `string'
PUBLIC	??_C@_0DG@LJPG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@ ; `string'
PUBLIC	??_C@_0DG@MJNO@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@ ; `string'
EXTRN	?gmsgDeathMsg@@3HA:DWORD			; gmsgDeathMsg
EXTRN	_strcmp:NEAR
EXTRN	_strncmp:NEAR
;	COMDAT ??_C@_05MOPF@world?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_05MOPF@world?$AA@ DB 'world', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EPOB@tau_cannon?$AA@
CONST	SEGMENT
??_C@_0L@EPOB@tau_cannon?$AA@ DB 'tau_cannon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HCIF@gluon?5gun?$AA@
CONST	SEGMENT
??_C@_09HCIF@gluon?5gun?$AA@ DB 'gluon gun', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07BHGE@weapon_?$AA@
CONST	SEGMENT
??_C@_07BHGE@weapon_?$AA@ DB 'weapon_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NIHN@monster_?$AA@
CONST	SEGMENT
??_C@_08NIHN@monster_?$AA@ DB 'monster_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CEIF@func_?$AA@
CONST	SEGMENT
??_C@_05CEIF@func_?$AA@ DB 'func_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MANP@egon?$AA@
CONST	SEGMENT
??_C@_04MANP@egon?$AA@ DB 'egon', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFIA@gauss?$AA@
CONST	SEGMENT
??_C@_05MFIA@gauss?$AA@ DB 'gauss', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@HNOP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@
CONST	SEGMENT
??_C@_0CO@HNOP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@ DB '"'
	DB	'%s<%i><%s><%s>" committed suicide with "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EGBI@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@
CONST	SEGMENT
??_C@_0CO@EGBI@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@ DB '"'
	DB	'%s<%i><%s><%i>" committed suicide with "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FGHG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@
CONST	SEGMENT
??_C@_0DE@FGHG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@ DB '"'
	DB	'%s<%i><%s><%s>" killed "%s<%i><%s><%s>" with "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@OIKA@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@
CONST	SEGMENT
??_C@_0DE@OIKA@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@ DB '"'
	DB	'%s<%i><%s><%i>" killed "%s<%i><%s><%i>" with "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@LJPG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@
CONST	SEGMENT
??_C@_0DG@LJPG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@ DB '"'
	DB	'%s<%i><%s><%s>" committed suicide with "%s" (world)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MJNO@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@
CONST	SEGMENT
??_C@_0DG@MJNO@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@ DB '"'
	DB	'%s<%i><%s><%i>" committed suicide with "%s" (world)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?DeathNotice@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z
_TEXT	SEGMENT
_pVictim$ = 8
_pKiller$ = 12
_pevInflictor$ = 16
_this$ = -4
_Killer$ = -8
_killer_weapon_name$ = -12
_killer_index$ = -16
_tau$ = -20
_gluon$ = -24
_pPlayer$38782 = -28
?DeathNotice@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z PROC NEAR ; CHalfLifeMultiplay::DeathNotice, COMDAT

; 648  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 649  : 	// Work out what killed the player, and send a message to all clients about it
; 650  : 	CBaseEntity *Killer = CBaseEntity::Instance( pKiller );

	mov	eax, DWORD PTR _pKiller$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _Killer$[ebp], eax

; 651  : 
; 652  : 	const char *killer_weapon_name = "world";		// by default, the player is killed by the world

	mov	DWORD PTR _killer_weapon_name$[ebp], OFFSET FLAT:??_C@_05MOPF@world?$AA@ ; `string'

; 653  : 	int killer_index = 0;

	mov	DWORD PTR _killer_index$[ebp], 0

; 654  : 	
; 655  : 	// Hack to fix name change
; 656  : 	char *tau = "tau_cannon";

	mov	DWORD PTR _tau$[ebp], OFFSET FLAT:??_C@_0L@EPOB@tau_cannon?$AA@ ; `string'

; 657  : 	char *gluon = "gluon gun";

	mov	DWORD PTR _gluon$[ebp], OFFSET FLAT:??_C@_09HCIF@gluon?5gun?$AA@ ; `string'

; 658  : 
; 659  : 	if ( pKiller->flags & FL_CLIENT )

	mov	ecx, DWORD PTR _pKiller$[ebp]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 8
	test	edx, edx
	je	SHORT $L38779

; 661  : 		killer_index = ENTINDEX(ENT(pKiller));

	mov	eax, DWORD PTR _pKiller$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	DWORD PTR _killer_index$[ebp], eax

; 662  : 		
; 663  : 		if ( pevInflictor )

	cmp	DWORD PTR _pevInflictor$[ebp], 0
	je	SHORT $L38785

; 665  : 			if ( pevInflictor == pKiller )

	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	cmp	ecx, DWORD PTR _pKiller$[ebp]
	jne	SHORT $L38781

; 667  : 				// If the inflictor is the killer,  then it must be their current weapon doing the damage
; 668  : 				CBasePlayer *pPlayer = (CBasePlayer*)CBaseEntity::Instance( pKiller );

	mov	edx, DWORD PTR _pKiller$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pPlayer$38782[ebp], eax

; 669  : 				
; 670  : 				if ( pPlayer->m_pActiveItem )

	mov	eax, DWORD PTR _pPlayer$38782[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L38784

; 672  : 					killer_weapon_name = pPlayer->m_pActiveItem->pszName();

	mov	ecx, DWORD PTR _pPlayer$38782[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	call	?pszName@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszName
	mov	DWORD PTR _killer_weapon_name$[ebp], eax
$L38784:

; 675  : 			else

	jmp	SHORT $L38785
$L38781:

; 677  : 				killer_weapon_name = STRING( pevInflictor->classname );  // it's just that easy

	mov	edx, DWORD PTR _pevInflictor$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _killer_weapon_name$[ebp], eax
$L38785:

; 681  : 	else

	jmp	SHORT $L38786
$L38779:

; 683  : 		killer_weapon_name = STRING( pevInflictor->classname );

	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _killer_weapon_name$[ebp], eax
$L38786:

; 685  : 
; 686  : 	// strip the monster_* or weapon_* from the inflictor's classname
; 687  : 	if ( strncmp( killer_weapon_name, "weapon_", 7 ) == 0 )

	push	7
	push	OFFSET FLAT:??_C@_07BHGE@weapon_?$AA@	; `string'
	mov	eax, DWORD PTR _killer_weapon_name$[ebp]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L38787

; 688  : 		killer_weapon_name += 7;

	mov	ecx, DWORD PTR _killer_weapon_name$[ebp]
	add	ecx, 7
	mov	DWORD PTR _killer_weapon_name$[ebp], ecx

; 689  : 	else if ( strncmp( killer_weapon_name, "monster_", 8 ) == 0 )

	jmp	SHORT $L38793
$L38787:
	push	8
	push	OFFSET FLAT:??_C@_08NIHN@monster_?$AA@	; `string'
	mov	edx, DWORD PTR _killer_weapon_name$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L38790

; 690  : 		killer_weapon_name += 8;

	mov	eax, DWORD PTR _killer_weapon_name$[ebp]
	add	eax, 8
	mov	DWORD PTR _killer_weapon_name$[ebp], eax

; 691  : 	else if ( strncmp( killer_weapon_name, "func_", 5 ) == 0 )

	jmp	SHORT $L38793
$L38790:
	push	5
	push	OFFSET FLAT:??_C@_05CEIF@func_?$AA@	; `string'
	mov	ecx, DWORD PTR _killer_weapon_name$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L38793

; 692  : 		killer_weapon_name += 5;

	mov	edx, DWORD PTR _killer_weapon_name$[ebp]
	add	edx, 5
	mov	DWORD PTR _killer_weapon_name$[ebp], edx
$L38793:

; 693  : 
; 694  : 	MESSAGE_BEGIN( MSG_ALL, gmsgDeathMsg );

	push	0
	push	0
	mov	eax, DWORD PTR ?gmsgDeathMsg@@3HA	; gmsgDeathMsg
	push	eax
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 695  : 		WRITE_BYTE( killer_index );						// the killer

	mov	ecx, DWORD PTR _killer_index$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 696  : 		WRITE_BYTE( ENTINDEX(pVictim->edict()) );		// the victim

	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 697  : 		WRITE_STRING( killer_weapon_name );		// what they were killed by (should this be a string?)

	mov	edx, DWORD PTR _killer_weapon_name$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 698  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 699  : 
; 700  : 	// replace the code names with the 'real' names
; 701  : 	if ( !strcmp( killer_weapon_name, "egon" ) )

	push	OFFSET FLAT:??_C@_04MANP@egon?$AA@	; `string'
	mov	eax, DWORD PTR _killer_weapon_name$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L38795

; 702  : 		killer_weapon_name = gluon;

	mov	ecx, DWORD PTR _gluon$[ebp]
	mov	DWORD PTR _killer_weapon_name$[ebp], ecx

; 703  : 	else if ( !strcmp( killer_weapon_name, "gauss" ) )

	jmp	SHORT $L38798
$L38795:
	push	OFFSET FLAT:??_C@_05MFIA@gauss?$AA@	; `string'
	mov	edx, DWORD PTR _killer_weapon_name$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L38798

; 704  : 		killer_weapon_name = tau;

	mov	eax, DWORD PTR _tau$[ebp]
	mov	DWORD PTR _killer_weapon_name$[ebp], eax
$L38798:

; 705  : 
; 706  : 	if ( pVictim->pev == pKiller )  

	mov	ecx, DWORD PTR _pVictim$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _pKiller$[ebp]
	jne	$L38800

; 708  : 		// killed self
; 709  : 
; 710  : 		// team match?
; 711  : 		if ( g_teamplay )

	cmp	DWORD PTR ?g_teamplay@@3HA, 0		; g_teamplay
	je	SHORT $L38801

; 713  : 			UTIL_LogPrintf( "\"%s<%i><%s><%s>\" committed suicide with \"%s\"\n",  
; 714  : 				STRING( pVictim->pev->netname ), 
; 715  : 				GETPLAYERUSERID( pVictim->edict() ),
; 716  : 				GETPLAYERAUTHID( pVictim->edict() ),
; 717  : 				g_engfuncs.pfnInfoKeyValue( g_engfuncs.pfnGetInfoKeyBuffer( pVictim->edict() ), "model" ),
; 718  : 				killer_weapon_name );		

	mov	eax, DWORD PTR _killer_weapon_name$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_05LHJL@model?$AA@	; `string'
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+424
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CO@HNOP@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 24					; 00000018H

; 720  : 		else

	jmp	SHORT $L38803
$L38801:

; 722  : 			UTIL_LogPrintf( "\"%s<%i><%s><%i>\" committed suicide with \"%s\"\n",  
; 723  : 				STRING( pVictim->pev->netname ), 
; 724  : 				GETPLAYERUSERID( pVictim->edict() ),
; 725  : 				GETPLAYERAUTHID( pVictim->edict() ),
; 726  : 				GETPLAYERUSERID( pVictim->edict() ),
; 727  : 				killer_weapon_name );		

	mov	ecx, DWORD PTR _killer_weapon_name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pVictim$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CO@EGBI@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 24					; 00000018H
$L38803:

; 730  : 	else if ( pKiller->flags & FL_CLIENT )

	jmp	$L38814
$L38800:
	mov	edx, DWORD PTR _pKiller$[ebp]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 8
	test	eax, eax
	je	$L38806

; 732  : 		// team match?
; 733  : 		if ( g_teamplay )

	cmp	DWORD PTR ?g_teamplay@@3HA, 0		; g_teamplay
	je	$L38807

; 735  : 			UTIL_LogPrintf( "\"%s<%i><%s><%s>\" killed \"%s<%i><%s><%s>\" with \"%s\"\n",  
; 736  : 				STRING( pKiller->netname ),
; 737  : 				GETPLAYERUSERID( ENT(pKiller) ),
; 738  : 				GETPLAYERAUTHID( ENT(pKiller) ),
; 739  : 				g_engfuncs.pfnInfoKeyValue( g_engfuncs.pfnGetInfoKeyBuffer( ENT(pKiller) ), "model" ),
; 740  : 				STRING( pVictim->pev->netname ),
; 741  : 				GETPLAYERUSERID( pVictim->edict() ),
; 742  : 				GETPLAYERAUTHID( pVictim->edict() ),
; 743  : 				g_engfuncs.pfnInfoKeyValue( g_engfuncs.pfnGetInfoKeyBuffer( pVictim->edict() ), "model" ),
; 744  : 				killer_weapon_name );

	mov	ecx, DWORD PTR _killer_weapon_name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_05LHJL@model?$AA@	; `string'
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+424
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pVictim$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_05LHJL@model?$AA@	; `string'
	mov	edx, DWORD PTR _pKiller$[ebp]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+424
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	push	eax
	mov	eax, DWORD PTR _pKiller$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pKiller$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pKiller$[ebp]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0DE@FGHG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 40					; 00000028H

; 746  : 		else

	jmp	$L38809
$L38807:

; 748  : 			UTIL_LogPrintf( "\"%s<%i><%s><%i>\" killed \"%s<%i><%s><%i>\" with \"%s\"\n",  
; 749  : 				STRING( pKiller->netname ),
; 750  : 				GETPLAYERUSERID( ENT(pKiller) ),
; 751  : 				GETPLAYERAUTHID( ENT(pKiller) ),
; 752  : 				GETPLAYERUSERID( ENT(pKiller) ),
; 753  : 				STRING( pVictim->pev->netname ),
; 754  : 				GETPLAYERUSERID( pVictim->edict() ),
; 755  : 				GETPLAYERAUTHID( pVictim->edict() ),
; 756  : 				GETPLAYERUSERID( pVictim->edict() ),
; 757  : 				killer_weapon_name );

	mov	ecx, DWORD PTR _killer_weapon_name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pVictim$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pKiller$[ebp]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pKiller$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pKiller$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pKiller$[ebp]
	mov	eax, DWORD PTR [edx+464]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0DE@OIKA@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5killed?5?$CC?$CFs?$DM?$CFi?$DO?$DM@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 40					; 00000028H
$L38809:

; 760  : 	else

	jmp	$L38814
$L38806:

; 762  : 		// killed by the world
; 763  : 
; 764  : 		// team match?
; 765  : 		if ( g_teamplay )

	cmp	DWORD PTR ?g_teamplay@@3HA, 0		; g_teamplay
	je	SHORT $L38812

; 767  : 			UTIL_LogPrintf( "\"%s<%i><%s><%s>\" committed suicide with \"%s\" (world)\n",
; 768  : 				STRING( pVictim->pev->netname ), 
; 769  : 				GETPLAYERUSERID( pVictim->edict() ), 
; 770  : 				GETPLAYERAUTHID( pVictim->edict() ),
; 771  : 				g_engfuncs.pfnInfoKeyValue( g_engfuncs.pfnGetInfoKeyBuffer( pVictim->edict() ), "model" ),
; 772  : 				killer_weapon_name );		

	mov	ecx, DWORD PTR _killer_weapon_name$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_05LHJL@model?$AA@	; `string'
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+424
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pVictim$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+464]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0DG@LJPG@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFs?$DO?$CC?5committed?5suici@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 24					; 00000018H

; 774  : 		else

	jmp	SHORT $L38814
$L38812:

; 776  : 			UTIL_LogPrintf( "\"%s<%i><%s><%i>\" committed suicide with \"%s\" (world)\n",
; 777  : 				STRING( pVictim->pev->netname ), 
; 778  : 				GETPLAYERUSERID( pVictim->edict() ), 
; 779  : 				GETPLAYERAUTHID( pVictim->edict() ),
; 780  : 				GETPLAYERUSERID( pVictim->edict() ),
; 781  : 				killer_weapon_name );		

	mov	edx, DWORD PTR _killer_weapon_name$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+572
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+452
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pVictim$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+464]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0DG@MJNO@?$CC?$CFs?$DM?$CFi?$DO?$DM?$CFs?$DO?$DM?$CFi?$DO?$CC?5committed?5suici@ ; `string'
	call	?UTIL_LogPrintf@@YAXPADZZ		; UTIL_LogPrintf
	add	esp, 24					; 00000018H
$L38814:

; 784  : 
; 785  : 	MESSAGE_BEGIN( MSG_SPEC, SVC_DIRECTOR );

	push	0
	push	0
	push	51					; 00000033H
	push	9
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 786  : 		WRITE_BYTE ( 9 );	// command length in bytes

	push	9
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 787  : 		WRITE_BYTE ( DRC_CMD_EVENT );	// player killed

	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 788  : 		WRITE_SHORT( ENTINDEX(pVictim->edict()) );	// index number of primary entity

	mov	ecx, DWORD PTR _pVictim$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 789  : 		if (pevInflictor)

	cmp	DWORD PTR _pevInflictor$[ebp], 0
	je	SHORT $L38816

; 790  : 			WRITE_SHORT( ENTINDEX(ENT(pevInflictor)) );	// index number of secondary entity

	mov	eax, DWORD PTR _pevInflictor$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 791  : 		else

	jmp	SHORT $L38817
$L38816:

; 792  : 			WRITE_SHORT( ENTINDEX(ENT(pKiller)) );	// index number of secondary entity

	mov	ecx, DWORD PTR _pKiller$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4
$L38817:

; 793  : 		WRITE_LONG( 7 | DRC_FLAG_DRAMATIC);   // eventflags (priority and flags)

	push	39					; 00000027H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+204
	add	esp, 4

; 794  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 795  : 
; 796  : //  Print a standard message
; 797  : 	// TODO: make this go direct to console
; 798  : 	return; // just remove for now
; 799  : /*
; 800  : 	char	szText[ 128 ];
; 801  : 
; 802  : 	if ( pKiller->flags & FL_MONSTER )
; 803  : 	{
; 804  : 		// killed by a monster
; 805  : 		strcpy ( szText, STRING( pVictim->pev->netname ) );
; 806  : 		strcat ( szText, " was killed by a monster.\n" );
; 807  : 		return;
; 808  : 	}
; 809  : 
; 810  : 	if ( pKiller == pVictim->pev )
; 811  : 	{
; 812  : 		strcpy ( szText, STRING( pVictim->pev->netname ) );
; 813  : 		strcat ( szText, " commited suicide.\n" );
; 814  : 	}
; 815  : 	else if ( pKiller->flags & FL_CLIENT )
; 816  : 	{
; 817  : 		strcpy ( szText, STRING( pKiller->netname ) );
; 818  : 
; 819  : 		strcat( szText, " : " );
; 820  : 		strcat( szText, killer_weapon_name );
; 821  : 		strcat( szText, " : " );
; 822  : 
; 823  : 		strcat ( szText, STRING( pVictim->pev->netname ) );
; 824  : 		strcat ( szText, "\n" );
; 825  : 	}
; 826  : 	else if ( pKiller == g_pWorld )
; 827  : 	{
; 828  : 		strcpy ( szText, STRING( pVictim->pev->netname ) );
; 829  : 		strcat ( szText, " fell or drowned or something.\n" );
; 830  : 	}
; 831  : 	else if ( pKiller->solid == SOLID_BSP )
; 832  : 	{
; 833  : 		strcpy ( szText, STRING( pVictim->pev->netname ) );
; 834  : 		strcat ( szText, " was mooshed.\n" );
; 835  : 	}
; 836  : 	else
; 837  : 	{
; 838  : 		strcpy ( szText, STRING( pVictim->pev->netname ) );
; 839  : 		strcat ( szText, " died mysteriously.\n" );
; 840  : 	}
; 841  : 
; 842  : 	UTIL_ClientPrintAll( szText );
; 843  : */
; 844  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?DeathNotice@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAUentvars_s@@1@Z ENDP ; CHalfLifeMultiplay::DeathNotice
_TEXT	ENDS
;	COMDAT ?pszName@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?pszName@CBasePlayerItem@@QAEPBDXZ PROC NEAR		; CBasePlayerItem::pszName, COMDAT

; 272  : 	const char	*pszName( void )	{ return ItemInfoArray[ m_iId ].pszName; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+24]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pszName@CBasePlayerItem@@QAEPBDXZ ENDP			; CBasePlayerItem::pszName
_TEXT	ENDS
;	COMDAT ?PlayerGotWeapon@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?PlayerGotWeapon@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::PlayerGotWeapon, COMDAT

; 851  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 852  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PlayerGotWeapon@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::PlayerGotWeapon
_TEXT	ENDS
PUBLIC	?iFlags@CBasePlayerItem@@QAEHXZ			; CBasePlayerItem::iFlags
PUBLIC	__real@4@4003a000000000000000
EXTRN	?weaponstay@@3Ucvar_s@@A:BYTE			; weaponstay
;	COMDAT __real@4@4003a000000000000000
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
__real@4@4003a000000000000000 DD 041a00000r	; 20
CONST	ENDS
;	COMDAT ?FlWeaponRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8
_this$ = -4
?FlWeaponRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::FlWeaponRespawnTime, COMDAT

; 859  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 860  : 	if ( weaponstay.value > 0 )

	fld	DWORD PTR ?weaponstay@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38828

; 862  : 		// make sure it's only certain weapons
; 863  : 		if ( !(pWeapon->iFlags() & ITEM_FLAG_LIMITINWORLD) )

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?iFlags@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iFlags
	and	eax, 8
	test	eax, eax
	jne	SHORT $L38828

; 865  : 			return gpGlobals->time + 0;		// weapon respawns almost instantly

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@00000000000000000000
	jmp	SHORT $L38826
$L38828:

; 868  : 
; 869  : 	return gpGlobals->time + WEAPON_RESPAWN_TIME;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@4003a000000000000000
$L38826:

; 870  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FlWeaponRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::FlWeaponRespawnTime
_TEXT	ENDS
;	COMDAT ?iFlags@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?iFlags@CBasePlayerItem@@QAEHXZ PROC NEAR		; CBasePlayerItem::iFlags, COMDAT

; 275  : 	int		iFlags( void )	{ return ItemInfoArray[ m_iId ].iFlags; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+36]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?iFlags@CBasePlayerItem@@QAEHXZ ENDP			; CBasePlayerItem::iFlags
_TEXT	ENDS
;	COMDAT ?FlWeaponTryRespawn@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8
_this$ = -4
?FlWeaponTryRespawn@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::FlWeaponTryRespawn, COMDAT

; 882  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 883  : 	if ( pWeapon && pWeapon->m_iId && (pWeapon->iFlags() & ITEM_FLAG_LIMITINWORLD) )

	cmp	DWORD PTR _pWeapon$[ebp], 0
	je	SHORT $L38834
	mov	eax, DWORD PTR _pWeapon$[ebp]
	cmp	DWORD PTR [eax+1824], 0
	je	SHORT $L38834
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?iFlags@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iFlags
	and	eax, 8
	test	eax, eax
	je	SHORT $L38834

; 885  : 		if ( NUMBER_OF_ENTITIES() < (gpGlobals->maxEntities - ENTITY_INTOLERANCE) )

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+420
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+148]
	sub	edx, 100				; 00000064H
	cmp	eax, edx
	jge	SHORT $L38835

; 886  : 			return 0;

	fld	DWORD PTR __real@4@00000000000000000000
	jmp	SHORT $L38833
$L38835:

; 887  : 
; 888  : 		// we're past the entity tolerance level,  so delay the respawn
; 889  : 		return FlWeaponRespawnTime( pWeapon );

	mov	eax, DWORD PTR _pWeapon$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+128]
	jmp	SHORT $L38833
$L38834:

; 891  : 
; 892  : 	return 0;

	fld	DWORD PTR __real@4@00000000000000000000
$L38833:

; 893  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FlWeaponTryRespawn@CHalfLifeMultiplay@@UAEMPAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::FlWeaponTryRespawn
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
;	COMDAT ?VecWeaponRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 12
___$ReturnUdt$ = 8
_this$ = -4
?VecWeaponRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::VecWeaponRespawnSpot, COMDAT

; 900  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 901  : 	return pWeapon->GetAbsOrigin();

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 902  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?VecWeaponRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::VecWeaponRespawnSpot
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ?WeaponShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8
_this$ = -4
?WeaponShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::WeaponShouldRespawn, COMDAT

; 909  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 910  : 	if ( pWeapon->pev->spawnflags & SF_NORESPAWN )

	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	SHORT $L38845

; 912  : 		return GR_WEAPON_RESPAWN_NO;

	mov	eax, 2
	jmp	SHORT $L38844
$L38845:

; 914  : 
; 915  : 	return GR_WEAPON_RESPAWN_YES;

	mov	eax, 1
$L38844:

; 916  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?WeaponShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::WeaponShouldRespawn
_TEXT	ENDS
;	COMDAT ?CanHavePlayerItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_pItem$ = 12
_this$ = -4
_i$38853 = -8
_it$38857 = -12
?CanHavePlayerItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z PROC NEAR ; CHalfLifeMultiplay::CanHavePlayerItem, COMDAT

; 923  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 924  : 	if ( weaponstay.value > 0 )

	fld	DWORD PTR ?weaponstay@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38856

; 926  : 		if ( pItem->iFlags() & ITEM_FLAG_LIMITINWORLD )

	mov	ecx, DWORD PTR _pItem$[ebp]
	call	?iFlags@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iFlags
	and	eax, 8
	test	eax, eax
	je	SHORT $L38852

; 927  : 			return CGameRules::CanHavePlayerItem( pPlayer, pItem );

	mov	eax, DWORD PTR _pItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanHavePlayerItem@CGameRules@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ; CGameRules::CanHavePlayerItem
	jmp	SHORT $L38850
$L38852:

; 928  : 
; 929  : 		// check if the player already has this weapon
; 930  : 		for ( int i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$38853[ebp], 0
	jmp	SHORT $L38854
$L38855:
	mov	edx, DWORD PTR _i$38853[ebp]
	add	edx, 1
	mov	DWORD PTR _i$38853[ebp], edx
$L38854:
	cmp	DWORD PTR _i$38853[ebp], 6
	jge	SHORT $L38856

; 932  : 			CBasePlayerItem *it = pPlayer->m_rgpPlayerItems[i];

	mov	eax, DWORD PTR _i$38853[ebp]
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2956]
	mov	DWORD PTR _it$38857[ebp], edx
$L38859:

; 933  : 
; 934  : 			while ( it != NULL )

	cmp	DWORD PTR _it$38857[ebp], 0
	je	SHORT $L38860

; 936  : 				if ( it->m_iId == pItem->m_iId )

	mov	eax, DWORD PTR _it$38857[ebp]
	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [eax+1824]
	cmp	edx, DWORD PTR [ecx+1824]
	jne	SHORT $L38861

; 938  : 					return FALSE;

	xor	eax, eax
	jmp	SHORT $L38850
$L38861:

; 940  : 
; 941  : 				it = it->m_pNext;

	mov	eax, DWORD PTR _it$38857[ebp]
	mov	ecx, DWORD PTR [eax+1820]
	mov	DWORD PTR _it$38857[ebp], ecx

; 942  : 			}

	jmp	SHORT $L38859
$L38860:

; 943  : 		}

	jmp	SHORT $L38855
$L38856:

; 945  : 
; 946  : 	return CGameRules::CanHavePlayerItem( pPlayer, pItem );

	mov	edx, DWORD PTR _pItem$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanHavePlayerItem@CGameRules@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ; CGameRules::CanHavePlayerItem
$L38850:

; 947  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CanHavePlayerItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCBasePlayerItem@@@Z ENDP ; CHalfLifeMultiplay::CanHavePlayerItem
_TEXT	ENDS
;	COMDAT ?CanHaveItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?CanHaveItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCItem@@@Z PROC NEAR ; CHalfLifeMultiplay::CanHaveItem, COMDAT

; 952  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 953  : 	return TRUE;

	mov	eax, 1

; 954  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CanHaveItem@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@PAVCItem@@@Z ENDP ; CHalfLifeMultiplay::CanHaveItem
_TEXT	ENDS
;	COMDAT ?PlayerGotItem@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?PlayerGotItem@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCItem@@@Z PROC NEAR ; CHalfLifeMultiplay::PlayerGotItem, COMDAT

; 959  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 960  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PlayerGotItem@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PAVCItem@@@Z ENDP ; CHalfLifeMultiplay::PlayerGotItem
_TEXT	ENDS
;	COMDAT ?ItemShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8
_this$ = -4
?ItemShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCItem@@@Z PROC NEAR ; CHalfLifeMultiplay::ItemShouldRespawn, COMDAT

; 965  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 	if ( pItem->pev->spawnflags & SF_NORESPAWN )

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	SHORT $L38876

; 968  : 		return GR_ITEM_RESPAWN_NO;

	mov	eax, 6
	jmp	SHORT $L38875
$L38876:

; 970  : 
; 971  : 	return GR_ITEM_RESPAWN_YES;

	mov	eax, 5
$L38875:

; 972  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ItemShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCItem@@@Z ENDP ; CHalfLifeMultiplay::ItemShouldRespawn
_TEXT	ENDS
PUBLIC	__real@4@4003f000000000000000
;	COMDAT __real@4@4003f000000000000000
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
__real@4@4003f000000000000000 DD 041f00000r	; 30
CONST	ENDS
;	COMDAT ?FlItemRespawnTime@CHalfLifeMultiplay@@UAEMPAVCItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?FlItemRespawnTime@CHalfLifeMultiplay@@UAEMPAVCItem@@@Z PROC NEAR ; CHalfLifeMultiplay::FlItemRespawnTime, COMDAT

; 979  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 	return gpGlobals->time + ITEM_RESPAWN_TIME;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4003f000000000000000

; 981  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FlItemRespawnTime@CHalfLifeMultiplay@@UAEMPAVCItem@@@Z ENDP ; CHalfLifeMultiplay::FlItemRespawnTime
_TEXT	ENDS
;	COMDAT ?VecItemRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCItem@@@Z
_TEXT	SEGMENT
_pItem$ = 12
___$ReturnUdt$ = 8
_this$ = -4
?VecItemRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCItem@@@Z PROC NEAR ; CHalfLifeMultiplay::VecItemRespawnSpot, COMDAT

; 988  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 989  : 	return pItem->GetAbsOrigin();

	mov	ecx, DWORD PTR _pItem$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 990  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?VecItemRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCItem@@@Z ENDP ; CHalfLifeMultiplay::VecItemRespawnSpot
_TEXT	ENDS
;	COMDAT ?PlayerGotAmmo@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PADH@Z
_TEXT	SEGMENT
_this$ = -4
?PlayerGotAmmo@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PADH@Z PROC NEAR ; CHalfLifeMultiplay::PlayerGotAmmo, COMDAT

; 995  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 996  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?PlayerGotAmmo@CHalfLifeMultiplay@@UAEXPAVCBasePlayer@@PADH@Z ENDP ; CHalfLifeMultiplay::PlayerGotAmmo
_TEXT	ENDS
;	COMDAT ?IsAllowedToSpawn@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?IsAllowedToSpawn@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CHalfLifeMultiplay::IsAllowedToSpawn, COMDAT

; 1001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1002 : //	if ( pEntity->pev->flags & FL_MONSTER )
; 1003 : //		return FALSE;
; 1004 : 
; 1005 : 	return TRUE;

	mov	eax, 1

; 1006 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsAllowedToSpawn@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@@Z ENDP ; CHalfLifeMultiplay::IsAllowedToSpawn
_TEXT	ENDS
;	COMDAT ?AmmoShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT
_pAmmo$ = 8
_this$ = -4
?AmmoShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerAmmo@@@Z PROC NEAR ; CHalfLifeMultiplay::AmmoShouldRespawn, COMDAT

; 1011 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1012 : 	if ( pAmmo->pev->spawnflags & SF_NORESPAWN )

	mov	eax, DWORD PTR _pAmmo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1073741824				; 40000000H
	test	edx, edx
	je	SHORT $L38900

; 1014 : 		return GR_AMMO_RESPAWN_NO;

	mov	eax, 4
	jmp	SHORT $L38899
$L38900:

; 1016 : 
; 1017 : 	return GR_AMMO_RESPAWN_YES;

	mov	eax, 3
$L38899:

; 1018 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AmmoShouldRespawn@CHalfLifeMultiplay@@UAEHPAVCBasePlayerAmmo@@@Z ENDP ; CHalfLifeMultiplay::AmmoShouldRespawn
_TEXT	ENDS
;	COMDAT ?FlAmmoRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT
_this$ = -4
?FlAmmoRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerAmmo@@@Z PROC NEAR ; CHalfLifeMultiplay::FlAmmoRespawnTime, COMDAT

; 1023 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1024 : 	return gpGlobals->time + AMMO_RESPAWN_TIME;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4003a000000000000000

; 1025 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FlAmmoRespawnTime@CHalfLifeMultiplay@@UAEMPAVCBasePlayerAmmo@@@Z ENDP ; CHalfLifeMultiplay::FlAmmoRespawnTime
_TEXT	ENDS
;	COMDAT ?VecAmmoRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerAmmo@@@Z
_TEXT	SEGMENT
_pAmmo$ = 12
___$ReturnUdt$ = 8
_this$ = -4
?VecAmmoRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerAmmo@@@Z PROC NEAR ; CHalfLifeMultiplay::VecAmmoRespawnSpot, COMDAT

; 1030 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1031 : 	return pAmmo->GetAbsOrigin();

	mov	ecx, DWORD PTR _pAmmo$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1032 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?VecAmmoRespawnSpot@CHalfLifeMultiplay@@UAE?AVVector@@PAVCBasePlayerAmmo@@@Z ENDP ; CHalfLifeMultiplay::VecAmmoRespawnSpot
_TEXT	ENDS
;	COMDAT ?FlHealthChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?FlHealthChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ PROC NEAR ; CHalfLifeMultiplay::FlHealthChargerRechargeTime, COMDAT

; 1037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1038 : 	return 60;

	fld	DWORD PTR __real@4@4004f000000000000000

; 1039 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlHealthChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ ENDP ; CHalfLifeMultiplay::FlHealthChargerRechargeTime
_TEXT	ENDS
;	COMDAT ?FlHEVChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?FlHEVChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ PROC NEAR ; CHalfLifeMultiplay::FlHEVChargerRechargeTime, COMDAT

; 1043 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1044 : 	return 30;

	fld	DWORD PTR __real@4@4003f000000000000000

; 1045 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlHEVChargerRechargeTime@CHalfLifeMultiplay@@UAEMXZ ENDP ; CHalfLifeMultiplay::FlHEVChargerRechargeTime
_TEXT	ENDS
;	COMDAT ?DeadPlayerWeapons@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeadPlayerWeapons@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::DeadPlayerWeapons, COMDAT

; 1050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1051 : 	return GR_PLR_DROP_GUN_ACTIVE;

	mov	eax, 8

; 1052 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeadPlayerWeapons@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::DeadPlayerWeapons
_TEXT	ENDS
;	COMDAT ?DeadPlayerAmmo@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeadPlayerAmmo@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::DeadPlayerAmmo, COMDAT

; 1057 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1058 : 	return GR_PLR_DROP_AMMO_ACTIVE;

	mov	eax, 11					; 0000000bH

; 1059 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeadPlayerAmmo@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::DeadPlayerAmmo
_TEXT	ENDS
;	COMDAT ?GetPlayerSpawnSpot@CHalfLifeMultiplay@@UAEPAUedict_s@@PAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
_pentSpawnSpot$ = -8
?GetPlayerSpawnSpot@CHalfLifeMultiplay@@UAEPAUedict_s@@PAVCBasePlayer@@@Z PROC NEAR ; CHalfLifeMultiplay::GetPlayerSpawnSpot, COMDAT

; 1062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 	edict_t *pentSpawnSpot = CGameRules::GetPlayerSpawnSpot( pPlayer );	

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPlayerSpawnSpot@CGameRules@@UAEPAUedict_s@@PAVCBasePlayer@@@Z ; CGameRules::GetPlayerSpawnSpot
	mov	DWORD PTR _pentSpawnSpot$[ebp], eax

; 1064 : 	if ( IsMultiplayer() && pentSpawnSpot->v.target )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L38931
	mov	eax, DWORD PTR _pentSpawnSpot$[ebp]
	cmp	DWORD PTR [eax+584], 0
	je	SHORT $L38931

; 1066 : 		UTIL_FireTargets( STRING(pentSpawnSpot->v.target), pPlayer, pPlayer, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pentSpawnSpot$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L38931:

; 1068 : 
; 1069 : 	return pentSpawnSpot;

	mov	eax, DWORD PTR _pentSpawnSpot$[ebp]

; 1070 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetPlayerSpawnSpot@CHalfLifeMultiplay@@UAEPAUedict_s@@PAVCBasePlayer@@@Z ENDP ; CHalfLifeMultiplay::GetPlayerSpawnSpot
_TEXT	ENDS
;	COMDAT ?PlayerRelationship@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@0@Z
_TEXT	SEGMENT
_this$ = -4
?PlayerRelationship@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@0@Z PROC NEAR ; CHalfLifeMultiplay::PlayerRelationship, COMDAT

; 1076 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1077 : 	// half life deathmatch has only enemies
; 1078 : 	return GR_NOTTEAMMATE;

	xor	eax, eax

; 1079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PlayerRelationship@CHalfLifeMultiplay@@UAEHPAVCBaseEntity@@0@Z ENDP ; CHalfLifeMultiplay::PlayerRelationship
_TEXT	ENDS
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	__real@4@4006dc00000000000000
EXTRN	?g_footsteps@@3PAUcvar_s@@A:DWORD		; g_footsteps
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
EXTRN	?IsOnLadder@CBasePlayer@@QAEHXZ:NEAR		; CBasePlayer::IsOnLadder
;	COMDAT __real@4@4006dc00000000000000
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
__real@4@4006dc00000000000000 DD 0435c0000r	; 220
CONST	ENDS
;	COMDAT ?PlayFootstepSounds@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@M@Z
_TEXT	SEGMENT
_pl$ = 8
_this$ = -4
?PlayFootstepSounds@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@M@Z PROC NEAR ; CHalfLifeMultiplay::PlayFootstepSounds, COMDAT

; 1082 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1083 : 	if ( g_footsteps && g_footsteps->value == 0 )

	cmp	DWORD PTR ?g_footsteps@@3PAUcvar_s@@A, 0 ; g_footsteps
	je	SHORT $L38942
	mov	eax, DWORD PTR ?g_footsteps@@3PAUcvar_s@@A ; g_footsteps
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L38942

; 1084 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L38941
$L38942:

; 1085 : 
; 1086 : 	if ( pl->IsOnLadder() || pl->GetAbsVelocity().Length2D() > 220 )

	mov	ecx, DWORD PTR _pl$[ebp]
	call	?IsOnLadder@CBasePlayer@@QAEHXZ		; CBasePlayer::IsOnLadder
	test	eax, eax
	jne	SHORT $L38944
	mov	ecx, DWORD PTR _pl$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fcomp	DWORD PTR __real@4@4006dc00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38943
$L38944:

; 1087 : 		return TRUE;  // only make step sounds in multiplayer if the player is moving fast enough

	mov	eax, 1
	jmp	SHORT $L38941
$L38943:

; 1088 : 
; 1089 : 	return FALSE;

	xor	eax, eax
$L38941:

; 1090 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?PlayFootstepSounds@CHalfLifeMultiplay@@UAEHPAVCBasePlayer@@M@Z ENDP ; CHalfLifeMultiplay::PlayFootstepSounds
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length2D@Vector@@QBEMXZ PROC NEAR			; Vector::Length2D, COMDAT

; 282  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
EXTRN	?flashlight@@3Ucvar_s@@A:BYTE			; flashlight
;	COMDAT ?FAllowFlashlight@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FAllowFlashlight@CHalfLifeMultiplay@@UAEHXZ PROC NEAR	; CHalfLifeMultiplay::FAllowFlashlight, COMDAT

; 1093 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 	return flashlight.value != 0; 

	fld	DWORD PTR ?flashlight@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39786
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39787
$L39786:
	mov	DWORD PTR -8+[ebp], 0
$L39787:
	mov	eax, DWORD PTR -8+[ebp]

; 1095 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FAllowFlashlight@CHalfLifeMultiplay@@UAEHXZ ENDP	; CHalfLifeMultiplay::FAllowFlashlight
_TEXT	ENDS
EXTRN	?allowmonsters@@3Ucvar_s@@A:BYTE		; allowmonsters
;	COMDAT ?FAllowMonsters@CHalfLifeMultiplay@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FAllowMonsters@CHalfLifeMultiplay@@UAEHXZ PROC NEAR	; CHalfLifeMultiplay::FAllowMonsters, COMDAT

; 1100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1101 : 	return ( allowmonsters.value != 0 );

	fld	DWORD PTR ?allowmonsters@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L39790
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L39791
$L39790:
	mov	DWORD PTR -8+[ebp], 0
$L39791:
	mov	eax, DWORD PTR -8+[ebp]

; 1102 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FAllowMonsters@CHalfLifeMultiplay@@UAEHXZ ENDP		; CHalfLifeMultiplay::FAllowMonsters
_TEXT	ENDS
;	COMDAT ?GoToIntermission@CHalfLifeMultiplay@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4
_time$ = -8
?GoToIntermission@CHalfLifeMultiplay@@MAEXXZ PROC NEAR	; CHalfLifeMultiplay::GoToIntermission, COMDAT

; 1109 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 	if ( g_fGameOver )

	cmp	DWORD PTR ?g_fGameOver@@3HA, 0		; g_fGameOver
	je	SHORT $L38958

; 1111 : 		return;  // intermission has already been triggered, so ignore.

	jmp	$L38957
$L38958:

; 1112 : 
; 1113 : 	MESSAGE_BEGIN(MSG_ALL, SVC_INTERMISSION);

	push	0
	push	0
	push	30					; 0000001eH
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1114 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1115 : 
; 1116 : 	// bounds check
; 1117 : 	int time = (int)CVAR_GET_FLOAT( "mp_chattime" );

	push	OFFSET FLAT:??_C@_0M@KANF@mp_chattime?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+228
	add	esp, 4
	call	__ftol
	mov	DWORD PTR _time$[ebp], eax

; 1118 : 	if ( time < 1 )

	cmp	DWORD PTR _time$[ebp], 1
	jge	SHORT $L38961

; 1119 : 		CVAR_SET_STRING( "mp_chattime", "1" );

	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0M@KANF@mp_chattime?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+240
	add	esp, 8

; 1120 : 	else if ( time > MAX_INTERMISSION_TIME )

	jmp	SHORT $L38963
$L38961:
	cmp	DWORD PTR _time$[ebp], 120		; 00000078H
	jle	SHORT $L38963

; 1121 : 		CVAR_SET_STRING( "mp_chattime", UTIL_dtos1( MAX_INTERMISSION_TIME ) );

	push	120					; 00000078H
	call	?UTIL_dtos1@@YAPADH@Z			; UTIL_dtos1
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0M@KANF@mp_chattime?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+240
	add	esp, 8
$L38963:

; 1122 : 
; 1123 : 	m_flIntermissionEndTime = gpGlobals->time + ( (int)mp_chattime.value );

	fld	DWORD PTR ?mp_chattime@@3Ucvar_s@@A+12
	call	__ftol
	mov	DWORD PTR -12+[ebp], eax
	fild	DWORD PTR -12+[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+4]

; 1124 : 	g_flIntermissionStartTime = gpGlobals->time;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR ?g_flIntermissionStartTime@@3MA, eax

; 1125 : 
; 1126 : 	g_fGameOver = TRUE;

	mov	DWORD PTR ?g_fGameOver@@3HA, 1		; g_fGameOver

; 1127 : 	m_iEndIntermissionButtonHit = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
$L38957:

; 1128 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GoToIntermission@CHalfLifeMultiplay@@MAEXXZ ENDP	; CHalfLifeMultiplay::GoToIntermission
_TEXT	ENDS
PUBLIC	?DestroyMapCycle@@YAXPAUmapcycle_s@@@Z		; DestroyMapCycle
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ?DestroyMapCycle@@YAXPAUmapcycle_s@@@Z
_TEXT	SEGMENT
_cycle$ = 8
_p$ = -4
_n$ = -8
_start$ = -12
$T39796 = -16
$T39797 = -20
?DestroyMapCycle@@YAXPAUmapcycle_s@@@Z PROC NEAR	; DestroyMapCycle, COMDAT

; 1155 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 1156 : 	mapcycle_item_t *p, *n, *start;
; 1157 : 	p = cycle->items;

	mov	eax, DWORD PTR _cycle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx

; 1158 : 	if ( p )

	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $L38997

; 1160 : 		start = p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _start$[ebp], edx

; 1161 : 		p = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _p$[ebp], ecx
$L38999:

; 1162 : 		while ( p != start )

	mov	edx, DWORD PTR _p$[ebp]
	cmp	edx, DWORD PTR _start$[ebp]
	je	SHORT $L39000

; 1164 : 			n = p->next;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _n$[ebp], ecx

; 1165 : 			delete p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR $T39796[ebp], edx
	mov	eax, DWORD PTR $T39796[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1166 : 			p = n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 1167 : 		}

	jmp	SHORT $L38999
$L39000:

; 1168 : 		
; 1169 : 		delete cycle->items;

	mov	edx, DWORD PTR _cycle$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T39797[ebp], eax
	mov	ecx, DWORD PTR $T39797[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38997:

; 1171 : 	cycle->items = NULL;

	mov	edx, DWORD PTR _cycle$[ebp]
	mov	DWORD PTR [edx], 0

; 1172 : 	cycle->next_item = NULL;

	mov	eax, DWORD PTR _cycle$[ebp]
	mov	DWORD PTR [eax+4], 0

; 1173 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DestroyMapCycle@@YAXPAUmapcycle_s@@@Z ENDP		; DestroyMapCycle
_TEXT	ENDS
PUBLIC	?ReloadMapCycleFile@@YAHPADPAUmapcycle_s@@@Z	; ReloadMapCycleFile
PUBLIC	??_C@_0L@MGMF@minplayers?$AA@			; `string'
PUBLIC	??_C@_0L@OGIK@maxplayers?$AA@			; `string'
PUBLIC	??_C@_0CM@JIAD@Skipping?5?$CFs?5from?5mapcycle?0?5not?5a@ ; `string'
EXTRN	_atoi:NEAR
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
EXTRN	?COM_ParseFileExt@@YAPADPAD0J_N@Z:NEAR		; COM_ParseFileExt
EXTRN	?COM_TokenWaiting@@YAHPAD@Z:NEAR		; COM_TokenWaiting
EXTRN	_memset:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strlen:NEAR
;	COMDAT ??_C@_0L@MGMF@minplayers?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_0L@MGMF@minplayers?$AA@ DB 'minplayers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OGIK@maxplayers?$AA@
CONST	SEGMENT
??_C@_0L@OGIK@maxplayers?$AA@ DB 'maxplayers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@JIAD@Skipping?5?$CFs?5from?5mapcycle?0?5not?5a@
CONST	SEGMENT
??_C@_0CM@JIAD@Skipping?5?$CFs?5from?5mapcycle?0?5not?5a@ DB 'Skipping %s'
	DB	' from mapcycle, not a valid map', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?ReloadMapCycleFile@@YAHPADPAUmapcycle_s@@@Z
_TEXT	SEGMENT
_filename$ = 8
_cycle$ = 12
_szBuffer$ = -1024
_szMap$ = -1056
_length$ = -1060
_pFileList$ = -1064
_aFileList$ = -1068
_hasbuffer$ = -1072
_item$ = -1076
_newlist$ = -1080
_next$ = -1084
_szToken$ = -1596
_s$39026 = -1600
$T39800 = -1604
?ReloadMapCycleFile@@YAHPADPAUmapcycle_s@@@Z PROC NEAR	; ReloadMapCycleFile, COMDAT

; 1184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1684				; 00000694H
	push	ebx
	push	esi
	push	edi

; 1185 : 	char szBuffer[ MAX_RULE_BUFFER ];
; 1186 : 	char szMap[ 32 ];
; 1187 : 	int length;
; 1188 : 	char *pFileList;
; 1189 : 	char *aFileList = pFileList = (char*)LOAD_FILE( filename, &length );

	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filename$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+380
	add	esp, 8
	mov	DWORD PTR _pFileList$[ebp], eax
	mov	edx, DWORD PTR _pFileList$[ebp]
	mov	DWORD PTR _aFileList$[ebp], edx

; 1190 : 	int hasbuffer;
; 1191 : 	mapcycle_item_s *item, *newlist = NULL, *next;

	mov	DWORD PTR _newlist$[ebp], 0

; 1192 : 	char szToken[512];
; 1193 : 
; 1194 : 	if ( pFileList && length )

	cmp	DWORD PTR _pFileList$[ebp], 0
	je	$L39018
	cmp	DWORD PTR _length$[ebp], 0
	je	$L39018
$L39020:

; 1196 : 		// the first map name in the file becomes the default
; 1197 : 		while ( 1 )

	mov	eax, 1
	test	eax, eax
	je	$L39021

; 1199 : 			hasbuffer = 0;

	mov	DWORD PTR _hasbuffer$[ebp], 0

; 1200 : 			memset( szBuffer, 0, MAX_RULE_BUFFER );

	push	1024					; 00000400H
	push	0
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1201 : 
; 1202 : 			pFileList = COM_ParseFile( pFileList, szToken );

	push	1
	push	512					; 00000200H
	lea	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFileList$[ebp]
	push	eax
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pFileList$[ebp], eax

; 1203 : 			if ( strlen( szToken ) <= 0 )

	lea	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	test	eax, eax
	ja	SHORT $L39022

; 1204 : 				break;

	jmp	$L39021
$L39022:

; 1205 : 
; 1206 : 			strcpy( szMap, szToken );

	lea	edx, DWORD PTR _szToken$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMap$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1207 : 
; 1208 : 			// Any more tokens on this line?
; 1209 : 			if ( COM_TokenWaiting( pFileList ) )

	mov	ecx, DWORD PTR _pFileList$[ebp]
	push	ecx
	call	?COM_TokenWaiting@@YAHPAD@Z		; COM_TokenWaiting
	add	esp, 4
	test	eax, eax
	je	SHORT $L39024

; 1211 : 				pFileList = COM_ParseFile( pFileList, szToken );

	push	1
	push	512					; 00000200H
	lea	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFileList$[ebp]
	push	eax
	call	?COM_ParseFileExt@@YAPADPAD0J_N@Z	; COM_ParseFileExt
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pFileList$[ebp], eax

; 1212 : 				if ( strlen( szToken ) > 0 )

	lea	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jbe	SHORT $L39024

; 1214 : 					hasbuffer = 1;

	mov	DWORD PTR _hasbuffer$[ebp], 1

; 1215 : 					strcpy( szBuffer, szToken );

	lea	edx, DWORD PTR _szToken$[ebp]
	push	edx
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L39024:

; 1218 : 
; 1219 : 			// Check map
; 1220 : 			if ( IS_MAP_VALID( szMap ) )

	lea	ecx, DWORD PTR _szMap$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+440
	add	esp, 4
	test	eax, eax
	je	$L39025

; 1222 : 				// Create entry
; 1223 : 				char *s;
; 1224 : 
; 1225 : 				item = new mapcycle_item_s;

	push	1068					; 0000042cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T39800[ebp], eax
	mov	edx, DWORD PTR $T39800[ebp]
	mov	DWORD PTR _item$[ebp], edx

; 1226 : 
; 1227 : 				strcpy( item->mapname, szMap );

	lea	eax, DWORD PTR _szMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 4
	push	ecx
	call	_strcpy
	add	esp, 8

; 1228 : 
; 1229 : 				item->minplayers = 0;

	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+36], 0

; 1230 : 				item->maxplayers = 0;

	mov	eax, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax+40], 0

; 1231 : 
; 1232 : 				memset( item->rulebuffer, 0, MAX_RULE_BUFFER );

	push	1024					; 00000400H
	push	0
	mov	ecx, DWORD PTR _item$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1233 : 
; 1234 : 				if ( hasbuffer )

	cmp	DWORD PTR _hasbuffer$[ebp], 0
	je	$L39029

; 1236 : 					s = g_engfuncs.pfnInfoKeyValue( szBuffer, "minplayers" );

	push	OFFSET FLAT:??_C@_0L@MGMF@minplayers?$AA@ ; `string'
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	mov	DWORD PTR _s$39026[ebp], eax

; 1237 : 					if ( s && s[0] )

	cmp	DWORD PTR _s$39026[ebp], 0
	je	$L39031
	mov	eax, DWORD PTR _s$39026[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$L39031

; 1239 : 						item->minplayers = Q_atoi( s );

	mov	edx, DWORD PTR _s$39026[ebp]
	push	edx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1240 : 						item->minplayers = Q_max( item->minplayers, 0 );

	mov	edx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [edx+36], 0
	jle	SHORT $L39801
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR -1608+[ebp], ecx
	jmp	SHORT $L39802
$L39801:
	mov	DWORD PTR -1608+[ebp], 0
$L39802:
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR -1608+[ebp]
	mov	DWORD PTR [edx+36], eax

; 1241 : 						item->minplayers = Q_min( item->minplayers, gpGlobals->maxClients );

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [ecx+36]
	cmp	eax, DWORD PTR [edx+144]
	jge	SHORT $L39803
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR -1612+[ebp], edx
	jmp	SHORT $L39804
$L39803:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+144]
	mov	DWORD PTR -1612+[ebp], ecx
$L39804:
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR -1612+[ebp]
	mov	DWORD PTR [edx+36], eax
$L39031:

; 1243 : 					s = g_engfuncs.pfnInfoKeyValue( szBuffer, "maxplayers" );

	push	OFFSET FLAT:??_C@_0L@OGIK@maxplayers?$AA@ ; `string'
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+428
	add	esp, 8
	mov	DWORD PTR _s$39026[ebp], eax

; 1244 : 					if ( s && s[0] )

	cmp	DWORD PTR _s$39026[ebp], 0
	je	$L39033
	mov	edx, DWORD PTR _s$39026[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L39033

; 1246 : 						item->maxplayers = atoi( s );

	mov	ecx, DWORD PTR _s$39026[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [edx+40], eax

; 1247 : 						item->maxplayers = Q_max( item->maxplayers, 0 );

	mov	eax, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jle	SHORT $L39805
	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR -1616+[ebp], edx
	jmp	SHORT $L39806
$L39805:
	mov	DWORD PTR -1616+[ebp], 0
$L39806:
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR -1616+[ebp]
	mov	DWORD PTR [eax+40], ecx

; 1248 : 						item->maxplayers = Q_min( item->maxplayers, gpGlobals->maxClients );

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [edx+40]
	cmp	ecx, DWORD PTR [eax+144]
	jge	SHORT $L39807
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR -1620+[ebp], eax
	jmp	SHORT $L39808
$L39807:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+144]
	mov	DWORD PTR -1620+[ebp], edx
$L39808:
	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR -1620+[ebp]
	mov	DWORD PTR [eax+40], ecx
$L39033:

; 1250 : 
; 1251 : 					// Remove keys
; 1252 : 					//
; 1253 : 					g_engfuncs.pfnInfo_RemoveKey( szBuffer, "minplayers" );

	push	OFFSET FLAT:??_C@_0L@MGMF@minplayers?$AA@ ; `string'
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+472
	add	esp, 8

; 1254 : 					g_engfuncs.pfnInfo_RemoveKey( szBuffer, "maxplayers" );

	push	OFFSET FLAT:??_C@_0L@OGIK@maxplayers?$AA@ ; `string'
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+472
	add	esp, 8

; 1255 : 
; 1256 : 					strcpy( item->rulebuffer, szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _item$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	call	_strcpy
	add	esp, 8
$L39029:

; 1258 : 
; 1259 : 				item->next = cycle->items;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR _cycle$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1260 : 				cycle->items = item;

	mov	eax, DWORD PTR _cycle$[ebp]
	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR [eax], ecx

; 1262 : 			else

	jmp	SHORT $L39034
$L39025:

; 1264 : 				ALERT( at_console, "Skipping %s from mapcycle, not a valid map\n", szMap );

	lea	edx, DWORD PTR _szMap$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CM@JIAD@Skipping?5?$CFs?5from?5mapcycle?0?5not?5a@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L39034:

; 1266 : 
; 1267 : 		}

	jmp	$L39020
$L39021:

; 1268 : 
; 1269 : 		FREE_FILE( aFileList );

	mov	eax, DWORD PTR _aFileList$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+384
	add	esp, 4
$L39018:

; 1271 : 
; 1272 : 	// Fixup circular list pointer
; 1273 : 	item = cycle->items;

	mov	ecx, DWORD PTR _cycle$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _item$[ebp], edx
$L39037:

; 1274 : 
; 1275 : 	// Reverse it to get original order
; 1276 : 	while ( item )

	cmp	DWORD PTR _item$[ebp], 0
	je	SHORT $L39038

; 1278 : 		next = item->next;

	mov	eax, DWORD PTR _item$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _next$[ebp], ecx

; 1279 : 		item->next = newlist;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR _newlist$[ebp]
	mov	DWORD PTR [edx], eax

; 1280 : 		newlist = item;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	DWORD PTR _newlist$[ebp], ecx

; 1281 : 		item = next;

	mov	edx, DWORD PTR _next$[ebp]
	mov	DWORD PTR _item$[ebp], edx

; 1282 : 	}

	jmp	SHORT $L39037
$L39038:

; 1283 : 	cycle->items = newlist;

	mov	eax, DWORD PTR _cycle$[ebp]
	mov	ecx, DWORD PTR _newlist$[ebp]
	mov	DWORD PTR [eax], ecx

; 1284 : 	item = cycle->items;

	mov	edx, DWORD PTR _cycle$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _item$[ebp], eax

; 1285 : 
; 1286 : 	// Didn't parse anything
; 1287 : 	if ( !item )

	cmp	DWORD PTR _item$[ebp], 0
	jne	SHORT $L39039

; 1289 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L39006
$L39039:

; 1291 : 
; 1292 : 	while ( item->next )

	mov	ecx, DWORD PTR _item$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L39042

; 1294 : 		item = item->next;

	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _item$[ebp], eax

; 1295 : 	}

	jmp	SHORT $L39039
$L39042:

; 1296 : 	item->next = cycle->items;

	mov	ecx, DWORD PTR _item$[ebp]
	mov	edx, DWORD PTR _cycle$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 1297 : 	
; 1298 : 	cycle->next_item = item->next;

	mov	ecx, DWORD PTR _cycle$[ebp]
	mov	edx, DWORD PTR _item$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 	return 1;

	mov	eax, 1
$L39006:

; 1301 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReloadMapCycleFile@@YAHPADPAUmapcycle_s@@@Z ENDP	; ReloadMapCycleFile
_TEXT	ENDS
PUBLIC	?CountPlayers@@YAHXZ				; CountPlayers
;	COMDAT ?CountPlayers@@YAHXZ
_TEXT	SEGMENT
_num$ = -4
_i$ = -8
_pEnt$39051 = -12
?CountPlayers@@YAHXZ PROC NEAR				; CountPlayers, COMDAT

; 1311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 1312 : 	int	num = 0;

	mov	DWORD PTR _num$[ebp], 0

; 1313 : 
; 1314 : 	for ( int i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L39048
$L39049:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39048:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L39050

; 1316 : 		CBaseEntity *pEnt = UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pEnt$39051[ebp], eax

; 1317 : 
; 1318 : 		if ( pEnt )

	cmp	DWORD PTR _pEnt$39051[ebp], 0
	je	SHORT $L39052

; 1320 : 			num = num + 1;

	mov	ecx, DWORD PTR _num$[ebp]
	add	ecx, 1
	mov	DWORD PTR _num$[ebp], ecx
$L39052:

; 1322 : 	}

	jmp	SHORT $L39049
$L39050:

; 1323 : 
; 1324 : 	return num;

	mov	eax, DWORD PTR _num$[ebp]

; 1325 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CountPlayers@@YAHXZ ENDP				; CountPlayers
_TEXT	ENDS
PUBLIC	?ExtractCommandString@@YAXPAD0@Z		; ExtractCommandString
PUBLIC	??_C@_01FCOA@?5?$AA@				; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
EXTRN	_strcat:NEAR
;	COMDAT ??_C@_01FCOA@?5?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_01FCOA@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?ExtractCommandString@@YAXPAD0@Z
_TEXT	SEGMENT
_s$ = 8
_szCommand$ = 12
_pkey$ = -512
_value$ = -1024
_o$ = -1028
?ExtractCommandString@@YAXPAD0@Z PROC NEAR		; ExtractCommandString, COMDAT

; 1336 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1092				; 00000444H
	push	ebx
	push	esi
	push	edi

; 1337 : 	// Now make rules happen
; 1338 : 	char	pkey[512];
; 1339 : 	char	value[512];	// use two buffers so compares
; 1340 : 								// work without stomping on each other
; 1341 : 	char	*o;
; 1342 : 	
; 1343 : 	if ( *s == '\\' )

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $L39060

; 1344 : 		s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx
$L39060:

; 1345 : 
; 1346 : 	while (1)

	mov	eax, 1
	test	eax, eax
	je	$L39063

; 1348 : 		o = pkey;

	lea	ecx, DWORD PTR _pkey$[ebp]
	mov	DWORD PTR _o$[ebp], ecx
$L39065:

; 1349 : 		while ( *s != '\\' )

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $L39066

; 1351 : 			if ( !*s )

	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L39067

; 1352 : 				return;

	jmp	$L39056
$L39067:

; 1353 : 			*o++ = *s++;

	mov	eax, DWORD PTR _o$[ebp]
	mov	ecx, DWORD PTR _s$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _o$[ebp]
	add	eax, 1
	mov	DWORD PTR _o$[ebp], eax
	mov	ecx, DWORD PTR _s$[ebp]
	add	ecx, 1
	mov	DWORD PTR _s$[ebp], ecx

; 1354 : 		}

	jmp	SHORT $L39065
$L39066:

; 1355 : 		*o = 0;

	mov	edx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [edx], 0

; 1356 : 		s++;

	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 1357 : 
; 1358 : 		o = value;

	lea	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _o$[ebp], ecx
$L39069:

; 1359 : 
; 1360 : 		while (*s != '\\' && *s)

	mov	edx, DWORD PTR _s$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	je	SHORT $L39070
	mov	ecx, DWORD PTR _s$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L39070

; 1362 : 			if (!*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L39071

; 1363 : 				return;

	jmp	$L39056
$L39071:

; 1364 : 			*o++ = *s++;

	mov	edx, DWORD PTR _o$[ebp]
	mov	eax, DWORD PTR _s$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _o$[ebp]
	add	edx, 1
	mov	DWORD PTR _o$[ebp], edx
	mov	eax, DWORD PTR _s$[ebp]
	add	eax, 1
	mov	DWORD PTR _s$[ebp], eax

; 1365 : 		}

	jmp	SHORT $L39069
$L39070:

; 1366 : 		*o = 0;

	mov	ecx, DWORD PTR _o$[ebp]
	mov	BYTE PTR [ecx], 0

; 1367 : 
; 1368 : 		strcat( szCommand, pkey );

	lea	edx, DWORD PTR _pkey$[ebp]
	push	edx
	mov	eax, DWORD PTR _szCommand$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1369 : 		if ( strlen( value ) > 0 )

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jbe	SHORT $L39072

; 1371 : 			strcat( szCommand, " " );

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	edx, DWORD PTR _szCommand$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1372 : 			strcat( szCommand, value );

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szCommand$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L39072:

; 1374 : 		strcat( szCommand, "\n" );

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	mov	edx, DWORD PTR _szCommand$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1375 : 
; 1376 : 		if (!*s)

	mov	eax, DWORD PTR _s$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L39075

; 1377 : 			return;

	jmp	SHORT $L39056
$L39075:

; 1378 : 		s++;

	mov	edx, DWORD PTR _s$[ebp]
	add	edx, 1
	mov	DWORD PTR _s$[ebp], edx

; 1379 : 	}

	jmp	$L39060
$L39063:
$L39056:

; 1380 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ExtractCommandString@@YAXPAD0@Z ENDP			; ExtractCommandString
_TEXT	ENDS
PUBLIC	??_C@_05BFEK@hldm1?$AA@				; `string'
PUBLIC	??_C@_0N@MLDJ@mapcyclefile?$AA@			; `string'
PUBLIC	?__LINE__Var@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4FA ; `CHalfLifeMultiplay::ChangeLevel'::`2'::__LINE__Var
PUBLIC	??_C@_0CM@PBEP@z?3?2xashxtsrc?2server?2multiplay_ga@ ; `string'
PUBLIC	??_C@_0BB@ICCI@mapcfile?5?$CB?$DN?5NULL?$AA@	; `string'
PUBLIC	??_C@_0CC@KJNK@Unable?5to?5load?5map?5cycle?5file?5?$CFs@ ; `string'
PUBLIC	??_C@_0N@PDME@item?5?$CB?$DN?5NULL?$AA@		; `string'
PUBLIC	??_C@_0BC@CCFN@CHANGE?5LEVEL?3?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0CJ@FEGG@PLAYER?5COUNT?3?5?5min?5?$CFi?5max?5?$CFi?5cur@ ; `string'
PUBLIC	??_C@_0M@GLI@RULES?3?5?5?$CFs?6?$AA@		; `string'
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	_stricmp:NEAR
_BSS	SEGMENT
_?szPreviousMapCycleFile@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4PADA DB 0100H DUP (?)
	ALIGN	8

_?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ?__LINE__Var@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4FA
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
_DATA	SEGMENT
?__LINE__Var@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4FA DW 056eH ; `CHalfLifeMultiplay::ChangeLevel'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_05BFEK@hldm1?$AA@
CONST	SEGMENT
??_C@_05BFEK@hldm1?$AA@ DB 'hldm1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MLDJ@mapcyclefile?$AA@
CONST	SEGMENT
??_C@_0N@MLDJ@mapcyclefile?$AA@ DB 'mapcyclefile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@PBEP@z?3?2xashxtsrc?2server?2multiplay_ga@
CONST	SEGMENT
??_C@_0CM@PBEP@z?3?2xashxtsrc?2server?2multiplay_ga@ DB 'z:\xashxtsrc\ser'
	DB	'ver\multiplay_gamerules.cpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ICCI@mapcfile?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0BB@ICCI@mapcfile?5?$CB?$DN?5NULL?$AA@ DB 'mapcfile != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KJNK@Unable?5to?5load?5map?5cycle?5file?5?$CFs@
CONST	SEGMENT
??_C@_0CC@KJNK@Unable?5to?5load?5map?5cycle?5file?5?$CFs@ DB 'Unable to l'
	DB	'oad map cycle file %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDME@item?5?$CB?$DN?5NULL?$AA@
CONST	SEGMENT
??_C@_0N@PDME@item?5?$CB?$DN?5NULL?$AA@ DB 'item != NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CCFN@CHANGE?5LEVEL?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@CCFN@CHANGE?5LEVEL?3?5?$CFs?6?$AA@ DB 'CHANGE LEVEL: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FEGG@PLAYER?5COUNT?3?5?5min?5?$CFi?5max?5?$CFi?5cur@
CONST	SEGMENT
??_C@_0CJ@FEGG@PLAYER?5COUNT?3?5?5min?5?$CFi?5max?5?$CFi?5cur@ DB 'PLAYER'
	DB	' COUNT:  min %i max %i current %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GLI@RULES?3?5?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0M@GLI@RULES?3?5?5?$CFs?6?$AA@ DB 'RULES:  %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?ChangeLevel@CHalfLifeMultiplay@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szNextMap$ = -36
_szFirstMapInList$ = -68
_szCommands$ = -1568
_szRules$ = -3068
_minplayers$ = -3072
_maxplayers$ = -3076
_curplayers$ = -3080
_do_cycle$ = -3084
_mapcfile$ = -3088
_keeplooking$39104 = -3092
_found$39105 = -3096
_item$39106 = -3100
?ChangeLevel@CHalfLifeMultiplay@@MAEXXZ PROC NEAR	; CHalfLifeMultiplay::ChangeLevel, COMDAT

; 1390 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3164				; 00000c5cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1391 : 	static char szPreviousMapCycleFile[ 256 ];
; 1392 : 	static mapcycle_t mapcycle;
; 1393 : 
; 1394 : 	char szNextMap[32];
; 1395 : 	char szFirstMapInList[32];
; 1396 : 	char szCommands[ 1500 ];
; 1397 : 	char szRules[ 1500 ];
; 1398 : 	int minplayers = 0, maxplayers = 0;

	mov	DWORD PTR _minplayers$[ebp], 0
	mov	DWORD PTR _maxplayers$[ebp], 0

; 1399 : 	strcpy( szFirstMapInList, "hldm1" );  // the absolute default level is hldm1

	push	OFFSET FLAT:??_C@_05BFEK@hldm1?$AA@	; `string'
	lea	eax, DWORD PTR _szFirstMapInList$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1400 : 
; 1401 : 	int	curplayers;
; 1402 : 	BOOL do_cycle = TRUE;

	mov	DWORD PTR _do_cycle$[ebp], 1

; 1403 : 
; 1404 : 	// find the map to change to
; 1405 : 	char *mapcfile = (char*)CVAR_GET_STRING( "mapcyclefile" );

	push	OFFSET FLAT:??_C@_0N@MLDJ@mapcyclefile?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+232
	add	esp, 4
	mov	DWORD PTR _mapcfile$[ebp], eax

; 1406 : 	ASSERT( mapcfile != NULL );

	push	0
	movsx	ecx, WORD PTR ?__LINE__Var@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4FA ; `CHalfLifeMultiplay::ChangeLevel'::`2'::__LINE__Var
	add	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET FLAT:??_C@_0CM@PBEP@z?3?2xashxtsrc?2server?2multiplay_ga@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@ICCI@mapcfile?5?$CB?$DN?5NULL?$AA@ ; `string'
	xor	edx, edx
	cmp	DWORD PTR _mapcfile$[ebp], 0
	setne	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1407 : 
; 1408 : 	szCommands[ 0 ] = '\0';

	mov	BYTE PTR _szCommands$[ebp], 0

; 1409 : 	szRules[ 0 ] = '\0';

	mov	BYTE PTR _szRules$[ebp], 0

; 1410 : 
; 1411 : 	curplayers = CountPlayers();

	call	?CountPlayers@@YAHXZ			; CountPlayers
	mov	DWORD PTR _curplayers$[ebp], eax

; 1412 : 
; 1413 : 	// Has the map cycle filename changed?
; 1414 : 	if ( stricmp( mapcfile, szPreviousMapCycleFile ) )

	push	OFFSET FLAT:_?szPreviousMapCycleFile@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4PADA
	mov	eax, DWORD PTR _mapcfile$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L39100

; 1416 : 		strcpy( szPreviousMapCycleFile, mapcfile );

	mov	ecx, DWORD PTR _mapcfile$[ebp]
	push	ecx
	push	OFFSET FLAT:_?szPreviousMapCycleFile@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4PADA
	call	_strcpy
	add	esp, 8

; 1417 : 
; 1418 : 		DestroyMapCycle( &mapcycle );

	push	OFFSET FLAT:_?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A
	call	?DestroyMapCycle@@YAXPAUmapcycle_s@@@Z	; DestroyMapCycle
	add	esp, 4

; 1419 : 
; 1420 : 		if ( !ReloadMapCycleFile( mapcfile, &mapcycle ) || ( !mapcycle.items ) )

	push	OFFSET FLAT:_?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A
	mov	edx, DWORD PTR _mapcfile$[ebp]
	push	edx
	call	?ReloadMapCycleFile@@YAHPADPAUmapcycle_s@@@Z ; ReloadMapCycleFile
	add	esp, 8
	test	eax, eax
	je	SHORT $L39101
	cmp	DWORD PTR _?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A, 0
	jne	SHORT $L39100
$L39101:

; 1422 : 			ALERT( at_console, "Unable to load map cycle file %s\n", mapcfile );

	mov	eax, DWORD PTR _mapcfile$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CC@KJNK@Unable?5to?5load?5map?5cycle?5file?5?$CFs@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1423 : 			do_cycle = FALSE;

	mov	DWORD PTR _do_cycle$[ebp], 0
$L39100:

; 1426 : 
; 1427 : 	if ( do_cycle && mapcycle.items )

	cmp	DWORD PTR _do_cycle$[ebp], 0
	je	$L39103
	cmp	DWORD PTR _?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A, 0
	je	$L39103

; 1429 : 		BOOL keeplooking = FALSE;

	mov	DWORD PTR _keeplooking$39104[ebp], 0

; 1430 : 		BOOL found = FALSE;

	mov	DWORD PTR _found$39105[ebp], 0

; 1431 : 		mapcycle_item_s *item;
; 1432 : 
; 1433 : 		// Assume current map
; 1434 : 		strcpy( szNextMap, STRING(gpGlobals->mapname) );

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _szNextMap$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1435 : 		strcpy( szFirstMapInList, STRING(gpGlobals->mapname) );

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _szFirstMapInList$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1436 : 
; 1437 : 		// Traverse list
; 1438 : 		for ( item = mapcycle.next_item; item->next != mapcycle.next_item; item = item->next )

	mov	ecx, DWORD PTR _?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A+4
	mov	DWORD PTR _item$39106[ebp], ecx
	jmp	SHORT $L39107
$L39108:
	mov	edx, DWORD PTR _item$39106[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _item$39106[ebp], eax
$L39107:
	mov	ecx, DWORD PTR _item$39106[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A+4
	je	$L39109

; 1440 : 			keeplooking = FALSE;

	mov	DWORD PTR _keeplooking$39104[ebp], 0

; 1441 : 
; 1442 : 			ASSERT( item != NULL );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4FA ; `CHalfLifeMultiplay::ChangeLevel'::`2'::__LINE__Var
	add	eax, 52					; 00000034H
	push	eax
	push	OFFSET FLAT:??_C@_0CM@PBEP@z?3?2xashxtsrc?2server?2multiplay_ga@ ; `string'
	push	OFFSET FLAT:??_C@_0N@PDME@item?5?$CB?$DN?5NULL?$AA@ ; `string'
	xor	ecx, ecx
	cmp	DWORD PTR _item$39106[ebp], 0
	setne	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1443 : 
; 1444 : 			if ( item->minplayers != 0 )

	mov	edx, DWORD PTR _item$39106[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $L39113

; 1446 : 				if ( curplayers >= item->minplayers )

	mov	eax, DWORD PTR _item$39106[ebp]
	mov	ecx, DWORD PTR _curplayers$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jl	SHORT $L39112

; 1448 : 					found = TRUE;

	mov	DWORD PTR _found$39105[ebp], 1

; 1449 : 					minplayers = item->minplayers;

	mov	edx, DWORD PTR _item$39106[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR _minplayers$[ebp], eax

; 1451 : 				else

	jmp	SHORT $L39113
$L39112:

; 1453 : 					keeplooking = TRUE;

	mov	DWORD PTR _keeplooking$39104[ebp], 1
$L39113:

; 1456 : 
; 1457 : 			if ( item->maxplayers != 0 )

	mov	ecx, DWORD PTR _item$39106[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $L39116

; 1459 : 				if ( curplayers <= item->maxplayers )

	mov	edx, DWORD PTR _item$39106[ebp]
	mov	eax, DWORD PTR _curplayers$[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jg	SHORT $L39115

; 1461 : 					found = TRUE;

	mov	DWORD PTR _found$39105[ebp], 1

; 1462 : 					maxplayers = item->maxplayers;

	mov	ecx, DWORD PTR _item$39106[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _maxplayers$[ebp], edx

; 1464 : 				else

	jmp	SHORT $L39116
$L39115:

; 1466 : 					keeplooking = TRUE;

	mov	DWORD PTR _keeplooking$39104[ebp], 1
$L39116:

; 1469 : 
; 1470 : 			if ( keeplooking )

	cmp	DWORD PTR _keeplooking$39104[ebp], 0
	je	SHORT $L39117

; 1471 : 				continue;

	jmp	$L39108
$L39117:

; 1472 : 
; 1473 : 			found = TRUE;

	mov	DWORD PTR _found$39105[ebp], 1
$L39109:

; 1476 : 
; 1477 : 		if ( !found )

	cmp	DWORD PTR _found$39105[ebp], 0
	jne	SHORT $L39118

; 1479 : 			item = mapcycle.next_item;

	mov	eax, DWORD PTR _?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A+4
	mov	DWORD PTR _item$39106[ebp], eax
$L39118:

; 1481 : 		
; 1482 : 		// Increment next item pointer
; 1483 : 		mapcycle.next_item = item->next;

	mov	ecx, DWORD PTR _item$39106[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _?mapcycle@?1??ChangeLevel@CHalfLifeMultiplay@@MAEXXZ@4Umapcycle_s@@A+4, edx

; 1484 : 
; 1485 : 		// Perform logic on current item
; 1486 : 		strcpy( szNextMap, item->mapname );

	mov	eax, DWORD PTR _item$39106[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR _szNextMap$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1487 : 
; 1488 : 		ExtractCommandString( item->rulebuffer, szCommands );

	lea	edx, DWORD PTR _szCommands$[ebp]
	push	edx
	mov	eax, DWORD PTR _item$39106[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	?ExtractCommandString@@YAXPAD0@Z	; ExtractCommandString
	add	esp, 8

; 1489 : 		strcpy( szRules, item->rulebuffer );

	mov	ecx, DWORD PTR _item$39106[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	lea	edx, DWORD PTR _szRules$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L39103:

; 1491 : 
; 1492 : 	if ( !IS_MAP_VALID(szNextMap) )

	lea	eax, DWORD PTR _szNextMap$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+440
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39119

; 1494 : 		strcpy( szNextMap, szFirstMapInList );

	lea	ecx, DWORD PTR _szFirstMapInList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szNextMap$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L39119:

; 1496 : 
; 1497 : 	g_fGameOver = TRUE;

	mov	DWORD PTR ?g_fGameOver@@3HA, 1		; g_fGameOver

; 1498 : 
; 1499 : 	ALERT( at_console, "CHANGE LEVEL: %s\n", szNextMap );

	lea	eax, DWORD PTR _szNextMap$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BC@CCFN@CHANGE?5LEVEL?3?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 1500 : 	if ( minplayers || maxplayers )

	cmp	DWORD PTR _minplayers$[ebp], 0
	jne	SHORT $L39122
	cmp	DWORD PTR _maxplayers$[ebp], 0
	je	SHORT $L39121
$L39122:

; 1502 : 		ALERT( at_console, "PLAYER COUNT:  min %i max %i current %i\n", minplayers, maxplayers, curplayers );

	mov	ecx, DWORD PTR _curplayers$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxplayers$[ebp]
	push	edx
	mov	eax, DWORD PTR _minplayers$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CJ@FEGG@PLAYER?5COUNT?3?5?5min?5?$CFi?5max?5?$CFi?5cur@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L39121:

; 1504 : 	if ( strlen( szRules ) > 0 )

	lea	ecx, DWORD PTR _szRules$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jbe	SHORT $L39124

; 1506 : 		ALERT( at_console, "RULES:  %s\n", szRules );

	lea	edx, DWORD PTR _szRules$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0M@GLI@RULES?3?5?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L39124:

; 1508 : 	
; 1509 : 	CHANGE_LEVEL( szNextMap, NULL );

	push	0
	lea	eax, DWORD PTR _szNextMap$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+24
	add	esp, 8

; 1510 : 	if ( strlen( szCommands ) > 0 )

	lea	ecx, DWORD PTR _szCommands$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jbe	SHORT $L39126

; 1512 : 		SERVER_COMMAND( szCommands );

	lea	edx, DWORD PTR _szCommands$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+156
	add	esp, 4
$L39126:

; 1514 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ChangeLevel@CHalfLifeMultiplay@@MAEXXZ ENDP		; CHalfLifeMultiplay::ChangeLevel
_TEXT	ENDS
PUBLIC	??_C@_08PDPP@motdfile?$AA@			; `string'
PUBLIC	??_C@_08NNNB@hostname?$AA@			; `string'
EXTRN	?gmsgMOTD@@3HA:DWORD				; gmsgMOTD
EXTRN	?gmsgServerName@@3HA:DWORD			; gmsgServerName
EXTRN	_strncpy:NEAR
;	COMDAT ??_C@_08PDPP@motdfile?$AA@
; File z:\xashxtsrc\server\multiplay_gamerules.cpp
CONST	SEGMENT
??_C@_08PDPP@motdfile?$AA@ DB 'motdfile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NNNB@hostname?$AA@
CONST	SEGMENT
??_C@_08NNNB@hostname?$AA@ DB 'hostname', 00H		; `string'
CONST	ENDS
;	COMDAT ?SendMOTDToClient@CHalfLifeMultiplay@@IAEXPAUedict_s@@@Z
_TEXT	SEGMENT
_client$ = 8
_this$ = -4
_length$ = -8
_char_count$ = -12
_pFileList$ = -16
_aFileList$ = -20
_chunk$39144 = -84
?SendMOTDToClient@CHalfLifeMultiplay@@IAEXPAUedict_s@@@Z PROC NEAR ; CHalfLifeMultiplay::SendMOTDToClient, COMDAT

; 1520 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1521 : 	// read from the MOTD.txt file
; 1522 : 	int length, char_count = 0;

	mov	DWORD PTR _char_count$[ebp], 0

; 1523 : 	char *pFileList;
; 1524 : 	char *aFileList = pFileList = (char*)LOAD_FILE( (char *)CVAR_GET_STRING( "motdfile" ), &length );

	lea	eax, DWORD PTR _length$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08PDPP@motdfile?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+232
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+380
	add	esp, 8
	mov	DWORD PTR _pFileList$[ebp], eax
	mov	ecx, DWORD PTR _pFileList$[ebp]
	mov	DWORD PTR _aFileList$[ebp], ecx

; 1525 : 
; 1526 : 	// send the server name
; 1527 : 	MESSAGE_BEGIN( MSG_ONE, gmsgServerName, NULL, client );

	mov	edx, DWORD PTR _client$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgServerName@@3HA	; gmsgServerName
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1528 : 		WRITE_STRING( CVAR_GET_STRING("hostname") );

	push	OFFSET FLAT:??_C@_08NNNB@hostname?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+232
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1529 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L39142:

; 1530 : 
; 1531 : 	// Send the message of the day
; 1532 : 	// read it chunk-by-chunk,  and send it in parts
; 1533 : 
; 1534 : 	while ( pFileList && *pFileList && char_count < MAX_MOTD_LENGTH )

	cmp	DWORD PTR _pFileList$[ebp], 0
	je	$L39143
	mov	ecx, DWORD PTR _pFileList$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L39143
	cmp	DWORD PTR _char_count$[ebp], 1536	; 00000600H
	jge	$L39143

; 1536 : 		char chunk[MAX_MOTD_CHUNK+1];
; 1537 : 		
; 1538 : 		if ( strlen( pFileList ) < MAX_MOTD_CHUNK )

	mov	eax, DWORD PTR _pFileList$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 60					; 0000003cH
	jae	SHORT $L39145

; 1540 : 			strcpy( chunk, pFileList );

	mov	ecx, DWORD PTR _pFileList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chunk$39144[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1542 : 		else

	jmp	SHORT $L39146
$L39145:

; 1544 : 			strncpy( chunk, pFileList, MAX_MOTD_CHUNK );

	push	60					; 0000003cH
	mov	eax, DWORD PTR _pFileList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _chunk$39144[ebp]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 1545 : 			chunk[MAX_MOTD_CHUNK] = 0;		// strncpy doesn't always append the null terminator

	mov	BYTE PTR _chunk$39144[ebp+60], 0
$L39146:

; 1547 : 
; 1548 : 		char_count += strlen( chunk );

	lea	edx, DWORD PTR _chunk$39144[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _char_count$[ebp]
	add	ecx, eax
	mov	DWORD PTR _char_count$[ebp], ecx

; 1549 : 		if ( char_count < MAX_MOTD_LENGTH )

	cmp	DWORD PTR _char_count$[ebp], 1536	; 00000600H
	jge	SHORT $L39147

; 1550 : 			pFileList = aFileList + char_count; 

	mov	edx, DWORD PTR _aFileList$[ebp]
	add	edx, DWORD PTR _char_count$[ebp]
	mov	DWORD PTR _pFileList$[ebp], edx

; 1551 : 		else

	jmp	SHORT $L39148
$L39147:

; 1552 : 			*pFileList = 0;

	mov	eax, DWORD PTR _pFileList$[ebp]
	mov	BYTE PTR [eax], 0
$L39148:

; 1553 : 
; 1554 : 		MESSAGE_BEGIN( MSG_ONE, gmsgMOTD, NULL, client );

	mov	ecx, DWORD PTR _client$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgMOTD@@3HA		; gmsgMOTD
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1555 : 			WRITE_BYTE( *pFileList ? FALSE : TRUE );	// FALSE means there is still more message to come

	mov	eax, DWORD PTR _pFileList$[ebp]
	movsx	ecx, BYTE PTR [eax]
	neg	ecx
	sbb	ecx, ecx
	inc	ecx
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1556 : 			WRITE_STRING( chunk );

	lea	edx, DWORD PTR _chunk$39144[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1557 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1558 : 	}

	jmp	$L39142
$L39143:

; 1559 : 
; 1560 : 	FREE_FILE( aFileList );

	mov	eax, DWORD PTR _aFileList$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+384
	add	esp, 4

; 1561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SendMOTDToClient@CHalfLifeMultiplay@@IAEXPAUedict_s@@@Z ENDP ; CHalfLifeMultiplay::SendMOTDToClient
_TEXT	ENDS
END
