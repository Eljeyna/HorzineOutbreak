	TITLE	Z:\XashXTSRC\server\monsters\talkmonster.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PPBO@CTalkMonster?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NLPJ@m_bitsSaid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HCOL@m_nSpeak?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MNEK@m_useTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08HBJM@m_iszUse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EIDC@UseSentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IAKF@m_iszUnUse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@NFJF@UnUseSentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@EGCF@m_iszDecline?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPMB@RefusalSentence?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FGJM@m_iszSpeakAs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PDEP@SpeakAs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BCCM@m_flLastSaidSmelled?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@ECNI@m_flStopTalkTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@CGLG@m_hTalkTarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KFLM@FollowerUse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HCDI@monster_barney?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNFL@monster_scientist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@LMBN@monster_sitting_scientist?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FPIG@monster_generic?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@INCI@Idle?5Response?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EDAJ@Idle?5Speak?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MFDG@Idle?5Speak?5Wait?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NEIJ@Idle?5Hello?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJEF@Idle?5Stop?5Shooting?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NONM@MoveAway?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@FL@MoveAwayFail?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@HBBI@MoveAwayFollow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMHA@TlkIdleWatchClient?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@KKOG@TlkIdleWatchClientStare?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JOEI@TlkIdleEyecontact?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NON@_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06POMA@ANSWER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PKJP@QUESTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04HGOH@IDLE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05OAGM@STARE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KAJG@PFOLLOW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HAGF@OK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05IIBA@PWAIT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04IDBB@WAIT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03NEKF@POK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05NAPF@NOTOK?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PANM@STOP?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PNJN@NOSHOOT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FAGC@HELLO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07KNDG@PLHURT1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FCIP@PLHURT2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PIBI@PLHURT3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06GCGJ@PHELLO?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HNOG@PIDLE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09EMBG@PQUESTION?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KEPI@SMELL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DGEO@WOUND?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06COBN@MORTAL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MNOE@player?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DKO@I?8m?5not?5following?5you?0?5you?5evil?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskFail@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TaskIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MovementIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopTalking@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFollowing@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CTalkMonster@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CTalkMonster@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E25
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E29
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleFromName@CTalkMonster@@UAEPAUSchedule_t@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActivity@CTalkMonster@@UAEXW4Activity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartTask@CTalkMonster@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RunTask@CTalkMonster@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Killed@CTalkMonster@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlertFriends@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShutUpFriends@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LimitFollowers@CTalkMonster@@QAEXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TargetDistance@CTalkMonster@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CTalkMonster@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TalkInit@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVoicePitch@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CTalkMonster@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleRespond@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FOkToSpeak@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CTalkMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FIdleStare@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FIdleHello@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FIdleSpeak@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayScriptedSentence@CTalkMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlaySentence@CTalkMonster@@UAEXPBDMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Talk@CTalkMonster@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAnswerQuestion@CTalkMonster@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeDamage@CTalkMonster@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetScheduleOfType@CTalkMonster@@UAEPAUSchedule_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTalking@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CTalkMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrySmellTalk@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IRelationship@CTalkMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopFollowing@CTalkMonster@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartFollowing@CTalkMonster@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanFollow@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FollowerUse@CTalkMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CTalkMonster@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CTalkMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_0N@PPBO@CTalkMonster?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CTalkMonster_DataDescInit@@3PAUdatamap_s@@A ; CTalkMonster_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0L@NLPJ@m_bitsSaid?$AA@			; `string'
PUBLIC	??_C@_08HCOL@m_nSpeak?$AA@			; `string'
PUBLIC	??_C@_09MNEK@m_useTime?$AA@			; `string'
PUBLIC	??_C@_08HBJM@m_iszUse?$AA@			; `string'
PUBLIC	??_C@_0M@EIDC@UseSentence?$AA@			; `string'
PUBLIC	??_C@_0L@IAKF@m_iszUnUse?$AA@			; `string'
PUBLIC	??_C@_0O@NFJF@UnUseSentence?$AA@		; `string'
PUBLIC	??_C@_0N@EGCF@m_iszDecline?$AA@			; `string'
PUBLIC	??_C@_0BA@DPMB@RefusalSentence?$AA@		; `string'
PUBLIC	??_C@_0N@FGJM@m_iszSpeakAs?$AA@			; `string'
PUBLIC	??_C@_07PDEP@SpeakAs?$AA@			; `string'
PUBLIC	??_C@_0BE@BCCM@m_flLastSaidSmelled?$AA@		; `string'
PUBLIC	??_C@_0BB@ECNI@m_flStopTalkTime?$AA@		; `string'
PUBLIC	??_C@_0O@CGLG@m_hTalkTarget?$AA@		; `string'
PUBLIC	??_C@_0P@HCDI@monster_barney?$AA@		; `string'
PUBLIC	??_C@_0BC@CNFL@monster_scientist?$AA@		; `string'
PUBLIC	??_C@_0BK@LMBN@monster_sitting_scientist?$AA@	; `string'
PUBLIC	??_C@_0BA@FPIG@monster_generic?$AA@		; `string'
PUBLIC	?tlIdleResponse@@3PAUTask_t@@A			; tlIdleResponse
PUBLIC	?slIdleResponse@@3PAUSchedule_t@@A		; slIdleResponse
PUBLIC	??_C@_0O@INCI@Idle?5Response?$AA@		; `string'
PUBLIC	?tlIdleSpeak@@3PAUTask_t@@A			; tlIdleSpeak
PUBLIC	?slIdleSpeak@@3PAUSchedule_t@@A			; slIdleSpeak
PUBLIC	??_C@_0L@EDAJ@Idle?5Speak?$AA@			; `string'
PUBLIC	?tlIdleSpeakWait@@3PAUTask_t@@A			; tlIdleSpeakWait
PUBLIC	?slIdleSpeakWait@@3PAUSchedule_t@@A		; slIdleSpeakWait
PUBLIC	??_C@_0BA@MFDG@Idle?5Speak?5Wait?$AA@		; `string'
PUBLIC	?tlIdleHello@@3PAUTask_t@@A			; tlIdleHello
PUBLIC	?slIdleHello@@3PAUSchedule_t@@A			; slIdleHello
PUBLIC	??_C@_0L@NEIJ@Idle?5Hello?$AA@			; `string'
PUBLIC	?tlIdleStopShooting@@3PAUTask_t@@A		; tlIdleStopShooting
PUBLIC	?slIdleStopShooting@@3PAUSchedule_t@@A		; slIdleStopShooting
PUBLIC	??_C@_0BD@HJEF@Idle?5Stop?5Shooting?$AA@	; `string'
PUBLIC	?tlMoveAway@@3PAUTask_t@@A			; tlMoveAway
PUBLIC	?slMoveAway@@3PAUSchedule_t@@A			; slMoveAway
PUBLIC	??_C@_08NONM@MoveAway?$AA@			; `string'
PUBLIC	?tlMoveAwayFail@@3PAUTask_t@@A			; tlMoveAwayFail
PUBLIC	?slMoveAwayFail@@3PAUSchedule_t@@A		; slMoveAwayFail
PUBLIC	??_C@_0N@FL@MoveAwayFail?$AA@			; `string'
PUBLIC	?tlMoveAwayFollow@@3PAUTask_t@@A		; tlMoveAwayFollow
PUBLIC	?slMoveAwayFollow@@3PAUSchedule_t@@A		; slMoveAwayFollow
PUBLIC	??_C@_0P@HBBI@MoveAwayFollow?$AA@		; `string'
PUBLIC	?tlTlkIdleWatchClient@@3PAUTask_t@@A		; tlTlkIdleWatchClient
PUBLIC	?tlTlkIdleWatchClientStare@@3PAUTask_t@@A	; tlTlkIdleWatchClientStare
PUBLIC	?slTlkIdleWatchClient@@3PAUSchedule_t@@A	; slTlkIdleWatchClient
PUBLIC	??_C@_0BD@OMHA@TlkIdleWatchClient?$AA@		; `string'
PUBLIC	??_C@_0BI@KKOG@TlkIdleWatchClientStare?$AA@	; `string'
PUBLIC	?tlTlkIdleEyecontact@@3PAUTask_t@@A		; tlTlkIdleEyecontact
PUBLIC	?slTlkIdleEyecontact@@3PAUSchedule_t@@A		; slTlkIdleEyecontact
PUBLIC	??_C@_0BC@JOEI@TlkIdleEyecontact?$AA@		; `string'
PUBLIC	?m_DataMap@CTalkMonster@@2Udatamap_s@@A		; CTalkMonster::m_DataMap
PUBLIC	?m_szFriends@CTalkMonster@@2PAPADA		; CTalkMonster::m_szFriends
PUBLIC	?g_talkWaitTime@CTalkMonster@@2MA		; CTalkMonster::g_talkWaitTime
PUBLIC	?m_scheduleList@CTalkMonster@@2PAPAUSchedule_t@@A ; CTalkMonster::m_scheduleList
_BSS	SEGMENT
?g_DataMapHolder@CTalkMonster_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CTalkMonster_DataDescInit::g_DataMapHolder
?g_talkWaitTime@CTalkMonster@@2MA DD 01H DUP (?)	; CTalkMonster::g_talkWaitTime
_BSS	ENDS
_DATA	SEGMENT
?m_DataMap@CTalkMonster@@2Udatamap_s@@A DD 00H		; CTalkMonster::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0N@PPBO@CTalkMonster?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S27	DD	FLAT:_$E26
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@NLPJ@m_bitsSaid?$AA@
	DD	095cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08HCOL@m_nSpeak?$AA@
	DD	0960H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_09MNEK@m_useTime?$AA@
	DD	09b4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_08HBJM@m_iszUse?$AA@
	DD	09b8H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@EIDC@UseSentence?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0L@IAKF@m_iszUnUse?$AA@
	DD	09bcH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0O@NFJF@UnUseSentence?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0N@EGCF@m_iszDecline?$AA@
	DD	09c0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BA@DPMB@RefusalSentence?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0N@FGJM@m_iszSpeakAs?$AA@
	DD	09c4H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_07PDEP@SpeakAs?$AA@
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BE@BCCM@m_flLastSaidSmelled?$AA@
	DD	09c8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BB@ECNI@m_flStopTalkTime?$AA@
	DD	09ccH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0O@CGLG@m_hTalkTarget?$AA@
	DD	09d0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+20
?m_szFriends@CTalkMonster@@2PAPADA DD FLAT:??_C@_0P@HCDI@monster_barney?$AA@ ; CTalkMonster::m_szFriends
	DD	FLAT:??_C@_0BC@CNFL@monster_scientist?$AA@
	DD	FLAT:??_C@_0BK@LMBN@monster_sitting_scientist?$AA@
	DD	FLAT:??_C@_0BA@FPIG@monster_generic?$AA@
?tlIdleResponse@@3PAUTask_t@@A DD 039H			; tlIdleResponse
	DD	03f800000r			; 1
	DD	01H
	DD	03f000000r			; 0.5
	DD	066H
	DD	000000000r			; 0
	DD	05eH
	DD	000000000r			; 0
	DD	067H
	DD	000000000r			; 0
	DD	01cH
	DD	000000000r			; 0
	DD	039H
	DD	041b80000r			; 23
	DD	066H
	DD	000000000r			; 0
?slIdleResponse@@3PAUSchedule_t@@A DD FLAT:?tlIdleResponse@@3PAUTask_t@@A ; slIdleResponse
	DD	08H
	DD	010300H
	DD	00H
	DD	FLAT:??_C@_0O@INCI@Idle?5Response?$AA@
	ORG $+4
?tlIdleSpeak@@3PAUTask_t@@A DD 05fH			; tlIdleSpeak
	DD	000000000r			; 0
	DD	067H
	DD	000000000r			; 0
	DD	01cH
	DD	000000000r			; 0
	DD	039H
	DD	041b80000r			; 23
	DD	066H
	DD	000000000r			; 0
	DD	052H
	DD	03f000000r			; 0.5
?slIdleSpeak@@3PAUSchedule_t@@A DD FLAT:?tlIdleSpeak@@3PAUTask_t@@A ; slIdleSpeak
	DD	06H
	DD	010010300H
	DD	00H
	DD	FLAT:??_C@_0L@EDAJ@Idle?5Speak?$AA@
	ORG $+4
?tlIdleSpeakWait@@3PAUTask_t@@A DD 039H			; tlIdleSpeakWait
	DD	041b80000r			; 23
	DD	05fH
	DD	000000000r			; 0
	DD	066H
	DD	000000000r			; 0
	DD	01H
	DD	040000000r			; 2
?slIdleSpeakWait@@3PAUSchedule_t@@A DD FLAT:?tlIdleSpeakWait@@3PAUTask_t@@A ; slIdleSpeakWait
	DD	04H
	DD	010010300H
	DD	00H
	DD	FLAT:??_C@_0BA@MFDG@Idle?5Speak?5Wait?$AA@
	ORG $+4
?tlIdleHello@@3PAUTask_t@@A DD 039H			; tlIdleHello
	DD	041b80000r			; 23
	DD	060H
	DD	000000000r			; 0
	DD	066H
	DD	000000000r			; 0
	DD	01H
	DD	03f000000r			; 0.5
	DD	060H
	DD	000000000r			; 0
	DD	066H
	DD	000000000r			; 0
	DD	01H
	DD	03f000000r			; 0.5
	DD	060H
	DD	000000000r			; 0
	DD	066H
	DD	000000000r			; 0
	DD	01H
	DD	03f000000r			; 0.5
	DD	060H
	DD	000000000r			; 0
	DD	066H
	DD	000000000r			; 0
	DD	01H
	DD	03f000000r			; 0.5
?slIdleHello@@3PAUSchedule_t@@A DD FLAT:?tlIdleHello@@3PAUTask_t@@A ; slIdleHello
	DD	0dH
	DD	010038300H
	DD	01H
	DD	FLAT:??_C@_0L@NEIJ@Idle?5Hello?$AA@
	ORG $+4
?tlIdleStopShooting@@3PAUTask_t@@A DD 062H		; tlIdleStopShooting
	DD	000000000r			; 0
?slIdleStopShooting@@3PAUSchedule_t@@A DD FLAT:?tlIdleStopShooting@@3PAUTask_t@@A ; slIdleStopShooting
	DD	01H
	DD	030300H
	DD	00H
	DD	FLAT:??_C@_0BD@HJEF@Idle?5Stop?5Shooting?$AA@
	ORG $+4
?tlMoveAway@@3PAUTask_t@@A DD 03bH			; tlMoveAway
	DD	042380000r			; 46
	DD	016H
	DD	000000000r			; 0
	DD	05cH
	DD	042c80000r			; 100
	DD	05dH
	DD	042c80000r			; 100
	DD	054H
	DD	000000000r			; 0
	DD	068H
	DD	03f000000r			; 0.5
?slMoveAway@@3PAUSchedule_t@@A DD FLAT:?tlMoveAway@@3PAUTask_t@@A ; slMoveAway
	DD	06H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_08NONM@MoveAway?$AA@
	ORG $+4
?tlMoveAwayFail@@3PAUTask_t@@A DD 054H			; tlMoveAwayFail
	DD	000000000r			; 0
	DD	068H
	DD	03f000000r			; 0.5
?slMoveAwayFail@@3PAUSchedule_t@@A DD FLAT:?tlMoveAwayFail@@3PAUTask_t@@A ; slMoveAwayFail
	DD	02H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0N@FL@MoveAwayFail?$AA@
	ORG $+4
?tlMoveAwayFollow@@3PAUTask_t@@A DD 03bH		; tlMoveAwayFollow
	DD	041700000r			; 15
	DD	016H
	DD	000000000r			; 0
	DD	05cH
	DD	042c80000r			; 100
	DD	05dH
	DD	042c80000r			; 100
	DD	054H
	DD	000000000r			; 0
	DD	03aH
	DD	041700000r			; 15
?slMoveAwayFollow@@3PAUSchedule_t@@A DD FLAT:?tlMoveAwayFollow@@3PAUTask_t@@A ; slMoveAwayFollow
	DD	06H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0P@HBBI@MoveAwayFollow?$AA@
	ORG $+4
?tlTlkIdleWatchClient@@3PAUTask_t@@A DD 054H		; tlTlkIdleWatchClient
	DD	000000000r			; 0
	DD	039H
	DD	03f800000r			; 1
	DD	064H
	DD	040c00000r			; 6
?tlTlkIdleWatchClientStare@@3PAUTask_t@@A DD 054H	; tlTlkIdleWatchClientStare
	DD	000000000r			; 0
	DD	039H
	DD	03f800000r			; 1
	DD	065H
	DD	040c00000r			; 6
	DD	063H
	DD	000000000r			; 0
	DD	067H
	DD	000000000r			; 0
	DD	01cH
	DD	000000000r			; 0
	DD	039H
	DD	041b80000r			; 23
	DD	066H
	DD	000000000r			; 0
?slTlkIdleWatchClient@@3PAUSchedule_t@@A DD FLAT:?tlTlkIdleWatchClient@@3PAUTask_t@@A ; slTlkIdleWatchClient
	DD	03H
	DD	030078300H
	DD	079H
	DD	FLAT:??_C@_0BD@OMHA@TlkIdleWatchClient?$AA@
	DD	FLAT:?tlTlkIdleWatchClientStare@@3PAUTask_t@@A
	DD	08H
	DD	030078300H
	DD	079H
	DD	FLAT:??_C@_0BI@KKOG@TlkIdleWatchClientStare?$AA@
?tlTlkIdleEyecontact@@3PAUTask_t@@A DD 067H		; tlTlkIdleEyecontact
	DD	000000000r			; 0
	DD	01cH
	DD	000000000r			; 0
	DD	039H
	DD	041b80000r			; 23
	DD	066H
	DD	000000000r			; 0
?slTlkIdleEyecontact@@3PAUSchedule_t@@A DD FLAT:?tlTlkIdleEyecontact@@3PAUTask_t@@A ; slTlkIdleEyecontact
	DD	04H
	DD	010010300H
	DD	00H
	DD	FLAT:??_C@_0BC@JOEI@TlkIdleEyecontact?$AA@
?m_scheduleList@CTalkMonster@@2PAPAUSchedule_t@@A DD FLAT:?slIdleResponse@@3PAUSchedule_t@@A ; CTalkMonster::m_scheduleList
	DD	FLAT:?slIdleSpeak@@3PAUSchedule_t@@A
	DD	FLAT:?slIdleHello@@3PAUSchedule_t@@A
	DD	FLAT:?slIdleSpeakWait@@3PAUSchedule_t@@A
	DD	FLAT:?slIdleStopShooting@@3PAUSchedule_t@@A
	DD	FLAT:?slMoveAway@@3PAUSchedule_t@@A
	DD	FLAT:?slMoveAwayFollow@@3PAUSchedule_t@@A
	DD	FLAT:?slMoveAwayFail@@3PAUSchedule_t@@A
	DD	FLAT:?slTlkIdleWatchClient@@3PAUSchedule_t@@A
	DD	FLAT:?slTlkIdleWatchClient@@3PAUSchedule_t@@A+20
	DD	FLAT:?slTlkIdleEyecontact@@3PAUSchedule_t@@A
_DATA	ENDS
;	COMDAT ??_C@_0N@PPBO@CTalkMonster?$AA@
CONST	SEGMENT
??_C@_0N@PPBO@CTalkMonster?$AA@ DB 'CTalkMonster', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLPJ@m_bitsSaid?$AA@
CONST	SEGMENT
??_C@_0L@NLPJ@m_bitsSaid?$AA@ DB 'm_bitsSaid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HCOL@m_nSpeak?$AA@
CONST	SEGMENT
??_C@_08HCOL@m_nSpeak?$AA@ DB 'm_nSpeak', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNEK@m_useTime?$AA@
CONST	SEGMENT
??_C@_09MNEK@m_useTime?$AA@ DB 'm_useTime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HBJM@m_iszUse?$AA@
CONST	SEGMENT
??_C@_08HBJM@m_iszUse?$AA@ DB 'm_iszUse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EIDC@UseSentence?$AA@
CONST	SEGMENT
??_C@_0M@EIDC@UseSentence?$AA@ DB 'UseSentence', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IAKF@m_iszUnUse?$AA@
CONST	SEGMENT
??_C@_0L@IAKF@m_iszUnUse?$AA@ DB 'm_iszUnUse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NFJF@UnUseSentence?$AA@
CONST	SEGMENT
??_C@_0O@NFJF@UnUseSentence?$AA@ DB 'UnUseSentence', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EGCF@m_iszDecline?$AA@
CONST	SEGMENT
??_C@_0N@EGCF@m_iszDecline?$AA@ DB 'm_iszDecline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DPMB@RefusalSentence?$AA@
CONST	SEGMENT
??_C@_0BA@DPMB@RefusalSentence?$AA@ DB 'RefusalSentence', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FGJM@m_iszSpeakAs?$AA@
CONST	SEGMENT
??_C@_0N@FGJM@m_iszSpeakAs?$AA@ DB 'm_iszSpeakAs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PDEP@SpeakAs?$AA@
CONST	SEGMENT
??_C@_07PDEP@SpeakAs?$AA@ DB 'SpeakAs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BCCM@m_flLastSaidSmelled?$AA@
CONST	SEGMENT
??_C@_0BE@BCCM@m_flLastSaidSmelled?$AA@ DB 'm_flLastSaidSmelled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@ECNI@m_flStopTalkTime?$AA@
CONST	SEGMENT
??_C@_0BB@ECNI@m_flStopTalkTime?$AA@ DB 'm_flStopTalkTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CGLG@m_hTalkTarget?$AA@
CONST	SEGMENT
??_C@_0O@CGLG@m_hTalkTarget?$AA@ DB 'm_hTalkTarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HCDI@monster_barney?$AA@
CONST	SEGMENT
??_C@_0P@HCDI@monster_barney?$AA@ DB 'monster_barney', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CNFL@monster_scientist?$AA@
CONST	SEGMENT
??_C@_0BC@CNFL@monster_scientist?$AA@ DB 'monster_scientist', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LMBN@monster_sitting_scientist?$AA@
CONST	SEGMENT
??_C@_0BK@LMBN@monster_sitting_scientist?$AA@ DB 'monster_sitting_scienti'
	DB	'st', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FPIG@monster_generic?$AA@
CONST	SEGMENT
??_C@_0BA@FPIG@monster_generic?$AA@ DB 'monster_generic', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@INCI@Idle?5Response?$AA@
CONST	SEGMENT
??_C@_0O@INCI@Idle?5Response?$AA@ DB 'Idle Response', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EDAJ@Idle?5Speak?$AA@
CONST	SEGMENT
??_C@_0L@EDAJ@Idle?5Speak?$AA@ DB 'Idle Speak', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MFDG@Idle?5Speak?5Wait?$AA@
CONST	SEGMENT
??_C@_0BA@MFDG@Idle?5Speak?5Wait?$AA@ DB 'Idle Speak Wait', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NEIJ@Idle?5Hello?$AA@
CONST	SEGMENT
??_C@_0L@NEIJ@Idle?5Hello?$AA@ DB 'Idle Hello', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJEF@Idle?5Stop?5Shooting?$AA@
CONST	SEGMENT
??_C@_0BD@HJEF@Idle?5Stop?5Shooting?$AA@ DB 'Idle Stop Shooting', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NONM@MoveAway?$AA@
CONST	SEGMENT
??_C@_08NONM@MoveAway?$AA@ DB 'MoveAway', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FL@MoveAwayFail?$AA@
CONST	SEGMENT
??_C@_0N@FL@MoveAwayFail?$AA@ DB 'MoveAwayFail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HBBI@MoveAwayFollow?$AA@
CONST	SEGMENT
??_C@_0P@HBBI@MoveAwayFollow?$AA@ DB 'MoveAwayFollow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMHA@TlkIdleWatchClient?$AA@
CONST	SEGMENT
??_C@_0BD@OMHA@TlkIdleWatchClient?$AA@ DB 'TlkIdleWatchClient', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KKOG@TlkIdleWatchClientStare?$AA@
CONST	SEGMENT
??_C@_0BI@KKOG@TlkIdleWatchClientStare?$AA@ DB 'TlkIdleWatchClientStare', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JOEI@TlkIdleEyecontact?$AA@
CONST	SEGMENT
??_C@_0BC@JOEI@TlkIdleEyecontact?$AA@ DB 'TlkIdleEyecontact', 00H ; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CTalkMonster@@UAEPAUdatamap_s@@XZ ; CTalkMonster::GetDataDescMap
;	COMDAT ?GetDataDescMap@CTalkMonster@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CTalkMonster@@UAEPAUdatamap_s@@XZ PROC NEAR ; CTalkMonster::GetDataDescMap, COMDAT

; 34   : BEGIN_DATADESC( CTalkMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CTalkMonster@@2Udatamap_s@@A ; CTalkMonster::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CTalkMonster@@UAEPAUdatamap_s@@XZ ENDP	; CTalkMonster::GetDataDescMap
_TEXT	ENDS
PUBLIC	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
PUBLIC	?GetBaseMap@CTalkMonster@@SAPAUdatamap_s@@XZ	; CTalkMonster::GetBaseMap
;	COMDAT ?GetBaseMap@CTalkMonster@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CTalkMonster@@SAPAUdatamap_s@@XZ PROC NEAR	; CTalkMonster::GetBaseMap, COMDAT

; 34   : BEGIN_DATADESC( CTalkMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CTalkMonster@@SAPAUdatamap_s@@XZ ENDP	; CTalkMonster::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E26
_TEXT	SEGMENT
_$E26	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E25
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E26	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z ; DataMapInit
;	COMDAT _$E25
_TEXT	SEGMENT
_$E25	PROC NEAR					; COMDAT

; 34   : BEGIN_DATADESC( CTalkMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CTalkMonster_DataDescInit@@3PAUdatamap_s@@A, eax ; CTalkMonster_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E25	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	??_C@_0M@KFLM@FollowerUse?$AA@			; `string'
PUBLIC	?FollowerUse@CTalkMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CTalkMonster::FollowerUse
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0M@KFLM@FollowerUse?$AA@
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
??_C@_0M@KFLM@FollowerUse?$AA@ DB 'FollowerUse', 00H	; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z PROC NEAR ; DataMapInit, COMDAT

; 34   : BEGIN_DATADESC( CTalkMonster )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L37092
	mov	cl, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0N@PPBO@CTalkMonster?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E29
	call	_atexit
	add	esp, 4
$L37092:
	call	?GetBaseMap@CTalkMonster@@SAPAUdatamap_s@@XZ ; CTalkMonster::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CTalkMonster@@2Udatamap_s@@A+12, eax

; 35   : 	DEFINE_FIELD( m_bitsSaid, FIELD_INTEGER ),
; 36   : 	DEFINE_FIELD( m_nSpeak, FIELD_INTEGER ),
; 37   : 	DEFINE_FIELD( m_useTime, FIELD_TIME ),
; 38   : 	DEFINE_KEYFIELD( m_iszUse, FIELD_STRING, "UseSentence" ),
; 39   : 	DEFINE_KEYFIELD( m_iszUnUse, FIELD_STRING, "UnUseSentence" ),
; 40   : 	DEFINE_KEYFIELD( m_iszDecline, FIELD_STRING, "RefusalSentence" ), //LRC
; 41   : 	DEFINE_KEYFIELD( m_iszSpeakAs, FIELD_STRING, "SpeakAs" ), //LRC
; 42   : 	DEFINE_FIELD( m_flLastSaidSmelled, FIELD_TIME ),
; 43   : 	DEFINE_FIELD( m_flStopTalkTime, FIELD_TIME ),
; 44   : 	DEFINE_FIELD( m_hTalkTarget, FIELD_EHANDLE ),
; 45   : 	DEFINE_FUNCTION( FollowerUse ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	SHORT $L37130
	mov	al, BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S28@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0M@KFLM@FollowerUse?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A+268, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A+272, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A+276, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A+278, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A+280, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A+284, OFFSET FLAT:?FollowerUse@CTalkMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CTalkMonster::FollowerUse
$L37130:

; 46   : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L37134
	mov	DWORD PTR ?m_DataMap@CTalkMonster@@2Udatamap_s@@A+4, 11 ; 0000000bH
	mov	DWORD PTR ?m_DataMap@CTalkMonster@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L37135
$L37134:
	mov	DWORD PTR ?m_DataMap@CTalkMonster@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CTalkMonster@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4PAUtypedescription_s@@A
$L37135:
	mov	eax, OFFSET FLAT:?m_DataMap@CTalkMonster@@2Udatamap_s@@A ; CTalkMonster::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
$T38190 = -12
_this$ = -4
_pBuf$ = -8
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T38190[ebp], eax
	mov	ecx, DWORD PTR $T38190[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E29
_TEXT	SEGMENT
_$E29	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCTalkMonster@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E29	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T38195 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T38195[ebp], edx
	mov	eax, DWORD PTR $T38195[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?ScheduleFromName@CTalkMonster@@UAEPAUSchedule_t@@PBD@Z ; CTalkMonster::ScheduleFromName
EXTRN	?ScheduleInList@CBaseMonster@@QAEPAUSchedule_t@@PBDPAPAU2@H@Z:NEAR ; CBaseMonster::ScheduleInList
EXTRN	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z:NEAR ; CBaseMonster::ScheduleFromName
;	COMDAT ?ScheduleFromName@CTalkMonster@@UAEPAUSchedule_t@@PBD@Z
_TEXT	SEGMENT
_pName$ = 8
_this$ = -4
_pSchedule$ = -8
?ScheduleFromName@CTalkMonster@@UAEPAUSchedule_t@@PBD@Z PROC NEAR ; CTalkMonster::ScheduleFromName, COMDAT

; 358  : IMPLEMENT_CUSTOM_SCHEDULES( CTalkMonster, CBaseMonster );

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	11					; 0000000bH
	push	OFFSET FLAT:?m_scheduleList@CTalkMonster@@2PAPAUSchedule_t@@A ; CTalkMonster::m_scheduleList
	mov	eax, DWORD PTR _pName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScheduleInList@CBaseMonster@@QAEPAUSchedule_t@@PBDPAPAU2@H@Z ; CBaseMonster::ScheduleInList
	mov	DWORD PTR _pSchedule$[ebp], eax
	cmp	DWORD PTR _pSchedule$[ebp], 0
	jne	SHORT $L37237
	mov	ecx, DWORD PTR _pName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z ; CBaseMonster::ScheduleFromName
	jmp	SHORT $L37235
$L37237:
	mov	eax, DWORD PTR _pSchedule$[ebp]
$L37235:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ScheduleFromName@CTalkMonster@@UAEPAUSchedule_t@@PBD@Z ENDP ; CTalkMonster::ScheduleFromName
_TEXT	ENDS
PUBLIC	?SetActivity@CTalkMonster@@UAEXW4Activity@@@Z	; CTalkMonster::SetActivity
PUBLIC	?IsTalking@CTalkMonster@@QAEHXZ			; CTalkMonster::IsTalking
EXTRN	?LookupActivity@CBaseAnimating@@QAEHH@Z:NEAR	; CBaseAnimating::LookupActivity
EXTRN	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z:NEAR ; CBaseMonster::SetActivity
;	COMDAT ?SetActivity@CTalkMonster@@UAEXW4Activity@@@Z
_TEXT	SEGMENT
_newActivity$ = 8
_this$ = -4
?SetActivity@CTalkMonster@@UAEXW4Activity@@@Z PROC NEAR	; CTalkMonster::SetActivity, COMDAT

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 363  : 	if (newActivity == ACT_IDLE && IsTalking() )

	cmp	DWORD PTR _newActivity$[ebp], 1
	jne	SHORT $L37242
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	je	SHORT $L37242

; 364  : 		newActivity = ACT_SIGNAL3;

	mov	DWORD PTR _newActivity$[ebp], 23	; 00000017H
$L37242:

; 365  : 	
; 366  : 	if ( newActivity == ACT_SIGNAL3 && (LookupActivity ( ACT_SIGNAL3 ) == ACTIVITY_NOT_AVAILABLE))

	cmp	DWORD PTR _newActivity$[ebp], 23	; 00000017H
	jne	SHORT $L37243
	push	23					; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	cmp	eax, -1
	jne	SHORT $L37243

; 367  : 		newActivity = ACT_IDLE;

	mov	DWORD PTR _newActivity$[ebp], 1
$L37243:

; 368  : 
; 369  : 	CBaseMonster::SetActivity( newActivity );

	mov	eax, DWORD PTR _newActivity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z ; CBaseMonster::SetActivity

; 370  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetActivity@CTalkMonster@@UAEXW4Activity@@@Z ENDP	; CTalkMonster::SetActivity
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	__real@4@4006b400000000000000
PUBLIC	__real@4@4007b400000000000000
PUBLIC	__real@4@c006b400000000000000
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@4@4004b400000000000000
PUBLIC	__real@4@40008000000000000000
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	?StartTask@CTalkMonster@@UAEXPAUTask_t@@@Z	; CTalkMonster::StartTask
PUBLIC	?IdleRespond@CTalkMonster@@QAEXXZ		; CTalkMonster::IdleRespond
PUBLIC	?FIdleSpeak@CTalkMonster@@QAEHXZ		; CTalkMonster::FIdleSpeak
PUBLIC	?FIdleStare@CTalkMonster@@QAEHXZ		; CTalkMonster::FIdleStare
PUBLIC	?FIdleHello@CTalkMonster@@QAEHXZ		; CTalkMonster::FIdleHello
PUBLIC	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z	; UTIL_MakeVectorsPrivate
PUBLIC	?TaskComplete@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskComplete
PUBLIC	?TaskFail@CBaseMonster@@QAEXXZ			; CBaseMonster::TaskFail
EXTRN	?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z:NEAR ; CBaseMonster::MoveToLocation
EXTRN	__fltused:NEAR
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?VecToYaw@CBaseMonster@@QAEMVVector@@@Z:NEAR	; CBaseMonster::VecToYaw
EXTRN	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::StartTask
;	COMDAT __real@4@4006b400000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@4@4006b400000000000000 DD 043340000r	; 180
CONST	ENDS
;	COMDAT __real@4@4007b400000000000000
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT __real@4@c006b400000000000000
CONST	SEGMENT
__real@4@c006b400000000000000 DD 0c3340000r	; -180
CONST	ENDS
;	COMDAT __real@4@00000000000000000000
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@4@4004b400000000000000
CONST	SEGMENT
__real@4@4004b400000000000000 DD 042340000r	; 45
CONST	ENDS
;	COMDAT __real@4@40008000000000000000
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT ?StartTask@CTalkMonster@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT
$T38214 = -48
$T38219 = -60
$T38220 = -72
_pTask$ = 8
_this$ = -4
_yaw$37260 = -8
_dir$37274 = -20
_move$37275 = -32
?StartTask@CTalkMonster@@UAEXPAUTask_t@@@Z PROC NEAR	; CTalkMonster::StartTask, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 	{

	mov	eax, DWORD PTR _pTask$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -84+[ebp], ecx
	mov	edx, DWORD PTR -84+[ebp]
	sub	edx, 78					; 0000004eH
	mov	DWORD PTR -84+[ebp], edx
	cmp	DWORD PTR -84+[ebp], 26			; 0000001aH
	ja	$L37285
	mov	ecx, DWORD PTR -84+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L38235[ecx]
	jmp	DWORD PTR $L38236[eax*4]
$L37252:

; 377  : 	case TASK_TLK_SPEAK:
; 378  : 		// ask question or make statement
; 379  : 		FIdleSpeak();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FIdleSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FIdleSpeak

; 380  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 381  : 		break;

	jmp	$L37249
$L37253:

; 382  : 
; 383  : 	case TASK_TLK_RESPOND:
; 384  : 		// respond to question
; 385  : 		IdleRespond();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleRespond@CTalkMonster@@QAEXXZ	; CTalkMonster::IdleRespond

; 386  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 387  : 		break;

	jmp	$L37249
$L37254:

; 388  : 
; 389  : 	case TASK_TLK_HELLO:
; 390  : 		// greet player
; 391  : 		FIdleHello();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FIdleHello@CTalkMonster@@QAEHXZ	; CTalkMonster::FIdleHello

; 392  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 393  : 		break;

	jmp	$L37249
$L37255:

; 394  : 	
; 395  : 
; 396  : 	case TASK_TLK_STARE:
; 397  : 		// let the player know I know he's staring at me.
; 398  : 		FIdleStare();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FIdleStare@CTalkMonster@@QAEHXZ	; CTalkMonster::FIdleStare

; 399  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 400  : 		break;

	jmp	$L37249
$L37256:

; 401  : 
; 402  : 	case TASK_FACE_PLAYER:
; 403  : 	case TASK_TLK_LOOK_AT_CLIENT:
; 404  : 	case TASK_TLK_CLIENT_STARE:
; 405  : 		// track head to the client for a while.
; 406  : 		m_flWaitFinished = gpGlobals->time + pTask->flData;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR _pTask$[ebp]
	fld	DWORD PTR [edx]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2060]

; 407  : 		break;

	jmp	$L37249
$L37257:

; 408  : 
; 409  : 	case TASK_TLK_EYECONTACT:
; 410  : 		break;

	jmp	$L37249
$L37258:

; 411  : 
; 412  : 	case TASK_TLK_IDEALYAW:
; 413  : 		if (m_hTalkTarget != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	$L37266

; 415  : 			pev->yaw_speed = 60;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+176], 1114636288		; 42700000H

; 416  : 			float yaw = VecToYaw(m_hTalkTarget->GetAbsOrigin() - GetAbsOrigin()) - GetAbsAngles().y;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T38214[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VecToYaw@CBaseMonster@@QAEMVVector@@@Z	; CBaseMonster::VecToYaw
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	fld	DWORD PTR -88+[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _yaw$37260[ebp]

; 417  : 
; 418  : 			if (yaw > 180) yaw -= 360;

	fld	DWORD PTR _yaw$37260[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37263
	fld	DWORD PTR _yaw$37260[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _yaw$37260[ebp]
$L37263:

; 419  : 			if (yaw < -180) yaw += 360;

	fld	DWORD PTR _yaw$37260[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37264
	fld	DWORD PTR _yaw$37260[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _yaw$37260[ebp]
$L37264:

; 420  : 
; 421  : 			if (yaw < 0)

	fld	DWORD PTR _yaw$37260[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37265

; 423  : 				pev->ideal_yaw = Q_min( yaw + 45, 0 ) + GetAbsAngles().y;

	fld	DWORD PTR _yaw$37260[ebp]
	fadd	DWORD PTR __real@4@4004b400000000000000
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38215
	fld	DWORD PTR _yaw$37260[ebp]
	fadd	DWORD PTR __real@4@4004b400000000000000
	fstp	DWORD PTR -92+[ebp]
	jmp	SHORT $L38216
$L38215:
	mov	DWORD PTR -92+[ebp], 0
$L38216:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	fld	DWORD PTR -92+[ebp]
	fadd	DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+172]

; 425  : 			else

	jmp	SHORT $L37266
$L37265:

; 427  : 				pev->ideal_yaw = Q_max( yaw - 45, 0 ) + GetAbsAngles().y;

	fld	DWORD PTR _yaw$37260[ebp]
	fsub	DWORD PTR __real@4@4004b400000000000000
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38217
	fld	DWORD PTR _yaw$37260[ebp]
	fsub	DWORD PTR __real@4@4004b400000000000000
	fstp	DWORD PTR -96+[ebp]
	jmp	SHORT $L38218
$L38217:
	mov	DWORD PTR -96+[ebp], 0
$L38218:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	fld	DWORD PTR -96+[ebp]
	fadd	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+172]
$L37266:

; 430  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 431  : 		break;

	jmp	$L37249
$L37267:

; 432  : 
; 433  : 	case TASK_TLK_HEADRESET:
; 434  : 		// reset head position after looking at something
; 435  : 		m_hTalkTarget = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 436  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 437  : 		break;

	jmp	$L37249
$L37268:

; 438  : 
; 439  : 	case TASK_TLK_STOPSHOOTING:
; 440  : 		// tell player to stop shooting
; 441  : 		PlaySentence( m_szGrp[TLK_NOSHOOT], RANDOM_FLOAT(2.8, 3.2), VOL_NORM, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2440]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+468]

; 442  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 443  : 		break;

	jmp	$L37249
$L37270:

; 444  : 
; 445  : 	case TASK_CANT_FOLLOW:
; 446  : 		StopFollowing( FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+612]

; 447  : 		PlaySentence( m_szGrp[TLK_STOP], RANDOM_FLOAT(2, 2.5), VOL_NORM, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	1075838976				; 40200000H
	push	1073741824				; 40000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2436]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+468]

; 448  : 		TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 449  : 		break;

	jmp	$L37249
$L37272:

; 450  : 
; 451  : 	case TASK_WALK_PATH_FOR_UNITS:
; 452  : 		m_movementActivity = ACT_WALK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2252], 3

; 453  : 		break;

	jmp	$L37249
$L37273:

; 457  : 			Vector dir = GetAbsAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _dir$37274[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 458  : 			dir.y = pev->ideal_yaw + 180;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+172]
	fadd	DWORD PTR __real@4@4006b400000000000000
	fstp	DWORD PTR _dir$37274[ebp+4]

; 459  : 			Vector move;

	lea	ecx, DWORD PTR _move$37275[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 460  : 
; 461  : 			UTIL_MakeVectorsPrivate( dir, move, NULL, NULL );

	push	0
	push	0
	lea	ecx, DWORD PTR _move$37275[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _dir$37274[ebp]
	push	ecx
	call	?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ; UTIL_MakeVectorsPrivate
	add	esp, 16					; 00000010H

; 462  : 			dir = GetAbsOrigin() + move * pTask->flData;

	mov	edx, DWORD PTR _pTask$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR $T38219[ebp]
	push	ecx
	lea	ecx, DWORD PTR _move$37275[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T38220[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dir$37274[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dir$37274[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _dir$37274[ebp+8], eax

; 463  : 
; 464  : 			if ( MoveToLocation( ACT_WALK, 2, dir ) )

	lea	ecx, DWORD PTR _dir$37274[ebp]
	push	ecx
	push	1073741824				; 40000000H
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MoveToLocation@CBaseMonster@@QAEHW4Activity@@MABVVector@@@Z ; CBaseMonster::MoveToLocation
	test	eax, eax
	je	SHORT $L37278

; 466  : 				TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 468  : 			else if ( FindCover( GetAbsOrigin(), pev->view_ofs, 0, CoverRadius() ) )

	jmp	SHORT $L37283
$L37278:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+516]
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 372				; 00000174H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+508]
	test	eax, eax
	je	SHORT $L37282

; 470  : 				// then try for plain ole cover
; 471  : 				m_flMoveWaitFinished = gpGlobals->time + 2;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@40008000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2064]

; 472  : 				TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 474  : 			else

	jmp	SHORT $L37283
$L37282:

; 476  : 				// nowhere to go?
; 477  : 				TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail
$L37283:

; 480  : 		break;

	jmp	SHORT $L37249
$L37284:

; 481  : 
; 482  : 	case TASK_PLAY_SCRIPT:
; 483  : 		m_hTalkTarget = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 484  : 		CBaseMonster::StartTask( pTask );

	mov	edx, DWORD PTR _pTask$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::StartTask

; 485  : 		break;

	jmp	SHORT $L37249
$L37285:

; 486  : 
; 487  : 	default:
; 488  : 		CBaseMonster::StartTask( pTask );

	mov	eax, DWORD PTR _pTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::StartTask
$L37249:

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L38236:
	DD	$L37284
	DD	$L37270
	DD	$L37273
	DD	$L37272
	DD	$L37253
	DD	$L37252
	DD	$L37254
	DD	$L37267
	DD	$L37268
	DD	$L37255
	DD	$L37256
	DD	$L37257
	DD	$L37258
	DD	$L37285
$L38235:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	10					; 0000000aH
?StartTask@CTalkMonster@@UAEXPAUTask_t@@@Z ENDP		; CTalkMonster::StartTask
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T38244 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T38244[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T38249 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T38249[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T38252 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T38252[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
;	COMDAT ?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z
_TEXT	SEGMENT
_vecAngles$ = 8
_p_vForward$ = 12
_p_vRight$ = 16
_p_vUp$ = 20
?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z PROC NEAR ; UTIL_MakeVectorsPrivate, COMDAT

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 344  : 	g_engfuncs.pfnAngleVectors( vecAngles, p_vForward, p_vRight, p_vUp );

	mov	eax, DWORD PTR _p_vUp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p_vRight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p_vForward$[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecAngles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+80
	add	esp, 16					; 00000010H

; 345  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UTIL_MakeVectorsPrivate@@YAXABVVector@@PAM11@Z ENDP	; UTIL_MakeVectorsPrivate
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
PUBLIC	?HasConditions@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasConditions
;	COMDAT ?TaskComplete@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TaskComplete@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::TaskComplete, COMDAT

; 226  : 		inline void TaskComplete( void ) { if ( !HasConditions(bits_COND_TASK_FAILED) ) m_iTaskStatus = TASKSTATUS_COMPLETE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L36088
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2088], 4
$L36088:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskComplete@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::TaskComplete
_TEXT	ENDS
PUBLIC	?SetConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::SetConditions
;	COMDAT ?TaskFail@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TaskFail@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::TaskFail, COMDAT

; 228  : 		inline void TaskFail( void ) { SetConditions(bits_COND_TASK_FAILED); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskFail@CBaseMonster@@QAEXXZ ENDP			; CBaseMonster::TaskFail
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?SetConditions@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::SetConditions, COMDAT

; 256  : 		inline void	SetConditions( int iConditions ) { m_afConditions |= iConditions; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	or	ecx, DWORD PTR _iConditions$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1956], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::SetConditions
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?HasConditions@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasConditions, COMDAT

; 258  : 		inline BOOL HasConditions( int iConditions ) { if ( m_afConditions & iConditions ) return TRUE; return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1956]
	and	ecx, DWORD PTR _iConditions$[ebp]
	test	ecx, ecx
	je	SHORT $L36111
	mov	eax, 1
	jmp	SHORT $L36110
$L36111:
	xor	eax, eax
$L36110:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasConditions@CBaseMonster@@QAEHH@Z ENDP		; CBaseMonster::HasConditions
_TEXT	ENDS
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	__real@4@40068000000000000000
PUBLIC	__real@4@4002a000000000000000
PUBLIC	?RunTask@CTalkMonster@@UAEXPAUTask_t@@@Z	; CTalkMonster::RunTask
PUBLIC	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z	; CTalkMonster::IdleHeadTurn
PUBLIC	?TaskIsComplete@CBaseMonster@@QAEHXZ		; CBaseMonster::TaskIsComplete
PUBLIC	?MovementIsComplete@CBaseMonster@@QAEHXZ	; CBaseMonster::MovementIsComplete
EXTRN	?RouteClear@CBaseMonster@@QAEXXZ:NEAR		; CBaseMonster::RouteClear
EXTRN	?UTIL_DotPoints@@YAMABVVector@@00@Z:NEAR	; UTIL_DotPoints
EXTRN	__ftol:NEAR
EXTRN	?SetBoneController@CBaseAnimating@@QAEMHM@Z:NEAR ; CBaseAnimating::SetBoneController
EXTRN	?FlYawDiff@CBaseMonster@@QAEMXZ:NEAR		; CBaseMonster::FlYawDiff
EXTRN	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z:NEAR	; UTIL_PlayerByIndex
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeVectors
EXTRN	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::RunTask
EXTRN	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z:NEAR ; CBaseMonster::MakeIdealYaw
;	COMDAT __real@4@40068000000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@4@40068000000000000000 DD 043000000r	; 128
CONST	ENDS
;	COMDAT __real@4@4002a000000000000000
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT ?RunTask@CTalkMonster@@UAEXPAUTask_t@@@Z
_TEXT	SEGMENT
$T38279 = -28
$T38281 = -44
_pTask$ = 8
_this$ = -4
_pPlayer$37295 = -8
_pPlayer$37305 = -12
_distance$37314 = -16
?RunTask@CTalkMonster@@UAEXPAUTask_t@@@Z PROC NEAR	; CTalkMonster::RunTask, COMDAT

; 494  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 496  : 	{

	mov	eax, DWORD PTR _pTask$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -48+[ebp], ecx
	mov	edx, DWORD PTR -48+[ebp]
	sub	edx, 89					; 00000059H
	mov	DWORD PTR -48+[ebp], edx
	cmp	DWORD PTR -48+[ebp], 15			; 0000000fH
	ja	$L37323
	mov	ecx, DWORD PTR -48+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L38287[ecx]
	jmp	DWORD PTR $L38288[eax*4]
$L37294:

; 497  : 	case TASK_TLK_CLIENT_STARE:
; 498  : 	case TASK_TLK_LOOK_AT_CLIENT:
; 499  : 
; 500  : 		CBaseEntity *pPlayer;
; 501  : 
; 502  : 		// track head to the client for a while.
; 503  : 		if ( m_MonsterState == MONSTERSTATE_IDLE && !IsMoving() && !IsTalking())

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2080], 1
	jne	SHORT $L37296
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+164]
	test	eax, eax
	jne	SHORT $L37296
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	jne	SHORT $L37296

; 505  : 			// Get edict for one player
; 506  : 			pPlayer = UTIL_PlayerByIndex( 1 );

	push	1
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$37295[ebp], eax

; 507  : 
; 508  : 			if ( pPlayer )

	cmp	DWORD PTR _pPlayer$37295[ebp], 0
	je	SHORT $L37297

; 510  : 				IdleHeadTurn( pPlayer->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pPlayer$37295[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ; CTalkMonster::IdleHeadTurn
$L37297:

; 513  : 		else

	jmp	SHORT $L37298
$L37296:

; 515  : 			// started moving or talking
; 516  : 			TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail

; 517  : 			return;

	jmp	$L37289
$L37298:

; 519  : 
; 520  : 		if ( pTask->iTask == TASK_TLK_CLIENT_STARE )

	mov	eax, DWORD PTR _pTask$[ebp]
	cmp	DWORD PTR [eax], 101			; 00000065H
	jne	$L37302

; 522  : 			// fail out if the player looks away or moves away.
; 523  : 			if ( ( pPlayer->GetAbsOrigin() - GetAbsOrigin() ).Length2D() > TLK_STARE_DIST )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T38279[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pPlayer$37295[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fcomp	DWORD PTR __real@4@40068000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37301

; 525  : 				// player moved away.
; 526  : 				TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail
$L37301:

; 528  : 
; 529  : 			UTIL_MakeVectors( pPlayer->GetAbsAngles() );

	mov	ecx, DWORD PTR _pPlayer$37295[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 530  : 			if ( UTIL_DotPoints( pPlayer->GetAbsOrigin(), GetAbsOrigin(), gpGlobals->v_forward ) < m_flFieldOfView )

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pPlayer$37295[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_DotPoints@@YAMABVVector@@00@Z	; UTIL_DotPoints
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	fcomp	DWORD PTR [eax+2056]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37302

; 532  : 				// player looked away
; 533  : 				TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail
$L37302:

; 536  : 
; 537  : 		if ( gpGlobals->time > m_flWaitFinished )

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+2060]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37303

; 539  : 			TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete
$L37303:

; 541  : 		break;

	jmp	$L37291
$L37304:

; 545  : 			// Get edict for one player
; 546  : 			CBaseEntity *pPlayer = UTIL_PlayerByIndex( 1 );

	push	1
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$37305[ebp], eax

; 547  : 
; 548  : 			if ( pPlayer )

	cmp	DWORD PTR _pPlayer$37305[ebp], 0
	je	$L37306

; 550  : 				MakeIdealYaw ( pPlayer->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pPlayer$37305[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z ; CBaseMonster::MakeIdealYaw

; 551  : 				ChangeYaw ( pev->yaw_speed );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+176]
	call	__ftol
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+356]
	fstp	ST(0)

; 552  : 				IdleHeadTurn( pPlayer->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pPlayer$37305[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ; CTalkMonster::IdleHeadTurn

; 553  : 				if ( gpGlobals->time > m_flWaitFinished && FlYawDiff() < 10 )

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+2060]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37308
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlYawDiff@CBaseMonster@@QAEMXZ		; CBaseMonster::FlYawDiff
	fcomp	DWORD PTR __real@4@4002a000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37308

; 555  : 					TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete
$L37308:

; 558  : 			else

	jmp	SHORT $L37309
$L37306:

; 560  : 				TaskFail();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskFail@CBaseMonster@@QAEXXZ		; CBaseMonster::TaskFail
$L37309:

; 563  : 		break;

	jmp	$L37291
$L37310:

; 564  : 
; 565  : 	case TASK_TLK_EYECONTACT:
; 566  : 		if (!IsMoving() && IsTalking() && m_hTalkTarget != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+164]
	test	eax, eax
	jne	SHORT $L37311
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	je	SHORT $L37311
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37311

; 568  : 			// ALERT( at_console, "waiting %f\n", m_flStopTalkTime - gpGlobals->time );
; 569  : 			IdleHeadTurn( m_hTalkTarget->GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ; CTalkMonster::IdleHeadTurn

; 571  : 		else

	jmp	SHORT $L37312
$L37311:

; 573  : 			TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete
$L37312:

; 575  : 		break;

	jmp	$L37291
$L37313:

; 579  : 			float distance;
; 580  : 
; 581  : 			distance = (m_vecLastPosition - GetAbsOrigin()).Length2D();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T38281[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2264				; 000008d8H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fstp	DWORD PTR _distance$37314[ebp]

; 582  : 
; 583  : 			// Walk path until far enough away
; 584  : 			if ( distance > pTask->flData || MovementIsComplete() )

	mov	ecx, DWORD PTR _pTask$[ebp]
	fld	DWORD PTR _distance$37314[ebp]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37317
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MovementIsComplete@CBaseMonster@@QAEHXZ ; CBaseMonster::MovementIsComplete
	test	eax, eax
	je	SHORT $L37316
$L37317:

; 586  : 				TaskComplete();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskComplete@CBaseMonster@@QAEXXZ	; CBaseMonster::TaskComplete

; 587  : 				RouteClear();		// Stop moving

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteClear@CBaseMonster@@QAEXXZ	; CBaseMonster::RouteClear
$L37316:

; 590  : 		break;

	jmp	$L37291
$L37318:

; 591  : 	case TASK_WAIT_FOR_MOVEMENT:
; 592  : 		if (IsTalking() && m_hTalkTarget != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	je	SHORT $L37319
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37319

; 594  : 			// ALERT(at_console, "walking, talking\n");
; 595  : 			IdleHeadTurn( m_hTalkTarget->GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ; CTalkMonster::IdleHeadTurn

; 597  : 		else

	jmp	SHORT $L37321
$L37319:

; 599  : 			IdleHeadTurn( GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ; CTalkMonster::IdleHeadTurn

; 600  : 			// override so that during walk, a scientist may talk and greet player
; 601  : 			FIdleHello();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FIdleHello@CTalkMonster@@QAEHXZ	; CTalkMonster::FIdleHello

; 602  : 			if (RANDOM_LONG(0,m_nSpeak * 20) == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2400]
	imul	eax, 20					; 00000014H
	push	eax
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	SHORT $L37321

; 604  : 				FIdleSpeak();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FIdleSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FIdleSpeak
$L37321:

; 607  : 
; 608  : 		CBaseMonster::RunTask( pTask );

	mov	ecx, DWORD PTR _pTask$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::RunTask

; 609  : 		if (TaskIsComplete())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?TaskIsComplete@CBaseMonster@@QAEHXZ	; CBaseMonster::TaskIsComplete
	test	eax, eax
	je	SHORT $L37322

; 610  : 			IdleHeadTurn( GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ; CTalkMonster::IdleHeadTurn
$L37322:

; 611  : 		break;

	jmp	SHORT $L37291
$L37323:

; 612  : 
; 613  : 	default:
; 614  : 		if (IsTalking() && m_hTalkTarget != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	je	SHORT $L37324
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37324

; 616  : 			IdleHeadTurn( m_hTalkTarget->GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ; CTalkMonster::IdleHeadTurn

; 618  : 		else

	jmp	SHORT $L37325
$L37324:

; 620  : 			SetBoneController( 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBoneController@CBaseAnimating@@QAEMHM@Z ; CBaseAnimating::SetBoneController
	fstp	ST(0)
$L37325:

; 622  : 		CBaseMonster::RunTask( pTask );

	mov	edx, DWORD PTR _pTask$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z ; CBaseMonster::RunTask
$L37291:
$L37289:

; 624  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L38288:
	DD	$L37318
	DD	$L37313
	DD	$L37294
	DD	$L37310
	DD	$L37304
	DD	$L37323
$L38287:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	DB	2
	DB	3
	DB	5
	DB	4
?RunTask@CTalkMonster@@UAEXPAUTask_t@@@Z ENDP		; CTalkMonster::RunTask
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length2D@Vector@@QBEMXZ PROC NEAR			; Vector::Length2D, COMDAT

; 282  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
;	COMDAT ?TaskIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?TaskIsComplete@CBaseMonster@@QAEHXZ PROC NEAR		; CBaseMonster::TaskIsComplete, COMDAT

; 231  : 		inline int TaskIsComplete( void ) { return (m_iTaskStatus == TASKSTATUS_COMPLETE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2088], 4
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TaskIsComplete@CBaseMonster@@QAEHXZ ENDP		; CBaseMonster::TaskIsComplete
_TEXT	ENDS
;	COMDAT ?MovementIsComplete@CBaseMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?MovementIsComplete@CBaseMonster@@QAEHXZ PROC NEAR	; CBaseMonster::MovementIsComplete, COMDAT

; 232  : 		inline int MovementIsComplete( void ) { return (m_movementGoal == MOVEGOAL_NONE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2228], 0
	sete	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MovementIsComplete@CBaseMonster@@QAEHXZ ENDP		; CBaseMonster::MovementIsComplete
_TEXT	ENDS
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
PUBLIC	?StopTalking@CTalkMonster@@QAEXXZ		; CTalkMonster::StopTalking
PUBLIC	?Killed@CTalkMonster@@UAEXPAUentvars_s@@H@Z	; CTalkMonster::Killed
PUBLIC	?AlertFriends@CTalkMonster@@QAEXXZ		; CTalkMonster::AlertFriends
PUBLIC	?LimitFollowers@CTalkMonster@@QAEXPAVCBaseEntity@@H@Z ; CTalkMonster::LimitFollowers
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
PUBLIC	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet
EXTRN	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z:NEAR ; CBaseMonster::Killed
;	COMDAT ??_C@_04BAK@NULL?$AA@
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ?Killed@CTalkMonster@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT
_pevAttacker$ = 8
_iGib$ = 12
_this$ = -4
?Killed@CTalkMonster@@UAEXPAUentvars_s@@H@Z PROC NEAR	; CTalkMonster::Killed, COMDAT

; 628  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 629  : 	// If a client killed me (unless I was already Barnacle'd), make everyone else mad/afraid of him
; 630  : 	if ( (pevAttacker->flags & FL_CLIENT) && m_MonsterState != MONSTERSTATE_PRONE )

	mov	eax, DWORD PTR _pevAttacker$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 8
	test	ecx, ecx
	je	SHORT $L37331
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2080], 5
	je	SHORT $L37331

; 632  : 		AlertFriends();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?AlertFriends@CTalkMonster@@QAEXXZ	; CTalkMonster::AlertFriends

; 633  : 		LimitFollowers( CBaseEntity::Instance(pevAttacker), 0 );

	push	0
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LimitFollowers@CTalkMonster@@QAEXPAVCBaseEntity@@H@Z ; CTalkMonster::LimitFollowers
$L37331:

; 635  : 
; 636  : 	m_hTargetEnt = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 637  : 	// Don't finish that sentence
; 638  : 	StopTalking();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopTalking@CTalkMonster@@QAEXXZ	; CTalkMonster::StopTalking

; 639  : 	SetUse( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ; CBaseEntity::UseSet

; 640  : 	CBaseMonster::Killed( pevAttacker, iGib );

	mov	ecx, DWORD PTR _iGib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevAttacker$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z ; CBaseMonster::Killed

; 641  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Killed@CTalkMonster@@UAEXPAUentvars_s@@H@Z ENDP	; CTalkMonster::Killed
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC NEAR ; CBaseEntity::Instance, COMDAT

; 533  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z PROC NEAR ; CBaseEntity::UseSet, COMDAT

; 574  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 575  : 		m_pfnUse = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1752], ecx

; 576  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnUse)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1752]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 577  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 578  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?UseSet@CBaseEntity@@QAEP81@AEXPAV1@0W4USE_TYPE@@M@ZP81@AEX001M@ZPAD@Z ENDP ; CBaseEntity::UseSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?StopTalking@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopTalking@CTalkMonster@@QAEXXZ PROC NEAR		; CTalkMonster::StopTalking, COMDAT

; 106  : 	void			StopTalking( void ) { SentenceStop(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+476]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopTalking@CTalkMonster@@QAEXXZ ENDP			; CTalkMonster::StopTalking
_TEXT	ENDS
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z ; CTalkMonster::EnumFriends
EXTRN	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByClassname
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT __real@8@3fff8000000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT ?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z
_TEXT	SEGMENT
_pPrevious$ = 8
_listNumber$ = 12
_bTrace$ = 16
_this$ = -4
_pFriend$ = -8
_pszFriend$ = -12
_tr$ = -68
_vecCheck$ = -80
?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z PROC NEAR ; CTalkMonster::EnumFriends, COMDAT

; 646  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 647  : 	CBaseEntity *pFriend = pPrevious;

	mov	eax, DWORD PTR _pPrevious$[ebp]
	mov	DWORD PTR _pFriend$[ebp], eax

; 648  : 	char *pszFriend;
; 649  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 650  : 	Vector vecCheck;

	lea	ecx, DWORD PTR _vecCheck$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 651  : 
; 652  : 	pszFriend = m_szFriends[ FriendNumber(listNumber) ];

	mov	ecx, DWORD PTR _listNumber$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+624]
	mov	ecx, DWORD PTR ?m_szFriends@CTalkMonster@@2PAPADA[eax*4]
	mov	DWORD PTR _pszFriend$[ebp], ecx
$L37349:

; 653  : 	while (pFriend = UTIL_FindEntityByClassname( pFriend, pszFriend ))

	mov	edx, DWORD PTR _pszFriend$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFriend$[ebp]
	push	eax
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pFriend$[ebp], eax
	cmp	DWORD PTR _pFriend$[ebp], 0
	je	$L37350

; 655  : 		if (pFriend == this || !pFriend->IsAlive())

	mov	ecx, DWORD PTR _pFriend$[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $L37352
	mov	edx, DWORD PTR _pFriend$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	jne	SHORT $L37351
$L37352:

; 656  : 			// don't talk to self or dead people
; 657  : 			continue;

	jmp	SHORT $L37349
$L37351:

; 658  : 		if ( bTrace )

	cmp	DWORD PTR _bTrace$[ebp], 0
	je	SHORT $L37353

; 660  : 			vecCheck = pFriend->GetAbsOrigin();

	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecCheck$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecCheck$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecCheck$[ebp+8], eax

; 661  : 			vecCheck.z = pFriend->pev->absmax.z;

	mov	ecx, DWORD PTR _pFriend$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+216]
	mov	DWORD PTR _vecCheck$[ebp+8], eax

; 662  : 
; 663  : 			UTIL_TraceLine( GetAbsOrigin(), vecCheck, ignore_monsters, ENT(pev), &tr);

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	lea	ecx, DWORD PTR _vecCheck$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 665  : 		else

	jmp	SHORT $L37354
$L37353:

; 666  : 			tr.flFraction = 1.0;

	mov	DWORD PTR _tr$[ebp+16], 1065353216	; 3f800000H
$L37354:

; 667  : 
; 668  : 		if (tr.flFraction == 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37355

; 670  : 			return pFriend;

	mov	eax, DWORD PTR _pFriend$[ebp]
	jmp	SHORT $L37343
$L37355:

; 672  : 	}

	jmp	$L37349
$L37350:

; 673  : 
; 674  : 	return NULL;

	xor	eax, eax
$L37343:

; 675  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z ENDP ; CTalkMonster::EnumFriends
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
;	COMDAT ?AlertFriends@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pFriend$ = -8
_i$ = -12
_pMonster$37370 = -16
?AlertFriends@CTalkMonster@@QAEXXZ PROC NEAR		; CTalkMonster::AlertFriends, COMDAT

; 679  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 680  : 	CBaseEntity *pFriend = NULL;

	mov	DWORD PTR _pFriend$[ebp], 0

; 681  : 	int i;
; 682  : 
; 683  : 	// for each friend in this bsp...
; 684  : 	for ( i = 0; i < TLK_CFRIENDS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37364
$L37365:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L37364:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L37366
$L37368:

; 686  : 		while (pFriend = EnumFriends( pFriend, i, TRUE ))

	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFriend$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z ; CTalkMonster::EnumFriends
	mov	DWORD PTR _pFriend$[ebp], eax
	cmp	DWORD PTR _pFriend$[ebp], 0
	je	SHORT $L37369

; 688  : 			CBaseMonster *pMonster = pFriend->MyMonsterPointer();

	mov	eax, DWORD PTR _pFriend$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pMonster$37370[ebp], eax

; 689  : 			if ( pMonster->IsAlive() )

	mov	eax, DWORD PTR _pMonster$37370[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pMonster$37370[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	SHORT $L37371

; 691  : 				// don't provoke a friend that's playing a death animation. They're a goner
; 692  : 				pMonster->m_afMemory |= bits_MEMORY_PROVOKED;

	mov	eax, DWORD PTR _pMonster$37370[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	or	ecx, 1
	mov	edx, DWORD PTR _pMonster$37370[ebp]
	mov	DWORD PTR [edx+2280], ecx
$L37371:

; 694  : 		}

	jmp	SHORT $L37368
$L37369:

; 695  : 	}

	jmp	SHORT $L37365
$L37366:

; 696  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlertFriends@CTalkMonster@@QAEXXZ ENDP			; CTalkMonster::AlertFriends
_TEXT	ENDS
PUBLIC	?ShutUpFriends@CTalkMonster@@QAEXXZ		; CTalkMonster::ShutUpFriends
;	COMDAT ?ShutUpFriends@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pFriend$ = -8
_i$ = -12
_pMonster$37384 = -16
?ShutUpFriends@CTalkMonster@@QAEXXZ PROC NEAR		; CTalkMonster::ShutUpFriends, COMDAT

; 701  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 702  : 	CBaseEntity *pFriend = NULL;

	mov	DWORD PTR _pFriend$[ebp], 0

; 703  : 	int i;
; 704  : 
; 705  : 	// for each friend in this bsp...
; 706  : 	for ( i = 0; i < TLK_CFRIENDS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37378
$L37379:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L37378:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L37380
$L37382:

; 708  : 		while (pFriend = EnumFriends( pFriend, i, TRUE ))

	push	1
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFriend$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z ; CTalkMonster::EnumFriends
	mov	DWORD PTR _pFriend$[ebp], eax
	cmp	DWORD PTR _pFriend$[ebp], 0
	je	SHORT $L37383

; 710  : 			CBaseMonster *pMonster = pFriend->MyMonsterPointer();

	mov	eax, DWORD PTR _pFriend$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pMonster$37384[ebp], eax

; 711  : 			if ( pMonster )

	cmp	DWORD PTR _pMonster$37384[ebp], 0
	je	SHORT $L37385

; 713  : 				pMonster->SentenceStop();

	mov	eax, DWORD PTR _pMonster$37384[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pMonster$37384[ebp]
	call	DWORD PTR [edx+476]
$L37385:

; 715  : 		}

	jmp	SHORT $L37382
$L37383:

; 716  : 	}

	jmp	SHORT $L37379
$L37380:

; 717  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ShutUpFriends@CTalkMonster@@QAEXXZ ENDP		; CTalkMonster::ShutUpFriends
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
;	COMDAT ?LimitFollowers@CTalkMonster@@QAEXPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_maxFollowers$ = 12
_this$ = -4
_pFriend$ = -8
_i$ = -12
_count$ = -16
_pMonster$37400 = -20
?LimitFollowers@CTalkMonster@@QAEXPAVCBaseEntity@@H@Z PROC NEAR ; CTalkMonster::LimitFollowers, COMDAT

; 723  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 724  : 	CBaseEntity *pFriend = NULL;

	mov	DWORD PTR _pFriend$[ebp], 0

; 725  : 	int i, count;
; 726  : 
; 727  : 	count = 0;

	mov	DWORD PTR _count$[ebp], 0

; 728  : 	// for each friend in this bsp...
; 729  : 	for ( i = 0; i < TLK_CFRIENDS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L37394
$L37395:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L37394:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L37396
$L37398:

; 731  : 		while (pFriend = EnumFriends( pFriend, i, FALSE ))

	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFriend$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnumFriends@CTalkMonster@@QAEPAVCBaseEntity@@PAV2@HH@Z ; CTalkMonster::EnumFriends
	mov	DWORD PTR _pFriend$[ebp], eax
	cmp	DWORD PTR _pFriend$[ebp], 0
	je	SHORT $L37399

; 733  : 			CBaseMonster *pMonster = pFriend->MyMonsterPointer();

	mov	eax, DWORD PTR _pFriend$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pMonster$37400[ebp], eax

; 734  : 			if ( pMonster )

	cmp	DWORD PTR _pMonster$37400[ebp], 0
	je	SHORT $L37403

; 736  : 				if ( pMonster->m_hTargetEnt == pPlayer )

	mov	ecx, DWORD PTR _pMonster$37400[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	eax, DWORD PTR _pPlayer$[ebp]
	jne	SHORT $L37403

; 738  : 					count++;

	mov	eax, DWORD PTR _count$[ebp]
	add	eax, 1
	mov	DWORD PTR _count$[ebp], eax

; 739  : 					if ( count > maxFollowers )

	mov	ecx, DWORD PTR _count$[ebp]
	cmp	ecx, DWORD PTR _maxFollowers$[ebp]
	jle	SHORT $L37403

; 740  : 						pMonster->StopFollowing( TRUE );

	push	1
	mov	edx, DWORD PTR _pMonster$37400[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pMonster$37400[ebp]
	call	DWORD PTR [eax+612]
$L37403:

; 743  : 		}

	jmp	SHORT $L37398
$L37399:

; 744  : 	}

	jmp	SHORT $L37395
$L37396:

; 745  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LimitFollowers@CTalkMonster@@QAEXPAVCBaseEntity@@H@Z ENDP ; CTalkMonster::LimitFollowers
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	__real@4@4012f424000000000000
PUBLIC	?TargetDistance@CTalkMonster@@QAEMXZ		; CTalkMonster::TargetDistance
;	COMDAT __real@4@4012f424000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@4@4012f424000000000000 DD 049742400r	; 1e+006
CONST	ENDS
;	COMDAT ?TargetDistance@CTalkMonster@@QAEMXZ
_TEXT	SEGMENT
$T38329 = -16
_this$ = -4
?TargetDistance@CTalkMonster@@QAEMXZ PROC NEAR		; CTalkMonster::TargetDistance, COMDAT

; 749  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 750  : 	// If we lose the player, or he dies, return a really large distance
; 751  : 	if ( m_hTargetEnt == NULL || !m_hTargetEnt->IsAlive() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37409
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -20+[ebp], eax
	mov	eax, DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -20+[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L37408
$L37409:

; 752  : 		return 1e6;

	fld	DWORD PTR __real@4@4012f424000000000000
	jmp	SHORT $L37407
$L37408:

; 753  : 
; 754  : 	return (m_hTargetEnt->GetAbsOrigin() - GetAbsOrigin()).Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T38329[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
$L37407:

; 755  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TargetDistance@CTalkMonster@@QAEMXZ ENDP		; CTalkMonster::TargetDistance
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
PUBLIC	?HandleAnimEvent@CTalkMonster@@UAEXPAUMonsterEvent_t@@@Z ; CTalkMonster::HandleAnimEvent
EXTRN	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z:NEAR ; CBaseMonster::HandleAnimEvent
;	COMDAT ?HandleAnimEvent@CTalkMonster@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_pEvent$ = 8
_this$ = -4
?HandleAnimEvent@CTalkMonster@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CTalkMonster::HandleAnimEvent, COMDAT

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 	{		

	mov	eax, DWORD PTR _pEvent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR -8+[ebp], ecx
	cmp	DWORD PTR -8+[ebp], 1005		; 000003edH
	je	SHORT $L37420
	cmp	DWORD PTR -8+[ebp], 1009		; 000003f1H
	je	SHORT $L37419
	jmp	SHORT $L37423
$L37419:

; 766  : 	case SCRIPT_EVENT_SENTENCE_RND1:		// Play a named sentence group 25% of the time
; 767  : 		if (RANDOM_LONG(0,99) < 75)

	push	99					; 00000063H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	cmp	eax, 75					; 0000004bH
	jge	SHORT $L37420

; 768  : 			break;

	jmp	SHORT $L37416
$L37420:

; 771  : 		ShutUpFriends();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShutUpFriends@CTalkMonster@@QAEXXZ	; CTalkMonster::ShutUpFriends

; 772  : 		PlaySentence( pEvent->options, RANDOM_FLOAT(2.8, 3.4), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1079613850				; 4059999aH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _pEvent$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 773  : 		//ALERT(at_console, "script event speak\n");
; 774  : 		break;

	jmp	SHORT $L37416
$L37423:

; 775  : 
; 776  : 	default:
; 777  : 		CBaseMonster::HandleAnimEvent( pEvent );

	mov	eax, DWORD PTR _pEvent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z ; CBaseMonster::HandleAnimEvent
$L37416:

; 780  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HandleAnimEvent@CTalkMonster@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CTalkMonster::HandleAnimEvent
_TEXT	ENDS
PUBLIC	??_C@_01NON@_?$AA@				; `string'
PUBLIC	??_C@_06POMA@ANSWER?$AA@			; `string'
PUBLIC	??_C@_08PKJP@QUESTION?$AA@			; `string'
PUBLIC	??_C@_04HGOH@IDLE?$AA@				; `string'
PUBLIC	??_C@_05OAGM@STARE?$AA@				; `string'
PUBLIC	??_C@_07KAJG@PFOLLOW?$AA@			; `string'
PUBLIC	??_C@_02HAGF@OK?$AA@				; `string'
PUBLIC	??_C@_05IIBA@PWAIT?$AA@				; `string'
PUBLIC	??_C@_04IDBB@WAIT?$AA@				; `string'
PUBLIC	??_C@_03NEKF@POK?$AA@				; `string'
PUBLIC	??_C@_05NAPF@NOTOK?$AA@				; `string'
PUBLIC	??_C@_04PANM@STOP?$AA@				; `string'
PUBLIC	??_C@_07PNJN@NOSHOOT?$AA@			; `string'
PUBLIC	??_C@_05FAGC@HELLO?$AA@				; `string'
PUBLIC	??_C@_07KNDG@PLHURT1?$AA@			; `string'
PUBLIC	??_C@_07FCIP@PLHURT2?$AA@			; `string'
PUBLIC	??_C@_07PIBI@PLHURT3?$AA@			; `string'
PUBLIC	??_C@_06GCGJ@PHELLO?$AA@			; `string'
PUBLIC	??_C@_05HNOG@PIDLE?$AA@				; `string'
PUBLIC	??_C@_09EMBG@PQUESTION?$AA@			; `string'
PUBLIC	??_C@_05KEPI@SMELL?$AA@				; `string'
PUBLIC	??_C@_05DGEO@WOUND?$AA@				; `string'
PUBLIC	??_C@_06COBN@MORTAL?$AA@			; `string'
PUBLIC	?TalkInit@CTalkMonster@@QAEXXZ			; CTalkMonster::TalkInit
EXTRN	_strcpy:NEAR
;	COMDAT ??_C@_01NON@_?$AA@
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
??_C@_01NON@_?$AA@ DB '_', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06POMA@ANSWER?$AA@
CONST	SEGMENT
??_C@_06POMA@ANSWER?$AA@ DB 'ANSWER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08PKJP@QUESTION?$AA@
CONST	SEGMENT
??_C@_08PKJP@QUESTION?$AA@ DB 'QUESTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HGOH@IDLE?$AA@
CONST	SEGMENT
??_C@_04HGOH@IDLE?$AA@ DB 'IDLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAGM@STARE?$AA@
CONST	SEGMENT
??_C@_05OAGM@STARE?$AA@ DB 'STARE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KAJG@PFOLLOW?$AA@
CONST	SEGMENT
??_C@_07KAJG@PFOLLOW?$AA@ DB 'PFOLLOW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HAGF@OK?$AA@
CONST	SEGMENT
??_C@_02HAGF@OK?$AA@ DB 'OK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05IIBA@PWAIT?$AA@
CONST	SEGMENT
??_C@_05IIBA@PWAIT?$AA@ DB 'PWAIT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IDBB@WAIT?$AA@
CONST	SEGMENT
??_C@_04IDBB@WAIT?$AA@ DB 'WAIT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NEKF@POK?$AA@
CONST	SEGMENT
??_C@_03NEKF@POK?$AA@ DB 'POK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAPF@NOTOK?$AA@
CONST	SEGMENT
??_C@_05NAPF@NOTOK?$AA@ DB 'NOTOK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PANM@STOP?$AA@
CONST	SEGMENT
??_C@_04PANM@STOP?$AA@ DB 'STOP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07PNJN@NOSHOOT?$AA@
CONST	SEGMENT
??_C@_07PNJN@NOSHOOT?$AA@ DB 'NOSHOOT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGC@HELLO?$AA@
CONST	SEGMENT
??_C@_05FAGC@HELLO?$AA@ DB 'HELLO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KNDG@PLHURT1?$AA@
CONST	SEGMENT
??_C@_07KNDG@PLHURT1?$AA@ DB 'PLHURT1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCIP@PLHURT2?$AA@
CONST	SEGMENT
??_C@_07FCIP@PLHURT2?$AA@ DB 'PLHURT2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PIBI@PLHURT3?$AA@
CONST	SEGMENT
??_C@_07PIBI@PLHURT3?$AA@ DB 'PLHURT3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GCGJ@PHELLO?$AA@
CONST	SEGMENT
??_C@_06GCGJ@PHELLO?$AA@ DB 'PHELLO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNOG@PIDLE?$AA@
CONST	SEGMENT
??_C@_05HNOG@PIDLE?$AA@ DB 'PIDLE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EMBG@PQUESTION?$AA@
CONST	SEGMENT
??_C@_09EMBG@PQUESTION?$AA@ DB 'PQUESTION', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KEPI@SMELL?$AA@
CONST	SEGMENT
??_C@_05KEPI@SMELL?$AA@ DB 'SMELL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DGEO@WOUND?$AA@
CONST	SEGMENT
??_C@_05DGEO@WOUND?$AA@ DB 'WOUND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06COBN@MORTAL?$AA@
CONST	SEGMENT
??_C@_06COBN@MORTAL?$AA@ DB 'MORTAL', 00H		; `string'
CONST	ENDS
;	COMDAT ?TalkInit@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_szBuf$37429 = -68
_szAssign$37431 = -72
?TalkInit@CTalkMonster@@QAEXXZ PROC NEAR		; CTalkMonster::TalkInit, COMDAT

; 785  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 786  : 	// every new talking monster must reset this global, otherwise
; 787  : 	// when a level is loaded, nobody will talk (time is reset to 0)
; 788  : 
; 789  : 	CTalkMonster::g_talkWaitTime = 0;

	mov	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA, 0

; 790  : 
; 791  : 	if (m_iszSpeakAs) //LRC: changing voice groups for monsters

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2500], 0
	je	$L37428

; 793  : 		char szBuf[64];
; 794  : 		strcpy(szBuf,STRING(m_iszSpeakAs));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2500]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _szBuf$37429[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 795  : 		strcat(szBuf,"_");

	push	OFFSET FLAT:??_C@_01NON@_?$AA@		; `string'
	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 796  : 		char *szAssign = &(szBuf[strlen(szBuf)]);

	lea	edx, DWORD PTR _szBuf$37429[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szBuf$37429[ebp+eax]
	mov	DWORD PTR _szAssign$37431[ebp], eax

; 797  : 
; 798  : 		//LRC - this is pretty dodgy; test with save/restore.
; 799  : 		strcpy(szAssign,"ANSWER");

	push	OFFSET FLAT:??_C@_06POMA@ANSWER?$AA@	; `string'
	mov	ecx, DWORD PTR _szAssign$37431[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 800  : 		m_szGrp[TLK_ANSWER]  = STRING(ALLOC_STRING(szBuf));

	lea	edx, DWORD PTR _szBuf$37429[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2408], eax

; 801  : 		strcpy(szAssign,"QUESTION");

	push	OFFSET FLAT:??_C@_08PKJP@QUESTION?$AA@	; `string'
	mov	edx, DWORD PTR _szAssign$37431[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 802  : 		m_szGrp[TLK_QUESTION]  = STRING(ALLOC_STRING(szBuf));

	lea	eax, DWORD PTR _szBuf$37429[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2412], eax

; 803  : 		strcpy(szAssign,"IDLE");

	push	OFFSET FLAT:??_C@_04HGOH@IDLE?$AA@	; `string'
	mov	edx, DWORD PTR _szAssign$37431[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 804  : 		m_szGrp[TLK_IDLE]  = STRING(ALLOC_STRING(szBuf));

	lea	eax, DWORD PTR _szBuf$37429[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2416], eax

; 805  : 		strcpy(szAssign,"STARE");

	push	OFFSET FLAT:??_C@_05OAGM@STARE?$AA@	; `string'
	mov	edx, DWORD PTR _szAssign$37431[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 806  : 		m_szGrp[TLK_STARE]  = STRING(ALLOC_STRING(szBuf));

	lea	eax, DWORD PTR _szBuf$37429[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2420], eax

; 807  : 		if (pev->spawnflags & SF_MONSTER_PREDISASTER) //LRC

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L37436

; 808  : 			strcpy(szAssign,"PFOLLOW");

	push	OFFSET FLAT:??_C@_07KAJG@PFOLLOW?$AA@	; `string'
	mov	edx, DWORD PTR _szAssign$37431[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 809  : 		else

	jmp	SHORT $L37438
$L37436:

; 810  : 			strcpy(szAssign,"OK");

	push	OFFSET FLAT:??_C@_02HAGF@OK?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L37438:

; 811  : 		m_szGrp[TLK_USE]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2424], eax

; 812  : 		if (pev->spawnflags & SF_MONSTER_PREDISASTER) //LRC

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L37440

; 813  : 			strcpy(szAssign,"PWAIT");

	push	OFFSET FLAT:??_C@_05IIBA@PWAIT?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 814  : 		else

	jmp	SHORT $L37442
$L37440:

; 815  : 			strcpy(szAssign,"WAIT");

	push	OFFSET FLAT:??_C@_04IDBB@WAIT?$AA@	; `string'
	mov	ecx, DWORD PTR _szAssign$37431[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L37442:

; 816  : 		m_szGrp[TLK_UNUSE]  = STRING(ALLOC_STRING(szBuf));

	lea	edx, DWORD PTR _szBuf$37429[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2428], eax

; 817  : 		if (pev->spawnflags & SF_MONSTER_PREDISASTER) //LRC

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L37444

; 818  : 			strcpy(szAssign,"POK");

	push	OFFSET FLAT:??_C@_03NEKF@POK?$AA@	; `string'
	mov	edx, DWORD PTR _szAssign$37431[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 819  : 		else

	jmp	SHORT $L37446
$L37444:

; 820  : 			strcpy(szAssign,"NOTOK");

	push	OFFSET FLAT:??_C@_05NAPF@NOTOK?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L37446:

; 821  : 		m_szGrp[TLK_DECLINE]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2432], eax

; 822  : 		strcpy(szAssign,"STOP");

	push	OFFSET FLAT:??_C@_04PANM@STOP?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 823  : 		m_szGrp[TLK_STOP]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2436], eax

; 824  : 		strcpy(szAssign,"NOSHOOT");

	push	OFFSET FLAT:??_C@_07PNJN@NOSHOOT?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 825  : 		m_szGrp[TLK_NOSHOOT]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2440], eax

; 826  : 		strcpy(szAssign,"HELLO");

	push	OFFSET FLAT:??_C@_05FAGC@HELLO?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 827  : 		m_szGrp[TLK_HELLO]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2444], eax

; 828  : 		strcpy(szAssign,"PLHURT1");

	push	OFFSET FLAT:??_C@_07KNDG@PLHURT1?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 829  : 		m_szGrp[TLK_PLHURT1]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2460], eax

; 830  : 		strcpy(szAssign,"PLHURT2");

	push	OFFSET FLAT:??_C@_07FCIP@PLHURT2?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 831  : 		m_szGrp[TLK_PLHURT2]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2464], eax

; 832  : 		strcpy(szAssign,"PLHURT3");

	push	OFFSET FLAT:??_C@_07PIBI@PLHURT3?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 833  : 		m_szGrp[TLK_PLHURT3]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2468], eax

; 834  : 		strcpy(szAssign,"PHELLO");

	push	OFFSET FLAT:??_C@_06GCGJ@PHELLO?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 835  : 		m_szGrp[TLK_PHELLO]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2448], eax

; 836  : 		strcpy(szAssign,"PIDLE");

	push	OFFSET FLAT:??_C@_05HNOG@PIDLE?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 837  : 		m_szGrp[TLK_PIDLE]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2452], eax

; 838  : 		strcpy(szAssign,"PQUESTION");

	push	OFFSET FLAT:??_C@_09EMBG@PQUESTION?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 839  : 		m_szGrp[TLK_PQUESTION]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2456], eax

; 840  : 		strcpy(szAssign,"SMELL");

	push	OFFSET FLAT:??_C@_05KEPI@SMELL?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 841  : 		m_szGrp[TLK_SMELL]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2472], eax

; 842  : 		strcpy(szAssign,"WOUND");

	push	OFFSET FLAT:??_C@_05DGEO@WOUND?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 843  : 		m_szGrp[TLK_WOUND]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2476], eax

; 844  : 		strcpy(szAssign,"MORTAL");

	push	OFFSET FLAT:??_C@_06COBN@MORTAL?$AA@	; `string'
	mov	eax, DWORD PTR _szAssign$37431[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 845  : 		m_szGrp[TLK_MORTAL]  = STRING(ALLOC_STRING(szBuf));

	lea	ecx, DWORD PTR _szBuf$37429[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2480], eax
$L37428:

; 847  : 
; 848  : 	m_voicePitch = 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2404], 100		; 00000064H

; 849  : }	

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TalkInit@CTalkMonster@@QAEXXZ ENDP			; CTalkMonster::TalkInit
_TEXT	ENDS
PUBLIC	__real@8@4007fa00000000000000
PUBLIC	??_C@_06MNOE@player?$AA@			; `string'
PUBLIC	?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z ; CTalkMonster::FindNearestFriend
;	COMDAT ??_C@_06MNOE@player?$AA@
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
??_C@_06MNOE@player?$AA@ DB 'player', 00H		; `string'
CONST	ENDS
;	COMDAT __real@8@4007fa00000000000000
CONST	SEGMENT
__real@8@4007fa00000000000000 DQ 0407f400000000000r ; 500
CONST	ENDS
;	COMDAT ?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
$T38340 = -124
$T38341 = -136
$T38342 = -148
_fPlayer$ = 8
_this$ = -4
_pFriend$ = -8
_pNearest$ = -12
_range$ = -16
_tr$ = -72
_vecStart$ = -84
_vecCheck$ = -96
_i$ = -100
_pszFriend$ = -104
_cfriends$ = -108
_pMonster$37487 = -112
?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z PROC NEAR ; CTalkMonster::FindNearestFriend, COMDAT

; 856  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 857  : 	CBaseEntity *pFriend = NULL;

	mov	DWORD PTR _pFriend$[ebp], 0

; 858  : 	CBaseEntity *pNearest = NULL;

	mov	DWORD PTR _pNearest$[ebp], 0

; 859  : 	float range = 10000000.0;

	mov	DWORD PTR _range$[ebp], 1259902592	; 4b189680H

; 860  : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 861  : 	Vector vecStart = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 862  : 	Vector vecCheck;

	lea	ecx, DWORD PTR _vecCheck$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 863  : 	int i;
; 864  : 	char *pszFriend;
; 865  : 	int cfriends;
; 866  : 
; 867  : 	vecStart.z = pev->absmax.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+216]
	mov	DWORD PTR _vecStart$[ebp+8], edx

; 868  : 	
; 869  : 	if (fPlayer)

	cmp	DWORD PTR _fPlayer$[ebp], 0
	je	SHORT $L37473

; 870  : 		cfriends = 1;

	mov	DWORD PTR _cfriends$[ebp], 1

; 871  : 	else

	jmp	SHORT $L37474
$L37473:

; 872  : 		cfriends = TLK_CFRIENDS;

	mov	DWORD PTR _cfriends$[ebp], 4
$L37474:

; 873  : 
; 874  : 	// for each type of friend...
; 875  : 
; 876  : 	for (i = cfriends-1; i > -1; i--)

	mov	eax, DWORD PTR _cfriends$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L37475
$L37476:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L37475:
	cmp	DWORD PTR _i$[ebp], -1
	jle	$L37477

; 878  : 		if (fPlayer)

	cmp	DWORD PTR _fPlayer$[ebp], 0
	je	SHORT $L37478

; 879  : 			pszFriend = "player";

	mov	DWORD PTR _pszFriend$[ebp], OFFSET FLAT:??_C@_06MNOE@player?$AA@ ; `string'

; 880  : 		else

	jmp	SHORT $L37480
$L37478:

; 881  : 			pszFriend = m_szFriends[FriendNumber(i)];

	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+624]
	mov	eax, DWORD PTR ?m_szFriends@CTalkMonster@@2PAPADA[eax*4]
	mov	DWORD PTR _pszFriend$[ebp], eax
$L37480:

; 882  : 
; 883  : 		if (!pszFriend)

	cmp	DWORD PTR _pszFriend$[ebp], 0
	jne	SHORT $L37481

; 884  : 			continue;

	jmp	SHORT $L37476
$L37481:

; 885  : 
; 886  : 		// for each friend in this bsp...
; 887  : 		while (pFriend = UTIL_FindEntityByClassname( pFriend, pszFriend ))

	mov	ecx, DWORD PTR _pszFriend$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFriend$[ebp]
	push	edx
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pFriend$[ebp], eax
	cmp	DWORD PTR _pFriend$[ebp], 0
	je	$L37484

; 889  : 			if (pFriend == this || !pFriend->IsAlive())

	mov	eax, DWORD PTR _pFriend$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	je	SHORT $L37486
	mov	ecx, DWORD PTR _pFriend$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L37485
$L37486:

; 890  : 				// don't talk to self or dead people
; 891  : 				continue;

	jmp	SHORT $L37481
$L37485:

; 892  : 
; 893  : 			CBaseMonster *pMonster = pFriend->MyMonsterPointer();

	mov	eax, DWORD PTR _pFriend$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	DWORD PTR [edx+124]
	mov	DWORD PTR _pMonster$37487[ebp], eax

; 894  : 
; 895  : 			// If not a monster for some reason, or in a script, or prone
; 896  : 			if ( !pMonster || pMonster->m_MonsterState == MONSTERSTATE_SCRIPT || pMonster->m_MonsterState == MONSTERSTATE_PRONE )

	cmp	DWORD PTR _pMonster$37487[ebp], 0
	je	SHORT $L37489
	mov	eax, DWORD PTR _pMonster$37487[ebp]
	cmp	DWORD PTR [eax+2080], 6
	je	SHORT $L37489
	mov	ecx, DWORD PTR _pMonster$37487[ebp]
	cmp	DWORD PTR [ecx+2080], 5
	jne	SHORT $L37488
$L37489:

; 897  : 				continue;

	jmp	SHORT $L37481
$L37488:

; 898  : 
; 899  : 			vecCheck = pFriend->GetAbsOrigin();

	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecCheck$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecCheck$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecCheck$[ebp+8], edx

; 900  : 			vecCheck.z = pFriend->pev->absmax.z;

	mov	eax, DWORD PTR _pFriend$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+216]
	mov	DWORD PTR _vecCheck$[ebp+8], edx

; 901  : 
; 902  : 			// if closer than previous friend, and in range, see if he's visible
; 903  : 
; 904  : 			if (range > (vecStart - vecCheck).Length())

	lea	eax, DWORD PTR _vecCheck$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T38340[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR _range$[ebp]
	fnstsw	ax
	test	ah, 1
	je	$L37494

; 906  : 				UTIL_TraceLine(vecStart, vecCheck, ignore_monsters, ENT(pev), &tr);

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	push	1
	lea	edx, DWORD PTR _vecCheck$[ebp]
	push	edx
	lea	eax, DWORD PTR _vecStart$[ebp]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 907  : 
; 908  : 				if (tr.flFraction == 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L37494

; 910  : 					// visible and in range, this is the new nearest scientist
; 911  : 					if ((vecStart - vecCheck).Length() < TALKRANGE_MIN)

	lea	ecx, DWORD PTR _vecCheck$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T38341[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	QWORD PTR __real@8@4007fa00000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37494

; 913  : 						pNearest = pFriend;

	mov	eax, DWORD PTR _pFriend$[ebp]
	mov	DWORD PTR _pNearest$[ebp], eax

; 914  : 						range = (vecStart - vecCheck).Length();

	lea	ecx, DWORD PTR _vecCheck$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T38342[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecStart$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _range$[ebp]
$L37494:

; 918  : 		}

	jmp	$L37481
$L37484:

; 919  : 	}

	jmp	$L37476
$L37477:

; 920  : 	return pNearest;

	mov	eax, DWORD PTR _pNearest$[ebp]

; 921  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z ENDP ; CTalkMonster::FindNearestFriend
_TEXT	ENDS
PUBLIC	?GetVoicePitch@CTalkMonster@@QAEHXZ		; CTalkMonster::GetVoicePitch
;	COMDAT ?GetVoicePitch@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetVoicePitch@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::GetVoicePitch, COMDAT

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 925  : 	return m_voicePitch + RANDOM_LONG(0,3);

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2404]
	add	eax, edx

; 926  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVoicePitch@CTalkMonster@@QAEHXZ ENDP		; CTalkMonster::GetVoicePitch
_TEXT	ENDS
PUBLIC	__real@4@4004c800000000000000
PUBLIC	?Touch@CTalkMonster@@UAEXPAVCBaseEntity@@@Z	; CTalkMonster::Touch
EXTRN	_fabs:NEAR
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
;	COMDAT __real@4@4004c800000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@4@4004c800000000000000 DD 042480000r	; 50
CONST	ENDS
;	COMDAT ?Touch@CTalkMonster@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
_speed$37507 = -8
?Touch@CTalkMonster@@UAEXPAVCBaseEntity@@@Z PROC NEAR	; CTalkMonster::Touch, COMDAT

; 930  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 931  : 	// Did the player touch me?
; 932  : 	if ( pOther->IsPlayer() )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	$L37508

; 934  : 		// Ignore if pissed at player
; 935  : 		if ( m_afMemory & bits_MEMORY_PROVOKED )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L37505

; 936  : 			return;

	jmp	$L37503
$L37505:

; 937  : 
; 938  : 		// Stay put during speech
; 939  : 		if ( IsTalking() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	je	SHORT $L37506

; 940  : 			return;

	jmp	SHORT $L37503
$L37506:

; 941  : 
; 942  : 		// Heuristic for determining if the player is pushing me away
; 943  : 		float speed = fabs(pOther->GetAbsVelocity().x) + fabs(pOther->GetAbsVelocity().y);

	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -20+[ebp]
	add	esp, 8
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fadd	QWORD PTR -20+[ebp]
	fstp	DWORD PTR _speed$37507[ebp]

; 944  : 		if ( speed > 50 )

	fld	DWORD PTR _speed$37507[ebp]
	fcomp	DWORD PTR __real@4@4004c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37508

; 946  : 			SetConditions( bits_COND_CLIENT_PUSH );

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions

; 947  : 			MakeIdealYaw( pOther->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeIdealYaw@CBaseMonster@@QAEXVVector@@@Z ; CBaseMonster::MakeIdealYaw
$L37508:
$L37503:

; 950  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CTalkMonster@@UAEXPAVCBaseEntity@@@Z ENDP	; CTalkMonster::Touch
_TEXT	ENDS
;	COMDAT ?IdleRespond@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pitch$ = -8
?IdleRespond@CTalkMonster@@QAEXXZ PROC NEAR		; CTalkMonster::IdleRespond, COMDAT

; 959  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 960  : 	int pitch = GetVoicePitch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVoicePitch@CTalkMonster@@QAEHXZ	; CTalkMonster::GetVoicePitch
	mov	DWORD PTR _pitch$[ebp], eax

; 961  : 	
; 962  : 	// play response
; 963  : 	PlaySentence( m_szGrp[TLK_ANSWER], RANDOM_FLOAT(2.8, 3.2), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2408]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+468]

; 964  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IdleRespond@CTalkMonster@@QAEXXZ ENDP			; CTalkMonster::IdleRespond
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?FOkToSpeak@CTalkMonster@@QAEHXZ		; CTalkMonster::FOkToSpeak
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
;	COMDAT ?FOkToSpeak@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FOkToSpeak@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::FOkToSpeak, COMDAT

; 967  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 968  : 	// if in the grip of a barnacle, don't speak
; 969  : 	if ( m_MonsterState == MONSTERSTATE_PRONE || m_IdealMonsterState == MONSTERSTATE_PRONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 5
	je	SHORT $L37521
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2084], 5
	jne	SHORT $L37520
$L37521:

; 971  : 		return FALSE;

	xor	eax, eax
	jmp	$L37519
$L37520:

; 973  : 
; 974  : 	// if not alive, certainly don't speak
; 975  : 	if ( pev->deadflag != DEAD_NO )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+368], 0
	je	SHORT $L37522

; 977  : 		return FALSE;

	xor	eax, eax
	jmp	$L37519
$L37522:

; 979  : 
; 980  : 	// if someone else is talking, don't speak
; 981  : 	if (gpGlobals->time <= CTalkMonster::g_talkWaitTime)

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA ; CTalkMonster::g_talkWaitTime
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37523

; 982  : 		return FALSE;

	xor	eax, eax
	jmp	$L37519
$L37523:

; 983  : 
; 984  : 	if ( pev->spawnflags & SF_MONSTER_GAG )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L37524

; 985  : 		return FALSE;

	xor	eax, eax
	jmp	$L37519
$L37524:

; 986  : 
; 987  : 	if ( m_MonsterState == MONSTERSTATE_PRONE )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2080], 5
	jne	SHORT $L37525

; 988  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L37519
$L37525:

; 989  : 
; 990  : 	// if player is not in pvs, don't speak
; 991  : 	if (!IsAlive() || FNullEnt(FIND_CLIENT_IN_PVS(edict())))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	SHORT $L37527
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+68
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L37526
$L37527:

; 992  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L37519
$L37526:

; 993  : 
; 994  : 	// don't talk if you're in combat
; 995  : 	if (m_hEnemy != NULL && FVisible( m_hEnemy ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37528
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+332]
	test	eax, eax
	je	SHORT $L37528

; 996  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L37519
$L37528:

; 997  : 
; 998  : 	return TRUE;

	mov	eax, 1
$L37519:

; 999  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FOkToSpeak@CTalkMonster@@QAEHXZ ENDP			; CTalkMonster::FOkToSpeak
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L38358
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L38358
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L38359
$L38358:
	mov	DWORD PTR -4+[ebp], 1
$L38359:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
PUBLIC	?CanPlaySentence@CTalkMonster@@UAEHH@Z		; CTalkMonster::CanPlaySentence
PUBLIC	?CanPlaySentence@CBaseMonster@@UAEHH@Z		; CBaseMonster::CanPlaySentence
;	COMDAT ?CanPlaySentence@CTalkMonster@@UAEHH@Z
_TEXT	SEGMENT
_fDisregardState$ = 8
_this$ = -4
?CanPlaySentence@CTalkMonster@@UAEHH@Z PROC NEAR	; CTalkMonster::CanPlaySentence, COMDAT

; 1003 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1004 : 	if ( fDisregardState )

	cmp	DWORD PTR _fDisregardState$[ebp], 0
	je	SHORT $L37533

; 1005 : 		return CBaseMonster::CanPlaySentence( fDisregardState );

	mov	eax, DWORD PTR _fDisregardState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanPlaySentence@CBaseMonster@@UAEHH@Z	; CBaseMonster::CanPlaySentence
	jmp	SHORT $L37532
$L37533:

; 1006 : 	return FOkToSpeak(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FOkToSpeak
$L37532:

; 1007 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanPlaySentence@CTalkMonster@@UAEHH@Z ENDP		; CTalkMonster::CanPlaySentence
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
?CanPlaySentence@CBaseMonster@@UAEHH@Z PROC NEAR	; CBaseMonster::CanPlaySentence, COMDAT

; 206  : 		virtual int CanPlaySentence( BOOL fDisregardState ) { return IsAlive(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanPlaySentence@CBaseMonster@@UAEHH@Z ENDP		; CBaseMonster::CanPlaySentence
_TEXT	ENDS
;	COMDAT ?FIdleStare@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FIdleStare@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::FIdleStare, COMDAT

; 1013 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1014 : 	if (!FOkToSpeak())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FOkToSpeak
	test	eax, eax
	jne	SHORT $L37538

; 1015 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L37537
$L37538:

; 1016 : 
; 1017 : 	PlaySentence( m_szGrp[TLK_STARE], RANDOM_FLOAT(5, 7.5), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1089470464				; 40f00000H
	push	1084227584				; 40a00000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2420]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+468]

; 1018 : 
; 1019 : 	m_hTalkTarget = FindNearestFriend( TRUE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z ; CTalkMonster::FindNearestFriend
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1020 : 	return TRUE;

	mov	eax, 1
$L37537:

; 1021 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FIdleStare@CTalkMonster@@QAEHXZ ENDP			; CTalkMonster::FIdleStare
_TEXT	ENDS
;	COMDAT ?FIdleHello@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_pPlayer$37546 = -8
?FIdleHello@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::FIdleHello, COMDAT

; 1028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 	if (!FOkToSpeak())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FOkToSpeak
	test	eax, eax
	jne	SHORT $L37544

; 1030 : 		return FALSE;

	xor	eax, eax
	jmp	$L37543
$L37544:

; 1031 : 
; 1032 : 	// if this is first time scientist has seen player, greet him
; 1033 : 	if (!FBitSet(m_bitsSaid, bit_saidHelloPlayer))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	and	ecx, 8
	test	ecx, ecx
	jne	$L37548

; 1035 : 		// get a player
; 1036 : 		CBaseEntity *pPlayer = FindNearestFriend(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z ; CTalkMonster::FindNearestFriend
	mov	DWORD PTR _pPlayer$37546[ebp], eax

; 1037 : 
; 1038 : 		if (pPlayer)

	cmp	DWORD PTR _pPlayer$37546[ebp], 0
	je	$L37548

; 1040 : 			if (FInViewCone(pPlayer) && FVisible(pPlayer))

	mov	edx, DWORD PTR _pPlayer$37546[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+392]
	test	eax, eax
	je	$L37548
	mov	eax, DWORD PTR _pPlayer$37546[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+332]
	test	eax, eax
	je	$L37548

; 1042 : 				m_hTalkTarget = pPlayer;

	mov	eax, DWORD PTR _pPlayer$37546[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1043 : 
; 1044 : 				if (FBitSet(pev->spawnflags, SF_MONSTER_PREDISASTER))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L37549

; 1045 : 					PlaySentence( m_szGrp[TLK_PHELLO], RANDOM_FLOAT(3, 3.5), VOL_NORM,  ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1080033280				; 40600000H
	push	1077936128				; 40400000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2448]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1046 : 				else

	jmp	SHORT $L37551
$L37549:

; 1047 : 					PlaySentence( m_szGrp[TLK_HELLO], RANDOM_FLOAT(3, 3.5), VOL_NORM,  ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1080033280				; 40600000H
	push	1077936128				; 40400000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2444]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+468]
$L37551:

; 1048 : 
; 1049 : 				SetBits(m_bitsSaid, bit_saidHelloPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2396]
	or	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2396], edx

; 1050 : 				
; 1051 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L37543
$L37548:

; 1055 : 	return FALSE;

	xor	eax, eax
$L37543:

; 1056 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FIdleHello@CTalkMonster@@QAEHXZ ENDP			; CTalkMonster::FIdleHello
_TEXT	ENDS
;	COMDAT ?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z
_TEXT	SEGMENT
$T38377 = -24
_vecFriend$ = 8
_this$ = -4
_yaw$37558 = -8
?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z PROC NEAR	; CTalkMonster::IdleHeadTurn, COMDAT

; 1061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1062 : 	 // turn head in desired direction only if ent has a turnable head
; 1063 : 	if (m_afCapability & bits_CAP_TURN_HEAD)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2304]
	and	ecx, 1024				; 00000400H
	test	ecx, ecx
	je	$L37557

; 1065 : 		float yaw = VecToYaw(vecFriend - GetAbsOrigin()) - GetAbsAngles().y;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T38377[ebp]
	push	edx
	mov	ecx, DWORD PTR _vecFriend$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?VecToYaw@CBaseMonster@@QAEMVVector@@@Z	; CBaseMonster::VecToYaw
	fstp	DWORD PTR -28+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	fld	DWORD PTR -28+[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _yaw$37558[ebp]

; 1066 : 
; 1067 : 		if (yaw > 180) yaw -= 360;

	fld	DWORD PTR _yaw$37558[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37561
	fld	DWORD PTR _yaw$37558[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _yaw$37558[ebp]
$L37561:

; 1068 : 		if (yaw < -180) yaw += 360;

	fld	DWORD PTR _yaw$37558[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37562
	fld	DWORD PTR _yaw$37558[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _yaw$37558[ebp]
$L37562:

; 1069 : 
; 1070 : 		// turn towards vector
; 1071 : 		SetBoneController( 0, yaw );

	mov	eax, DWORD PTR _yaw$37558[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetBoneController@CBaseAnimating@@QAEMHM@Z ; CBaseAnimating::SetBoneController
	fstp	ST(0)
$L37557:

; 1073 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IdleHeadTurn@CTalkMonster@@QAEXABVVector@@@Z ENDP	; CTalkMonster::IdleHeadTurn
_TEXT	ENDS
PUBLIC	__real@4@40028000000000000000
PUBLIC	__real@4@40018000000000000000
PUBLIC	?Talk@CTalkMonster@@QAEXM@Z			; CTalkMonster::Talk
;	COMDAT __real@4@40028000000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@4@40028000000000000000 DD 041000000r	; 8
CONST	ENDS
;	COMDAT __real@4@40018000000000000000
CONST	SEGMENT
__real@4@40018000000000000000 DD 040800000r	; 4
CONST	ENDS
;	COMDAT ?FIdleSpeak@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_pitch$ = -8
_szIdleGroup$ = -12
_szQuestionGroup$ = -16
_duration$ = -20
_pTarget$ = -24
_pFriend$ = -28
_pTalkMonster$37590 = -32
_pFriend$37593 = -36
?FIdleSpeak@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::FIdleSpeak, COMDAT

; 1080 : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1081 : 	// try to start a conversation, or make statement
; 1082 : 	int pitch;
; 1083 : 	const char *szIdleGroup;
; 1084 : 	const char *szQuestionGroup;
; 1085 : 	float duration;
; 1086 : 
; 1087 : 	if (!FOkToSpeak())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FOkToSpeak
	test	eax, eax
	jne	SHORT $L37571

; 1088 : 		return FALSE;

	xor	eax, eax
	jmp	$L37566
$L37571:

; 1089 : 
; 1090 : 	// set idle groups based on pre/post disaster
; 1091 : 	if (FBitSet(pev->spawnflags, SF_MONSTER_PREDISASTER))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 256				; 00000100H
	test	edx, edx
	je	SHORT $L37572

; 1093 : 		szIdleGroup = m_szGrp[TLK_PIDLE];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2452]
	mov	DWORD PTR _szIdleGroup$[ebp], ecx

; 1094 : 		szQuestionGroup = m_szGrp[TLK_PQUESTION];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2456]
	mov	DWORD PTR _szQuestionGroup$[ebp], eax

; 1095 : 		// set global min delay for next conversation
; 1096 : 		duration = RANDOM_FLOAT(4.8, 5.2);

	push	1084647014				; 40a66666H
	push	1083808154				; 4099999aH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _duration$[ebp]

; 1098 : 	else

	jmp	SHORT $L37573
$L37572:

; 1100 : 		szIdleGroup = m_szGrp[TLK_IDLE];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2416]
	mov	DWORD PTR _szIdleGroup$[ebp], edx

; 1101 : 		szQuestionGroup = m_szGrp[TLK_QUESTION];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2412]
	mov	DWORD PTR _szQuestionGroup$[ebp], ecx

; 1102 : 		// set global min delay for next conversation
; 1103 : 		duration = RANDOM_FLOAT(2.8, 3.2);

	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _duration$[ebp]
$L37573:

; 1106 : 
; 1107 : 	pitch = GetVoicePitch();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVoicePitch@CTalkMonster@@QAEHXZ	; CTalkMonster::GetVoicePitch
	mov	DWORD PTR _pitch$[ebp], eax

; 1108 : 		
; 1109 : 	// player using this entity is alive and wounded?
; 1110 : 	CBaseEntity *pTarget = m_hTargetEnt;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pTarget$[ebp], eax

; 1111 : 
; 1112 : 	if ( pTarget != NULL )

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	$L37577

; 1114 : 		if ( pTarget->IsPlayer() )

	mov	edx, DWORD PTR _pTarget$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	je	$L37577

; 1116 : 			if ( pTarget->IsAlive() )

	mov	ecx, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	$L37577

; 1118 : 				m_hTalkTarget = m_hTargetEnt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1968]
	mov	edx, DWORD PTR [eax+1972]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2512], ecx
	mov	DWORD PTR [eax+2516], edx

; 1120 : 					(m_hTargetEnt->pev->health <= m_hTargetEnt->pev->max_health / 8))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2396]
	and	edx, 4
	test	edx, edx
	jne	$L37578
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	fld	DWORD PTR [eax+432]
	fdiv	DWORD PTR __real@4@40028000000000000000
	fcomp	DWORD PTR [esi+352]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37578

; 1122 : 					//EMIT_SOUND_DYN(ENT(pev), CHAN_VOICE, m_szGrp[TLK_PLHURT3], 1.0, ATTN_IDLE, 0, pitch);
; 1123 : 					PlaySentence( m_szGrp[TLK_PLHURT3], duration, VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _duration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2468]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1124 : 					SetBits(m_bitsSaid, bit_saidDamageHeavy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2396], ecx

; 1125 : 					return TRUE;

	mov	eax, 1
	jmp	$L37566
$L37578:

; 1128 : 					(m_hTargetEnt->pev->health <= m_hTargetEnt->pev->max_health / 4))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	and	ecx, 2
	test	ecx, ecx
	jne	$L37581
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+432]
	fdiv	DWORD PTR __real@4@40018000000000000000
	fcomp	DWORD PTR [esi+352]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37581

; 1130 : 					//EMIT_SOUND_DYN(ENT(pev), CHAN_VOICE, m_szGrp[TLK_PLHURT2], 1.0, ATTN_IDLE, 0, pitch);
; 1131 : 					PlaySentence( m_szGrp[TLK_PLHURT2], duration, VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _duration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2464]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1132 : 					SetBits(m_bitsSaid, bit_saidDamageMedium);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2396], ecx

; 1133 : 					return TRUE;

	mov	eax, 1
	jmp	$L37566
$L37581:

; 1136 : 					(m_hTargetEnt->pev->health <= m_hTargetEnt->pev->max_health / 2))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	and	ecx, 1
	test	ecx, ecx
	jne	$L37584
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	esi, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	edx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+432]
	fdiv	DWORD PTR __real@4@40008000000000000000
	fcomp	DWORD PTR [esi+352]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37584

; 1138 : 					//EMIT_SOUND_DYN(ENT(pev), CHAN_VOICE, m_szGrp[TLK_PLHURT1], 1.0, ATTN_IDLE, 0, pitch);
; 1139 : 					PlaySentence( m_szGrp[TLK_PLHURT1], duration, VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _duration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2460]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1140 : 					SetBits(m_bitsSaid, bit_saidDamageLight);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2396], ecx

; 1141 : 					return TRUE;

	mov	eax, 1
	jmp	$L37566
$L37584:
$L37577:

; 1152 : 
; 1153 : 	// if there is a friend nearby to speak to, play sentence, set friend's response time, return
; 1154 : 	CBaseEntity *pFriend = FindNearestFriend(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z ; CTalkMonster::FindNearestFriend
	mov	DWORD PTR _pFriend$[ebp], eax

; 1155 : 
; 1156 : 	if (pFriend && !(pFriend->IsMoving()) && (RANDOM_LONG(0,99) < 75))

	cmp	DWORD PTR _pFriend$[ebp], 0
	je	$L37588
	mov	eax, DWORD PTR _pFriend$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFriend$[ebp]
	call	DWORD PTR [edx+164]
	test	eax, eax
	jne	$L37588
	push	99					; 00000063H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	cmp	eax, 75					; 0000004bH
	jge	SHORT $L37588

; 1158 : 		PlaySentence( szQuestionGroup, duration, VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _duration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szQuestionGroup$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+468]

; 1159 : 		//SENTENCEG_PlayRndSz( ENT(pev), szQuestionGroup, 1.0, ATTN_IDLE, 0, pitch );
; 1160 : 
; 1161 : 		// force friend to answer
; 1162 : 		CTalkMonster *pTalkMonster = (CTalkMonster *)pFriend;

	mov	ecx, DWORD PTR _pFriend$[ebp]
	mov	DWORD PTR _pTalkMonster$37590[ebp], ecx

; 1163 : 		m_hTalkTarget = pFriend;

	mov	edx, DWORD PTR _pFriend$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1164 : 		pTalkMonster->SetAnswerQuestion( this ); // UNDONE: This is EVIL!!!

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTalkMonster$37590[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTalkMonster$37590[ebp]
	call	DWORD PTR [edx+620]

; 1165 : 		pTalkMonster->m_flStopTalkTime = m_flStopTalkTime;

	mov	eax, DWORD PTR _pTalkMonster$37590[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2508]
	mov	DWORD PTR [eax+2508], edx

; 1166 : 
; 1167 : 		m_nSpeak++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2400]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2400], ecx

; 1168 : 		return TRUE;

	mov	eax, 1
	jmp	$L37566
$L37588:

; 1170 : 
; 1171 : 	// otherwise, play an idle statement, try to face client when making a statement.
; 1172 : 	if ( RANDOM_LONG(0,1) )

	push	1
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	je	SHORT $L37594

; 1174 : 		//SENTENCEG_PlayRndSz( ENT(pev), szIdleGroup, 1.0, ATTN_IDLE, 0, pitch );
; 1175 : 		CBaseEntity *pFriend = FindNearestFriend(TRUE);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z ; CTalkMonster::FindNearestFriend
	mov	DWORD PTR _pFriend$37593[ebp], eax

; 1176 : 
; 1177 : 		if ( pFriend )

	cmp	DWORD PTR _pFriend$37593[ebp], 0
	je	SHORT $L37594

; 1179 : 			m_hTalkTarget = pFriend;

	mov	eax, DWORD PTR _pFriend$37593[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1180 : 			PlaySentence( szIdleGroup, duration, VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _duration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szIdleGroup$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1181 : 			m_nSpeak++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2400]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2400], ecx

; 1182 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L37566
$L37594:

; 1185 : 
; 1186 : 	// didn't speak
; 1187 : 	Talk( 0 );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Talk@CTalkMonster@@QAEXM@Z		; CTalkMonster::Talk

; 1188 : 	CTalkMonster::g_talkWaitTime = 0;

	mov	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA, 0

; 1189 : 	return FALSE;

	xor	eax, eax
$L37566:

; 1190 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FIdleSpeak@CTalkMonster@@QAEHXZ ENDP			; CTalkMonster::FIdleSpeak
_TEXT	ENDS
PUBLIC	?ClearConditions@CBaseMonster@@QAEXH@Z		; CBaseMonster::ClearConditions
PUBLIC	?PlayScriptedSentence@CTalkMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z ; CTalkMonster::PlayScriptedSentence
;	COMDAT ?PlayScriptedSentence@CTalkMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pszSentence$ = 8
_duration$ = 12
_volume$ = 16
_attenuation$ = 20
_bConcurrent$ = 24
_pListener$ = 28
_this$ = -4
?PlayScriptedSentence@CTalkMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z PROC NEAR ; CTalkMonster::PlayScriptedSentence, COMDAT

; 1193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1194 : 	if ( !bConcurrent )

	cmp	DWORD PTR _bConcurrent$[ebp], 0
	jne	SHORT $L37605

; 1195 : 		ShutUpFriends();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShutUpFriends@CTalkMonster@@QAEXXZ	; CTalkMonster::ShutUpFriends
$L37605:

; 1196 : 
; 1197 : 	ClearConditions( bits_COND_CLIENT_PUSH );	// Forget about moving!  I've got something to say!

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 1198 : 	m_useTime = gpGlobals->time + duration;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _duration$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2484]

; 1199 : 	PlaySentence( pszSentence, duration, volume, attenuation );

	mov	edx, DWORD PTR _attenuation$[ebp]
	push	edx
	mov	eax, DWORD PTR _volume$[ebp]
	push	eax
	mov	ecx, DWORD PTR _duration$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszSentence$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1200 : 
; 1201 : 	m_hTalkTarget = pListener;

	mov	eax, DWORD PTR _pListener$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1202 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?PlayScriptedSentence@CTalkMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z ENDP ; CTalkMonster::PlayScriptedSentence
_TEXT	ENDS
;	COMDAT ?ClearConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_iConditions$ = 8
_this$ = -4
?ClearConditions@CBaseMonster@@QAEXH@Z PROC NEAR	; CBaseMonster::ClearConditions, COMDAT

; 257  : 		inline void	ClearConditions( int iConditions ) { m_afConditions &= ~iConditions; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _iConditions$[ebp]
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1956]
	and	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1956], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearConditions@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::ClearConditions
_TEXT	ENDS
PUBLIC	__real@8@40008000000000000000
PUBLIC	?PlaySentence@CTalkMonster@@UAEXPBDMMM@Z	; CTalkMonster::PlaySentence
EXTRN	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z:NEAR ; SENTENCEG_PlayRndSz
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT __real@8@40008000000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@8@40008000000000000000 DQ 04000000000000000r ; 2
CONST	ENDS
;	COMDAT ?PlaySentence@CTalkMonster@@UAEXPBDMMM@Z
_TEXT	SEGMENT
_pszSentence$ = 8
_duration$ = 12
_volume$ = 16
_attenuation$ = 20
_this$ = -4
?PlaySentence@CTalkMonster@@UAEXPBDMMM@Z PROC NEAR	; CTalkMonster::PlaySentence, COMDAT

; 1205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1206 : 	if ( !pszSentence )

	cmp	DWORD PTR _pszSentence$[ebp], 0
	jne	SHORT $L37613

; 1207 : 		return;

	jmp	$L37612
$L37613:

; 1208 : 
; 1209 : 	Talk ( duration );

	mov	eax, DWORD PTR _duration$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Talk@CTalkMonster@@QAEXM@Z		; CTalkMonster::Talk

; 1210 : 
; 1211 : 	CTalkMonster::g_talkWaitTime = gpGlobals->time + duration + 2.0;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _duration$[ebp]
	fadd	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@40008000000000000000
	fstp	DWORD PTR ?g_talkWaitTime@CTalkMonster@@2MA ; CTalkMonster::g_talkWaitTime

; 1212 : 	if ( pszSentence[0] == '!' )

	mov	edx, DWORD PTR _pszSentence$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 33					; 00000021H
	jne	SHORT $L37614

; 1213 : 		EMIT_SOUND_DYN( edict(), CHAN_VOICE, pszSentence, volume, attenuation, 0, GetVoicePitch());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVoicePitch@CTalkMonster@@QAEHXZ	; CTalkMonster::GetVoicePitch
	push	eax
	push	0
	mov	ecx, DWORD PTR _attenuation$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszSentence$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 1214 : 	else

	jmp	SHORT $L37615
$L37614:

; 1215 : 		SENTENCEG_PlayRndSz( edict(), pszSentence, volume, attenuation, 0, GetVoicePitch() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetVoicePitch@CTalkMonster@@QAEHXZ	; CTalkMonster::GetVoicePitch
	push	eax
	push	0
	mov	ecx, DWORD PTR _attenuation$[ebp]
	push	ecx
	mov	edx, DWORD PTR _volume$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszSentence$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?SENTENCEG_PlayRndSz@@YAHPAUedict_s@@PBDMMHH@Z ; SENTENCEG_PlayRndSz
	add	esp, 24					; 00000018H
$L37615:

; 1216 : 
; 1217 : 	// If you say anything, don't greet the player - you may have already spoken to them
; 1218 : 	SetBits(m_bitsSaid, bit_saidHelloPlayer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2396]
	or	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2396], edx
$L37612:

; 1219 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?PlaySentence@CTalkMonster@@UAEXPBDMMM@Z ENDP		; CTalkMonster::PlaySentence
_TEXT	ENDS
PUBLIC	__real@4@4000c000000000000000
;	COMDAT __real@4@4000c000000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@4@4000c000000000000000 DD 040400000r	; 3
CONST	ENDS
;	COMDAT ?Talk@CTalkMonster@@QAEXM@Z
_TEXT	SEGMENT
_flDuration$ = 8
_this$ = -4
?Talk@CTalkMonster@@QAEXM@Z PROC NEAR			; CTalkMonster::Talk, COMDAT

; 1226 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1227 : 	if ( flDuration <= 0 )

	fld	DWORD PTR _flDuration$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L37620

; 1229 : 		// no duration :( 
; 1230 : 		m_flStopTalkTime = gpGlobals->time + 3;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4000c000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2508]

; 1232 : 	else

	jmp	SHORT $L37621
$L37620:

; 1234 : 		m_flStopTalkTime = gpGlobals->time + flDuration;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _flDuration$[ebp]
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2508]
$L37621:

; 1236 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Talk@CTalkMonster@@QAEXM@Z ENDP			; CTalkMonster::Talk
_TEXT	ENDS
PUBLIC	?SetAnswerQuestion@CTalkMonster@@UAEXPAV1@@Z	; CTalkMonster::SetAnswerQuestion
EXTRN	?ChangeSchedule@CBaseMonster@@QAEXPAUSchedule_t@@@Z:NEAR ; CBaseMonster::ChangeSchedule
;	COMDAT ?SetAnswerQuestion@CTalkMonster@@UAEXPAV1@@Z
_TEXT	SEGMENT
_pSpeaker$ = 8
_this$ = -4
?SetAnswerQuestion@CTalkMonster@@UAEXPAV1@@Z PROC NEAR	; CTalkMonster::SetAnswerQuestion, COMDAT

; 1240 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1241 : 	if ( !m_pCine )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2384], 0
	jne	SHORT $L37626

; 1242 : 		ChangeSchedule( slIdleResponse );

	push	OFFSET FLAT:?slIdleResponse@@3PAUSchedule_t@@A ; slIdleResponse
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ChangeSchedule@CBaseMonster@@QAEXPAUSchedule_t@@@Z ; CBaseMonster::ChangeSchedule
$L37626:

; 1243 : 	m_hTalkTarget = (CBaseMonster *)pSpeaker;

	mov	ecx, DWORD PTR _pSpeaker$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2512				; 000009d0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1244 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAnswerQuestion@CTalkMonster@@UAEXPAV1@@Z ENDP	; CTalkMonster::SetAnswerQuestion
_TEXT	ENDS
PUBLIC	?TakeDamage@CTalkMonster@@UAEHPAUentvars_s@@0MH@Z ; CTalkMonster::TakeDamage
EXTRN	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseMonster::TakeDamage
;	COMDAT ?TakeDamage@CTalkMonster@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pevAttacker$ = 12
_flDamage$ = 16
_bitsDamageType$ = 20
_this$ = -4
_pFriend$37637 = -8
_pTalkMonster$37639 = -12
?TakeDamage@CTalkMonster@@UAEHPAUentvars_s@@0MH@Z PROC NEAR ; CTalkMonster::TakeDamage, COMDAT

; 1247 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1248 : 	if ( IsAlive() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	SHORT $L37638

; 1250 : 		// if player damaged this entity, have other friends talk about it
; 1251 : 		if (pevAttacker && m_MonsterState != MONSTERSTATE_PRONE && FBitSet(pevAttacker->flags, FL_CLIENT))

	cmp	DWORD PTR _pevAttacker$[ebp], 0
	je	SHORT $L37638
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 5
	je	SHORT $L37638
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 8
	test	edx, edx
	je	SHORT $L37638

; 1253 : 			CBaseEntity *pFriend = FindNearestFriend(FALSE);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindNearestFriend@CTalkMonster@@QAEPAVCBaseEntity@@H@Z ; CTalkMonster::FindNearestFriend
	mov	DWORD PTR _pFriend$37637[ebp], eax

; 1254 : 
; 1255 : 			if (pFriend && pFriend->IsAlive())

	cmp	DWORD PTR _pFriend$37637[ebp], 0
	je	SHORT $L37638
	mov	eax, DWORD PTR _pFriend$37637[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pFriend$37637[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	SHORT $L37638

; 1257 : 				// only if not dead or dying!
; 1258 : 				CTalkMonster *pTalkMonster = (CTalkMonster *)pFriend;

	mov	eax, DWORD PTR _pFriend$37637[ebp]
	mov	DWORD PTR _pTalkMonster$37639[ebp], eax

; 1259 : 				pTalkMonster->ChangeSchedule( slIdleStopShooting );

	push	OFFSET FLAT:?slIdleStopShooting@@3PAUSchedule_t@@A ; slIdleStopShooting
	mov	ecx, DWORD PTR _pTalkMonster$37639[ebp]
	call	?ChangeSchedule@CBaseMonster@@QAEXPAUSchedule_t@@@Z ; CBaseMonster::ChangeSchedule
$L37638:

; 1263 : 	return CBaseMonster::TakeDamage(pevInflictor, pevAttacker, flDamage, bitsDamageType);

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z ; CBaseMonster::TakeDamage

; 1264 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TakeDamage@CTalkMonster@@UAEHPAUentvars_s@@0MH@Z ENDP	; CTalkMonster::TakeDamage
_TEXT	ENDS
PUBLIC	__real@8@3ffec000000000000000
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	?GetScheduleOfType@CTalkMonster@@UAEPAUSchedule_t@@H@Z ; CTalkMonster::GetScheduleOfType
EXTRN	?slIdleStand@@3PAUSchedule_t@@A:BYTE		; slIdleStand
EXTRN	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z:NEAR ; CBaseMonster::GetScheduleOfType
;	COMDAT __real@8@3ffec000000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@8@3ffec000000000000000 DQ 03fe8000000000000r ; 0.75
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT ?GetScheduleOfType@CTalkMonster@@UAEPAUSchedule_t@@H@Z
_TEXT	SEGMENT
$T38402 = -20
_Type$ = 8
_this$ = -4
_pPlayer$37664 = -8
?GetScheduleOfType@CTalkMonster@@UAEPAUSchedule_t@@H@Z PROC NEAR ; CTalkMonster::GetScheduleOfType, COMDAT

; 1268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1270 : 	{

	mov	eax, DWORD PTR _Type$[ebp]
	mov	DWORD PTR -24+[ebp], eax
	mov	ecx, DWORD PTR -24+[ebp]
	sub	ecx, 1
	mov	DWORD PTR -24+[ebp], ecx
	cmp	DWORD PTR -24+[ebp], 45			; 0000002dH
	ja	$L37646
	mov	eax, DWORD PTR -24+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L38407[eax]
	jmp	DWORD PTR $L38408[edx*4]
$L37649:

; 1271 : 	case SCHED_MOVE_AWAY:
; 1272 : 		return slMoveAway;

	mov	eax, OFFSET FLAT:?slMoveAway@@3PAUSchedule_t@@A ; slMoveAway
	jmp	$L37644
$L37650:

; 1273 : 
; 1274 : 	case SCHED_MOVE_AWAY_FOLLOW:
; 1275 : 		return slMoveAwayFollow;

	mov	eax, OFFSET FLAT:?slMoveAwayFollow@@3PAUSchedule_t@@A ; slMoveAwayFollow
	jmp	$L37644
$L37651:

; 1276 : 
; 1277 : 	case SCHED_MOVE_AWAY_FAIL:
; 1278 : 		return slMoveAwayFail;

	mov	eax, OFFSET FLAT:?slMoveAwayFail@@3PAUSchedule_t@@A ; slMoveAwayFail
	jmp	$L37644
$L37652:

; 1279 : 
; 1280 : 	case SCHED_TARGET_FACE:
; 1281 : 		// speak during 'use'
; 1282 : 		if (RANDOM_LONG(0,99) < 2)

	push	99					; 00000063H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	cmp	eax, 2
	jge	SHORT $L37653

; 1283 : 			//ALERT ( at_console, "target chase speak\n" );
; 1284 : 			return slIdleSpeakWait;

	mov	eax, OFFSET FLAT:?slIdleSpeakWait@@3PAUSchedule_t@@A ; slIdleSpeakWait
	jmp	$L37644
$L37653:

; 1286 : 			return slIdleStand;

	mov	eax, OFFSET FLAT:?slIdleStand@@3PAUSchedule_t@@A ; slIdleStand
	jmp	$L37644
$L37654:

; 1290 : 			// if never seen player, try to greet him
; 1291 : 			if (!FBitSet(m_bitsSaid, bit_saidHelloPlayer))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2396]
	and	edx, 8
	test	edx, edx
	jne	SHORT $L37656

; 1293 : 				return slIdleHello;

	mov	eax, OFFSET FLAT:?slIdleHello@@3PAUSchedule_t@@A ; slIdleHello
	jmp	$L37644
$L37656:

; 1295 : 
; 1296 : 			// sustained light wounds?
; 1297 : 			if (!FBitSet(m_bitsSaid, bit_saidWoundLight) && (pev->health <= (pev->max_health * 0.75)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	jne	SHORT $L37657
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+432]
	fmul	QWORD PTR __real@8@3ffec000000000000000
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37657

; 1299 : 				//SENTENCEG_PlayRndSz( ENT(pev), m_szGrp[TLK_WOUND], 1.0, ATTN_IDLE, 0, GetVoicePitch() );
; 1300 : 				//CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT(2.8, 3.2);
; 1301 : 				PlaySentence( m_szGrp[TLK_WOUND], RANDOM_FLOAT(2.8, 3.2), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2476]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+468]

; 1302 : 				SetBits(m_bitsSaid, bit_saidWoundLight);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2396]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2396], edx

; 1303 : 				return slIdleStand;

	mov	eax, OFFSET FLAT:?slIdleStand@@3PAUSchedule_t@@A ; slIdleStand
	jmp	$L37644
$L37657:

; 1305 : 			// sustained heavy wounds?
; 1306 : 			else if (!FBitSet(m_bitsSaid, bit_saidWoundHeavy) && (pev->health <= (pev->max_health * 0.5)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2396]
	and	edx, 32					; 00000020H
	test	edx, edx
	jne	SHORT $L37660
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+432]
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37660

; 1308 : 				//SENTENCEG_PlayRndSz( ENT(pev), m_szGrp[TLK_MORTAL], 1.0, ATTN_IDLE, 0, GetVoicePitch() );
; 1309 : 				//CTalkMonster::g_talkWaitTime = gpGlobals->time + RANDOM_FLOAT(2.8, 3.2);
; 1310 : 				PlaySentence( m_szGrp[TLK_MORTAL], RANDOM_FLOAT(2.8, 3.2), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2480]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1311 : 				SetBits(m_bitsSaid, bit_saidWoundHeavy);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2396]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2396], ecx

; 1312 : 				return slIdleStand;

	mov	eax, OFFSET FLAT:?slIdleStand@@3PAUSchedule_t@@A ; slIdleStand
	jmp	$L37644
$L37660:

; 1314 : 
; 1315 : 			// talk about world
; 1316 : 			if (FOkToSpeak() && RANDOM_LONG(0,m_nSpeak * 2) == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FOkToSpeak
	test	eax, eax
	je	SHORT $L37662
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2400]
	shl	ecx, 1
	push	ecx
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	SHORT $L37662

; 1318 : 				//ALERT ( at_console, "standing idle speak\n" );
; 1319 : 				return slIdleSpeak;

	mov	eax, OFFSET FLAT:?slIdleSpeak@@3PAUSchedule_t@@A ; slIdleSpeak
	jmp	$L37644
$L37662:

; 1321 : 			
; 1322 : 			if ( !IsTalking() && HasConditions ( bits_COND_SEE_CLIENT ) && RANDOM_LONG( 0, 6 ) == 0 )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	jne	$L37663
	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	$L37663
	push	6
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	$L37663

; 1324 : 				CBaseEntity *pPlayer = UTIL_PlayerByIndex( 1 );

	push	1
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$37664[ebp], eax

; 1325 : 
; 1326 : 				if ( pPlayer )

	cmp	DWORD PTR _pPlayer$37664[ebp], 0
	je	$L37665

; 1328 : 					// watch the client.
; 1329 : 					UTIL_MakeVectors ( pPlayer->GetAbsAngles() );

	mov	ecx, DWORD PTR _pPlayer$37664[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1331 : 						 UTIL_DotPoints( pPlayer->GetAbsOrigin(), GetAbsOrigin(), gpGlobals->v_forward ) >= m_flFieldOfView )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T38402[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPlayer$37664[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fcomp	DWORD PTR __real@4@40068000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L37667
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pPlayer$37664[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_DotPoints@@YAMABVVector@@00@Z	; UTIL_DotPoints
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	fcomp	DWORD PTR [ecx+2056]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L37667

; 1333 : 						// go into the special STARE schedule if the player is close, and looking at me too.
; 1334 : 						return &slTlkIdleWatchClient[ 1 ];

	mov	eax, OFFSET FLAT:?slTlkIdleWatchClient@@3PAUSchedule_t@@A+20
	jmp	SHORT $L37644
$L37667:

; 1336 : 
; 1337 : 					return slTlkIdleWatchClient;

	mov	eax, OFFSET FLAT:?slTlkIdleWatchClient@@3PAUSchedule_t@@A
	jmp	SHORT $L37644
$L37665:

; 1340 : 			else

	jmp	SHORT $L37670
$L37663:

; 1342 : 				if (IsTalking())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsTalking@CTalkMonster@@QAEHXZ		; CTalkMonster::IsTalking
	test	eax, eax
	je	SHORT $L37669

; 1343 : 					// look at who we're talking to
; 1344 : 					return slTlkIdleEyecontact;

	mov	eax, OFFSET FLAT:?slTlkIdleEyecontact@@3PAUSchedule_t@@A ; slTlkIdleEyecontact
	jmp	SHORT $L37644
$L37669:

; 1346 : 					// regular standing idle
; 1347 : 					return slIdleStand;

	mov	eax, OFFSET FLAT:?slIdleStand@@3PAUSchedule_t@@A ; slIdleStand
	jmp	SHORT $L37644
$L37670:
$L37646:

; 1357 : 
; 1358 : 	return CBaseMonster::GetScheduleOfType( Type );

	mov	edx, DWORD PTR _Type$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z ; CBaseMonster::GetScheduleOfType
$L37644:

; 1359 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L38408:
	DD	$L37654
	DD	$L37652
	DD	$L37649
	DD	$L37650
	DD	$L37651
	DD	$L37646
$L38407:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	DB	3
	DB	4
?GetScheduleOfType@CTalkMonster@@UAEPAUSchedule_t@@H@Z ENDP ; CTalkMonster::GetScheduleOfType
_TEXT	ENDS
;	COMDAT ?IsTalking@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTalking@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::IsTalking, COMDAT

; 1365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1366 : 	if ( m_flStopTalkTime > gpGlobals->time )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+2508]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37675

; 1368 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L37674
$L37675:

; 1370 : 
; 1371 : 	return FALSE;

	xor	eax, eax
$L37674:

; 1372 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTalking@CTalkMonster@@QAEHXZ ENDP			; CTalkMonster::IsTalking
_TEXT	ENDS
PUBLIC	?PrescheduleThink@CTalkMonster@@UAEXXZ		; CTalkMonster::PrescheduleThink
;	COMDAT ?PrescheduleThink@CTalkMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrescheduleThink@CTalkMonster@@UAEXXZ PROC NEAR	; CTalkMonster::PrescheduleThink, COMDAT

; 1378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1379 : 	if ( !HasConditions ( bits_COND_SEE_CLIENT ) )

	push	2097152					; 00200000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	jne	SHORT $L37680

; 1381 : 		SetConditions ( bits_COND_CLIENT_UNSEEN );

	push	536870912				; 20000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::SetConditions
$L37680:

; 1383 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrescheduleThink@CTalkMonster@@UAEXXZ ENDP		; CTalkMonster::PrescheduleThink
_TEXT	ENDS
PUBLIC	__real@4@4004f000000000000000
PUBLIC	?TrySmellTalk@CTalkMonster@@QAEXXZ		; CTalkMonster::TrySmellTalk
;	COMDAT __real@4@4004f000000000000000
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
__real@4@4004f000000000000000 DD 042700000r	; 60
CONST	ENDS
;	COMDAT ?TrySmellTalk@CTalkMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TrySmellTalk@CTalkMonster@@QAEXXZ PROC NEAR		; CTalkMonster::TrySmellTalk, COMDAT

; 1387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1388 : 	if ( !FOkToSpeak() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FOkToSpeak@CTalkMonster@@QAEHXZ	; CTalkMonster::FOkToSpeak
	test	eax, eax
	jne	SHORT $L37685

; 1389 : 		return;

	jmp	$L37684
$L37685:

; 1390 : 
; 1391 : 	// clear smell bits periodically
; 1392 : 	if ( gpGlobals->time > m_flLastSaidSmelled  )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+2504]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37686

; 1394 : //		ALERT ( at_aiconsole, "Clear smell bits\n" );
; 1395 : 		ClearBits(m_bitsSaid, bit_saidSmelled);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2396]
	and	al, 127					; 0000007fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax
$L37686:

; 1397 : 	// smelled something?
; 1398 : 	if (!FBitSet(m_bitsSaid, bit_saidSmelled) && HasConditions ( bits_COND_SMELL ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2396]
	and	eax, 128				; 00000080H
	test	eax, eax
	jne	SHORT $L37687
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasConditions@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasConditions
	test	eax, eax
	je	SHORT $L37687

; 1400 : 		PlaySentence( m_szGrp[TLK_SMELL], RANDOM_FLOAT(2.8, 3.2), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2472]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1401 : 		m_flLastSaidSmelled = gpGlobals->time + 60;// don't talk about the stinky for a while.

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4004f000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2504]

; 1402 : 		SetBits(m_bitsSaid, bit_saidSmelled);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2396]
	or	al, -128				; ffffff80H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax
$L37687:
$L37684:

; 1404 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TrySmellTalk@CTalkMonster@@QAEXXZ ENDP			; CTalkMonster::TrySmellTalk
_TEXT	ENDS
PUBLIC	?IRelationship@CTalkMonster@@UAEHPAVCBaseEntity@@@Z ; CTalkMonster::IRelationship
EXTRN	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::IRelationship
;	COMDAT ?IRelationship@CTalkMonster@@UAEHPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pTarget$ = 8
_this$ = -4
?IRelationship@CTalkMonster@@UAEHPAVCBaseEntity@@@Z PROC NEAR ; CTalkMonster::IRelationship, COMDAT

; 1409 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1410 : 	if ( pTarget->IsPlayer() )

	mov	eax, DWORD PTR _pTarget$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L37694

; 1411 : 		if ( m_afMemory & bits_MEMORY_PROVOKED )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L37694

; 1412 : 			return R_HT;

	mov	eax, 2
	jmp	SHORT $L37692
$L37694:

; 1413 : 	return CBaseMonster::IRelationship( pTarget );

	mov	edx, DWORD PTR _pTarget$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z ; CBaseMonster::IRelationship
$L37692:

; 1414 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IRelationship@CTalkMonster@@UAEHPAVCBaseEntity@@@Z ENDP ; CTalkMonster::IRelationship
_TEXT	ENDS
PUBLIC	?IsFollowing@CTalkMonster@@QAEHXZ		; CTalkMonster::IsFollowing
PUBLIC	?StopFollowing@CTalkMonster@@UAEXH@Z		; CTalkMonster::StopFollowing
EXTRN	?ClearSchedule@CBaseMonster@@QAEXXZ:NEAR	; CBaseMonster::ClearSchedule
;	COMDAT ?StopFollowing@CTalkMonster@@UAEXH@Z
_TEXT	SEGMENT
_clearSchedule$ = 8
_this$ = -4
?StopFollowing@CTalkMonster@@UAEXH@Z PROC NEAR		; CTalkMonster::StopFollowing, COMDAT

; 1418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1419 : 	if ( IsFollowing() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsFollowing@CTalkMonster@@QAEHXZ	; CTalkMonster::IsFollowing
	test	eax, eax
	je	$L37704

; 1421 : 		if ( !(m_afMemory & bits_MEMORY_PROVOKED) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2280]
	and	ecx, 1
	test	ecx, ecx
	jne	SHORT $L37700

; 1423 : 			PlaySentence( m_szGrp[TLK_UNUSE], RANDOM_FLOAT(2.8, 3.2), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2428]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1424 : 			m_hTalkTarget = m_hTargetEnt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1968]
	mov	edx, DWORD PTR [eax+1972]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2512], ecx
	mov	DWORD PTR [eax+2516], edx
$L37700:

; 1426 : 
; 1427 : 		if ( m_movementGoal == MOVEGOAL_TARGETENT )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2228], 1
	jne	SHORT $L37702

; 1428 : 			RouteClear(); // Stop him from walking toward the player

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RouteClear@CBaseMonster@@QAEXXZ	; CBaseMonster::RouteClear
$L37702:

; 1429 : 		m_hTargetEnt = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1430 : 		if ( clearSchedule )

	cmp	DWORD PTR _clearSchedule$[ebp], 0
	je	SHORT $L37703

; 1431 : 			ClearSchedule();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearSchedule@CBaseMonster@@QAEXXZ	; CBaseMonster::ClearSchedule
$L37703:

; 1432 : 		if ( m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37704

; 1433 : 			m_IdealMonsterState = MONSTERSTATE_COMBAT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2084], 2
$L37704:

; 1435 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StopFollowing@CTalkMonster@@UAEXH@Z ENDP		; CTalkMonster::StopFollowing
_TEXT	ENDS
;	COMDAT ?IsFollowing@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFollowing@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::IsFollowing, COMDAT

; 145  : 	BOOL			IsFollowing( void ) { return m_hTargetEnt != NULL && m_hTargetEnt->IsPlayer(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L38423
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L38423
	mov	DWORD PTR -12+[ebp], 1
	jmp	SHORT $L38424
$L38423:
	mov	DWORD PTR -12+[ebp], 0
$L38424:
	mov	eax, DWORD PTR -12+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFollowing@CTalkMonster@@QAEHXZ ENDP			; CTalkMonster::IsFollowing
_TEXT	ENDS
PUBLIC	?StartFollowing@CTalkMonster@@QAEXPAVCBaseEntity@@@Z ; CTalkMonster::StartFollowing
EXTRN	?CancelScript@CCineMonster@@QAEXXZ:NEAR		; CCineMonster::CancelScript
;	COMDAT ?StartFollowing@CTalkMonster@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pLeader$ = 8
_this$ = -4
?StartFollowing@CTalkMonster@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CTalkMonster::StartFollowing, COMDAT

; 1439 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1440 : 	if ( m_pCine )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2384], 0
	je	SHORT $L37709

; 1441 : 		m_pCine->CancelScript();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2384]
	call	?CancelScript@CCineMonster@@QAEXXZ	; CCineMonster::CancelScript
$L37709:

; 1442 : 
; 1443 : 	if ( m_hEnemy != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L37710

; 1444 : 		m_IdealMonsterState = MONSTERSTATE_ALERT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2084], 3
$L37710:

; 1445 : 
; 1446 : 	m_hTargetEnt = pLeader;

	mov	eax, DWORD PTR _pLeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1968				; 000007b0H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1447 : 	PlaySentence( m_szGrp[TLK_USE], RANDOM_FLOAT(2.8, 3.2), VOL_NORM, ATTN_IDLE );

	push	1073741824				; 40000000H
	push	1065353216				; 3f800000H
	push	1078774989				; 404ccccdH
	push	1077097267				; 40333333H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2424]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+468]

; 1448 : 	m_hTalkTarget = m_hTargetEnt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1968]
	mov	edx, DWORD PTR [eax+1972]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2512], ecx
	mov	DWORD PTR [eax+2516], edx

; 1449 : 	ClearConditions( bits_COND_CLIENT_PUSH );

	push	268435456				; 10000000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearConditions@CBaseMonster@@QAEXH@Z	; CBaseMonster::ClearConditions

; 1450 : 	ClearSchedule();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearSchedule@CBaseMonster@@QAEXXZ	; CBaseMonster::ClearSchedule

; 1451 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartFollowing@CTalkMonster@@QAEXPAVCBaseEntity@@@Z ENDP ; CTalkMonster::StartFollowing
_TEXT	ENDS
PUBLIC	?CanFollow@CTalkMonster@@QAEHXZ			; CTalkMonster::CanFollow
EXTRN	?CanInterrupt@CCineMonster@@QAEHXZ:NEAR		; CCineMonster::CanInterrupt
;	COMDAT ?CanFollow@CTalkMonster@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?CanFollow@CTalkMonster@@QAEHXZ PROC NEAR		; CTalkMonster::CanFollow, COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1456 : 	if ( m_MonsterState == MONSTERSTATE_SCRIPT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2080], 6
	jne	SHORT $L37717

; 1458 : 		if ( !m_pCine->CanInterrupt() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2384]
	call	?CanInterrupt@CCineMonster@@QAEHXZ	; CCineMonster::CanInterrupt
	test	eax, eax
	jne	SHORT $L37717

; 1459 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L37715
$L37717:

; 1461 : 	
; 1462 : 	if ( !IsAlive() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	jne	SHORT $L37718

; 1463 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L37715
$L37718:

; 1464 : 
; 1465 : 	return !IsFollowing();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsFollowing@CTalkMonster@@QAEHXZ	; CTalkMonster::IsFollowing
	neg	eax
	sbb	eax, eax
	inc	eax
$L37715:

; 1466 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CanFollow@CTalkMonster@@QAEHXZ ENDP			; CTalkMonster::CanFollow
_TEXT	ENDS
PUBLIC	??_C@_0CJ@DKO@I?8m?5not?5following?5you?0?5you?5evil?5@ ; `string'
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z:NEAR ; CBaseDelay::IsLockedByMaster
;	COMDAT ??_C@_0CJ@DKO@I?8m?5not?5following?5you?0?5you?5evil?5@
; File z:\xashxtsrc\server\monsters\talkmonster.cpp
CONST	SEGMENT
??_C@_0CJ@DKO@I?8m?5not?5following?5you?0?5you?5evil?5@ DB 'I''m not foll'
	DB	'owing you, you evil person!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?FollowerUse@CTalkMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_pCaller$ = 12
_this$ = -4
?FollowerUse@CTalkMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CTalkMonster::FollowerUse, COMDAT

; 1470 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1471 : 	// Don't allow use during a scripted_sentence
; 1472 : 	if ( m_useTime > gpGlobals->time )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+2484]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L37726

; 1473 : 		return;

	jmp	$L37725
$L37726:

; 1474 : 
; 1475 : 	if ( pCaller != NULL && pCaller->IsPlayer() )

	cmp	DWORD PTR _pCaller$[ebp], 0
	je	$L37735
	mov	edx, DWORD PTR _pCaller$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pCaller$[ebp]
	call	DWORD PTR [eax+224]
	test	eax, eax
	je	$L37735

; 1477 : 		// Pre-disaster followers can't be used
; 1478 : 		if ( IsLockedByMaster( pActivator ) || pev->spawnflags & SF_MONSTER_PREDISASTER )

	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	jne	SHORT $L37729
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+416]
	and	ecx, 256				; 00000100H
	test	ecx, ecx
	je	SHORT $L37728
$L37729:

; 1480 : 			DeclineFollowing();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+616]

; 1482 : 		else if ( CanFollow() )

	jmp	SHORT $L37735
$L37728:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanFollow@CTalkMonster@@QAEHXZ		; CTalkMonster::CanFollow
	test	eax, eax
	je	SHORT $L37731

; 1484 : 			LimitFollowers( pCaller , 1 );

	push	1
	mov	ecx, DWORD PTR _pCaller$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LimitFollowers@CTalkMonster@@QAEXPAVCBaseEntity@@H@Z ; CTalkMonster::LimitFollowers

; 1485 : 
; 1486 : 			if ( m_afMemory & bits_MEMORY_PROVOKED )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2280]
	and	eax, 1
	test	eax, eax
	je	SHORT $L37732

; 1487 : 				ALERT( at_console, "I'm not following you, you evil person!\n" );

	push	OFFSET FLAT:??_C@_0CJ@DKO@I?8m?5not?5following?5you?0?5you?5evil?5@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1488 : 			else

	jmp	SHORT $L37734
$L37732:

; 1490 : 				StartFollowing( pCaller );

	mov	ecx, DWORD PTR _pCaller$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartFollowing@CTalkMonster@@QAEXPAVCBaseEntity@@@Z ; CTalkMonster::StartFollowing

; 1491 : 				SetBits(m_bitsSaid, bit_saidHelloPlayer);	// Don't say hi after you've started following

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2396]
	or	al, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax
$L37734:

; 1494 : 		else

	jmp	SHORT $L37735
$L37731:

; 1496 : 			StopFollowing( TRUE );

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+612]
$L37735:
$L37725:

; 1499 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?FollowerUse@CTalkMonster@@QAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CTalkMonster::FollowerUse
_TEXT	ENDS
PUBLIC	?KeyValue@CTalkMonster@@UAEXPAUKeyValueData_s@@@Z ; CTalkMonster::KeyValue
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
EXTRN	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseMonster::KeyValue
;	COMDAT ?KeyValue@CTalkMonster@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CTalkMonster@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CTalkMonster::KeyValue, COMDAT

; 1502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1503 : 	if (FStrEq(pkvd->szKeyName, "UseSentence"))

	push	OFFSET FLAT:??_C@_0M@EIDC@UseSentence?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37740

; 1505 : 		m_iszUse = ALLOC_STRING(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2488], eax

; 1506 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1508 : 	else if (FStrEq(pkvd->szKeyName, "UnUseSentence"))

	jmp	$L37747
$L37740:
	push	OFFSET FLAT:??_C@_0O@NFJF@UnUseSentence?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37742

; 1510 : 		m_iszUnUse = ALLOC_STRING(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2492], eax

; 1511 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1513 : 	else if (FStrEq(pkvd->szKeyName, "RefusalSentence")) //LRC

	jmp	$L37747
$L37742:
	push	OFFSET FLAT:??_C@_0BA@DPMB@RefusalSentence?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37744

; 1515 : 		m_iszDecline = ALLOC_STRING(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2496], eax

; 1516 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1518 : 	else if (FStrEq(pkvd->szKeyName, "SpeakAs")) //LRC

	jmp	SHORT $L37747
$L37744:
	push	OFFSET FLAT:??_C@_07PDEP@SpeakAs?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L37746

; 1520 : 		m_iszSpeakAs = ALLOC_STRING(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2500], eax

; 1521 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 1523 : 	else 

	jmp	SHORT $L37747
$L37746:

; 1524 : 		CBaseMonster::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z ; CBaseMonster::KeyValue
$L37747:

; 1525 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CTalkMonster@@UAEXPAUKeyValueData_s@@@Z ENDP	; CTalkMonster::KeyValue
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?Precache@CTalkMonster@@UAEXXZ			; CTalkMonster::Precache
;	COMDAT ?Precache@CTalkMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CTalkMonster@@UAEXXZ PROC NEAR		; CTalkMonster::Precache, COMDAT

; 1529 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1530 : 	if ( m_iszUse )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2488], 0
	je	SHORT $L37752

; 1531 : 		m_szGrp[TLK_USE] = STRING( m_iszUse );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2488]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2424], eax
$L37752:

; 1532 : 	if ( m_iszUnUse )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2492], 0
	je	SHORT $L37753

; 1533 : 		m_szGrp[TLK_UNUSE] = STRING( m_iszUnUse );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2492]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2428], eax
$L37753:

; 1534 : 	if ( m_iszDecline ) //LRC

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2496], 0
	je	SHORT $L37754

; 1535 : 		m_szGrp[TLK_DECLINE] = STRING( m_iszDecline );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2496]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2432], eax
$L37754:

; 1536 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CTalkMonster@@UAEXXZ ENDP			; CTalkMonster::Precache
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L38461
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L38461
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L38461
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38461:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseMonster@@2Udatamap_s@@A:BYTE	; CBaseMonster::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseMonster@@2Udatamap_s@@A ; CBaseMonster::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L38470
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L38470
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L38470
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38470:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L38471
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38471
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38471:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L38476
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38476:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L37806

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L37806:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38481
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38481:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38482
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38482:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L38485
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38485:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L38492
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L38492
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L38493
$L38492:
	mov	DWORD PTR -8+[ebp], 0
$L38493:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L37839:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L37840

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L37839
$L37840:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L37849

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L37849:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38500
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L38500
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L38500
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38500:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L37858
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L37858

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L37858:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
$T38503 = -4
_pMemory$ = 8
_src$ = 12
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T38503[ebp], eax
	cmp	DWORD PTR $T38503[ebp], 0
	je	SHORT $L38504
	mov	ecx, DWORD PTR $T38503[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T38503[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L38505
$L38504:
	mov	DWORD PTR -8+[ebp], 0
$L38505:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L38510
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L38510
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L38511
$L38510:
	mov	DWORD PTR -8+[ebp], 0
$L38511:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L37872

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L37873

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L37873:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L37872:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_nAllocationRequested$ = -8
_num$ = 8
_this$ = -4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L38520
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38520:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L37887

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L38521
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38521:

; 567  : 		return;

	jmp	$L37884
$L37887:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L37907

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L37899
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L37899

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L37907
$L37899:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L37903

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L38522
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38522:

; 589  : 				return;

	jmp	$L37884
$L37903:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L37907

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L37903
$L37907:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L37910

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L38523
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38523:

; 603  : 	else

	jmp	SHORT $L38524
$L37910:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L38524
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L38524:
$L37884:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
