	TITLE	Z:\XashXTSRC\server\player.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KECC@CBasePlayer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMEP@m_flFlashLightTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBGK@m_iFlashBattery?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MIOL@m_afButtonLast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GBEG@m_afButtonPressed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@KFOL@m_afButtonReleased?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KJJK@m_rgItems?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCMP@m_afPhysicsFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BDEP@m_flTimeStepSound?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HOOD@m_flSwimTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BPHG@m_flDuckTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@OEFN@m_flWallJumpTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NJHH@m_flSuitUpdate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EFMO@m_rgSuitPlayList?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPB@m_iSuitPlayNext?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@OGJN@m_rgiSuitNoRepeat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@LLEI@m_rgflSuitNoRepeatTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HNKI@m_lastDamageAmount?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KJCH@m_pActiveItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@CFPO@m_pLastItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FKCE@m_rgAmmo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ILIP@m_idrowndmg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BBMB@m_idrownrestored?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GLKA@m_tSneaking?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08ENBA@m_iTrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CDPM@m_bitsHUDDamage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DAFJ@m_flFallVelocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGPL@m_iTargetVolume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CMBG@m_iWeaponVolume?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@CDKK@m_iExtraSoundTypes?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@GNJF@m_iWeaponFlash?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LMLC@m_fLongJump?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@PFJK@m_iInCarState?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GEOO@m_fInitHUD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LNGJ@m_tbdPrev?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PIL@m_pTank?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EOAP@m_pMonitor?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@INFE@m_pHoldableItem?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LOLJ@m_pVehicle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@EKEP@m_iHideHUD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MNED@m_iFOV?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@OAPM@m_iRainDripsPerSecond?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OOCO@m_flRainWindX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EELJ@m_flRainWindY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OEAO@m_flRainRandX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EOJJ@m_flRainRandY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@BJKH@m_iRainIdealDripsPerSecond?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JLGD@m_flRainIdealWindX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBPE@m_flRainIdealWindY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@JBED@m_flRainIdealRandX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@DLNE@m_flRainIdealRandY?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MLJ@m_flRainEndFade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@ENAH@m_flRainNextFadeUpdate?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JNAJ@m_hKeyCatchers?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBI@m_iNumKeyCatchers?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@EBBK@m_vecHoldableItemPosition?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FDEN@m_flHoldableItemDistance?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOGA@m_nCustomSprayFrames?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNKM@m_szAnimExtention?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GOGA@PlayerDeathThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KGLE@m_iSndRoomtype?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OAGP@SelAmmo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09MOMN@CurWeapon?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07GJNE@Weapons?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BNLF@Geiger?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PAOI@Flashlight?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MMIN@FlashBat?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MACP@Health?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06ILDP@Damage?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EFDJ@Battery?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HPFM@Train?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07EFI@HudText?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MFFM@SayText?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07FKFB@TextMsg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KAL@WeaponList?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EHIO@ResetHUD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07PHEM@InitHUD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KAAJ@GameTitle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FJPD@DeathMsg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HCEC@ScoreInfo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DBKP@TeamInfo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GODL@TeamScore?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MAFF@GameMode?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04PAEL@MOTD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMLK@ServerName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DJEN@AmmoPickup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHE@WeapPickup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KPIL@ItemPickup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HFOM@HideWeapon?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HLLA@SetFOV?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FEII@ShowMenu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PCMK@ScreenShake?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OBGK@ScreenFade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05HDEE@AmmoX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09POID@TeamNames?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LPOH@StatusText?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NJMM@StatusValue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FFNH@Particle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EMEB@KillPart?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OFCA@KillDecals?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MHAK@StudioDecal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08COBI@RainData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IHJL@MusicFade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DPCB@StatusIcon?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OCKM@SetupBones?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06MNOE@player?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FIFI@player?1pl_pain5?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@LIDH@player?1pl_pain6?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BIBC@player?1pl_pain7?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KMAI@weaponbox?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FAMA@CWeaponBox?3?3Kill?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KCNB@crouch_shoot_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@FJK@ref_shoot_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OOG@crouch_aim_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GBMH@ref_aim_?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09KCMO@deep_idle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@BCPL@player?1pl_swim1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@PCJE@player?1pl_swim2?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@FCLB@player?1pl_swim3?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@DCEL@player?1pl_swim4?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@FEBM@info_intermission?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOEM@plats?1train_use1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@MCNG@common?1wpn_select?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@FGJL@1?5?$CFp1?62?5Health?3?5?$CFi2?$CF?$CF?63?5Armor?3?5?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNFC@player_keycatcher?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PIHH@?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@DJPP@Client?5lost?5reserved?5sound?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HJAP@info_player_coop?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MCPA@info_player_start?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKJP@info_player_deathmatch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DB@HALC@PutClientInServer?3?5no?5info_playe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07DGNG@?$CKplayer?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HGJB@slj?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MDGH@hl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PECN@incar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMHA@models?1player?4mdl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JFAD@Couldn?8t?5alloc?5player?5sound?5slot@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FC@DGFM@You?5use?5is?5too?5old?5version?5of?5Xa@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@HLMG@?$CK?$CKGraph?5pointers?5were?5not?5set?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@OMEJ@?$CK?$CKGraph?5Pointers?5Set?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILEC@No?5Landmark?3?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@NACB@player?1sprayer?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05MLJC@Spray?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@PIHH@NULL?5Ent?5in?5GiveNamedItem?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@BKIG@items?1flashlight1?4wav?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@MPDL@game_firetarget?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OKCJ@Logo?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@LDKC@gmsgLogo?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??ImpulseCommands@CBasePlayer@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GHND@Generic?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JHAH@Head?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DKPC@Chest?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07JFJJ@Stomach?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EBCB@Left?5Arm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJE@Right?5Arm?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MBLC@Left?5Leg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BDAH@Right?5Leg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GCNK@Unknown8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08MIEN@Unknown9?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CKAM@Unknown10?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IAJL@Unknown11?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HPCC@Unknown12?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NFLF@Unknown13?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IAFA@Unknown14?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CKMH@Unknown15?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@HADJ@monster_human_grunt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KBEE@monster_zombie?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IMIN@item_suit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@LMGJ@item_healthkit?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@CIMM@item_battery?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@NAIF@weapon_crowbar?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NFGM@weapon_axe?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@FNBB@weapon_chainsaw?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09LNJP@ammo_fuel?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@MPPM@ammo_9mmclip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@PHLB@weapon_shotgun?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@FHCF@ammo_buckshot?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@JNOE@weapon_9mmAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HEPA@ammo_9mmAR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGIA@weapon_handgrenade?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@NPOO@weapon_357?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08BGGJ@ammo_357?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HAEF@weapon_crossbow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OFDM@ammo_crossbow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OCEH@weapon_rpg?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BIME@ammo_rpgclip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GFEK@Player?5is?5audible?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@IGLL@Player?5is?5silent?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HPKB@Texture?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JIOJ@Hitgroup?3?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILEJ@node_viewer_fly?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@BACI@node_viewer_large?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDJE@node_viewer_human?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03HMFC@?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LINJ@m_rgAmmo?$FLi?$FN?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@MENA@m_rgAmmo?$FLi?$FN?5?$DM?51000?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??SendAmmoUpdate@CBasePlayer@@QAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@CAEF@game_playerjoin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOHN@game_playerspawn?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCJ@gmsgBattery?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CK@DEAA@Rain?5fading?3?5curdrips?3?5?$CFi?0?5ideal@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@NEFF@Rain?5fading?5finished?5at?5?$CFi?5drips@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OHDJ@env_rain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@JDGE@env_rainmodify?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@PHGK@Sending?5enabling?5rain?5message?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@HLGI@Sending?5disabling?5rain?5message?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKKA@Clearing?5rain?5data?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DJKJ@gmsgTrain?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05EEDH@Empty?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??UpdateClientData@CBasePlayer@@UAEXXZ@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DADH@deadback?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HFON@deadsitting?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JAIB@deadstomach?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09DHBC@deadtable?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JLAH@pose?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BGGJ@monster_hevsuit_dead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@FAED@Dead?5hevsuit?5with?5bad?5pose?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06HFHN@attack?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LKFJ@jump?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04IPPP@duck?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07OHGK@forward?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DJCD@back?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03CFBD@use?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GACI@left?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05PJFF@right?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FLKH@moveleft?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09CKGO@moveright?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07LDML@attack2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03EHIM@run?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06BMJE@reload?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04NKPG@alt1?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05FILO@score?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GIDL@CPlayerKeyCatcher?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HGJK@m_iszKeyPressed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCPM@m_iszKeyReleased?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNCI@m_iszKeyHoldDown?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@BEGF@m_iszKeyToCatch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BL@FCGB@?$CFs?5has?5invalid?5keyname?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@LCP@player_weaponstrip?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IBM@player_loadsaved?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PJHA@CRevertSaved?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@DAMF@m_messageTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KMKM@m_loadTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PMMA@MessageThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09FGAG@LoadThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08OIHC@duration?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08GFEH@holdtime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LJDP@messagetime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08CLNM@loadtime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MPIK@reload?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PGFC@hud_sprite?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WRITE_BYTES@@YAXPBEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FIND_ENTITY_BY_CLASSNAME@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeNonSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeNonMoving@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreMoveType@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasWeapon@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAllWeapons@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopAnimation@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPlayerKeyCatcher@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAlive@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Link@CGraph@@QAEAAVCLink@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NodeLink@CGraph@@QAEAAVCLink@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pszAmmo1@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?iFlags@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBasePlayer@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E41
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkUserMessages@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Pain@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VecVelocityForDamage@@YA?AVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TrainSpeed@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeathSound@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeHealth@CBasePlayer@@UAEHMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PackDeadPlayerItems@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAllItems@CBasePlayer@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WaterMove@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsOnLadder@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerDeathThink@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartDeathCam@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartObserver@CBasePlayer@@QAEXVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PlayerUse@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Jump@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duck@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPoints@CBasePlayer@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBasePlayer@@UAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InitStatusBar@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateStatusBar@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransferReset@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateKeyCatchers@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreThink@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckTimeBasedDamage@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateGeigerCounter@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckSuitUpdate@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSuitUpdate@CBasePlayer@@QAEXPADHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckPowerups@@YAXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdatePlayerSound@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PostThink@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsSpawnPointValid@@YAHPAVCBaseEntity@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntSelectSpawnPoint@@YAPAUedict_s@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckCompatibility@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Precache@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RenewItems@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanEnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LeaveVehicle@CBasePlayer@@QAEXABVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateHoldableItem@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PickHoldableItem@CBasePlayer@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DropHoldableItem@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectNextItem@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectItem@CBasePlayer@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectLastItem@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasWeapons@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SelectPrevItem@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TeamID@CBasePlayer@@UAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CSprayCan@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CSprayCan@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CSprayCan@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CBloodSplat@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spray@CBloodSplat@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveNamedItem@CBasePlayer@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlashlightIsOn@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlashlightTurnOn@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FlashlightTurnOff@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ForceClientDllUpdate@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ImpulseCommands@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheatImpulseCommands@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBasePlayer@@UAEHHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ItemPreFrame@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ItemPostFrame@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AmmoInventory@CBasePlayer@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAmmoIndex@CBasePlayer@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendAmmoUpdate@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateClientData@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendStartMessages@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BarnacleVictimReleased@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Illumination@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableControl@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HideWeapons@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAutoaimVector@CBasePlayer@@QAE?AVVector@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AutoaimDeflection@CBasePlayer@@QAE?AVVector@@AAV2@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetAutoaim@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCustomDecalFrames@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCustomDecalFrames@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DropPlayerItem@CBasePlayer@@QAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasPlayerItem@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasNamedPlayerItem@CBasePlayer@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Classify@CDeadHEV@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CDeadHEV@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E46
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CDeadHEV@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CPlayerKeyCatcher@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CPlayerKeyCatcher@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E49
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E53
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CPlayerKeyCatcher@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Restore@CPlayerKeyCatcher@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CPlayerKeyCatcher@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CatchButton@CPlayerKeyCatcher@@QAEXPAVCBaseEntity@@HHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E57
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E58
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CStripWeapons@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Duration@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HoldTime@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MessageTime@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadTime@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDuration@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHoldTime@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMessageTime@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLoadTime@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E61
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CRevertSaved@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CRevertSaved@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E64
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E65
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KeyValue@CRevertSaved@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CRevertSaved@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MessageThink@CRevertSaved@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadThink@CRevertSaved@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CInfoIntermission@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Think@CInfoIntermission@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E69
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E70
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetState@CHudSprite@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E72
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E73
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Spawn@CHudSprite@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartMessage@CHudSprite@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Use@CHudSprite@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCBasePlayer@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCBasePlayer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCBasePlayer@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCBasePlayer@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCDeadHEV@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCDeadHEV@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCDeadHEV@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCDeadHEV@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCPlayerKeyCatcher@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCStripWeapons@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCStripWeapons@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCStripWeapons@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCStripWeapons@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCRevertSaved@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCRevertSaved@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCRevertSaved@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCRevertSaved@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCInfoIntermission@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCInfoIntermission@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCInfoIntermission@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCInfoIntermission@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CEntityFactory@VCHudSprite@@@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CEntityFactory@VCHudSprite@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCHudSprite@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCHudSprite@@@@UAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSprayCan@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBloodSplat@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBasePlayer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDeadHEV@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPlayerKeyCatcher@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CStripWeapons@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRevertSaved@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CInfoIntermission@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CHudSprite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPointEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPointEntity@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBloodSplat@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRevertSaved@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBasePlayer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPlayerKeyCatcher@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCInfoIntermission@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStripWeapons@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCPlayerKeyCatcher@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CDeadHEV@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CInfoIntermission@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CHudSprite@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCDeadHEV@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCHudSprite@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCStripWeapons@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCBasePlayer@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSprayCan@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPointEntity@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CEntityFactory@VCRevertSaved@@@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_0BG@OAPM@m_iRainDripsPerSecond?$AA@	; `string'
PUBLIC	??_C@_0O@OOCO@m_flRainWindX?$AA@		; `string'
PUBLIC	??_C@_0O@EELJ@m_flRainWindY?$AA@		; `string'
PUBLIC	??_C@_0O@OEAO@m_flRainRandX?$AA@		; `string'
PUBLIC	??_C@_0O@EOJJ@m_flRainRandY?$AA@		; `string'
PUBLIC	??_C@_0BA@HGJK@m_iszKeyPressed?$AA@		; `string'
PUBLIC	??_C@_0BL@BJKH@m_iRainIdealDripsPerSecond?$AA@	; `string'
PUBLIC	??_C@_0BB@LCPM@m_iszKeyReleased?$AA@		; `string'
PUBLIC	??_C@_0BD@JLGD@m_flRainIdealWindX?$AA@		; `string'
PUBLIC	??_C@_0BB@MNCI@m_iszKeyHoldDown?$AA@		; `string'
PUBLIC	??_C@_0BD@DBPE@m_flRainIdealWindY?$AA@		; `string'
PUBLIC	??_C@_0BD@JBED@m_flRainIdealRandX?$AA@		; `string'
PUBLIC	??_C@_0BD@DLNE@m_flRainIdealRandY?$AA@		; `string'
PUBLIC	??_C@_0BA@MLJ@m_flRainEndFade?$AA@		; `string'
PUBLIC	??_C@_0BH@ENAH@m_flRainNextFadeUpdate?$AA@	; `string'
PUBLIC	??_C@_0P@JNAJ@m_hKeyCatchers?$AA@		; `string'
PUBLIC	??_C@_0BC@MBI@m_iNumKeyCatchers?$AA@		; `string'
PUBLIC	??_C@_0BK@EBBK@m_vecHoldableItemPosition?$AA@	; `string'
PUBLIC	??_C@_0BJ@FDEN@m_flHoldableItemDistance?$AA@	; `string'
PUBLIC	?gmsgShake@@3HA					; gmsgShake
PUBLIC	??_C@_0BF@BOGA@m_nCustomSprayFrames?$AA@	; `string'
PUBLIC	??_C@_0BC@KNKM@m_szAnimExtention?$AA@		; `string'
PUBLIC	?gmsgFade@@3HA					; gmsgFade
PUBLIC	?giPrecacheGrunt@@3HA				; giPrecacheGrunt
PUBLIC	?gmsgSelAmmo@@3HA				; gmsgSelAmmo
PUBLIC	?gmsgFlashlight@@3HA				; gmsgFlashlight
PUBLIC	?gmsgFlashBattery@@3HA				; gmsgFlashBattery
PUBLIC	?gmsgResetHUD@@3HA				; gmsgResetHUD
PUBLIC	?gmsgInitHUD@@3HA				; gmsgInitHUD
PUBLIC	?gmsgShowGameTitle@@3HA				; gmsgShowGameTitle
PUBLIC	?gmsgCurWeapon@@3HA				; gmsgCurWeapon
PUBLIC	?gmsgWeapons@@3HA				; gmsgWeapons
PUBLIC	?gmsgHealth@@3HA				; gmsgHealth
PUBLIC	?gmsgDamage@@3HA				; gmsgDamage
PUBLIC	?gmsgBattery@@3HA				; gmsgBattery
PUBLIC	?gmsgTrain@@3HA					; gmsgTrain
PUBLIC	?gmsgLogo@@3HA					; gmsgLogo
PUBLIC	?gmsgWeaponList@@3HA				; gmsgWeaponList
PUBLIC	?gmsgAmmoX@@3HA					; gmsgAmmoX
PUBLIC	?gmsgDeathMsg@@3HA				; gmsgDeathMsg
PUBLIC	?gmsgScoreInfo@@3HA				; gmsgScoreInfo
PUBLIC	?gmsgTeamInfo@@3HA				; gmsgTeamInfo
PUBLIC	?gmsgTeamScore@@3HA				; gmsgTeamScore
PUBLIC	?gmsgGameMode@@3HA				; gmsgGameMode
PUBLIC	?gmsgMOTD@@3HA					; gmsgMOTD
PUBLIC	?gmsgServerName@@3HA				; gmsgServerName
PUBLIC	?gmsgAmmoPickup@@3HA				; gmsgAmmoPickup
PUBLIC	?gmsgItemPickup@@3HA				; gmsgItemPickup
PUBLIC	?gmsgHideWeapon@@3HA				; gmsgHideWeapon
PUBLIC	?gmsgSetCurWeap@@3HA				; gmsgSetCurWeap
PUBLIC	?gmsgSayText@@3HA				; gmsgSayText
PUBLIC	?gmsgTextMsg@@3HA				; gmsgTextMsg
PUBLIC	?gmsgSetFOV@@3HA				; gmsgSetFOV
PUBLIC	?gmsgShowMenu@@3HA				; gmsgShowMenu
PUBLIC	?gmsgGeigerRange@@3HA				; gmsgGeigerRange
PUBLIC	?gmsgTeamNames@@3HA				; gmsgTeamNames
PUBLIC	?gmsgStatusText@@3HA				; gmsgStatusText
PUBLIC	?gmsgStatusValue@@3HA				; gmsgStatusValue
PUBLIC	?gmsgKillPart@@3HA				; gmsgKillPart
PUBLIC	?gmsgKillDecals@@3HA				; gmsgKillDecals
PUBLIC	?gmsgRainData@@3HA				; gmsgRainData
PUBLIC	?gmsgStatusIcon@@3HA				; gmsgStatusIcon
PUBLIC	?m_DataMap@CRevertSaved@@2Udatamap_s@@A		; CRevertSaved::m_DataMap
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_0N@PJHA@CRevertSaved?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CRevertSaved_DataDescInit@@3PAUdatamap_s@@A ; CRevertSaved_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0O@DAMF@m_messageTime?$AA@		; `string'
PUBLIC	??_C@_0L@KMKM@m_loadTime?$AA@			; `string'
PUBLIC	?pHitboxNames@@3PAPBDA				; pHitboxNames
PUBLIC	??_C@_07GHND@Generic?$AA@			; `string'
PUBLIC	??_C@_04JHAH@Head?$AA@				; `string'
PUBLIC	??_C@_05DKPC@Chest?$AA@				; `string'
PUBLIC	??_C@_07JFJJ@Stomach?$AA@			; `string'
PUBLIC	??_C@_08EBCB@Left?5Arm?$AA@			; `string'
PUBLIC	??_C@_09JDJE@Right?5Arm?$AA@			; `string'
PUBLIC	??_C@_08MBLC@Left?5Leg?$AA@			; `string'
PUBLIC	??_C@_09BDAH@Right?5Leg?$AA@			; `string'
PUBLIC	??_C@_08GCNK@Unknown8?$AA@			; `string'
PUBLIC	??_C@_08MIEN@Unknown9?$AA@			; `string'
PUBLIC	??_C@_09CKAM@Unknown10?$AA@			; `string'
PUBLIC	??_C@_09IAJL@Unknown11?$AA@			; `string'
PUBLIC	??_C@_09HPCC@Unknown12?$AA@			; `string'
PUBLIC	?g_pevLastInflictor@@3PAUentvars_s@@A		; g_pevLastInflictor
PUBLIC	??_C@_09NFLF@Unknown13?$AA@			; `string'
PUBLIC	??_C@_09IAFA@Unknown14?$AA@			; `string'
PUBLIC	??_C@_09CKMH@Unknown15?$AA@			; `string'
PUBLIC	?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A	; CPlayerKeyCatcher::m_DataMap
PUBLIC	?m_DataMap@CBasePlayer@@2Udatamap_s@@A		; CBasePlayer::m_DataMap
PUBLIC	?gEvilImpulse101@@3HA				; gEvilImpulse101
PUBLIC	??_C@_0M@KECC@CBasePlayer?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CBasePlayer_DataDescInit@@3PAUdatamap_s@@A ; CBasePlayer_DataDescInit::g_DataMapHolder
PUBLIC	?gmsgHudText@@3HA				; gmsgHudText
PUBLIC	?gmsgParticle@@3HA				; gmsgParticle
PUBLIC	?gmsgStudioDecal@@3HA				; gmsgStudioDecal
PUBLIC	?gmsgMusicFade@@3HA				; gmsgMusicFade
PUBLIC	?gmsgSetupBones@@3HA				; gmsgSetupBones
PUBLIC	?gInitHUD@@3HA					; gInitHUD
PUBLIC	??_C@_0BD@JMEP@m_flFlashLightTime?$AA@		; `string'
PUBLIC	??_C@_0BA@NBGK@m_iFlashBattery?$AA@		; `string'
PUBLIC	??_C@_0P@MIOL@m_afButtonLast?$AA@		; `string'
PUBLIC	??_C@_0BC@GBEG@m_afButtonPressed?$AA@		; `string'
PUBLIC	??_C@_0BD@KFOL@m_afButtonReleased?$AA@		; `string'
PUBLIC	??_C@_09KJJK@m_rgItems?$AA@			; `string'
PUBLIC	??_C@_0BB@DCMP@m_afPhysicsFlags?$AA@		; `string'
PUBLIC	??_C@_0BC@BDEP@m_flTimeStepSound?$AA@		; `string'
PUBLIC	??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@		; `string'
PUBLIC	??_C@_0N@HOOD@m_flSwimTime?$AA@			; `string'
PUBLIC	??_C@_0N@BPHG@m_flDuckTime?$AA@			; `string'
PUBLIC	?m_szPoses@CDeadHEV@@2PAPADA			; CDeadHEV::m_szPoses
PUBLIC	??_C@_0BB@OEFN@m_flWallJumpTime?$AA@		; `string'
PUBLIC	??_C@_0P@NJHH@m_flSuitUpdate?$AA@		; `string'
PUBLIC	??_C@_0BB@EFMO@m_rgSuitPlayList?$AA@		; `string'
PUBLIC	??_C@_0BA@HPB@m_iSuitPlayNext?$AA@		; `string'
PUBLIC	??_C@_0BC@OGJN@m_rgiSuitNoRepeat?$AA@		; `string'
PUBLIC	??_C@_08DADH@deadback?$AA@			; `string'
PUBLIC	??_C@_0M@HFON@deadsitting?$AA@			; `string'
PUBLIC	??_C@_0M@JAIB@deadstomach?$AA@			; `string'
PUBLIC	??_C@_09DHBC@deadtable?$AA@			; `string'
PUBLIC	??_C@_0BH@LLEI@m_rgflSuitNoRepeatTime?$AA@	; `string'
PUBLIC	??_C@_0BD@HNKI@m_lastDamageAmount?$AA@		; `string'
PUBLIC	??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@		; `string'
PUBLIC	??_C@_0O@KJCH@m_pActiveItem?$AA@		; `string'
PUBLIC	??_C@_0M@CFPO@m_pLastItem?$AA@			; `string'
PUBLIC	??_C@_08FKCE@m_rgAmmo?$AA@			; `string'
PUBLIC	??_C@_0M@ILIP@m_idrowndmg?$AA@			; `string'
PUBLIC	??_C@_0BB@BBMB@m_idrownrestored?$AA@		; `string'
PUBLIC	??_C@_0M@GLKA@m_tSneaking?$AA@			; `string'
PUBLIC	??_C@_08ENBA@m_iTrain?$AA@			; `string'
PUBLIC	??_C@_0BA@CDPM@m_bitsHUDDamage?$AA@		; `string'
PUBLIC	??_C@_0BB@DAFJ@m_flFallVelocity?$AA@		; `string'
PUBLIC	??_C@_06HFHN@attack?$AA@			; `string'
PUBLIC	??_C@_04LKFJ@jump?$AA@				; `string'
PUBLIC	??_C@_04IPPP@duck?$AA@				; `string'
PUBLIC	??_C@_0BA@CGPL@m_iTargetVolume?$AA@		; `string'
PUBLIC	??_C@_07OHGK@forward?$AA@			; `string'
PUBLIC	??_C@_04DJCD@back?$AA@				; `string'
PUBLIC	??_C@_03CFBD@use?$AA@				; `string'
PUBLIC	??_C@_0BA@CMBG@m_iWeaponVolume?$AA@		; `string'
PUBLIC	??_C@_04GACI@left?$AA@				; `string'
PUBLIC	??_C@_05PJFF@right?$AA@				; `string'
PUBLIC	??_C@_08FLKH@moveleft?$AA@			; `string'
PUBLIC	??_C@_0BD@CDKK@m_iExtraSoundTypes?$AA@		; `string'
PUBLIC	??_C@_09CKGO@moveright?$AA@			; `string'
PUBLIC	??_C@_07LDML@attack2?$AA@			; `string'
PUBLIC	??_C@_03EHIM@run?$AA@				; `string'
PUBLIC	??_C@_0P@GNJF@m_iWeaponFlash?$AA@		; `string'
PUBLIC	??_C@_06BMJE@reload?$AA@			; `string'
PUBLIC	??_C@_04NKPG@alt1?$AA@				; `string'
PUBLIC	??_C@_05FILO@score?$AA@				; `string'
PUBLIC	??_C@_0M@LMLC@m_fLongJump?$AA@			; `string'
PUBLIC	??_C@_0BC@GIDL@CPlayerKeyCatcher?$AA@		; `string'
PUBLIC	??_C@_0O@PFJK@m_iInCarState?$AA@		; `string'
PUBLIC	??_C@_0L@GEOO@m_fInitHUD?$AA@			; `string'
PUBLIC	?gmsgWeapPickup@@3HA				; gmsgWeapPickup
PUBLIC	??_C@_09LNGJ@m_tbdPrev?$AA@			; `string'
PUBLIC	??_C@_07PIL@m_pTank?$AA@			; `string'
PUBLIC	??_C@_0L@EOAP@m_pMonitor?$AA@			; `string'
PUBLIC	??_C@_0BA@INFE@m_pHoldableItem?$AA@		; `string'
PUBLIC	?g_pLastSpawn@@3PAVCBaseEntity@@A		; g_pLastSpawn
PUBLIC	??_C@_0L@LOLJ@m_pVehicle?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CPlayerKeyCatcher_DataDescInit@@3PAUdatamap_s@@A ; CPlayerKeyCatcher_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0L@EKEP@m_iHideHUD?$AA@			; `string'
PUBLIC	??_C@_06MNED@m_iFOV?$AA@			; `string'
_BSS	SEGMENT
?gmsgShake@@3HA DD 01H DUP (?)				; gmsgShake
?gmsgFade@@3HA DD 01H DUP (?)				; gmsgFade
?giPrecacheGrunt@@3HA DD 01H DUP (?)			; giPrecacheGrunt
?gmsgSelAmmo@@3HA DD 01H DUP (?)			; gmsgSelAmmo
?gmsgFlashlight@@3HA DD 01H DUP (?)			; gmsgFlashlight
?gmsgFlashBattery@@3HA DD 01H DUP (?)			; gmsgFlashBattery
?gmsgResetHUD@@3HA DD 01H DUP (?)			; gmsgResetHUD
?gmsgInitHUD@@3HA DD 01H DUP (?)			; gmsgInitHUD
?gmsgShowGameTitle@@3HA DD 01H DUP (?)			; gmsgShowGameTitle
?gmsgCurWeapon@@3HA DD 01H DUP (?)			; gmsgCurWeapon
?gmsgWeapons@@3HA DD 01H DUP (?)			; gmsgWeapons
?gmsgHealth@@3HA DD 01H DUP (?)				; gmsgHealth
?gmsgDamage@@3HA DD 01H DUP (?)				; gmsgDamage
?gmsgBattery@@3HA DD 01H DUP (?)			; gmsgBattery
?gmsgTrain@@3HA DD 01H DUP (?)				; gmsgTrain
?gmsgLogo@@3HA DD 01H DUP (?)				; gmsgLogo
?gmsgWeaponList@@3HA DD 01H DUP (?)			; gmsgWeaponList
?gmsgAmmoX@@3HA DD 01H DUP (?)				; gmsgAmmoX
?gmsgDeathMsg@@3HA DD 01H DUP (?)			; gmsgDeathMsg
?gmsgScoreInfo@@3HA DD 01H DUP (?)			; gmsgScoreInfo
?gmsgTeamInfo@@3HA DD 01H DUP (?)			; gmsgTeamInfo
?gmsgTeamScore@@3HA DD 01H DUP (?)			; gmsgTeamScore
?gmsgGameMode@@3HA DD 01H DUP (?)			; gmsgGameMode
?gmsgMOTD@@3HA DD 01H DUP (?)				; gmsgMOTD
?gmsgServerName@@3HA DD 01H DUP (?)			; gmsgServerName
?gmsgAmmoPickup@@3HA DD 01H DUP (?)			; gmsgAmmoPickup
?gmsgItemPickup@@3HA DD 01H DUP (?)			; gmsgItemPickup
?gmsgHideWeapon@@3HA DD 01H DUP (?)			; gmsgHideWeapon
?gmsgSetCurWeap@@3HA DD 01H DUP (?)			; gmsgSetCurWeap
?gmsgSayText@@3HA DD 01H DUP (?)			; gmsgSayText
?gmsgTextMsg@@3HA DD 01H DUP (?)			; gmsgTextMsg
?gmsgSetFOV@@3HA DD 01H DUP (?)				; gmsgSetFOV
?gmsgShowMenu@@3HA DD 01H DUP (?)			; gmsgShowMenu
?gmsgGeigerRange@@3HA DD 01H DUP (?)			; gmsgGeigerRange
?gmsgTeamNames@@3HA DD 01H DUP (?)			; gmsgTeamNames
?gmsgStatusText@@3HA DD 01H DUP (?)			; gmsgStatusText
?gmsgStatusValue@@3HA DD 01H DUP (?)			; gmsgStatusValue
?gmsgKillPart@@3HA DD 01H DUP (?)			; gmsgKillPart
?gmsgKillDecals@@3HA DD 01H DUP (?)			; gmsgKillDecals
?gmsgRainData@@3HA DD 01H DUP (?)			; gmsgRainData
?gmsgStatusIcon@@3HA DD 01H DUP (?)			; gmsgStatusIcon
?g_DataMapHolder@CRevertSaved_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CRevertSaved_DataDescInit::g_DataMapHolder
?g_pevLastInflictor@@3PAUentvars_s@@A DD 01H DUP (?)	; g_pevLastInflictor
_?fInSelect@?1??ItemPostFrame@CBasePlayer@@QAEXXZ@4HA DD 01H DUP (?)
?gEvilImpulse101@@3HA DD 01H DUP (?)			; gEvilImpulse101
_?gtbdPrev@?1??CheckTimeBasedDamage@CBasePlayer@@QAEXXZ@4MA DD 01H DUP (?)
?g_DataMapHolder@CBasePlayer_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBasePlayer_DataDescInit::g_DataMapHolder
?gmsgHudText@@3HA DD 01H DUP (?)			; gmsgHudText
?gmsgParticle@@3HA DD 01H DUP (?)			; gmsgParticle
?gmsgStudioDecal@@3HA DD 01H DUP (?)			; gmsgStudioDecal
?gmsgMusicFade@@3HA DD 01H DUP (?)			; gmsgMusicFade
?gmsgSetupBones@@3HA DD 01H DUP (?)			; gmsgSetupBones
?gmsgWeapPickup@@3HA DD 01H DUP (?)			; gmsgWeapPickup
?g_pLastSpawn@@3PAVCBaseEntity@@A DD 01H DUP (?)	; g_pLastSpawn
?g_DataMapHolder@CPlayerKeyCatcher_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CPlayerKeyCatcher_DataDescInit::g_DataMapHolder
_BSS	ENDS
_DATA	SEGMENT
?gInitHUD@@3HA DD 01H					; gInitHUD
	ORG $+4
?m_DataMap@CBasePlayer@@2Udatamap_s@@A DD 00H		; CBasePlayer::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0M@KECC@CBasePlayer?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S39	DD	FLAT:_$E38
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BD@JMEP@m_flFlashLightTime?$AA@
	DD	0978H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@NBGK@m_iFlashBattery?$AA@
	DD	097cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@MIOL@m_afButtonLast?$AA@
	DD	0980H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BC@GBEG@m_afButtonPressed?$AA@
	DD	0984H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BD@KFOL@m_afButtonReleased?$AA@
	DD	0988H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_09KJJK@m_rgItems?$AA@
	DD	099cH
	DW	05H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BB@DCMP@m_afPhysicsFlags?$AA@
	DD	09b8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BC@BDEP@m_flTimeStepSound?$AA@
	DD	09c0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@
	DD	09c4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0N@HOOD@m_flSwimTime?$AA@
	DD	09c8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0N@BPHG@m_flDuckTime?$AA@
	DD	09ccH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BB@OEFN@m_flWallJumpTime?$AA@
	DD	09d0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0P@NJHH@m_flSuitUpdate?$AA@
	DD	09d4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BB@EFMO@m_rgSuitPlayList?$AA@
	DD	09d8H
	DW	04H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@HPB@m_iSuitPlayNext?$AA@
	DD	09e8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BC@OGJN@m_rgiSuitNoRepeat?$AA@
	DD	09ecH
	DW	020H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BH@LLEI@m_rgflSuitNoRepeatTime?$AA@
	DD	0a6cH
	DW	020H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BD@HNKI@m_lastDamageAmount?$AA@
	DD	0aecH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@
	DD	0b8cH
	DW	06H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0O@KJCH@m_pActiveItem?$AA@
	DD	0ba4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0M@CFPO@m_pLastItem?$AA@
	DD	0bacH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08FKCE@m_rgAmmo?$AA@
	DD	0db4H
	DW	020H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0M@ILIP@m_idrowndmg?$AA@
	DD	0b14H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BB@BBMB@m_idrownrestored?$AA@
	DD	0b18H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0M@GLKA@m_tSneaking?$AA@
	DD	0b60H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08ENBA@m_iTrain?$AA@
	DD	0b28H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@CDPM@m_bitsHUDDamage?$AA@
	DD	0b1cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BB@DAFJ@m_flFallVelocity?$AA@
	DD	0998H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@CGPL@m_iTargetVolume?$AA@
	DD	0964H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BA@CMBG@m_iWeaponVolume?$AA@
	DD	0968H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BD@CDKK@m_iExtraSoundTypes?$AA@
	DD	096cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@GNJF@m_iWeaponFlash?$AA@
	DD	0970H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0M@LMLC@m_fLongJump?$AA@
	DD	0b58H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0O@PFJK@m_iInCarState?$AA@
	DD	0b5cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0L@GEOO@m_fInitHUD?$AA@
	DD	0b20H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_09LNGJ@m_tbdPrev?$AA@
	DD	0af0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_07PIL@m_pTank?$AA@
	DD	0b30H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0L@EOAP@m_pMonitor?$AA@
	DD	0b38H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0BA@INFE@m_pHoldableItem?$AA@
	DD	0b40H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0L@LOLJ@m_pVehicle?$AA@
	DD	0b48H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0L@EKEP@m_iHideHUD?$AA@
	DD	0b70H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_06MNED@m_iFOV?$AA@
	DD	0b78H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BG@OAPM@m_iRainDripsPerSecond?$AA@
	DD	0104cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0O@OOCO@m_flRainWindX?$AA@
	DD	01050H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0O@EELJ@m_flRainWindY?$AA@
	DD	01054H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0O@OEAO@m_flRainRandX?$AA@
	DD	01058H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0O@EOJJ@m_flRainRandY?$AA@
	DD	0105cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BL@BJKH@m_iRainIdealDripsPerSecond?$AA@
	DD	01060H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BD@JLGD@m_flRainIdealWindX?$AA@
	DD	01064H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BD@DBPE@m_flRainIdealWindY?$AA@
	DD	01068H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BD@JBED@m_flRainIdealRandX?$AA@
	DD	0106cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BD@DLNE@m_flRainIdealRandY?$AA@
	DD	01070H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BA@MLJ@m_flRainEndFade?$AA@
	DD	01074H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BH@ENAH@m_flRainNextFadeUpdate?$AA@
	DD	01078H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0P@JNAJ@m_hKeyCatchers?$AA@
	DD	0bb0H
	DW	040H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BC@MBI@m_iNumKeyCatchers?$AA@
	DD	0db0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0BK@EBBK@m_vecHoldableItemPosition?$AA@
	DD	01034H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BJ@FDEN@m_flHoldableItemDistance?$AA@
	DD	01030H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0BF@BOGA@m_nCustomSprayFrames?$AA@
	DD	0ed4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0eH
	DD	FLAT:??_C@_0BC@KNKM@m_szAnimExtention?$AA@
	DD	0eecH
	DW	020H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+44
_DATA	ENDS
CRT$XCU	SEGMENT
_$S44	DD	FLAT:_$E43
CRT$XCU	ENDS
_DATA	SEGMENT
?pHitboxNames@@3PAPBDA DD FLAT:??_C@_07GHND@Generic?$AA@ ; pHitboxNames
	DD	FLAT:??_C@_04JHAH@Head?$AA@
	DD	FLAT:??_C@_05DKPC@Chest?$AA@
	DD	FLAT:??_C@_07JFJJ@Stomach?$AA@
	DD	FLAT:??_C@_08EBCB@Left?5Arm?$AA@
	DD	FLAT:??_C@_09JDJE@Right?5Arm?$AA@
	DD	FLAT:??_C@_08MBLC@Left?5Leg?$AA@
	DD	FLAT:??_C@_09BDAH@Right?5Leg?$AA@
	DD	FLAT:??_C@_08GCNK@Unknown8?$AA@
	DD	FLAT:??_C@_08MIEN@Unknown9?$AA@
	DD	FLAT:??_C@_09CKAM@Unknown10?$AA@
	DD	FLAT:??_C@_09IAJL@Unknown11?$AA@
	DD	FLAT:??_C@_09HPCC@Unknown12?$AA@
	DD	FLAT:??_C@_09NFLF@Unknown13?$AA@
	DD	FLAT:??_C@_09IAFA@Unknown14?$AA@
	DD	FLAT:??_C@_09CKMH@Unknown15?$AA@
	DD	FLAT:??_C@_00A@?$AA@
?m_szPoses@CDeadHEV@@2PAPADA DD FLAT:??_C@_08DADH@deadback?$AA@ ; CDeadHEV::m_szPoses
	DD	FLAT:??_C@_0M@HFON@deadsitting?$AA@
	DD	FLAT:??_C@_0M@JAIB@deadstomach?$AA@
	DD	FLAT:??_C@_09DHBC@deadtable?$AA@
_DATA	ENDS
CRT$XCU	SEGMENT
_$S48	DD	FLAT:_$E47
CRT$XCU	ENDS
_DATA	SEGMENT
	ORG $+4
_gPlayerButtonTable DD FLAT:??_C@_06HFHN@attack?$AA@
	DD	01H
	DD	FLAT:??_C@_04LKFJ@jump?$AA@
	DD	02H
	DD	FLAT:??_C@_04IPPP@duck?$AA@
	DD	04H
	DD	FLAT:??_C@_07OHGK@forward?$AA@
	DD	08H
	DD	FLAT:??_C@_04DJCD@back?$AA@
	DD	010H
	DD	FLAT:??_C@_03CFBD@use?$AA@
	DD	020H
	DD	FLAT:??_C@_04GACI@left?$AA@
	DD	080H
	DD	FLAT:??_C@_05PJFF@right?$AA@
	DD	0100H
	DD	FLAT:??_C@_08FLKH@moveleft?$AA@
	DD	0200H
	DD	FLAT:??_C@_09CKGO@moveright?$AA@
	DD	0400H
	DD	FLAT:??_C@_07LDML@attack2?$AA@
	DD	0800H
	DD	FLAT:??_C@_03EHIM@run?$AA@
	DD	01000H
	DD	FLAT:??_C@_06BMJE@reload?$AA@
	DD	02000H
	DD	FLAT:??_C@_04NKPG@alt1?$AA@
	DD	04000H
	DD	FLAT:??_C@_05FILO@score?$AA@
	DD	08000H
?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A DD 00H	; CPlayerKeyCatcher::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0BC@GIDL@CPlayerKeyCatcher?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S51	DD	FLAT:_$E50
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BA@HGJK@m_iszKeyPressed?$AA@
	DD	0700H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BA@HGJK@m_iszKeyPressed?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BB@LCPM@m_iszKeyReleased?$AA@
	DD	0704H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BB@LCPM@m_iszKeyReleased?$AA@
	DD	00H
	DD	01H
	DD	FLAT:??_C@_0BB@MNCI@m_iszKeyHoldDown?$AA@
	DD	0708H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0BB@MNCI@m_iszKeyHoldDown?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S56	DD	FLAT:_$E55
_$S59	DD	FLAT:_$E58
_$S63	DD	FLAT:_$E62
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CRevertSaved@@2Udatamap_s@@A DD 00H		; CRevertSaved::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0N@PJHA@CRevertSaved?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S66	DD	FLAT:_$E65
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0O@DAMF@m_messageTime?$AA@
	DD	06e4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0L@KMKM@m_loadTime?$AA@
	DD	06e8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+44
_DATA	ENDS
CRT$XCU	SEGMENT
_$S71	DD	FLAT:_$E70
_$S74	DD	FLAT:_$E73
CRT$XCU	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT
??_C@_00A@?$AA@ DB 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KECC@CBasePlayer?$AA@
CONST	SEGMENT
??_C@_0M@KECC@CBasePlayer?$AA@ DB 'CBasePlayer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JMEP@m_flFlashLightTime?$AA@
CONST	SEGMENT
??_C@_0BD@JMEP@m_flFlashLightTime?$AA@ DB 'm_flFlashLightTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBGK@m_iFlashBattery?$AA@
CONST	SEGMENT
??_C@_0BA@NBGK@m_iFlashBattery?$AA@ DB 'm_iFlashBattery', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIOL@m_afButtonLast?$AA@
CONST	SEGMENT
??_C@_0P@MIOL@m_afButtonLast?$AA@ DB 'm_afButtonLast', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GBEG@m_afButtonPressed?$AA@
CONST	SEGMENT
??_C@_0BC@GBEG@m_afButtonPressed?$AA@ DB 'm_afButtonPressed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KFOL@m_afButtonReleased?$AA@
CONST	SEGMENT
??_C@_0BD@KFOL@m_afButtonReleased?$AA@ DB 'm_afButtonReleased', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KJJK@m_rgItems?$AA@
CONST	SEGMENT
??_C@_09KJJK@m_rgItems?$AA@ DB 'm_rgItems', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCMP@m_afPhysicsFlags?$AA@
CONST	SEGMENT
??_C@_0BB@DCMP@m_afPhysicsFlags?$AA@ DB 'm_afPhysicsFlags', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BDEP@m_flTimeStepSound?$AA@
CONST	SEGMENT
??_C@_0BC@BDEP@m_flTimeStepSound?$AA@ DB 'm_flTimeStepSound', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@
CONST	SEGMENT
??_C@_0BD@BHFE@m_flTimeWeaponIdle?$AA@ DB 'm_flTimeWeaponIdle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HOOD@m_flSwimTime?$AA@
CONST	SEGMENT
??_C@_0N@HOOD@m_flSwimTime?$AA@ DB 'm_flSwimTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BPHG@m_flDuckTime?$AA@
CONST	SEGMENT
??_C@_0N@BPHG@m_flDuckTime?$AA@ DB 'm_flDuckTime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OEFN@m_flWallJumpTime?$AA@
CONST	SEGMENT
??_C@_0BB@OEFN@m_flWallJumpTime?$AA@ DB 'm_flWallJumpTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NJHH@m_flSuitUpdate?$AA@
CONST	SEGMENT
??_C@_0P@NJHH@m_flSuitUpdate?$AA@ DB 'm_flSuitUpdate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EFMO@m_rgSuitPlayList?$AA@
CONST	SEGMENT
??_C@_0BB@EFMO@m_rgSuitPlayList?$AA@ DB 'm_rgSuitPlayList', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HPB@m_iSuitPlayNext?$AA@
CONST	SEGMENT
??_C@_0BA@HPB@m_iSuitPlayNext?$AA@ DB 'm_iSuitPlayNext', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OGJN@m_rgiSuitNoRepeat?$AA@
CONST	SEGMENT
??_C@_0BC@OGJN@m_rgiSuitNoRepeat?$AA@ DB 'm_rgiSuitNoRepeat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LLEI@m_rgflSuitNoRepeatTime?$AA@
CONST	SEGMENT
??_C@_0BH@LLEI@m_rgflSuitNoRepeatTime?$AA@ DB 'm_rgflSuitNoRepeatTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HNKI@m_lastDamageAmount?$AA@
CONST	SEGMENT
??_C@_0BD@HNKI@m_lastDamageAmount?$AA@ DB 'm_lastDamageAmount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@
CONST	SEGMENT
??_C@_0BB@EEJP@m_rgpPlayerItems?$AA@ DB 'm_rgpPlayerItems', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KJCH@m_pActiveItem?$AA@
CONST	SEGMENT
??_C@_0O@KJCH@m_pActiveItem?$AA@ DB 'm_pActiveItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFPO@m_pLastItem?$AA@
CONST	SEGMENT
??_C@_0M@CFPO@m_pLastItem?$AA@ DB 'm_pLastItem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FKCE@m_rgAmmo?$AA@
CONST	SEGMENT
??_C@_08FKCE@m_rgAmmo?$AA@ DB 'm_rgAmmo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ILIP@m_idrowndmg?$AA@
CONST	SEGMENT
??_C@_0M@ILIP@m_idrowndmg?$AA@ DB 'm_idrowndmg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BBMB@m_idrownrestored?$AA@
CONST	SEGMENT
??_C@_0BB@BBMB@m_idrownrestored?$AA@ DB 'm_idrownrestored', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GLKA@m_tSneaking?$AA@
CONST	SEGMENT
??_C@_0M@GLKA@m_tSneaking?$AA@ DB 'm_tSneaking', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08ENBA@m_iTrain?$AA@
CONST	SEGMENT
??_C@_08ENBA@m_iTrain?$AA@ DB 'm_iTrain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CDPM@m_bitsHUDDamage?$AA@
CONST	SEGMENT
??_C@_0BA@CDPM@m_bitsHUDDamage?$AA@ DB 'm_bitsHUDDamage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DAFJ@m_flFallVelocity?$AA@
CONST	SEGMENT
??_C@_0BB@DAFJ@m_flFallVelocity?$AA@ DB 'm_flFallVelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CGPL@m_iTargetVolume?$AA@
CONST	SEGMENT
??_C@_0BA@CGPL@m_iTargetVolume?$AA@ DB 'm_iTargetVolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CMBG@m_iWeaponVolume?$AA@
CONST	SEGMENT
??_C@_0BA@CMBG@m_iWeaponVolume?$AA@ DB 'm_iWeaponVolume', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CDKK@m_iExtraSoundTypes?$AA@
CONST	SEGMENT
??_C@_0BD@CDKK@m_iExtraSoundTypes?$AA@ DB 'm_iExtraSoundTypes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GNJF@m_iWeaponFlash?$AA@
CONST	SEGMENT
??_C@_0P@GNJF@m_iWeaponFlash?$AA@ DB 'm_iWeaponFlash', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMLC@m_fLongJump?$AA@
CONST	SEGMENT
??_C@_0M@LMLC@m_fLongJump?$AA@ DB 'm_fLongJump', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PFJK@m_iInCarState?$AA@
CONST	SEGMENT
??_C@_0O@PFJK@m_iInCarState?$AA@ DB 'm_iInCarState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GEOO@m_fInitHUD?$AA@
CONST	SEGMENT
??_C@_0L@GEOO@m_fInitHUD?$AA@ DB 'm_fInitHUD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LNGJ@m_tbdPrev?$AA@
CONST	SEGMENT
??_C@_09LNGJ@m_tbdPrev?$AA@ DB 'm_tbdPrev', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PIL@m_pTank?$AA@
CONST	SEGMENT
??_C@_07PIL@m_pTank?$AA@ DB 'm_pTank', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EOAP@m_pMonitor?$AA@
CONST	SEGMENT
??_C@_0L@EOAP@m_pMonitor?$AA@ DB 'm_pMonitor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@INFE@m_pHoldableItem?$AA@
CONST	SEGMENT
??_C@_0BA@INFE@m_pHoldableItem?$AA@ DB 'm_pHoldableItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LOLJ@m_pVehicle?$AA@
CONST	SEGMENT
??_C@_0L@LOLJ@m_pVehicle?$AA@ DB 'm_pVehicle', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EKEP@m_iHideHUD?$AA@
CONST	SEGMENT
??_C@_0L@EKEP@m_iHideHUD?$AA@ DB 'm_iHideHUD', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MNED@m_iFOV?$AA@
CONST	SEGMENT
??_C@_06MNED@m_iFOV?$AA@ DB 'm_iFOV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OAPM@m_iRainDripsPerSecond?$AA@
CONST	SEGMENT
??_C@_0BG@OAPM@m_iRainDripsPerSecond?$AA@ DB 'm_iRainDripsPerSecond', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OOCO@m_flRainWindX?$AA@
CONST	SEGMENT
??_C@_0O@OOCO@m_flRainWindX?$AA@ DB 'm_flRainWindX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EELJ@m_flRainWindY?$AA@
CONST	SEGMENT
??_C@_0O@EELJ@m_flRainWindY?$AA@ DB 'm_flRainWindY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OEAO@m_flRainRandX?$AA@
CONST	SEGMENT
??_C@_0O@OEAO@m_flRainRandX?$AA@ DB 'm_flRainRandX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EOJJ@m_flRainRandY?$AA@
CONST	SEGMENT
??_C@_0O@EOJJ@m_flRainRandY?$AA@ DB 'm_flRainRandY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BJKH@m_iRainIdealDripsPerSecond?$AA@
CONST	SEGMENT
??_C@_0BL@BJKH@m_iRainIdealDripsPerSecond?$AA@ DB 'm_iRainIdealDripsPerSe'
	DB	'cond', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JLGD@m_flRainIdealWindX?$AA@
CONST	SEGMENT
??_C@_0BD@JLGD@m_flRainIdealWindX?$AA@ DB 'm_flRainIdealWindX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBPE@m_flRainIdealWindY?$AA@
CONST	SEGMENT
??_C@_0BD@DBPE@m_flRainIdealWindY?$AA@ DB 'm_flRainIdealWindY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JBED@m_flRainIdealRandX?$AA@
CONST	SEGMENT
??_C@_0BD@JBED@m_flRainIdealRandX?$AA@ DB 'm_flRainIdealRandX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DLNE@m_flRainIdealRandY?$AA@
CONST	SEGMENT
??_C@_0BD@DLNE@m_flRainIdealRandY?$AA@ DB 'm_flRainIdealRandY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MLJ@m_flRainEndFade?$AA@
CONST	SEGMENT
??_C@_0BA@MLJ@m_flRainEndFade?$AA@ DB 'm_flRainEndFade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ENAH@m_flRainNextFadeUpdate?$AA@
CONST	SEGMENT
??_C@_0BH@ENAH@m_flRainNextFadeUpdate?$AA@ DB 'm_flRainNextFadeUpdate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JNAJ@m_hKeyCatchers?$AA@
CONST	SEGMENT
??_C@_0P@JNAJ@m_hKeyCatchers?$AA@ DB 'm_hKeyCatchers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBI@m_iNumKeyCatchers?$AA@
CONST	SEGMENT
??_C@_0BC@MBI@m_iNumKeyCatchers?$AA@ DB 'm_iNumKeyCatchers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EBBK@m_vecHoldableItemPosition?$AA@
CONST	SEGMENT
??_C@_0BK@EBBK@m_vecHoldableItemPosition?$AA@ DB 'm_vecHoldableItemPositi'
	DB	'on', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FDEN@m_flHoldableItemDistance?$AA@
CONST	SEGMENT
??_C@_0BJ@FDEN@m_flHoldableItemDistance?$AA@ DB 'm_flHoldableItemDistance'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOGA@m_nCustomSprayFrames?$AA@
CONST	SEGMENT
??_C@_0BF@BOGA@m_nCustomSprayFrames?$AA@ DB 'm_nCustomSprayFrames', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNKM@m_szAnimExtention?$AA@
CONST	SEGMENT
??_C@_0BC@KNKM@m_szAnimExtention?$AA@ DB 'm_szAnimExtention', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHND@Generic?$AA@
CONST	SEGMENT
??_C@_07GHND@Generic?$AA@ DB 'Generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JHAH@Head?$AA@
CONST	SEGMENT
??_C@_04JHAH@Head?$AA@ DB 'Head', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKPC@Chest?$AA@
CONST	SEGMENT
??_C@_05DKPC@Chest?$AA@ DB 'Chest', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JFJJ@Stomach?$AA@
CONST	SEGMENT
??_C@_07JFJJ@Stomach?$AA@ DB 'Stomach', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EBCB@Left?5Arm?$AA@
CONST	SEGMENT
??_C@_08EBCB@Left?5Arm?$AA@ DB 'Left Arm', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDJE@Right?5Arm?$AA@
CONST	SEGMENT
??_C@_09JDJE@Right?5Arm?$AA@ DB 'Right Arm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MBLC@Left?5Leg?$AA@
CONST	SEGMENT
??_C@_08MBLC@Left?5Leg?$AA@ DB 'Left Leg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BDAH@Right?5Leg?$AA@
CONST	SEGMENT
??_C@_09BDAH@Right?5Leg?$AA@ DB 'Right Leg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GCNK@Unknown8?$AA@
CONST	SEGMENT
??_C@_08GCNK@Unknown8?$AA@ DB 'Unknown8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MIEN@Unknown9?$AA@
CONST	SEGMENT
??_C@_08MIEN@Unknown9?$AA@ DB 'Unknown9', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CKAM@Unknown10?$AA@
CONST	SEGMENT
??_C@_09CKAM@Unknown10?$AA@ DB 'Unknown10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IAJL@Unknown11?$AA@
CONST	SEGMENT
??_C@_09IAJL@Unknown11?$AA@ DB 'Unknown11', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HPCC@Unknown12?$AA@
CONST	SEGMENT
??_C@_09HPCC@Unknown12?$AA@ DB 'Unknown12', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NFLF@Unknown13?$AA@
CONST	SEGMENT
??_C@_09NFLF@Unknown13?$AA@ DB 'Unknown13', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IAFA@Unknown14?$AA@
CONST	SEGMENT
??_C@_09IAFA@Unknown14?$AA@ DB 'Unknown14', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CKMH@Unknown15?$AA@
CONST	SEGMENT
??_C@_09CKMH@Unknown15?$AA@ DB 'Unknown15', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DADH@deadback?$AA@
CONST	SEGMENT
??_C@_08DADH@deadback?$AA@ DB 'deadback', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HFON@deadsitting?$AA@
CONST	SEGMENT
??_C@_0M@HFON@deadsitting?$AA@ DB 'deadsitting', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JAIB@deadstomach?$AA@
CONST	SEGMENT
??_C@_0M@JAIB@deadstomach?$AA@ DB 'deadstomach', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09DHBC@deadtable?$AA@
CONST	SEGMENT
??_C@_09DHBC@deadtable?$AA@ DB 'deadtable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HFHN@attack?$AA@
CONST	SEGMENT
??_C@_06HFHN@attack?$AA@ DB 'attack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LKFJ@jump?$AA@
CONST	SEGMENT
??_C@_04LKFJ@jump?$AA@ DB 'jump', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPPP@duck?$AA@
CONST	SEGMENT
??_C@_04IPPP@duck?$AA@ DB 'duck', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHGK@forward?$AA@
CONST	SEGMENT
??_C@_07OHGK@forward?$AA@ DB 'forward', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DJCD@back?$AA@
CONST	SEGMENT
??_C@_04DJCD@back?$AA@ DB 'back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CFBD@use?$AA@
CONST	SEGMENT
??_C@_03CFBD@use?$AA@ DB 'use', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GACI@left?$AA@
CONST	SEGMENT
??_C@_04GACI@left?$AA@ DB 'left', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PJFF@right?$AA@
CONST	SEGMENT
??_C@_05PJFF@right?$AA@ DB 'right', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLKH@moveleft?$AA@
CONST	SEGMENT
??_C@_08FLKH@moveleft?$AA@ DB 'moveleft', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CKGO@moveright?$AA@
CONST	SEGMENT
??_C@_09CKGO@moveright?$AA@ DB 'moveright', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDML@attack2?$AA@
CONST	SEGMENT
??_C@_07LDML@attack2?$AA@ DB 'attack2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03EHIM@run?$AA@
CONST	SEGMENT
??_C@_03EHIM@run?$AA@ DB 'run', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMJE@reload?$AA@
CONST	SEGMENT
??_C@_06BMJE@reload?$AA@ DB 'reload', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NKPG@alt1?$AA@
CONST	SEGMENT
??_C@_04NKPG@alt1?$AA@ DB 'alt1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FILO@score?$AA@
CONST	SEGMENT
??_C@_05FILO@score?$AA@ DB 'score', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GIDL@CPlayerKeyCatcher?$AA@
CONST	SEGMENT
??_C@_0BC@GIDL@CPlayerKeyCatcher?$AA@ DB 'CPlayerKeyCatcher', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HGJK@m_iszKeyPressed?$AA@
CONST	SEGMENT
??_C@_0BA@HGJK@m_iszKeyPressed?$AA@ DB 'm_iszKeyPressed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCPM@m_iszKeyReleased?$AA@
CONST	SEGMENT
??_C@_0BB@LCPM@m_iszKeyReleased?$AA@ DB 'm_iszKeyReleased', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MNCI@m_iszKeyHoldDown?$AA@
CONST	SEGMENT
??_C@_0BB@MNCI@m_iszKeyHoldDown?$AA@ DB 'm_iszKeyHoldDown', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PJHA@CRevertSaved?$AA@
CONST	SEGMENT
??_C@_0N@PJHA@CRevertSaved?$AA@ DB 'CRevertSaved', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAMF@m_messageTime?$AA@
CONST	SEGMENT
??_C@_0O@DAMF@m_messageTime?$AA@ DB 'm_messageTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KMKM@m_loadTime?$AA@
CONST	SEGMENT
??_C@_0L@KMKM@m_loadTime?$AA@ DB 'm_loadTime', 00H	; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ ; CBasePlayer::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBasePlayer::GetDataDescMap, COMDAT

; 75   : BEGIN_DATADESC( CBasePlayer )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayer@@2Udatamap_s@@A ; CBasePlayer::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ ENDP	; CBasePlayer::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CBasePlayer@@SAPAUdatamap_s@@XZ	; CBasePlayer::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CBasePlayer@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CBasePlayer@@SAPAUdatamap_s@@XZ PROC NEAR	; CBasePlayer::GetBaseMap, COMDAT

; 75   : BEGIN_DATADESC( CBasePlayer )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBasePlayer@@SAPAUdatamap_s@@XZ ENDP	; CBasePlayer::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT
_$E38	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E37
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E38	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z ; DataMapInit
;	COMDAT _$E37
_TEXT	SEGMENT
_$E37	PROC NEAR					; COMDAT

; 75   : BEGIN_DATADESC( CBasePlayer )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBasePlayer_DataDescInit@@3PAUdatamap_s@@A, eax ; CBasePlayer_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E37	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@GOGA@PlayerDeathThink?$AA@		; `string'
PUBLIC	??_C@_0P@KGLE@m_iSndRoomtype?$AA@		; `string'
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	?PlayerDeathThink@CBasePlayer@@QAEXXZ		; CBasePlayer::PlayerDeathThink
EXTRN	_atexit:NEAR
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S40@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@GOGA@PlayerDeathThink?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BB@GOGA@PlayerDeathThink?$AA@ DB 'PlayerDeathThink', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KGLE@m_iSndRoomtype?$AA@
CONST	SEGMENT
??_C@_0P@KGLE@m_iSndRoomtype?$AA@ DB 'm_iSndRoomtype', 00H ; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z PROC NEAR ; DataMapInit, COMDAT

; 75   : BEGIN_DATADESC( CBasePlayer )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S40@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39794
	mov	cl, BYTE PTR _?$S40@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S40@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0M@KECC@CBasePlayer?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E41
	call	_atexit
	add	esp, 4
$L39794:
	call	?GetBaseMap@CBasePlayer@@SAPAUdatamap_s@@XZ ; CBasePlayer::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBasePlayer@@2Udatamap_s@@A+12, eax

; 76   : 	DEFINE_FIELD( m_flFlashLightTime, FIELD_TIME ),
; 77   : 	DEFINE_FIELD( m_iFlashBattery, FIELD_INTEGER ),
; 78   : 
; 79   : 	DEFINE_FIELD( m_afButtonLast, FIELD_INTEGER ),
; 80   : 	DEFINE_FIELD( m_afButtonPressed, FIELD_INTEGER ),
; 81   : 	DEFINE_FIELD( m_afButtonReleased, FIELD_INTEGER ),
; 82   : 
; 83   : 	DEFINE_AUTO_ARRAY( m_rgItems, FIELD_INTEGER ),
; 84   : 	DEFINE_FIELD( m_afPhysicsFlags, FIELD_INTEGER ),
; 85   : 
; 86   : 	DEFINE_FIELD( m_flTimeStepSound, FIELD_TIME ),
; 87   : 	DEFINE_FIELD( m_flTimeWeaponIdle, FIELD_TIME ),
; 88   : 	DEFINE_FIELD( m_flSwimTime, FIELD_TIME ),
; 89   : 	DEFINE_FIELD( m_flDuckTime, FIELD_TIME ),
; 90   : 	DEFINE_FIELD( m_flWallJumpTime, FIELD_TIME ),
; 91   : 
; 92   : 	DEFINE_FIELD( m_flSuitUpdate, FIELD_TIME ),
; 93   : 	DEFINE_AUTO_ARRAY( m_rgSuitPlayList, FIELD_INTEGER ),
; 94   : 	DEFINE_FIELD( m_iSuitPlayNext, FIELD_INTEGER ),
; 95   : 	DEFINE_AUTO_ARRAY( m_rgiSuitNoRepeat, FIELD_INTEGER ),
; 96   : 	DEFINE_AUTO_ARRAY( m_rgflSuitNoRepeatTime, FIELD_TIME ),
; 97   : 	DEFINE_FIELD( m_lastDamageAmount, FIELD_INTEGER ),
; 98   : 
; 99   : 	DEFINE_AUTO_ARRAY( m_rgpPlayerItems, FIELD_CLASSPTR ),
; 100  : 	DEFINE_FIELD( m_pActiveItem, FIELD_CLASSPTR ),
; 101  : 	DEFINE_FIELD( m_pLastItem, FIELD_CLASSPTR ),
; 102  : 
; 103  : 	DEFINE_AUTO_ARRAY( m_rgAmmo, FIELD_INTEGER ),
; 104  : 	DEFINE_FIELD( m_idrowndmg, FIELD_INTEGER ),
; 105  : 	DEFINE_FIELD( m_idrownrestored, FIELD_INTEGER ),
; 106  : 	DEFINE_FIELD( m_tSneaking, FIELD_TIME ),
; 107  : 
; 108  : 	DEFINE_FIELD( m_iTrain, FIELD_INTEGER ),
; 109  : 	DEFINE_FIELD( m_bitsHUDDamage, FIELD_INTEGER ),
; 110  : 	DEFINE_FIELD( m_flFallVelocity, FIELD_FLOAT ),
; 111  : 	DEFINE_FIELD( m_iTargetVolume, FIELD_INTEGER ),
; 112  : 	DEFINE_FIELD( m_iWeaponVolume, FIELD_INTEGER ),
; 113  : 	DEFINE_FIELD( m_iExtraSoundTypes, FIELD_INTEGER ),
; 114  : 	DEFINE_FIELD( m_iWeaponFlash, FIELD_INTEGER ),
; 115  : 	DEFINE_FIELD( m_fLongJump, FIELD_BOOLEAN ),
; 116  : 	DEFINE_FIELD( m_iInCarState, FIELD_INTEGER ),
; 117  : 	DEFINE_FIELD( m_fInitHUD, FIELD_BOOLEAN ),
; 118  : 	DEFINE_FIELD( m_tbdPrev, FIELD_TIME ),
; 119  : 
; 120  : 	DEFINE_FIELD( m_pTank, FIELD_EHANDLE ),
; 121  : 	DEFINE_FIELD( m_pMonitor, FIELD_EHANDLE ),
; 122  : 	DEFINE_FIELD( m_pHoldableItem, FIELD_EHANDLE ),
; 123  : 	DEFINE_FIELD( m_pVehicle, FIELD_EHANDLE ),
; 124  : 	DEFINE_FIELD( m_iHideHUD, FIELD_INTEGER ),
; 125  : 	DEFINE_FIELD( m_iFOV, FIELD_INTEGER ),
; 126  : 
; 127  : 	DEFINE_FIELD( m_iRainDripsPerSecond, FIELD_INTEGER ),
; 128  : 	DEFINE_FIELD( m_flRainWindX, FIELD_FLOAT ),
; 129  : 	DEFINE_FIELD( m_flRainWindY, FIELD_FLOAT ),
; 130  : 	DEFINE_FIELD( m_flRainRandX, FIELD_FLOAT ),
; 131  : 	DEFINE_FIELD( m_flRainRandY, FIELD_FLOAT ),
; 132  : 
; 133  : 	DEFINE_FIELD( m_iRainIdealDripsPerSecond, FIELD_INTEGER ),
; 134  : 	DEFINE_FIELD( m_flRainIdealWindX, FIELD_FLOAT ),
; 135  : 	DEFINE_FIELD( m_flRainIdealWindY, FIELD_FLOAT ),
; 136  : 	DEFINE_FIELD( m_flRainIdealRandX, FIELD_FLOAT ),
; 137  : 	DEFINE_FIELD( m_flRainIdealRandY, FIELD_FLOAT ),
; 138  : 
; 139  : 	DEFINE_FIELD( m_flRainEndFade, FIELD_TIME ),
; 140  : 	DEFINE_FIELD( m_flRainNextFadeUpdate, FIELD_TIME ),
; 141  : 
; 142  : 	DEFINE_AUTO_ARRAY( m_hKeyCatchers, FIELD_EHANDLE ),
; 143  : 	DEFINE_FIELD( m_iNumKeyCatchers, FIELD_INTEGER ),
; 144  : 
; 145  : 	// holdable item stuff
; 146  : 	DEFINE_FIELD( m_vecHoldableItemPosition, FIELD_VECTOR ),
; 147  : 	DEFINE_FIELD( m_flHoldableItemDistance, FIELD_FLOAT ),
; 148  : 
; 149  : 	DEFINE_FIELD( m_nCustomSprayFrames, FIELD_INTEGER ),
; 150  : 	DEFINE_AUTO_ARRAY( m_szAnimExtention, FIELD_CHARACTER ),
; 151  : 	DEFINE_FUNCTION( PlayerDeathThink ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S40@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L39994
	mov	al, BYTE PTR _?$S40@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S40@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0BB@GOGA@PlayerDeathThink?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1468, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1472, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1476, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1478, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1480, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1484, OFFSET FLAT:?PlayerDeathThink@CBasePlayer@@QAEXXZ ; CBasePlayer::PlayerDeathThink

; 152  : 	DEFINE_FIELD( m_iSndRoomtype, FIELD_INTEGER ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1488, 10 ; 0000000aH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1492, OFFSET FLAT:??_C@_0P@KGLE@m_iSndRoomtype?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1496, 4140 ; 0000102cH
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1500, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1502, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1504, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+1508, 0
$L39994:

; 153  : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L40001
	mov	DWORD PTR ?m_DataMap@CBasePlayer@@2Udatamap_s@@A+4, 62 ; 0000003eH
	mov	DWORD PTR ?m_DataMap@CBasePlayer@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L40002
$L40001:
	mov	DWORD PTR ?m_DataMap@CBasePlayer@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBasePlayer@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4PAUtypedescription_s@@A
$L40002:
	mov	eax, OFFSET FLAT:?m_DataMap@CBasePlayer@@2Udatamap_s@@A ; CBasePlayer::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
$T43694 = -12
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T43694[ebp], eax
	mov	ecx, DWORD PTR $T43694[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E41
_TEXT	SEGMENT
_$E41	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBasePlayer@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E41	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
_i$ = -20
$T43699 = -24
__$EHRec$ = -12
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T43699[ebp], edx
	mov	eax, DWORD PTR $T43699[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?LinkUserMessages@@YAXXZ			; LinkUserMessages
PUBLIC	??_C@_07OAGP@SelAmmo?$AA@			; `string'
PUBLIC	??_C@_09MOMN@CurWeapon?$AA@			; `string'
PUBLIC	??_C@_07GJNE@Weapons?$AA@			; `string'
PUBLIC	??_C@_06BNLF@Geiger?$AA@			; `string'
PUBLIC	??_C@_0L@PAOI@Flashlight?$AA@			; `string'
PUBLIC	??_C@_08MMIN@FlashBat?$AA@			; `string'
PUBLIC	??_C@_06MACP@Health?$AA@			; `string'
PUBLIC	??_C@_06ILDP@Damage?$AA@			; `string'
PUBLIC	??_C@_07EFDJ@Battery?$AA@			; `string'
PUBLIC	??_C@_05HPFM@Train?$AA@				; `string'
PUBLIC	??_C@_07EFI@HudText?$AA@			; `string'
PUBLIC	??_C@_07MFFM@SayText?$AA@			; `string'
PUBLIC	??_C@_07FKFB@TextMsg?$AA@			; `string'
PUBLIC	??_C@_0L@KAL@WeaponList?$AA@			; `string'
PUBLIC	??_C@_08EHIO@ResetHUD?$AA@			; `string'
PUBLIC	??_C@_07PHEM@InitHUD?$AA@			; `string'
PUBLIC	??_C@_09KAAJ@GameTitle?$AA@			; `string'
PUBLIC	??_C@_08FJPD@DeathMsg?$AA@			; `string'
PUBLIC	??_C@_09HCEC@ScoreInfo?$AA@			; `string'
PUBLIC	??_C@_08DBKP@TeamInfo?$AA@			; `string'
PUBLIC	??_C@_09GODL@TeamScore?$AA@			; `string'
PUBLIC	??_C@_08MAFF@GameMode?$AA@			; `string'
PUBLIC	??_C@_04PAEL@MOTD?$AA@				; `string'
PUBLIC	??_C@_0L@PMLK@ServerName?$AA@			; `string'
PUBLIC	??_C@_0L@DJEN@AmmoPickup?$AA@			; `string'
PUBLIC	??_C@_0L@MCHE@WeapPickup?$AA@			; `string'
PUBLIC	??_C@_0L@KPIL@ItemPickup?$AA@			; `string'
PUBLIC	??_C@_0L@HFOM@HideWeapon?$AA@			; `string'
PUBLIC	??_C@_06HLLA@SetFOV?$AA@			; `string'
PUBLIC	??_C@_08FEII@ShowMenu?$AA@			; `string'
PUBLIC	??_C@_0M@PCMK@ScreenShake?$AA@			; `string'
PUBLIC	??_C@_0L@OBGK@ScreenFade?$AA@			; `string'
PUBLIC	??_C@_05HDEE@AmmoX?$AA@				; `string'
PUBLIC	??_C@_09POID@TeamNames?$AA@			; `string'
PUBLIC	??_C@_0L@LPOH@StatusText?$AA@			; `string'
PUBLIC	??_C@_0M@NJMM@StatusValue?$AA@			; `string'
PUBLIC	??_C@_08FFNH@Particle?$AA@			; `string'
PUBLIC	??_C@_08EMEB@KillPart?$AA@			; `string'
PUBLIC	??_C@_0L@OFCA@KillDecals?$AA@			; `string'
PUBLIC	??_C@_0M@MHAK@StudioDecal?$AA@			; `string'
PUBLIC	??_C@_08COBI@RainData?$AA@			; `string'
PUBLIC	??_C@_09IHJL@MusicFade?$AA@			; `string'
PUBLIC	??_C@_0L@DPCB@StatusIcon?$AA@			; `string'
PUBLIC	??_C@_0L@OCKM@SetupBones?$AA@			; `string'
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
;	COMDAT ??_C@_07OAGP@SelAmmo?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_07OAGP@SelAmmo?$AA@ DB 'SelAmmo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOMN@CurWeapon?$AA@
CONST	SEGMENT
??_C@_09MOMN@CurWeapon?$AA@ DB 'CurWeapon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GJNE@Weapons?$AA@
CONST	SEGMENT
??_C@_07GJNE@Weapons?$AA@ DB 'Weapons', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNLF@Geiger?$AA@
CONST	SEGMENT
??_C@_06BNLF@Geiger?$AA@ DB 'Geiger', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PAOI@Flashlight?$AA@
CONST	SEGMENT
??_C@_0L@PAOI@Flashlight?$AA@ DB 'Flashlight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MMIN@FlashBat?$AA@
CONST	SEGMENT
??_C@_08MMIN@FlashBat?$AA@ DB 'FlashBat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MACP@Health?$AA@
CONST	SEGMENT
??_C@_06MACP@Health?$AA@ DB 'Health', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ILDP@Damage?$AA@
CONST	SEGMENT
??_C@_06ILDP@Damage?$AA@ DB 'Damage', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFDJ@Battery?$AA@
CONST	SEGMENT
??_C@_07EFDJ@Battery?$AA@ DB 'Battery', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HPFM@Train?$AA@
CONST	SEGMENT
??_C@_05HPFM@Train?$AA@ DB 'Train', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFI@HudText?$AA@
CONST	SEGMENT
??_C@_07EFI@HudText?$AA@ DB 'HudText', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFFM@SayText?$AA@
CONST	SEGMENT
??_C@_07MFFM@SayText?$AA@ DB 'SayText', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKFB@TextMsg?$AA@
CONST	SEGMENT
??_C@_07FKFB@TextMsg?$AA@ DB 'TextMsg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KAL@WeaponList?$AA@
CONST	SEGMENT
??_C@_0L@KAL@WeaponList?$AA@ DB 'WeaponList', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08EHIO@ResetHUD?$AA@
CONST	SEGMENT
??_C@_08EHIO@ResetHUD?$AA@ DB 'ResetHUD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PHEM@InitHUD?$AA@
CONST	SEGMENT
??_C@_07PHEM@InitHUD?$AA@ DB 'InitHUD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KAAJ@GameTitle?$AA@
CONST	SEGMENT
??_C@_09KAAJ@GameTitle?$AA@ DB 'GameTitle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJPD@DeathMsg?$AA@
CONST	SEGMENT
??_C@_08FJPD@DeathMsg?$AA@ DB 'DeathMsg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HCEC@ScoreInfo?$AA@
CONST	SEGMENT
??_C@_09HCEC@ScoreInfo?$AA@ DB 'ScoreInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DBKP@TeamInfo?$AA@
CONST	SEGMENT
??_C@_08DBKP@TeamInfo?$AA@ DB 'TeamInfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GODL@TeamScore?$AA@
CONST	SEGMENT
??_C@_09GODL@TeamScore?$AA@ DB 'TeamScore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MAFF@GameMode?$AA@
CONST	SEGMENT
??_C@_08MAFF@GameMode?$AA@ DB 'GameMode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PAEL@MOTD?$AA@
CONST	SEGMENT
??_C@_04PAEL@MOTD?$AA@ DB 'MOTD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PMLK@ServerName?$AA@
CONST	SEGMENT
??_C@_0L@PMLK@ServerName?$AA@ DB 'ServerName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DJEN@AmmoPickup?$AA@
CONST	SEGMENT
??_C@_0L@DJEN@AmmoPickup?$AA@ DB 'AmmoPickup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHE@WeapPickup?$AA@
CONST	SEGMENT
??_C@_0L@MCHE@WeapPickup?$AA@ DB 'WeapPickup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KPIL@ItemPickup?$AA@
CONST	SEGMENT
??_C@_0L@KPIL@ItemPickup?$AA@ DB 'ItemPickup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HFOM@HideWeapon?$AA@
CONST	SEGMENT
??_C@_0L@HFOM@HideWeapon?$AA@ DB 'HideWeapon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HLLA@SetFOV?$AA@
CONST	SEGMENT
??_C@_06HLLA@SetFOV?$AA@ DB 'SetFOV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FEII@ShowMenu?$AA@
CONST	SEGMENT
??_C@_08FEII@ShowMenu?$AA@ DB 'ShowMenu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCMK@ScreenShake?$AA@
CONST	SEGMENT
??_C@_0M@PCMK@ScreenShake?$AA@ DB 'ScreenShake', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OBGK@ScreenFade?$AA@
CONST	SEGMENT
??_C@_0L@OBGK@ScreenFade?$AA@ DB 'ScreenFade', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDEE@AmmoX?$AA@
CONST	SEGMENT
??_C@_05HDEE@AmmoX?$AA@ DB 'AmmoX', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09POID@TeamNames?$AA@
CONST	SEGMENT
??_C@_09POID@TeamNames?$AA@ DB 'TeamNames', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPOH@StatusText?$AA@
CONST	SEGMENT
??_C@_0L@LPOH@StatusText?$AA@ DB 'StatusText', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJMM@StatusValue?$AA@
CONST	SEGMENT
??_C@_0M@NJMM@StatusValue?$AA@ DB 'StatusValue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FFNH@Particle?$AA@
CONST	SEGMENT
??_C@_08FFNH@Particle?$AA@ DB 'Particle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EMEB@KillPart?$AA@
CONST	SEGMENT
??_C@_08EMEB@KillPart?$AA@ DB 'KillPart', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OFCA@KillDecals?$AA@
CONST	SEGMENT
??_C@_0L@OFCA@KillDecals?$AA@ DB 'KillDecals', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MHAK@StudioDecal?$AA@
CONST	SEGMENT
??_C@_0M@MHAK@StudioDecal?$AA@ DB 'StudioDecal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08COBI@RainData?$AA@
CONST	SEGMENT
??_C@_08COBI@RainData?$AA@ DB 'RainData', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IHJL@MusicFade?$AA@
CONST	SEGMENT
??_C@_09IHJL@MusicFade?$AA@ DB 'MusicFade', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPCB@StatusIcon?$AA@
CONST	SEGMENT
??_C@_0L@DPCB@StatusIcon?$AA@ DB 'StatusIcon', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCKM@SetupBones?$AA@
CONST	SEGMENT
??_C@_0L@OCKM@SetupBones?$AA@ DB 'SetupBones', 00H	; `string'
CONST	ENDS
;	COMDAT ?LinkUserMessages@@YAXXZ
_TEXT	SEGMENT
?LinkUserMessages@@YAXXZ PROC NEAR			; LinkUserMessages, COMDAT

; 207  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 208  : 	// Already taken care of?
; 209  : 	if ( gmsgSelAmmo )

	cmp	DWORD PTR ?gmsgSelAmmo@@3HA, 0		; gmsgSelAmmo
	je	SHORT $L40046

; 211  : 		return;

	jmp	$L40045
$L40046:

; 213  : 
; 214  : 	gmsgSelAmmo = REG_USER_MSG("SelAmmo", sizeof(SelAmmo));

	push	4
	push	OFFSET FLAT:??_C@_07OAGP@SelAmmo?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgSelAmmo@@3HA, eax	; gmsgSelAmmo

; 215  : 	gmsgCurWeapon = REG_USER_MSG("CurWeapon", 3);

	push	3
	push	OFFSET FLAT:??_C@_09MOMN@CurWeapon?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgCurWeapon@@3HA, eax	; gmsgCurWeapon

; 216  : 	gmsgWeapons = REG_USER_MSG("Weapons", MAX_WEAPON_BYTES );

	push	8
	push	OFFSET FLAT:??_C@_07GJNE@Weapons?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgWeapons@@3HA, eax	; gmsgWeapons

; 217  : 	gmsgGeigerRange = REG_USER_MSG("Geiger", 1);

	push	1
	push	OFFSET FLAT:??_C@_06BNLF@Geiger?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgGeigerRange@@3HA, eax	; gmsgGeigerRange

; 218  : 	gmsgFlashlight = REG_USER_MSG("Flashlight", 2);

	push	2
	push	OFFSET FLAT:??_C@_0L@PAOI@Flashlight?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgFlashlight@@3HA, eax	; gmsgFlashlight

; 219  : 	gmsgFlashBattery = REG_USER_MSG("FlashBat", 1);

	push	1
	push	OFFSET FLAT:??_C@_08MMIN@FlashBat?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgFlashBattery@@3HA, eax	; gmsgFlashBattery

; 220  : 	gmsgHealth = REG_USER_MSG( "Health", 1 );

	push	1
	push	OFFSET FLAT:??_C@_06MACP@Health?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgHealth@@3HA, eax		; gmsgHealth

; 221  : 	gmsgDamage = REG_USER_MSG( "Damage", 12 );

	push	12					; 0000000cH
	push	OFFSET FLAT:??_C@_06ILDP@Damage?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgDamage@@3HA, eax		; gmsgDamage

; 222  : 	gmsgBattery = REG_USER_MSG( "Battery", 2);

	push	2
	push	OFFSET FLAT:??_C@_07EFDJ@Battery?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgBattery@@3HA, eax	; gmsgBattery

; 223  : 	gmsgTrain = REG_USER_MSG( "Train", 1);

	push	1
	push	OFFSET FLAT:??_C@_05HPFM@Train?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgTrain@@3HA, eax		; gmsgTrain

; 224  : 	gmsgHudText = REG_USER_MSG( "HudText", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_07EFI@HudText?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgHudText@@3HA, eax	; gmsgHudText

; 225  : 	gmsgSayText = REG_USER_MSG( "SayText", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_07MFFM@SayText?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgSayText@@3HA, eax	; gmsgSayText

; 226  : 	gmsgTextMsg = REG_USER_MSG( "TextMsg", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_07FKFB@TextMsg?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgTextMsg@@3HA, eax	; gmsgTextMsg

; 227  : 	gmsgWeaponList = REG_USER_MSG("WeaponList", -1);

	push	-1
	push	OFFSET FLAT:??_C@_0L@KAL@WeaponList?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgWeaponList@@3HA, eax	; gmsgWeaponList

; 228  : 	gmsgResetHUD = REG_USER_MSG("ResetHUD", 1);		// called every respawn

	push	1
	push	OFFSET FLAT:??_C@_08EHIO@ResetHUD?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgResetHUD@@3HA, eax	; gmsgResetHUD

; 229  : 	gmsgInitHUD = REG_USER_MSG("InitHUD", 0 );		// called every time a new player joins the server

	push	0
	push	OFFSET FLAT:??_C@_07PHEM@InitHUD?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgInitHUD@@3HA, eax	; gmsgInitHUD

; 230  : 	gmsgShowGameTitle = REG_USER_MSG("GameTitle", 1);

	push	1
	push	OFFSET FLAT:??_C@_09KAAJ@GameTitle?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgShowGameTitle@@3HA, eax	; gmsgShowGameTitle

; 231  : 	gmsgDeathMsg = REG_USER_MSG( "DeathMsg", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_08FJPD@DeathMsg?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgDeathMsg@@3HA, eax	; gmsgDeathMsg

; 232  : 	gmsgScoreInfo = REG_USER_MSG( "ScoreInfo", 9 );

	push	9
	push	OFFSET FLAT:??_C@_09HCEC@ScoreInfo?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgScoreInfo@@3HA, eax	; gmsgScoreInfo

; 233  : 	gmsgTeamInfo = REG_USER_MSG( "TeamInfo", -1 );  // sets the name of a player's team

	push	-1
	push	OFFSET FLAT:??_C@_08DBKP@TeamInfo?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgTeamInfo@@3HA, eax	; gmsgTeamInfo

; 234  : 	gmsgTeamScore = REG_USER_MSG( "TeamScore", -1 );  // sets the score of a team on the scoreboard

	push	-1
	push	OFFSET FLAT:??_C@_09GODL@TeamScore?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgTeamScore@@3HA, eax	; gmsgTeamScore

; 235  : 	gmsgGameMode = REG_USER_MSG( "GameMode", 1 );

	push	1
	push	OFFSET FLAT:??_C@_08MAFF@GameMode?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgGameMode@@3HA, eax	; gmsgGameMode

; 236  : 	gmsgMOTD = REG_USER_MSG( "MOTD", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_04PAEL@MOTD?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgMOTD@@3HA, eax		; gmsgMOTD

; 237  : 	gmsgServerName = REG_USER_MSG( "ServerName", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0L@PMLK@ServerName?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgServerName@@3HA, eax	; gmsgServerName

; 238  : 	gmsgAmmoPickup = REG_USER_MSG( "AmmoPickup", 2 );

	push	2
	push	OFFSET FLAT:??_C@_0L@DJEN@AmmoPickup?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgAmmoPickup@@3HA, eax	; gmsgAmmoPickup

; 239  : 	gmsgWeapPickup = REG_USER_MSG( "WeapPickup", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0L@MCHE@WeapPickup?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgWeapPickup@@3HA, eax	; gmsgWeapPickup

; 240  : 	gmsgItemPickup = REG_USER_MSG( "ItemPickup", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0L@KPIL@ItemPickup?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgItemPickup@@3HA, eax	; gmsgItemPickup

; 241  : 	gmsgHideWeapon = REG_USER_MSG( "HideWeapon", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0L@HFOM@HideWeapon?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgHideWeapon@@3HA, eax	; gmsgHideWeapon

; 242  : 	gmsgSetFOV = REG_USER_MSG( "SetFOV", 1 );

	push	1
	push	OFFSET FLAT:??_C@_06HLLA@SetFOV?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgSetFOV@@3HA, eax		; gmsgSetFOV

; 243  : 	gmsgShowMenu = REG_USER_MSG( "ShowMenu", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_08FEII@ShowMenu?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgShowMenu@@3HA, eax	; gmsgShowMenu

; 244  : 	gmsgShake = REG_USER_MSG("ScreenShake", sizeof(ScreenShake));

	push	6
	push	OFFSET FLAT:??_C@_0M@PCMK@ScreenShake?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgShake@@3HA, eax		; gmsgShake

; 245  : 	gmsgFade = REG_USER_MSG("ScreenFade", sizeof(ScreenFade));

	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0L@OBGK@ScreenFade?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgFade@@3HA, eax		; gmsgFade

; 246  : 	//gmsgAmmoX = REG_USER_MSG("AmmoX", 2);
; 247  : 	gmsgAmmoX = REG_USER_MSG("AmmoX", 4);

	push	4
	push	OFFSET FLAT:??_C@_05HDEE@AmmoX?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgAmmoX@@3HA, eax		; gmsgAmmoX

; 248  : 	gmsgTeamNames = REG_USER_MSG( "TeamNames", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_09POID@TeamNames?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgTeamNames@@3HA, eax	; gmsgTeamNames

; 249  : 	gmsgStatusText = REG_USER_MSG("StatusText", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0L@LPOH@StatusText?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgStatusText@@3HA, eax	; gmsgStatusText

; 250  : 	gmsgStatusValue = REG_USER_MSG("StatusValue", 3 );

	push	3
	push	OFFSET FLAT:??_C@_0M@NJMM@StatusValue?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgStatusValue@@3HA, eax	; gmsgStatusValue

; 251  : 
; 252  : 	gmsgParticle = REG_USER_MSG( "Particle", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_08FFNH@Particle?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgParticle@@3HA, eax	; gmsgParticle

; 253  : 	gmsgKillPart = REG_USER_MSG( "KillPart", 2 );

	push	2
	push	OFFSET FLAT:??_C@_08EMEB@KillPart?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgKillPart@@3HA, eax	; gmsgKillPart

; 254  : 	gmsgKillDecals = REG_USER_MSG( "KillDecals", 2 );

	push	2
	push	OFFSET FLAT:??_C@_0L@OFCA@KillDecals?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgKillDecals@@3HA, eax	; gmsgKillDecals

; 255  : 	gmsgStudioDecal = REG_USER_MSG("StudioDecal", 33);

	push	33					; 00000021H
	push	OFFSET FLAT:??_C@_0M@MHAK@StudioDecal?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgStudioDecal@@3HA, eax	; gmsgStudioDecal

; 256  : 	gmsgRainData = REG_USER_MSG( "RainData", 16 );

	push	16					; 00000010H
	push	OFFSET FLAT:??_C@_08COBI@RainData?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgRainData@@3HA, eax	; gmsgRainData

; 257  : 	gmsgMusicFade = REG_USER_MSG( "MusicFade", 2 );

	push	2
	push	OFFSET FLAT:??_C@_09IHJL@MusicFade?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgMusicFade@@3HA, eax	; gmsgMusicFade

; 258  : 	gmsgStatusIcon = REG_USER_MSG( "StatusIcon", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0L@DPCB@StatusIcon?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgStatusIcon@@3HA, eax	; gmsgStatusIcon

; 259  : 	gmsgSetupBones = REG_USER_MSG( "SetupBones", -1 );

	push	-1
	push	OFFSET FLAT:??_C@_0L@OCKM@SetupBones?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgSetupBones@@3HA, eax	; gmsgSetupBones
$L40045:

; 260  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LinkUserMessages@@YAXXZ ENDP				; LinkUserMessages
_TEXT	ENDS
;	COMDAT _$E43
_TEXT	SEGMENT
_$E43	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E42
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E43	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCBasePlayer@@@@QAE@PBD@Z	; CEntityFactory<CBasePlayer>::CEntityFactory<CBasePlayer>
PUBLIC	??_C@_06MNOE@player?$AA@			; `string'
_BSS	SEGMENT
	ALIGN	4

_player	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_06MNOE@player?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_06MNOE@player?$AA@ DB 'player', 00H		; `string'
CONST	ENDS
;	COMDAT _$E42
_TEXT	SEGMENT
_$E42	PROC NEAR					; COMDAT

; 262  : LINK_ENTITY_TO_CLASS( player, CBasePlayer );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_06MNOE@player?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_player
	call	??0?$CEntityFactory@VCBasePlayer@@@@QAE@PBD@Z ; CEntityFactory<CBasePlayer>::CEntityFactory<CBasePlayer>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E42	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@FIFI@player?1pl_pain5?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@LIDH@player?1pl_pain6?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@BIBC@player?1pl_pain7?4wav?$AA@	; `string'
PUBLIC	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z		; EMIT_SOUND
PUBLIC	?Pain@CBasePlayer@@QAEXXZ			; CBasePlayer::Pain
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
PUBLIC	__real@8@3ffda8f5c28f5c28f800
PUBLIC	__real@8@3ffea8f5c28f5c28f800
EXTRN	__fltused:NEAR
;	COMDAT ??_C@_0BE@FIFI@player?1pl_pain5?4wav?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BE@FIFI@player?1pl_pain5?4wav?$AA@ DB 'player/pl_pain5.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LIDH@player?1pl_pain6?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@LIDH@player?1pl_pain6?4wav?$AA@ DB 'player/pl_pain6.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BIBC@player?1pl_pain7?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BIBC@player?1pl_pain7?4wav?$AA@ DB 'player/pl_pain7.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@8@3ffda8f5c28f5c28f800
CONST	SEGMENT
__real@8@3ffda8f5c28f5c28f800 DQ 03fd51eb851eb851fr ; 0.33
CONST	ENDS
;	COMDAT __real@8@3ffea8f5c28f5c28f800
CONST	SEGMENT
__real@8@3ffea8f5c28f5c28f800 DQ 03fe51eb851eb851fr ; 0.66
CONST	ENDS
;	COMDAT ?Pain@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_flRndSound$ = -8
?Pain@CBasePlayer@@QAEXXZ PROC NEAR			; CBasePlayer::Pain, COMDAT

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 268  : 	float	flRndSound;//sound randomizer
; 269  : 
; 270  : 	flRndSound = RANDOM_FLOAT ( 0 , 1 );

	push	1065353216				; 3f800000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 8
	fstp	DWORD PTR _flRndSound$[ebp]

; 271  : 
; 272  : 	if ( flRndSound <= 0.33 )

	fld	DWORD PTR _flRndSound$[ebp]
	fcomp	QWORD PTR __real@8@3ffda8f5c28f5c28f800
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40124

; 273  : 		EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_pain5.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@FIFI@player?1pl_pain5?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 274  : 	else if ( flRndSound <= 0.66 )

	jmp	SHORT $L40131
$L40124:
	fld	DWORD PTR _flRndSound$[ebp]
	fcomp	QWORD PTR __real@8@3ffea8f5c28f5c28f800
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40128

; 275  : 		EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_pain6.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@LIDH@player?1pl_pain6?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 276  : 	else

	jmp	SHORT $L40131
$L40128:

; 277  : 		EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_pain7.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@BIBC@player?1pl_pain7?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40131:

; 278  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Pain@CBasePlayer@@QAEXXZ ENDP				; CBasePlayer::Pain
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
EXTRN	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z:NEAR	; EMIT_SOUND_DYN
;	COMDAT ?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z
_TEXT	SEGMENT
_entity$ = 8
_channel$ = 12
_sample$ = 16
_volume$ = 20
_attenuation$ = 24
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z PROC NEAR		; EMIT_SOUND, COMDAT

; 609  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 610  : 	EMIT_SOUND_DYN( entity, channel, sample, volume, attenuation, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _attenuation$[ebp]
	push	eax
	mov	ecx, DWORD PTR _volume$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sample$[ebp]
	push	edx
	mov	eax, DWORD PTR _channel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entity$[ebp]
	push	ecx
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 611  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z ENDP		; EMIT_SOUND
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?VecVelocityForDamage@@YA?AVVector@@M@Z		; VecVelocityForDamage
PUBLIC	__real@4@c004c800000000000000
PUBLIC	__real@4@c006c800000000000000
;	COMDAT __real@4@c004c800000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@c004c800000000000000 DD 0c2480000r	; -50
CONST	ENDS
;	COMDAT __real@4@c006c800000000000000
CONST	SEGMENT
__real@4@c006c800000000000000 DD 0c3480000r	; -200
CONST	ENDS
;	COMDAT ?VecVelocityForDamage@@YA?AVVector@@M@Z
_TEXT	SEGMENT
_flDamage$ = 12
___$ReturnUdt$ = 8
_vec$ = -12
$T43730 = -24
$T43731 = -36
$T43732 = -48
?VecVelocityForDamage@@YA?AVVector@@M@Z PROC NEAR	; VecVelocityForDamage, COMDAT

; 284  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 285  : 	Vector vec(RANDOM_FLOAT(-100,100), RANDOM_FLOAT(-100,100), RANDOM_FLOAT(200,300));

	push	1133903872				; 43960000H
	push	1128792064				; 43480000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	1120403456				; 42c80000H
	push	-1027080192				; c2c80000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _vec$[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector

; 286  : 
; 287  : 	if (flDamage > -50)

	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@c004c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40139

; 288  : 		vec = vec * 0.7;

	push	1060320051				; 3f333333H
	lea	eax, DWORD PTR $T43730[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vec$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vec$[ebp+8], eax

; 289  : 	else if (flDamage > -200)

	jmp	SHORT $L40144
$L40139:
	fld	DWORD PTR _flDamage$[ebp]
	fcomp	DWORD PTR __real@4@c006c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40142

; 290  : 		vec = vec * 2;

	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR $T43731[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vec$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vec$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vec$[ebp+8], edx

; 291  : 	else

	jmp	SHORT $L40144
$L40142:

; 292  : 		vec = vec * 10;

	push	1092616192				; 41200000H
	lea	eax, DWORD PTR $T43732[ebp]
	push	eax
	lea	ecx, DWORD PTR _vec$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vec$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vec$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vec$[ebp+8], eax
$L40144:

; 293  : 
; 294  : 	return vec;

	lea	ecx, DWORD PTR _vec$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 295  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VecVelocityForDamage@@YA?AVVector@@M@Z ENDP		; VecVelocityForDamage
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T43743 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T43743[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
PUBLIC	?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z	; CBasePlayer::SnapEyeAngles
;	COMDAT ?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_viewAngles$ = 8
_this$ = -4
?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z PROC NEAR	; CBasePlayer::SnapEyeAngles, COMDAT

; 301  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 302  : 	pev->v_angle = viewAngles;

	mov	eax, DWORD PTR _viewAngles$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 303  : 	pev->fixangle = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+160], 1

; 304  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z ENDP	; CBasePlayer::SnapEyeAngles
_TEXT	ENDS
PUBLIC	?TrainSpeed@@YAHHH@Z				; TrainSpeed
PUBLIC	__real@4@00000000000000000000
EXTRN	_fabs:NEAR
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT ?TrainSpeed@@YAHHH@Z
_TEXT	SEGMENT
_iSpeed$ = 8
_iMax$ = 12
_fSpeed$ = -4
_fMax$ = -8
_iBack$ = -12
_iRet$ = -16
?TrainSpeed@@YAHHH@Z PROC NEAR				; TrainSpeed, COMDAT

; 307  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 308  : 	float fSpeed, fMax;
; 309  : 	int iBack, iRet = 0;

	mov	DWORD PTR _iRet$[ebp], 0

; 310  : 
; 311  : 	fMax = (float)iMax;

	fild	DWORD PTR _iMax$[ebp]
	fstp	DWORD PTR _fMax$[ebp]

; 312  : 	fSpeed = iSpeed;

	fild	DWORD PTR _iSpeed$[ebp]
	fst	DWORD PTR _fSpeed$[ebp]

; 313  : 
; 314  : 	fSpeed = fSpeed/fMax;

	fdiv	DWORD PTR _fMax$[ebp]
	fst	DWORD PTR _fSpeed$[ebp]

; 315  : 	iBack = (fSpeed < 0.0f) ? 1 : 0;

	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L43748
	mov	DWORD PTR -20+[ebp], 1
	jmp	SHORT $L43749
$L43748:
	mov	DWORD PTR -20+[ebp], 0
$L43749:
	mov	eax, DWORD PTR -20+[ebp]
	mov	DWORD PTR _iBack$[ebp], eax

; 316  : 	fSpeed = fabs( fSpeed );

	fld	DWORD PTR _fSpeed$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR _fSpeed$[ebp]

; 317  : 
; 318  : 	if (iSpeed == 0)

	cmp	DWORD PTR _iSpeed$[ebp], 0
	jne	SHORT $L40159

; 319  : 		iRet = TRAIN_NEUTRAL;

	mov	DWORD PTR _iRet$[ebp], 1

; 320  : 	else if (fSpeed < 0.33)

	jmp	SHORT $L40164
$L40159:
	fld	DWORD PTR _fSpeed$[ebp]
	fcomp	QWORD PTR __real@8@3ffda8f5c28f5c28f800
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40161

; 321  : 		iRet = (iBack) ? TRAIN_BACK_SLOW : TRAIN_SLOW;

	mov	ecx, DWORD PTR _iBack$[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, 3
	add	ecx, 2
	mov	DWORD PTR _iRet$[ebp], ecx

; 322  : 	else if (fSpeed < 0.66)

	jmp	SHORT $L40164
$L40161:
	fld	DWORD PTR _fSpeed$[ebp]
	fcomp	QWORD PTR __real@8@3ffea8f5c28f5c28f800
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40163

; 323  : 		iRet = (iBack) ? TRAIN_BACK_MEDIUM : TRAIN_MEDIUM;

	mov	edx, DWORD PTR _iBack$[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, 3
	add	edx, 3
	mov	DWORD PTR _iRet$[ebp], edx

; 324  : 	else

	jmp	SHORT $L40164
$L40163:

; 325  : 		iRet = (iBack) ? TRAIN_BACK_FAST : TRAIN_FAST;

	mov	eax, DWORD PTR _iBack$[ebp]
	neg	eax
	sbb	eax, eax
	and	eax, 3
	add	eax, 4
	mov	DWORD PTR _iRet$[ebp], eax
$L40164:

; 326  : 
; 327  : 	return iRet;

	mov	eax, DWORD PTR _iRet$[ebp]

; 328  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TrainSpeed@@YAHHH@Z ENDP				; TrainSpeed
_TEXT	ENDS
PUBLIC	?DeathSound@CBasePlayer@@UAEXXZ			; CBasePlayer::DeathSound
;	COMDAT ?DeathSound@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DeathSound@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::DeathSound, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 343  : 	{

	push	5
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L40173
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L40175
	cmp	DWORD PTR -8+[ebp], 3
	je	SHORT $L40177
	jmp	SHORT $L40170
$L40173:

; 344  : 	case 1:
; 345  : 		EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_pain5.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@FIFI@player?1pl_pain5?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 346  : 		break;

	jmp	SHORT $L40170
$L40175:

; 347  : 	case 2:
; 348  : 		EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_pain6.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@LIDH@player?1pl_pain6?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 349  : 		break;

	jmp	SHORT $L40170
$L40177:

; 350  : 	case 3:
; 351  : 		EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_pain7.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@BIBC@player?1pl_pain7?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40170:

; 354  : 
; 355  : 	// play one of the suit death alarms
; 356  : 	//LRC- if no suit, then no flatline sound. (unless it's a deathmatch.)
; 357  : 	/*if ( !HasWeapon( WEAPON_SUIT ) && !g_pGameRules->IsDeathmatch() )
; 358  : 		return;
; 359  : 
; 360  : 	// play one of the suit death alarms
; 361  : 	EMIT_GROUPNAME_SUIT(ENT(pev), "HEV_DEAD");*/
; 362  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeathSound@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::DeathSound
_TEXT	ENDS
PUBLIC	?TakeHealth@CBasePlayer@@UAEHMH@Z		; CBasePlayer::TakeHealth
EXTRN	?TakeHealth@CBaseMonster@@UAEHMH@Z:NEAR		; CBaseMonster::TakeHealth
;	COMDAT ?TakeHealth@CBasePlayer@@UAEHMH@Z
_TEXT	SEGMENT
_flHealth$ = 8
_bitsDamageType$ = 12
_this$ = -4
?TakeHealth@CBasePlayer@@UAEHMH@Z PROC NEAR		; CBasePlayer::TakeHealth, COMDAT

; 368  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 	return CBaseMonster :: TakeHealth (flHealth, bitsDamageType);

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flHealth$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TakeHealth@CBaseMonster@@UAEHMH@Z	; CBaseMonster::TakeHealth

; 370  : 
; 371  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TakeHealth@CBasePlayer@@UAEHMH@Z ENDP			; CBasePlayer::TakeHealth
_TEXT	ENDS
PUBLIC	?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ	; CBasePlayer::GetGunPosition
;	COMDAT ?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T43758 = -16
?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ PROC NEAR	; CBasePlayer::GetGunPosition, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	return EyePosition();

	lea	eax, DWORD PTR $T43758[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 376  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ ENDP	; CBasePlayer::GetGunPosition
_TEXT	ENDS
PUBLIC	?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ; CBasePlayer::TraceAttack
EXTRN	?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z:NEAR ; AddMultiDamage
EXTRN	?SpawnBlood@@YAXVVector@@HM@Z:NEAR		; SpawnBlood
EXTRN	?gSkillData@@3Uskilldata_t@@A:BYTE		; gSkillData
;	COMDAT ?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
_TEXT	SEGMENT
_pevAttacker$ = 8
_flDamage$ = 12
_vecDir$ = 16
_ptr$ = 28
_bitsDamageType$ = 32
_this$ = -4
?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z PROC NEAR ; CBasePlayer::TraceAttack, COMDAT

; 382  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 383  : 	if ( pev->takedamage )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L40197

; 385  : 		m_LastHitGroup = ptr->iHitgroup;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+2076], ecx

; 388  : 		{

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR -16+[ebp], eax
	mov	ecx, DWORD PTR -16+[ebp]
	sub	ecx, 1
	mov	DWORD PTR -16+[ebp], ecx
	cmp	DWORD PTR -16+[ebp], 6
	ja	SHORT $L40208
	mov	edx, DWORD PTR -16+[ebp]
	jmp	DWORD PTR $L43763[edx*4]
$L40203:

; 389  : 		case HITGROUP_GENERIC:
; 390  : 			break;
; 391  : 		case HITGROUP_HEAD:
; 392  : 			flDamage *= gSkillData.plrHead;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+340
	fstp	DWORD PTR _flDamage$[ebp]

; 393  : 			break;

	jmp	SHORT $L40199
$L40204:

; 394  : 		case HITGROUP_CHEST:
; 395  : 			flDamage *= gSkillData.plrChest;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+344
	fstp	DWORD PTR _flDamage$[ebp]

; 396  : 			break;

	jmp	SHORT $L40199
$L40205:

; 397  : 		case HITGROUP_STOMACH:
; 398  : 			flDamage *= gSkillData.plrStomach;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+348
	fstp	DWORD PTR _flDamage$[ebp]

; 399  : 			break;

	jmp	SHORT $L40199
$L40206:

; 400  : 		case HITGROUP_LEFTARM:
; 401  : 		case HITGROUP_RIGHTARM:
; 402  : 			flDamage *= gSkillData.plrArm;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+356
	fstp	DWORD PTR _flDamage$[ebp]

; 403  : 			break;

	jmp	SHORT $L40199
$L40207:

; 404  : 		case HITGROUP_LEFTLEG:
; 405  : 		case HITGROUP_RIGHTLEG:
; 406  : 			flDamage *= gSkillData.plrLeg;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR ?gSkillData@@3Uskilldata_t@@A+352
	fstp	DWORD PTR _flDamage$[ebp]
$L40208:
$L40199:

; 411  : 
; 412  : 		SpawnBlood(ptr->vecEndPos, BloodColor(), flDamage);// a little surface blood.

	mov	eax, DWORD PTR _flDamage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+112]
	push	eax
	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, 20					; 00000014H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	call	?SpawnBlood@@YAXVVector@@HM@Z		; SpawnBlood
	add	esp, 20					; 00000014H

; 413  : 		TraceBleed( flDamage, vecDir, ptr, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	eax, DWORD PTR _vecDir$[ebp]
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _flDamage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+116]

; 414  : 		AddMultiDamage( pevAttacker, this, flDamage, bitsDamageType );

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flDamage$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	call	?AddMultiDamage@@YAXPAUentvars_s@@PAVCBaseEntity@@MH@Z ; AddMultiDamage
	add	esp, 16					; 00000010H
$L40197:

; 416  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L43763:
	DD	$L40203
	DD	$L40204
	DD	$L40205
	DD	$L40206
	DD	$L40206
	DD	$L40207
	DD	$L40207
?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z ENDP ; CBasePlayer::TraceAttack
_TEXT	ENDS
PUBLIC	?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z ; CBasePlayer::TakeDamage
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
PUBLIC	__real@4@3fff8000000000000000
PUBLIC	__real@4@40059600000000000000
PUBLIC	__real@4@4003f000000000000000
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z	; CBaseEntity::Instance
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
EXTRN	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseMonster::TakeDamage
EXTRN	?g_pGameRules@@3PAVCGameRules@@A:DWORD		; g_pGameRules
EXTRN	__ftol:NEAR
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT __real@4@40059600000000000000
CONST	SEGMENT
__real@4@40059600000000000000 DD 042960000r	; 75
CONST	ENDS
;	COMDAT __real@4@4003f000000000000000
CONST	SEGMENT
__real@4@4003f000000000000000 DD 041f00000r	; 30
CONST	ENDS
;	COMDAT ?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
_pevInflictor$ = 8
_pevAttacker$ = 12
_flDamage$ = 16
_bitsDamageType$ = 20
_this$ = -4
_bitsDamage$ = -8
_ffound$ = -12
_fmajor$ = -16
_fcritical$ = -20
_fTookDamage$ = -24
_ftrivial$ = -28
_flRatio$ = -32
_flBonus$ = -36
_flHealthPrev$ = -40
_pAttacker$ = -44
_flNew$40234 = -48
_flArmor$40235 = -52
_i$40239 = -56
?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z PROC NEAR ; CBasePlayer::TakeDamage, COMDAT

; 429  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 430  : 	// have suit diagnose the problem - ie: report damage type
; 431  : 	int bitsDamage = bitsDamageType;

	mov	eax, DWORD PTR _bitsDamageType$[ebp]
	mov	DWORD PTR _bitsDamage$[ebp], eax

; 432  : 	int ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1

; 433  : 	int fmajor;
; 434  : 	int fcritical;
; 435  : 	int fTookDamage;
; 436  : 	int ftrivial;
; 437  : 	float flRatio;
; 438  : 	float flBonus;
; 439  : 	float flHealthPrev = pev->health;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+352]
	mov	DWORD PTR _flHealthPrev$[ebp], eax

; 440  : 
; 441  : 	flBonus = ARMOR_BONUS;

	mov	DWORD PTR _flBonus$[ebp], 1056964608	; 3f000000H

; 442  : 	flRatio = ARMOR_RATIO;

	mov	DWORD PTR _flRatio$[ebp], 1045220557	; 3e4ccccdH

; 443  : 
; 444  : 	if ( ( bitsDamageType & DMG_BLAST ) && g_pGameRules->IsMultiplayer() )

	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	and	ecx, 64					; 00000040H
	test	ecx, ecx
	je	SHORT $L40229
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $L40229

; 446  : 		// blasts damage armor more.
; 447  : 		flBonus *= 2;

	fld	DWORD PTR _flBonus$[ebp]
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _flBonus$[ebp]
$L40229:

; 449  : 
; 450  : 	// Already dead
; 451  : 	if ( !IsAlive() )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L40230

; 452  : 		return 0;

	xor	eax, eax
	jmp	$L40219
$L40230:

; 453  : 	// go take the damage first
; 454  : 
; 455  : 
; 456  : 	CBaseEntity *pAttacker = CBaseEntity::Instance(pevAttacker);

	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pAttacker$[ebp], eax

; 457  : 
; 458  : 	if ( !g_pGameRules->FPlayerCanTakeDamage( this, pAttacker ) )

	mov	ecx, DWORD PTR _pAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+64]
	test	eax, eax
	jne	SHORT $L40232

; 460  : 		// Refuse the damage
; 461  : 		return 0;

	xor	eax, eax
	jmp	$L40219
$L40232:

; 463  : 
; 464  : 	// keep track of amount of damage last sustained
; 465  : 	m_lastDamageAmount = flDamage;

	fld	DWORD PTR _flDamage$[ebp]
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2796], eax

; 466  : 
; 467  : 	// Armor.
; 468  : 	if (pev->armorvalue && !(bitsDamageType & (DMG_FALL | DMG_DROWN)) )// armor doesn't protect against fall or drown damage!

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+444]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L40233
	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	and	ecx, 16416				; 00004020H
	test	ecx, ecx
	jne	$L40233

; 470  : 		float flNew = flDamage * flRatio;

	fld	DWORD PTR _flDamage$[ebp]
	fmul	DWORD PTR _flRatio$[ebp]
	fstp	DWORD PTR _flNew$40234[ebp]

; 471  : 
; 472  : 		float flArmor;
; 473  : 
; 474  : 		flArmor = (flDamage - flNew) * flBonus;

	fld	DWORD PTR _flDamage$[ebp]
	fsub	DWORD PTR _flNew$40234[ebp]
	fmul	DWORD PTR _flBonus$[ebp]
	fstp	DWORD PTR _flArmor$40235[ebp]

; 475  : 
; 476  : 		// Does this use more armor than we have?
; 477  : 		if (flArmor > pev->armorvalue)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR _flArmor$40235[ebp]
	fcomp	DWORD PTR [eax+444]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40236

; 479  : 			flArmor = pev->armorvalue;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+444]
	mov	DWORD PTR _flArmor$40235[ebp], eax

; 480  : 			flArmor *= (1/flBonus);

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flBonus$[ebp]
	fmul	DWORD PTR _flArmor$40235[ebp]
	fstp	DWORD PTR _flArmor$40235[ebp]

; 481  : 			flNew = flDamage - flArmor;

	fld	DWORD PTR _flDamage$[ebp]
	fsub	DWORD PTR _flArmor$40235[ebp]
	fstp	DWORD PTR _flNew$40234[ebp]

; 482  : 			pev->armorvalue = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+444], 0

; 484  : 		else

	jmp	SHORT $L40237
$L40236:

; 485  : 			pev->armorvalue -= flArmor;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+444]
	fsub	DWORD PTR _flArmor$40235[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+444]
$L40237:

; 486  : 
; 487  : 		flDamage = flNew;

	mov	ecx, DWORD PTR _flNew$40234[ebp]
	mov	DWORD PTR _flDamage$[ebp], ecx
$L40233:

; 489  : 
; 490  : 	// this cast to INT is critical!!! If a player ends up with 0.5 health, the engine will get that
; 491  : 	// as an int (zero) and think the player is dead! (this will incite a clientside screentilt, etc)
; 492  : 	fTookDamage = CBaseMonster::TakeDamage(pevInflictor, pevAttacker, (int)flDamage, bitsDamageType);

	mov	edx, DWORD PTR _bitsDamageType$[ebp]
	push	edx
	fld	DWORD PTR _flDamage$[ebp]
	call	__ftol
	mov	DWORD PTR -60+[ebp], eax
	fild	DWORD PTR -60+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z ; CBaseMonster::TakeDamage
	mov	DWORD PTR _fTookDamage$[ebp], eax

; 497  : 		for (int i = 0; i < CDMG_TIMEBASED; i++)

	mov	DWORD PTR _i$40239[ebp], 0
	jmp	SHORT $L40240
$L40241:
	mov	edx, DWORD PTR _i$40239[ebp]
	add	edx, 1
	mov	DWORD PTR _i$40239[ebp], edx
$L40240:
	cmp	DWORD PTR _i$40239[ebp], 8
	jge	SHORT $L40242

; 498  : 			if (bitsDamageType & (DMG_PARALYZE << i))

	mov	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR _i$40239[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _bitsDamageType$[ebp]
	and	ecx, eax
	test	ecx, ecx
	je	SHORT $L40243

; 499  : 				m_rgbTimeBasedDamage[i] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$40239[ebp]
	mov	BYTE PTR [edx+2316], 0
$L40243:

; 500  : 	}

	jmp	SHORT $L40241
$L40242:

; 501  : 
; 502  : 	// tell director about it
; 503  : 	MESSAGE_BEGIN( MSG_SPEC, SVC_DIRECTOR );

	push	0
	push	0
	push	51					; 00000033H
	push	9
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 504  : 		WRITE_BYTE ( 9 );	// command length in bytes

	push	9
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 505  : 		WRITE_BYTE ( DRC_CMD_EVENT );	// take damage event

	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 506  : 		WRITE_SHORT( ENTINDEX(this->edict()) );	// index number of primary entity

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 507  : 		WRITE_SHORT( ENTINDEX(ENT(pevInflictor)) );	// index number of secondary entity

	mov	eax, DWORD PTR _pevInflictor$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 508  : 		WRITE_LONG( 5 );   // eventflags (priority and flags)

	push	5
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+204
	add	esp, 4

; 509  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 510  : 
; 511  : 
; 512  : 	// how bad is it, doc?
; 513  : 
; 514  : 	ftrivial = (pev->health > 75 || m_lastDamageAmount < 5);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fcomp	DWORD PTR __real@4@40059600000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L43766
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2796], 5
	jl	SHORT $L43766
	mov	DWORD PTR -64+[ebp], 0
	jmp	SHORT $L43767
$L43766:
	mov	DWORD PTR -64+[ebp], 1
$L43767:
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR _ftrivial$[ebp], ecx

; 515  : 	fmajor = (m_lastDamageAmount > 25);

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+2796], 25		; 00000019H
	setg	al
	mov	DWORD PTR _fmajor$[ebp], eax

; 516  : 	fcritical = (pev->health < 30);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fcomp	DWORD PTR __real@4@4003f000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L43768
	mov	DWORD PTR -68+[ebp], 1
	jmp	SHORT $L43769
$L43768:
	mov	DWORD PTR -68+[ebp], 0
$L43769:
	mov	eax, DWORD PTR -68+[ebp]
	mov	DWORD PTR _fcritical$[ebp], eax

; 517  : 
; 518  : 	// handle all bits set in this damage message,
; 519  : 	// let the suit give player the diagnosis
; 520  : 
; 521  : 	// UNDONE: add sounds for types of damage sustained (ie: burn, shock, slash )
; 522  : 
; 523  : 	// UNDONE: still need to record damage and heal messages for the following types
; 524  : 
; 525  : 		// DMG_BURN
; 526  : 		// DMG_FREEZE
; 527  : 		// DMG_BLAST
; 528  : 		// DMG_SHOCK
; 529  : 
; 530  : 	m_bitsDamageType |= bitsDamage; // Save this so we can report it to the client

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2312]
	or	edx, DWORD PTR _bitsDamage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2312], edx

; 531  : 	m_bitsHUDDamage = -1;  // make sure the damage bits get resent

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2844], -1
$L40245:

; 532  : 
; 533  : 	while (fTookDamage && (!ftrivial || (bitsDamage & DMG_TIMEBASED)) && ffound && bitsDamage)

	cmp	DWORD PTR _fTookDamage$[ebp], 0
	je	$L40246
	cmp	DWORD PTR _ftrivial$[ebp], 0
	je	SHORT $L40247
	mov	edx, DWORD PTR _bitsDamage$[ebp]
	and	edx, 16760832				; 00ffc000H
	test	edx, edx
	je	$L40246
$L40247:
	cmp	DWORD PTR _ffound$[ebp], 0
	je	$L40246
	cmp	DWORD PTR _bitsDamage$[ebp], 0
	je	$L40246

; 535  : 		ffound = FALSE;

	mov	DWORD PTR _ffound$[ebp], 0

; 536  : 
; 537  : 		if (bitsDamage & DMG_CLUB)

	mov	eax, DWORD PTR _bitsDamage$[ebp]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $L40248

; 539  : 			/*if (fmajor)
; 540  : 				SetSuitUpdate("!HEV_DMG4", FALSE, SUIT_NEXT_IN_30SEC);	// minor fracture*/
; 541  : 			bitsDamage &= ~DMG_CLUB;

	mov	ecx, DWORD PTR _bitsDamage$[ebp]
	and	cl, 127					; 0000007fH
	mov	DWORD PTR _bitsDamage$[ebp], ecx

; 542  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40248:

; 544  : 		if (bitsDamage & (DMG_FALL | DMG_CRUSH))

	mov	edx, DWORD PTR _bitsDamage$[ebp]
	and	edx, 33					; 00000021H
	test	edx, edx
	je	SHORT $L40249

; 546  : 			/*if (fmajor)
; 547  : 				SetSuitUpdate("!HEV_DMG5", FALSE, SUIT_NEXT_IN_30SEC);	// major fracture
; 548  : 			else
; 549  : 				SetSuitUpdate("!HEV_DMG4", FALSE, SUIT_NEXT_IN_30SEC);	// minor fracture*/
; 550  : 
; 551  : 			bitsDamage &= ~(DMG_FALL | DMG_CRUSH);

	mov	eax, DWORD PTR _bitsDamage$[ebp]
	and	al, -34					; ffffffdeH
	mov	DWORD PTR _bitsDamage$[ebp], eax

; 552  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40249:

; 554  : 
; 555  : 		if (bitsDamage & DMG_BULLET)

	mov	ecx, DWORD PTR _bitsDamage$[ebp]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L40250

; 557  : 			/*if (m_lastDamageAmount > 5)
; 558  : 				SetSuitUpdate("!HEV_DMG6", FALSE, SUIT_NEXT_IN_30SEC);	// blood loss detected*/
; 559  : 			//else
; 560  : 			//	SetSuitUpdate("!HEV_DMG0", FALSE, SUIT_NEXT_IN_30SEC);	// minor laceration
; 561  : 
; 562  : 			bitsDamage &= ~DMG_BULLET;

	mov	edx, DWORD PTR _bitsDamage$[ebp]
	and	edx, -3					; fffffffdH
	mov	DWORD PTR _bitsDamage$[ebp], edx

; 563  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40250:

; 565  : 
; 566  : 		if (bitsDamage & DMG_SLASH)

	mov	eax, DWORD PTR _bitsDamage$[ebp]
	and	eax, 4
	test	eax, eax
	je	SHORT $L40251

; 568  : 			/*if (fmajor)
; 569  : 				SetSuitUpdate("!HEV_DMG1", FALSE, SUIT_NEXT_IN_30SEC);	// major laceration
; 570  : 			else
; 571  : 				SetSuitUpdate("!HEV_DMG0", FALSE, SUIT_NEXT_IN_30SEC);	// minor laceration*/
; 572  : 
; 573  : 			bitsDamage &= ~DMG_SLASH;

	mov	ecx, DWORD PTR _bitsDamage$[ebp]
	and	ecx, -5					; fffffffbH
	mov	DWORD PTR _bitsDamage$[ebp], ecx

; 574  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40251:

; 576  : 
; 577  : 		if (bitsDamage & DMG_SONIC)

	mov	edx, DWORD PTR _bitsDamage$[ebp]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40252

; 579  : 			/*if (fmajor)
; 580  : 				SetSuitUpdate("!HEV_DMG2", FALSE, SUIT_NEXT_IN_1MIN);	// internal bleeding*/
; 581  : 			bitsDamage &= ~DMG_SONIC;

	mov	eax, DWORD PTR _bitsDamage$[ebp]
	and	ah, -3					; fffffffdH
	mov	DWORD PTR _bitsDamage$[ebp], eax

; 582  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40252:

; 584  : 
; 585  : 		if (bitsDamage & (DMG_POISON | DMG_PARALYZE))

	mov	ecx, DWORD PTR _bitsDamage$[ebp]
	and	ecx, 163840				; 00028000H
	test	ecx, ecx
	je	SHORT $L40253

; 587  : 			//SetSuitUpdate("!HEV_DMG3", FALSE, SUIT_NEXT_IN_1MIN);	// blood toxins detected
; 588  : 			bitsDamage &= ~(DMG_POISON | DMG_PARALYZE);

	mov	edx, DWORD PTR _bitsDamage$[ebp]
	and	edx, -163841				; fffd7fffH
	mov	DWORD PTR _bitsDamage$[ebp], edx

; 589  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40253:

; 591  : 
; 592  : 		if (bitsDamage & DMG_ACID)

	mov	eax, DWORD PTR _bitsDamage$[ebp]
	and	eax, 1048576				; 00100000H
	test	eax, eax
	je	SHORT $L40254

; 594  : 			//SetSuitUpdate("!HEV_DET1", FALSE, SUIT_NEXT_IN_1MIN);	// hazardous chemicals detected
; 595  : 			bitsDamage &= ~DMG_ACID;

	mov	ecx, DWORD PTR _bitsDamage$[ebp]
	and	ecx, -1048577				; ffefffffH
	mov	DWORD PTR _bitsDamage$[ebp], ecx

; 596  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40254:

; 598  : 
; 599  : 		if (bitsDamage & DMG_NERVEGAS)

	mov	edx, DWORD PTR _bitsDamage$[ebp]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	SHORT $L40255

; 601  : 			//SetSuitUpdate("!HEV_DET0", FALSE, SUIT_NEXT_IN_1MIN);	// biohazard detected
; 602  : 			bitsDamage &= ~DMG_NERVEGAS;

	mov	eax, DWORD PTR _bitsDamage$[ebp]
	and	eax, -65537				; fffeffffH
	mov	DWORD PTR _bitsDamage$[ebp], eax

; 603  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40255:

; 605  : 
; 606  : 		if (bitsDamage & DMG_RADIATION)

	mov	ecx, DWORD PTR _bitsDamage$[ebp]
	and	ecx, 262144				; 00040000H
	test	ecx, ecx
	je	SHORT $L40256

; 608  : 			//SetSuitUpdate("!HEV_DET2", FALSE, SUIT_NEXT_IN_1MIN);	// radiation detected
; 609  : 			bitsDamage &= ~DMG_RADIATION;

	mov	edx, DWORD PTR _bitsDamage$[ebp]
	and	edx, -262145				; fffbffffH
	mov	DWORD PTR _bitsDamage$[ebp], edx

; 610  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40256:

; 612  : 		if (bitsDamage & DMG_SHOCK)

	mov	eax, DWORD PTR _bitsDamage$[ebp]
	and	eax, 256				; 00000100H
	test	eax, eax
	je	SHORT $L40257

; 614  : 			bitsDamage &= ~DMG_SHOCK;

	mov	ecx, DWORD PTR _bitsDamage$[ebp]
	and	ch, -2					; fffffffeH
	mov	DWORD PTR _bitsDamage$[ebp], ecx

; 615  : 			ffound = TRUE;

	mov	DWORD PTR _ffound$[ebp], 1
$L40257:

; 617  : 	}

	jmp	$L40245
$L40246:

; 618  : 
; 619  : 	pev->punchangle.x = -2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+104], -1073741824	; c0000000H

; 620  : 
; 621  : 	/*if (fTookDamage && !ftrivial && fmajor && flHealthPrev >= 75)
; 622  : 	{
; 623  : 		// first time we take major damage...
; 624  : 		// turn automedic on if not on
; 625  : 		SetSuitUpdate("!HEV_MED1", FALSE, SUIT_NEXT_IN_30MIN);	// automedic on
; 626  : 
; 627  : 		// give morphine shot if not given recently
; 628  : 		SetSuitUpdate("!HEV_HEAL7", FALSE, SUIT_NEXT_IN_30MIN);	// morphine shot
; 629  : 	}
; 630  : 
; 631  : 	if (fTookDamage && !ftrivial && fcritical && flHealthPrev < 75)
; 632  : 	{
; 633  : 
; 634  : 		// already took major damage, now it's critical...
; 635  : 		if (pev->health < 6)
; 636  : 			SetSuitUpdate("!HEV_HLTH3", FALSE, SUIT_NEXT_IN_10MIN);	// near death
; 637  : 		else if (pev->health < 20)
; 638  : 			SetSuitUpdate("!HEV_HLTH2", FALSE, SUIT_NEXT_IN_10MIN);	// health critical
; 639  : 
; 640  : 		// give critical health warnings
; 641  : 		if (!RANDOM_LONG(0,3) && flHealthPrev < 50)
; 642  : 			SetSuitUpdate("!HEV_DMG7", FALSE, SUIT_NEXT_IN_5MIN); //seek medical attention
; 643  : 	}
; 644  : 
; 645  : 	// if we're taking time based damage, warn about its continuing effects
; 646  : 	if (fTookDamage && (bitsDamageType & DMG_TIMEBASED) && flHealthPrev < 75)
; 647  : 		{
; 648  : 			if (flHealthPrev < 50)
; 649  : 			{
; 650  : 				if (!RANDOM_LONG(0,3))
; 651  : 					SetSuitUpdate("!HEV_DMG7", FALSE, SUIT_NEXT_IN_5MIN); //seek medical attention
; 652  : 			}
; 653  : 			else
; 654  : 				SetSuitUpdate("!HEV_HLTH1", FALSE, SUIT_NEXT_IN_10MIN);	// health dropping
; 655  : 		}*/
; 656  : 
; 657  : 	return fTookDamage;

	mov	eax, DWORD PTR _fTookDamage$[ebp]
$L40219:

; 658  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z ENDP	; CBasePlayer::TakeDamage
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
?ENTINDEX@@YAHPAUedict_s@@@Z PROC NEAR			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z PROC NEAR ; CBaseEntity::Instance, COMDAT

; 533  : 	static CBaseEntity *Instance( entvars_t *pev ) { return Instance( ENT( pev ) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
PUBLIC	??_C@_09KMAI@weaponbox?$AA@			; `string'
PUBLIC	??_C@_0BB@FAMA@CWeaponBox?3?3Kill?$AA@		; `string'
PUBLIC	?PackDeadPlayerItems@CBasePlayer@@QAEXXZ	; CBasePlayer::PackDeadPlayerItems
PUBLIC	?RemoveAllItems@CBasePlayer@@QAEXHH@Z		; CBasePlayer::RemoveAllItems
PUBLIC	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet
EXTRN	?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A:BYTE ; CBasePlayerItem::AmmoInfoArray
EXTRN	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsOrigin
EXTRN	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsAngles
EXTRN	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsAngles
EXTRN	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsVelocity
EXTRN	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetAbsVelocity
EXTRN	?Kill@CWeaponBox@@QAEXXZ:NEAR			; CWeaponBox::Kill
EXTRN	?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z:NEAR ; CWeaponBox::PackWeapon
EXTRN	?PackAmmo@CWeaponBox@@QAEHHH@Z:NEAR		; CWeaponBox::PackAmmo
EXTRN	_memset:NEAR
EXTRN	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z:NEAR ; CBaseEntity::Create
;	COMDAT ??_C@_09KMAI@weaponbox?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_09KMAI@weaponbox?$AA@ DB 'weaponbox', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FAMA@CWeaponBox?3?3Kill?$AA@
CONST	SEGMENT
??_C@_0BB@FAMA@CWeaponBox?3?3Kill?$AA@ DB 'CWeaponBox::Kill', 00H ; `string'
CONST	ENDS
;	COMDAT ?PackDeadPlayerItems@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_iWeaponRules$ = -8
_iAmmoRules$ = -12
_i$ = -16
_rgpPackWeapons$ = -96
_iPackAmmo$ = -228
_iPW$ = -232
_iPA$ = -236
_pPlayerItem$40274 = -240
_pWeaponBox$ = -244
_vecAngles$ = -256
$T43795 = -268
?PackDeadPlayerItems@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::PackDeadPlayerItems, COMDAT

; 668  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 669  : 	int iWeaponRules;
; 670  : 	int iAmmoRules;
; 671  : 	int i;
; 672  : 	CBasePlayerWeapon *rgpPackWeapons[ 20 ];// 20 hardcoded for now. How to determine exactly how many weapons we have?
; 673  : 	int iPackAmmo[ MAX_AMMO_SLOTS + 1];
; 674  : 	int iPW = 0;// index into packweapons array

	mov	DWORD PTR _iPW$[ebp], 0

; 675  : 	int iPA = 0;// index into packammo array

	mov	DWORD PTR _iPA$[ebp], 0

; 676  : 
; 677  : 	memset(rgpPackWeapons, NULL, sizeof(rgpPackWeapons) );

	push	80					; 00000050H
	push	0
	lea	eax, DWORD PTR _rgpPackWeapons$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 678  : 	memset(iPackAmmo, -1, sizeof(iPackAmmo) );

	push	132					; 00000084H
	push	-1
	lea	ecx, DWORD PTR _iPackAmmo$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 679  : 
; 680  : 	// get the game rules
; 681  : 	iWeaponRules = g_pGameRules->DeadPlayerWeapons( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+188]
	mov	DWORD PTR _iWeaponRules$[ebp], eax

; 682  :  	iAmmoRules = g_pGameRules->DeadPlayerAmmo( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+192]
	mov	DWORD PTR _iAmmoRules$[ebp], eax

; 683  : 
; 684  : 	if ( iWeaponRules == GR_PLR_DROP_GUN_NO && iAmmoRules == GR_PLR_DROP_AMMO_NO )

	cmp	DWORD PTR _iWeaponRules$[ebp], 9
	jne	SHORT $L40269
	cmp	DWORD PTR _iAmmoRules$[ebp], 12		; 0000000cH
	jne	SHORT $L40269

; 686  : 		// nothing to pack. Remove the weapons and return. Don't call create on the box!
; 687  : 		RemoveAllItems( TRUE );

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllItems@CBasePlayer@@QAEXHH@Z	; CBasePlayer::RemoveAllItems

; 688  : 		return;

	jmp	$L40261
$L40269:

; 690  : 
; 691  : // go through all of the weapons and make a list of the ones to pack
; 692  : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40270
$L40271:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40270:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$L40272

; 694  : 		if ( m_rgpPlayerItems[ i ] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+2956], 0
	je	$L40277

; 696  : 			// there's a weapon here. Should I pack it?
; 697  : 			CBasePlayerItem *pPlayerItem = m_rgpPlayerItems[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2956]
	mov	DWORD PTR _pPlayerItem$40274[ebp], edx
$L40276:

; 698  : 
; 699  : 			while ( pPlayerItem )

	cmp	DWORD PTR _pPlayerItem$40274[ebp], 0
	je	$L40277

; 702  : 				{

	mov	eax, DWORD PTR _iWeaponRules$[ebp]
	mov	DWORD PTR -272+[ebp], eax
	cmp	DWORD PTR -272+[ebp], 7
	je	SHORT $L40285
	cmp	DWORD PTR -272+[ebp], 8
	je	SHORT $L40282
	jmp	SHORT $L40287
$L40282:

; 703  : 				case GR_PLR_DROP_GUN_ACTIVE:
; 704  : 					if ( m_pActiveItem && pPlayerItem == m_pActiveItem )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2980], 0
	je	SHORT $L40283
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pPlayerItem$40274[ebp]
	cmp	eax, DWORD PTR [edx+2980]
	jne	SHORT $L40283

; 706  : 						// this is the active item. Pack it.
; 707  : 						rgpPackWeapons[ iPW++ ] = (CBasePlayerWeapon *)pPlayerItem;

	mov	ecx, DWORD PTR _iPW$[ebp]
	mov	edx, DWORD PTR _pPlayerItem$40274[ebp]
	mov	DWORD PTR _rgpPackWeapons$[ebp+ecx*4], edx
	mov	eax, DWORD PTR _iPW$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPW$[ebp], eax
$L40283:

; 709  : 					break;

	jmp	SHORT $L40279
$L40285:

; 710  : 
; 711  : 				case GR_PLR_DROP_GUN_ALL:
; 712  : 					rgpPackWeapons[ iPW++ ] = (CBasePlayerWeapon *)pPlayerItem;

	mov	ecx, DWORD PTR _iPW$[ebp]
	mov	edx, DWORD PTR _pPlayerItem$40274[ebp]
	mov	DWORD PTR _rgpPackWeapons$[ebp+ecx*4], edx
	mov	eax, DWORD PTR _iPW$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPW$[ebp], eax
$L40287:
$L40279:

; 718  : 
; 719  : 				pPlayerItem = pPlayerItem->m_pNext;

	mov	ecx, DWORD PTR _pPlayerItem$40274[ebp]
	mov	edx, DWORD PTR [ecx+1820]
	mov	DWORD PTR _pPlayerItem$40274[ebp], edx

; 720  : 			}

	jmp	$L40276
$L40277:

; 722  : 	}

	jmp	$L40271
$L40272:

; 723  : 
; 724  : // now go through ammo and make a list of which types to pack.
; 725  : 	if ( iAmmoRules != GR_PLR_DROP_AMMO_NO )

	cmp	DWORD PTR _iAmmoRules$[ebp], 12		; 0000000cH
	je	$L40291

; 727  : 		for ( i = 0 ; i < MAX_AMMO_SLOTS ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40289
$L40290:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40289:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$L40291

; 729  : 			if ( m_rgAmmo[ i ] > 0 )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+3508], 0
	jle	$L40294

; 733  : 				{

	mov	eax, DWORD PTR _iAmmoRules$[ebp]
	mov	DWORD PTR -276+[ebp], eax
	cmp	DWORD PTR -276+[ebp], 10		; 0000000aH
	je	SHORT $L40297
	cmp	DWORD PTR -276+[ebp], 11		; 0000000bH
	je	SHORT $L40298
	jmp	$L40302
$L40297:

; 734  : 				case GR_PLR_DROP_AMMO_ALL:
; 735  : 					iPackAmmo[ iPA++ ] = i;

	mov	ecx, DWORD PTR _iPA$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iPackAmmo$[ebp+ecx*4], edx
	mov	eax, DWORD PTR _iPA$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPA$[ebp], eax

; 736  : 					break;

	jmp	$L40294
$L40298:

; 737  : 
; 738  : 				case GR_PLR_DROP_AMMO_ACTIVE:
; 739  : 					if ( m_pActiveItem && i == m_pActiveItem->PrimaryAmmoIndex() )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2980], 0
	je	SHORT $L40299
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+396]
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $L40299

; 741  : 						// this is the primary ammo type for the active weapon
; 742  : 						iPackAmmo[ iPA++ ] = i;

	mov	ecx, DWORD PTR _iPA$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iPackAmmo$[ebp+ecx*4], edx
	mov	eax, DWORD PTR _iPA$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPA$[ebp], eax

; 744  : 					else if ( m_pActiveItem && i == m_pActiveItem->SecondaryAmmoIndex() )

	jmp	SHORT $L40301
$L40299:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2980], 0
	je	SHORT $L40301
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+400]
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $L40301

; 746  : 						// this is the secondary ammo type for the active weapon
; 747  : 						iPackAmmo[ iPA++ ] = i;

	mov	ecx, DWORD PTR _iPA$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iPackAmmo$[ebp+ecx*4], edx
	mov	eax, DWORD PTR _iPA$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPA$[ebp], eax
$L40301:
$L40302:
$L40294:

; 755  : 		}

	jmp	$L40290
$L40291:

; 757  : 
; 758  : 	// create a box to pack the stuff into.
; 759  : 	CWeaponBox *pWeaponBox = (CWeaponBox *)CBaseEntity::Create( "weaponbox", GetAbsOrigin(), GetAbsAngles(), edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	OFFSET FLAT:??_C@_09KMAI@weaponbox?$AA@	; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pWeaponBox$[ebp], eax

; 760  : 
; 761  : 	Vector vecAngles = pWeaponBox->GetAbsAngles();

	mov	ecx, DWORD PTR _pWeaponBox$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _vecAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 762  : 
; 763  : 	vecAngles.x = 0;// don't let weaponbox tilt.

	mov	DWORD PTR _vecAngles$[ebp], 0

; 764  : 	vecAngles.z = 0;

	mov	DWORD PTR _vecAngles$[ebp+8], 0

; 765  : 
; 766  : 	pWeaponBox->SetAbsAngles( vecAngles );

	lea	ecx, DWORD PTR _vecAngles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWeaponBox$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 767  : 	pWeaponBox->SetThink( CWeaponBox::Kill );

	push	OFFSET FLAT:??_C@_0BB@FAMA@CWeaponBox?3?3Kill?$AA@ ; `string'
	push	OFFSET FLAT:?Kill@CWeaponBox@@QAEXXZ	; CWeaponBox::Kill
	mov	ecx, DWORD PTR _pWeaponBox$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 768  : 	pWeaponBox->SetNextThink( 120 );

	push	1123024896				; 42f00000H
	mov	edx, DWORD PTR _pWeaponBox$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pWeaponBox$[ebp]
	call	DWORD PTR [eax+80]

; 769  : 
; 770  : 	// back these two lists up to their first elements
; 771  : 	iPA = 0;

	mov	DWORD PTR _iPA$[ebp], 0

; 772  : 	iPW = 0;

	mov	DWORD PTR _iPW$[ebp], 0
$L40311:

; 773  : 
; 774  : 	// pack the ammo
; 775  : 	while ( iPackAmmo[iPA] != -1 )

	mov	ecx, DWORD PTR _iPA$[ebp]
	cmp	DWORD PTR _iPackAmmo$[ebp+ecx*4], -1
	je	SHORT $L40312

; 777  : 		pWeaponBox->PackAmmo( MAKE_STRING( CBasePlayerItem::AmmoInfoArray[iPackAmmo[iPA]].pszName ), m_rgAmmo[iPackAmmo[iPA]] );

	mov	edx, DWORD PTR _iPA$[ebp]
	mov	eax, DWORD PTR _iPackAmmo$[ebp+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+3508]
	push	edx
	mov	eax, DWORD PTR _iPA$[ebp]
	mov	ecx, DWORD PTR _iPackAmmo$[ebp+eax*4]
	mov	edx, DWORD PTR ?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A[ecx*8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pWeaponBox$[ebp]
	call	?PackAmmo@CWeaponBox@@QAEHHH@Z		; CWeaponBox::PackAmmo

; 778  : 		iPA++;

	mov	eax, DWORD PTR _iPA$[ebp]
	add	eax, 1
	mov	DWORD PTR _iPA$[ebp], eax

; 779  : 	}

	jmp	SHORT $L40311
$L40312:

; 780  : 
; 781  : 	// now pack all of the items in the lists
; 782  : 	while ( rgpPackWeapons[iPW] )

	mov	ecx, DWORD PTR _iPW$[ebp]
	cmp	DWORD PTR _rgpPackWeapons$[ebp+ecx*4], 0
	je	SHORT $L40315

; 784  : 		// weapon unhooked from the player. Pack it into der box.
; 785  : 		pWeaponBox->PackWeapon( rgpPackWeapons[iPW] );

	mov	edx, DWORD PTR _iPW$[ebp]
	mov	eax, DWORD PTR _rgpPackWeapons$[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _pWeaponBox$[ebp]
	call	?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z ; CWeaponBox::PackWeapon

; 786  : 
; 787  : 		iPW++;

	mov	ecx, DWORD PTR _iPW$[ebp]
	add	ecx, 1
	mov	DWORD PTR _iPW$[ebp], ecx

; 788  : 	}

	jmp	SHORT $L40312
$L40315:

; 789  : 
; 790  : 	pWeaponBox->SetAbsVelocity( GetAbsVelocity() * 1.2 ); // weaponbox has player's velocity, then some.

	push	1067030938				; 3f99999aH
	lea	edx, DWORD PTR $T43795[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _pWeaponBox$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 791  : 
; 792  : 	RemoveAllItems( TRUE );// now strip off everything that wasn't handled by the code above.

	push	1
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllItems@CBasePlayer@@QAEXHH@Z	; CBasePlayer::RemoveAllItems
$L40261:

; 793  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PackDeadPlayerItems@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::PackDeadPlayerItems
_TEXT	ENDS
PUBLIC	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z	; CBaseEntity::FunctionCheck
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT
_this$ = -4
_func$ = 8
_name$ = 12
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z PROC NEAR ; CBaseEntity::ThinkSet, COMDAT

; 560  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 		m_pfnThink = func; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _func$[ebp]
	mov	DWORD PTR [eax+1744], ecx

; 562  : 		FunctionCheck( *(reinterpret_cast<void **>(&m_pfnThink)), name ); 

	mov	edx, DWORD PTR _name$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1744]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ; CBaseEntity::FunctionCheck

; 563  : 		return func;

	mov	eax, DWORD PTR _func$[ebp]

; 564  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ENDP	; CBaseEntity::ThinkSet
_TEXT	ENDS
PUBLIC	??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
EXTRN	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z:NEAR ; UTIL_FunctionToName
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ DB 'F'
	DB	'UNCTION NOT IN TABLE!: %s:%s (%08lx)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT
_this$ = -4
_pFunction$ = 8
_name$ = 12
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z PROC NEAR	; CBaseEntity::FunctionCheck, COMDAT

; 554  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 555  : 		if (pFunction && !UTIL_FunctionToName( GetDataDescMap(), pFunction ) )

	cmp	DWORD PTR _pFunction$[ebp], 0
	je	SHORT $L35044
	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	call	?UTIL_FunctionToName@@YAPBDPAUdatamap_s@@PAX@Z ; UTIL_FunctionToName
	add	esp, 8
	test	eax, eax
	jne	SHORT $L35044

; 556  : 			ALERT( at_warning, "FUNCTION NOT IN TABLE!: %s:%s (%08lx)\n", GetClassname(), name, (unsigned long)pFunction );

	mov	eax, DWORD PTR _pFunction$[ebp]
	push	eax
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L35044:

; 557  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z ENDP		; CBaseEntity::FunctionCheck
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z	; MESSAGE_BEGIN
PUBLIC	?ResetAutoaim@CBasePlayer@@QAEXXZ		; CBasePlayer::ResetAutoaim
PUBLIC	?HasWeapon@CBaseMonster@@QAEHH@Z		; CBaseMonster::HasWeapon
PUBLIC	?AddWeapon@CBaseMonster@@QAEXH@Z		; CBaseMonster::AddWeapon
PUBLIC	?RemoveAllWeapons@CBaseMonster@@QAEXXZ		; CBaseMonster::RemoveAllWeapons
;	COMDAT ?RemoveAllItems@CBasePlayer@@QAEXHH@Z
_TEXT	SEGMENT
_removeSuit$ = 8
_removeCycler$ = 12
_this$ = -4
_i$ = -8
_pPendingItem$ = -12
?RemoveAllItems@CBasePlayer@@QAEXHH@Z PROC NEAR		; CBasePlayer::RemoveAllItems, COMDAT

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 797  : 	if (m_pActiveItem)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L40322

; 799  : 		ResetAutoaim( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetAutoaim@CBasePlayer@@QAEXXZ	; CBasePlayer::ResetAutoaim

; 800  : 		m_pActiveItem->Holster( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+368]

; 801  : 		m_pActiveItem = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2980], 0
$L40322:

; 803  : 
; 804  : 	m_pLastItem = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2988], 0

; 805  : 
; 806  : 	int i;
; 807  : 	CBasePlayerItem *pPendingItem;
; 808  : 	for (i = 0; i < MAX_ITEM_TYPES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40325
$L40326:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L40325:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L40327

; 810  : 		m_pActiveItem = m_rgpPlayerItems[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2956]
	mov	DWORD PTR [eax+2980], ecx
$L40329:

; 811  : 		while (m_pActiveItem)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2980], 0
	je	SHORT $L40330

; 813  : 			pPendingItem = m_pActiveItem->m_pNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR [ecx+1820]
	mov	DWORD PTR _pPendingItem$[ebp], edx

; 814  : 			m_pActiveItem->Drop( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+384]

; 815  : 			m_pActiveItem = pPendingItem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pPendingItem$[ebp]
	mov	DWORD PTR [eax+2980], ecx

; 816  : 		}

	jmp	SHORT $L40329
$L40330:

; 817  : 		m_rgpPlayerItems[i] = NULL;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+2956], 0

; 818  : 	}

	jmp	SHORT $L40326
$L40327:

; 819  : 	m_pActiveItem = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2980], 0

; 820  : 
; 821  : 	pev->viewmodel	= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+188], 0

; 822  : 	pev->weaponmodel	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+192], 0

; 823  : 
; 824  : 	if ( removeSuit && removeCycler )

	cmp	DWORD PTR _removeSuit$[ebp], 0
	je	SHORT $L40331
	cmp	DWORD PTR _removeCycler$[ebp], 0
	je	SHORT $L40331

; 826  : 		RemoveAllWeapons();	// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons

; 828  : 	else if( removeCycler )

	jmp	$L40346
$L40331:
	cmp	DWORD PTR _removeCycler$[ebp], 0
	je	SHORT $L40333

; 830  : 		if( HasWeapon( WEAPON_SUIT ))

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L40334

; 832  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons

; 833  : 			AddWeapon( WEAPON_SUIT );	// leave only suit

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 835  : 		else

	jmp	SHORT $L40335
$L40334:

; 837  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons
$L40335:

; 840  : 	else if( removeSuit )

	jmp	$L40346
$L40333:
	cmp	DWORD PTR _removeSuit$[ebp], 0
	je	SHORT $L40337

; 842  : 		if( HasWeapon( WEAPON_CYCLER ))

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L40338

; 844  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons

; 845  : 			AddWeapon( WEAPON_CYCLER );	// leave only cycler

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 847  : 		else

	jmp	SHORT $L40339
$L40338:

; 849  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons
$L40339:

; 852  : 	else

	jmp	$L40346
$L40337:

; 854  : 		if( HasWeapon( WEAPON_SUIT ) && HasWeapon( WEAPON_CYCLER ))

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L40341
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L40341

; 856  : 			// leave both cycler and suit
; 857  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons

; 858  : 			AddWeapon( WEAPON_CYCLER );

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 859  : 			AddWeapon( WEAPON_SUIT );

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 861  : 		else if( HasWeapon( WEAPON_SUIT ))

	jmp	SHORT $L40346
$L40341:
	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L40343

; 863  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons

; 864  : 			AddWeapon( WEAPON_SUIT );	// leave only suit

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 866  : 		else if( HasWeapon( WEAPON_CYCLER ))

	jmp	SHORT $L40346
$L40343:
	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	SHORT $L40345

; 868  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons

; 869  : 			AddWeapon( WEAPON_CYCLER );	// leave only cycler

	push	5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::AddWeapon

; 871  : 		else

	jmp	SHORT $L40346
$L40345:

; 873  : 			RemoveAllWeapons();		// clear all the weapons

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAllWeapons@CBaseMonster@@QAEXXZ	; CBaseMonster::RemoveAllWeapons
$L40346:

; 876  : 
; 877  : 	for ( i = 0; i < MAX_AMMO_SLOTS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40347
$L40348:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40347:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L40349

; 878  : 		m_rgAmmo[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+3508], 0
	jmp	SHORT $L40348
$L40349:

; 879  : 
; 880  : 	UpdateClientData();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+632]

; 881  : 	// send Selected Weapon Message to our client
; 882  : 	MESSAGE_BEGIN( MSG_ONE, gmsgCurWeapon, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgCurWeapon@@3HA	; gmsgCurWeapon
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 883  : 		WRITE_BYTE(0);

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 884  : 		WRITE_BYTE(0);

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 885  : 		WRITE_BYTE(0);

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 886  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 887  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?RemoveAllItems@CBasePlayer@@QAEXHH@Z ENDP		; CBasePlayer::RemoveAllItems
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ent$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 188  : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin, entvars_t *ent ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 189  : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ENT(ent));

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 190  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
;	COMDAT ?HasWeapon@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?HasWeapon@CBaseMonster@@QAEHH@Z PROC NEAR		; CBaseMonster::HasWeapon, COMDAT

; 142  : 	BOOL		HasWeapon( int weaponnum ) { return FBitSet( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	eax, edx
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasWeapon@CBaseMonster@@QAEHH@Z ENDP			; CBaseMonster::HasWeapon
_TEXT	ENDS
;	COMDAT ?AddWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?AddWeapon@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::AddWeapon, COMDAT

; 143  : 	void		AddWeapon( int weaponnum ) { SetBits( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	or	edx, eax
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	sar	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+2348], dl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddWeapon@CBaseMonster@@QAEXH@Z ENDP			; CBaseMonster::AddWeapon
_TEXT	ENDS
;	COMDAT ?RemoveAllWeapons@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RemoveAllWeapons@CBaseMonster@@QAEXXZ PROC NEAR	; CBaseMonster::RemoveAllWeapons, COMDAT

; 145  : 	void		RemoveAllWeapons( void ) { memset( m_iWeapons, 0, sizeof( m_iWeapons )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2348				; 0000092cH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAllWeapons@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::RemoveAllWeapons
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z	; CBasePlayer::Killed
PUBLIC	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation
PUBLIC	?SetSuitUpdate@CBasePlayer@@QAEXPADHH@Z		; CBasePlayer::SetSuitUpdate
PUBLIC	?DropHoldableItem@CBasePlayer@@QAEXXZ		; CBasePlayer::DropHoldableItem
PUBLIC	__real@4@4002a000000000000000
PUBLIC	__real@4@c004a000000000000000
PUBLIC	__real@8@3ffbccccccccccccd000
EXTRN	?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::ApplyAbsVelocityImpulse
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?Reset@CSound@@QAEXXZ:NEAR			; CSound::Reset
EXTRN	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z:NEAR ; CSoundEnt::SoundPointerForIndex
EXTRN	?ClientSoundIndex@CSoundEnt@@SAHPAUedict_s@@@Z:NEAR ; CSoundEnt::ClientSoundIndex
EXTRN	?g_ulModelIndexPlayer@@3KA:DWORD		; g_ulModelIndexPlayer
;	COMDAT __real@4@4002a000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@4002a000000000000000 DD 041200000r	; 10
CONST	ENDS
;	COMDAT __real@4@c004a000000000000000
CONST	SEGMENT
__real@4@c004a000000000000000 DD 0c2200000r	; -40
CONST	ENDS
;	COMDAT __real@8@3ffbccccccccccccd000
CONST	SEGMENT
__real@8@3ffbccccccccccccd000 DQ 03fb999999999999ar ; 0.1
CONST	ENDS
;	COMDAT ?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT
_pevAttacker$ = 8
_iGib$ = 12
_this$ = -4
_pSound$ = -8
_vecAngles$ = -20
$T43814 = -32
?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z PROC NEAR	; CBasePlayer::Killed, COMDAT

; 898  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 899  : 	CSound *pSound;
; 900  : 
; 901  : 	// Holster weapon immediately, to allow it to cleanup
; 902  : 	if ( m_pActiveItem )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L40357

; 903  : 		m_pActiveItem->Holster( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+368]
$L40357:

; 904  : 
; 905  : 	g_pGameRules->PlayerKilled( this, pevAttacker, g_pevLastInflictor );

	mov	eax, DWORD PTR ?g_pevLastInflictor@@3PAUentvars_s@@A ; g_pevLastInflictor
	push	eax
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+108]

; 906  : 
; 907  : 	if ( m_pTank != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40358

; 909  : 		m_pTank->Use( this, this, USE_OFF, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -36+[ebp], eax
	mov	edx, DWORD PTR -36+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -36+[ebp]
	call	DWORD PTR [eax+276]

; 910  : 		m_pTank = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L40358:

; 912  : 
; 913  : 	if (m_pMonitor != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40359

; 915  : 		m_pMonitor->Use( this, this, USE_RESET, 0 );

	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -40+[ebp], eax
	mov	eax, DWORD PTR -40+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -40+[ebp]
	call	DWORD PTR [edx+276]

; 916  : 		m_pMonitor = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L40359:

; 918  : 
; 919  : 	if (m_pHoldableItem != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40360

; 921  : 		DropHoldableItem ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropHoldableItem@CBasePlayer@@QAEXXZ	; CBasePlayer::DropHoldableItem
$L40360:

; 923  : 
; 924  : 	// this client isn't going to be thinking for a while, so reset the sound until they respawn
; 925  : 	pSound = CSoundEnt::SoundPointerForIndex( CSoundEnt::ClientSoundIndex( edict() ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ClientSoundIndex@CSoundEnt@@SAHPAUedict_s@@@Z ; CSoundEnt::ClientSoundIndex
	add	esp, 4
	push	eax
	call	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z ; CSoundEnt::SoundPointerForIndex
	add	esp, 4
	mov	DWORD PTR _pSound$[ebp], eax

; 927  : 		if ( pSound )

	cmp	DWORD PTR _pSound$[ebp], 0
	je	SHORT $L40361

; 929  : 			pSound->Reset();

	mov	ecx, DWORD PTR _pSound$[ebp]
	call	?Reset@CSound@@QAEXXZ			; CSound::Reset
$L40361:

; 932  : 
; 933  : 	SetAnimation( PLAYER_DIE );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation

; 934  : 
; 935  : 	m_iRespawnFrames = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3784], 0

; 936  : 
; 937  : 	pev->modelindex = g_ulModelIndexPlayer;    // don't use eyes

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ?g_ulModelIndexPlayer@@3KA ; g_ulModelIndexPlayer
	mov	DWORD PTR [edx+180], eax

; 938  : 
; 939  : 	pev->deadflag		= DEAD_DYING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+368], 1

; 940  : 	pev->movetype		= MOVETYPE_TOSS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 6

; 941  : 	ClearBits( pev->flags, FL_ONGROUND );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 942  : 	if (GetAbsVelocity().z < 10)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@4002a000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40362

; 943  : 		ApplyAbsVelocityImpulse( Vector( 0, 0, RANDOM_FLOAT(0,300)));

	push	1133903872				; 43960000H
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	push	0
	push	0
	lea	ecx, DWORD PTR $T43814[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::ApplyAbsVelocityImpulse
$L40362:

; 944  : 
; 945  : 	// clear out the suit message cache so we don't keep chattering
; 946  : 	SetSuitUpdate(NULL, FALSE, 0);

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetSuitUpdate@CBasePlayer@@QAEXPADHH@Z	; CBasePlayer::SetSuitUpdate

; 947  : 
; 948  : 	// send "health" update message to zero
; 949  : 	m_iClientHealth = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2920], 0

; 950  : 	MESSAGE_BEGIN( MSG_ONE, gmsgHealth, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgHealth@@3HA		; gmsgHealth
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 951  : 		WRITE_BYTE( m_iClientHealth );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2920]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 952  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 953  : 
; 954  : 	// Tell Ammo Hud that the player is dead
; 955  : 	MESSAGE_BEGIN( MSG_ONE, gmsgCurWeapon, NULL, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgCurWeapon@@3HA	; gmsgCurWeapon
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 956  : 		WRITE_BYTE(0);

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 957  : 		WRITE_BYTE(0XFF);

	push	255					; 000000ffH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 958  : 		WRITE_BYTE(0xFF);

	push	255					; 000000ffH
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 959  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 960  : 
; 961  : 	// reset FOV
; 962  : 	pev->fov = m_iFOV = m_iClientFOV = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2940], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2936], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+532], 0

; 963  : 
; 964  : 	MESSAGE_BEGIN( MSG_ONE, gmsgSetFOV, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgSetFOV@@3HA		; gmsgSetFOV
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 965  : 		WRITE_BYTE(0);

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 966  : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 967  : 
; 968  : 
; 969  : 	// UNDONE: Put this in, but add FFADE_PERMANENT and make fade time 8.8 instead of 4.12
; 970  : 	// UTIL_ScreenFade( edict(), Vector(128,0,0), 6, 15, 255, FFADE_OUT | FFADE_MODULATE );
; 971  : 
; 972  : 	if ( ( pev->health < -40 && iGib != GIB_NEVER ) || iGib == GIB_ALWAYS )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@c004a000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40366
	cmp	DWORD PTR _iGib$[ebp], 1
	jne	SHORT $L40365
$L40366:
	cmp	DWORD PTR _iGib$[ebp], 2
	jne	SHORT $L40364
$L40365:

; 974  : 		pev->solid			= SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0

; 975  : 		GibMonster();	// This clears pev->model

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+572]

; 976  : 		pev->effects |= EF_NODRAW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 977  : 		return;

	jmp	SHORT $L40355
$L40364:

; 979  : 
; 980  : 	DeathSound();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+592]

; 981  : 
; 982  : 	Vector vecAngles = GetAbsAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _vecAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 983  : 	vecAngles.x = 0;

	mov	DWORD PTR _vecAngles$[ebp], 0

; 984  : 	vecAngles.z = 0;

	mov	DWORD PTR _vecAngles$[ebp+8], 0

; 985  : 	SetAbsAngles( vecAngles );

	lea	ecx, DWORD PTR _vecAngles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 986  : 
; 987  : 	SetThink(PlayerDeathThink);

	push	OFFSET FLAT:??_C@_0BB@GOGA@PlayerDeathThink?$AA@ ; `string'
	push	OFFSET FLAT:?PlayerDeathThink@CBasePlayer@@QAEXXZ ; CBasePlayer::PlayerDeathThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 988  : 	pev->nextthink = gpGlobals->time + 0.1;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	fst	DWORD PTR -44+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+260]
$L40355:

; 989  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z ENDP		; CBasePlayer::Killed
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
PUBLIC	?Length2D@Vector@@QBEMXZ			; Vector::Length2D
PUBLIC	??_C@_0O@KCNB@crouch_shoot_?$AA@		; `string'
PUBLIC	??_C@_0L@FJK@ref_shoot_?$AA@			; `string'
PUBLIC	??_C@_0M@OOG@crouch_aim_?$AA@			; `string'
PUBLIC	??_C@_08GBMH@ref_aim_?$AA@			; `string'
PUBLIC	??_C@_09KCMO@deep_idle?$AA@			; `string'
PUBLIC	__real@4@4006dc00000000000000
EXTRN	?LookupActivity@CBaseAnimating@@QAEHH@Z:NEAR	; CBaseAnimating::LookupActivity
EXTRN	?LookupSequence@CBaseAnimating@@QAEHPBD@Z:NEAR	; CBaseAnimating::LookupSequence
EXTRN	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ:NEAR	; CBaseAnimating::ResetSequenceInfo
EXTRN	_strcpy:NEAR
;	COMDAT ??_C@_0O@KCNB@crouch_shoot_?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0O@KCNB@crouch_shoot_?$AA@ DB 'crouch_shoot_', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FJK@ref_shoot_?$AA@
CONST	SEGMENT
??_C@_0L@FJK@ref_shoot_?$AA@ DB 'ref_shoot_', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OOG@crouch_aim_?$AA@
CONST	SEGMENT
??_C@_0M@OOG@crouch_aim_?$AA@ DB 'crouch_aim_', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GBMH@ref_aim_?$AA@
CONST	SEGMENT
??_C@_08GBMH@ref_aim_?$AA@ DB 'ref_aim_', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KCMO@deep_idle?$AA@
CONST	SEGMENT
??_C@_09KCMO@deep_idle?$AA@ DB 'deep_idle', 00H		; `string'
CONST	ENDS
;	COMDAT __real@4@4006dc00000000000000
CONST	SEGMENT
__real@4@4006dc00000000000000 DD 0435c0000r	; 220
CONST	ENDS
;	COMDAT ?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z
_TEXT	SEGMENT
_playerAnim$ = 8
_this$ = -4
_animDesired$ = -8
_speed$ = -12
_szAnim$ = -76
?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z PROC NEAR ; CBasePlayer::SetAnimation, COMDAT

; 994  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 	int animDesired;
; 996  : 	float speed;
; 997  : 	char szAnim[64];
; 998  : 
; 999  : 	speed = GetAbsVelocity().Length2D();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	?Length2D@Vector@@QBEMXZ		; Vector::Length2D
	fstp	DWORD PTR _speed$[ebp]

; 1000 : 
; 1001 : 	if (pev->flags & FL_FROZEN)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 4096				; 00001000H
	test	edx, edx
	je	SHORT $L40377

; 1003 : 		speed = 0;

	mov	DWORD PTR _speed$[ebp], 0

; 1004 : 		playerAnim = PLAYER_IDLE;

	mov	DWORD PTR _playerAnim$[ebp], 0
$L40377:

; 1008 : 	{

	mov	eax, DWORD PTR _playerAnim$[ebp]
	mov	DWORD PTR -80+[ebp], eax
	cmp	DWORD PTR -80+[ebp], 5
	ja	$L40379
	mov	ecx, DWORD PTR -80+[ebp]
	jmp	DWORD PTR $L43833[ecx*4]
$L40382:

; 1009 : 	case PLAYER_JUMP:
; 1010 : 		m_IdealActivity = ACT_HOP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2072], 7

; 1011 : 		pev->fuser1 = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+596], 0

; 1012 : 		break;

	jmp	$L40379
$L40383:

; 1013 : 
; 1014 : 	case PLAYER_SUPERJUMP:
; 1015 : 		m_IdealActivity = ACT_LEAP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2072], 8

; 1016 : 		pev->fuser1 = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+596], 0

; 1017 : 		break;

	jmp	$L40379
$L40384:

; 1018 : 
; 1019 : 	case PLAYER_DIE:
; 1020 : 		m_IdealActivity = ACT_DIESIMPLE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2072], 36		; 00000024H

; 1021 : 		m_IdealActivity = GetDeathActivity( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+568]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], eax

; 1022 : 		break;

	jmp	$L40379
$L40385:

; 1026 : 		{

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2068]
	mov	DWORD PTR -84+[ebp], eax
	mov	ecx, DWORD PTR -84+[ebp]
	sub	ecx, 6
	mov	DWORD PTR -84+[ebp], ecx
	cmp	DWORD PTR -84+[ebp], 44			; 0000002cH
	ja	SHORT $L40391
	mov	eax, DWORD PTR -84+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L43834[eax]
	jmp	DWORD PTR $L43835[edx*4]
$L40390:

; 1027 : 		case ACT_HOVER:
; 1028 : 		case ACT_SWIM:
; 1029 : 		case ACT_HOP:
; 1030 : 		case ACT_LEAP:
; 1031 : 		case ACT_DIESIMPLE:
; 1032 : 			m_IdealActivity = m_Activity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2068]
	mov	DWORD PTR [ecx+2072], eax

; 1033 : 			break;

	jmp	SHORT $L40387
$L40391:

; 1034 : 		default:
; 1035 : 			m_IdealActivity = ACT_RANGE_ATTACK1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], 28		; 0000001cH
$L40387:

; 1038 : 		break;

	jmp	$L40379
$L40392:

; 1039 : 	case PLAYER_IDLE:
; 1040 : 	case PLAYER_WALK:
; 1041 : 		if ( !FBitSet( pev->flags, FL_ONGROUND ) && (m_Activity == ACT_HOP || m_Activity == ACT_LEAP) )	// Still jumping

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 512				; 00000200H
	test	ecx, ecx
	jne	SHORT $L40393
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2068], 7
	je	SHORT $L40394
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2068], 8
	jne	SHORT $L40393
$L40394:

; 1043 : 			m_IdealActivity = m_Activity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2068]
	mov	DWORD PTR [ecx+2072], eax

; 1045 : 		else if ( pev->waterlevel > 1 )

	jmp	SHORT $L40399
$L40393:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 1
	jle	SHORT $L40396

; 1047 : 			if ( speed == 0 )

	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40397

; 1048 : 				m_IdealActivity = ACT_HOVER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2072], 50		; 00000032H

; 1049 : 			else

	jmp	SHORT $L40398
$L40397:

; 1050 : 				m_IdealActivity = ACT_SWIM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], 6
$L40398:

; 1052 : 		else

	jmp	SHORT $L40399
$L40396:

; 1054 : 			m_IdealActivity = ACT_WALK;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2072], 3
$L40399:
$L40379:

; 1060 : 	{

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2072]
	mov	DWORD PTR -88+[ebp], ecx
	cmp	DWORD PTR -88+[ebp], 3
	je	$L40416
	cmp	DWORD PTR -88+[ebp], 28			; 0000001cH
	je	$L40407

; 1061 : 	case ACT_HOVER:
; 1062 : 	case ACT_LEAP:
; 1063 : 	case ACT_SWIM:
; 1064 : 	case ACT_HOP:
; 1065 : 	case ACT_DIESIMPLE:
; 1066 : 	default:
; 1067 : 		if ( m_Activity == m_IdealActivity)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2068]
	cmp	ecx, DWORD PTR [eax+2072]
	jne	SHORT $L40405

; 1068 : 			return;

	jmp	$L40373
$L40405:

; 1069 : 		m_Activity = m_IdealActivity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2072]
	mov	DWORD PTR [edx+2068], ecx

; 1070 : 
; 1071 : 		animDesired = LookupActivity( m_Activity );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2068]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	DWORD PTR _animDesired$[ebp], eax

; 1072 : 		// Already using the desired animation?
; 1073 : 		if (pev->sequence == animDesired)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+296]
	cmp	eax, DWORD PTR _animDesired$[ebp]
	jne	SHORT $L40406

; 1074 : 			return;

	jmp	$L40373
$L40406:

; 1075 : 
; 1076 : 		pev->gaitsequence = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+300], 0

; 1077 : 		pev->sequence		= animDesired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _animDesired$[ebp]
	mov	DWORD PTR [ecx+296], edx

; 1078 : 		pev->frame			= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+304], 0

; 1079 : 		ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo

; 1080 : 		return;

	jmp	$L40373
$L40407:

; 1081 : 
; 1082 : 	case ACT_RANGE_ATTACK1:
; 1083 : 		if ( FBitSet( pev->flags, FL_DUCKING ) )	// crouching

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 16384				; 00004000H
	test	ecx, ecx
	je	SHORT $L40408

; 1084 : 			strcpy( szAnim, "crouch_shoot_" );

	push	OFFSET FLAT:??_C@_0O@KCNB@crouch_shoot_?$AA@ ; `string'
	lea	edx, DWORD PTR _szAnim$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1085 : 		else

	jmp	SHORT $L40410
$L40408:

; 1086 : 			strcpy( szAnim, "ref_shoot_" );

	push	OFFSET FLAT:??_C@_0L@FJK@ref_shoot_?$AA@ ; `string'
	lea	eax, DWORD PTR _szAnim$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L40410:

; 1087 : 		strcat( szAnim, m_szAnimExtention );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3820				; 00000eecH
	push	ecx
	lea	edx, DWORD PTR _szAnim$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1088 : 		animDesired = LookupSequence( szAnim );

	lea	eax, DWORD PTR _szAnim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _animDesired$[ebp], eax

; 1089 : 		if (animDesired == -1)

	cmp	DWORD PTR _animDesired$[ebp], -1
	jne	SHORT $L40412

; 1090 : 			animDesired = 0;

	mov	DWORD PTR _animDesired$[ebp], 0
$L40412:

; 1091 : 
; 1092 : 		if ( pev->sequence != animDesired || !m_fSequenceLoops )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+296]
	cmp	eax, DWORD PTR _animDesired$[ebp]
	jne	SHORT $L40414
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	jne	SHORT $L40413
$L40414:

; 1094 : 			pev->frame = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+304], 0
$L40413:

; 1096 : 
; 1097 : 		if (!m_fSequenceLoops)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	jne	SHORT $L40415

; 1099 : 			pev->effects |= EF_NOINTERP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx
$L40415:

; 1101 : 
; 1102 : 		m_Activity = m_IdealActivity;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2072]
	mov	DWORD PTR [ecx+2068], eax

; 1103 : 
; 1104 : 		pev->sequence		= animDesired;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _animDesired$[ebp]
	mov	DWORD PTR [edx+296], eax

; 1105 : 		ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo

; 1106 : 		break;

	jmp	$L40401
$L40416:

; 1107 : 
; 1108 : 	case ACT_WALK:
; 1109 : 		if (m_Activity != ACT_RANGE_ATTACK1 || m_fSequenceFinished)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2068], 28		; 0000001cH
	jne	SHORT $L40418
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1804], 0
	je	SHORT $L40417
$L40418:

; 1111 : 			if ( FBitSet( pev->flags, FL_DUCKING ) )	// crouching

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 16384				; 00004000H
	test	edx, edx
	je	SHORT $L40419

; 1112 : 				strcpy( szAnim, "crouch_aim_" );

	push	OFFSET FLAT:??_C@_0M@OOG@crouch_aim_?$AA@ ; `string'
	lea	eax, DWORD PTR _szAnim$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1113 : 			else

	jmp	SHORT $L40421
$L40419:

; 1114 : 				strcpy( szAnim, "ref_aim_" );

	push	OFFSET FLAT:??_C@_08GBMH@ref_aim_?$AA@	; `string'
	lea	ecx, DWORD PTR _szAnim$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$L40421:

; 1115 : 			strcat( szAnim, m_szAnimExtention );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3820				; 00000eecH
	push	edx
	lea	eax, DWORD PTR _szAnim$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1116 : 			animDesired = LookupSequence( szAnim );

	lea	ecx, DWORD PTR _szAnim$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	DWORD PTR _animDesired$[ebp], eax

; 1117 : 			if (animDesired == -1)

	cmp	DWORD PTR _animDesired$[ebp], -1
	jne	SHORT $L40423

; 1118 : 				animDesired = 0;

	mov	DWORD PTR _animDesired$[ebp], 0
$L40423:

; 1119 : 			m_Activity = ACT_WALK;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2068], 3

; 1121 : 		else

	jmp	SHORT $L40424
$L40417:

; 1123 : 			animDesired = pev->sequence;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+296]
	mov	DWORD PTR _animDesired$[ebp], edx
$L40424:
$L40401:

; 1126 : 
; 1127 : 	if ( FBitSet( pev->flags, FL_DUCKING ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 16384				; 00004000H
	test	edx, edx
	je	SHORT $L40425

; 1129 : 		if ( speed == 0)

	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40426

; 1131 : 			pev->gaitsequence	= LookupActivity( ACT_CROUCHIDLE );

	push	18					; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+300], eax

; 1134 : 		else

	jmp	SHORT $L40427
$L40426:

; 1136 : 			pev->gaitsequence	= LookupActivity( ACT_CROUCH );

	push	17					; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+300], eax
$L40427:

; 1139 : 	else if ( speed > 220 )

	jmp	SHORT $L40432
$L40425:
	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@4006dc00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40429

; 1141 : 		pev->gaitsequence	= LookupActivity( ACT_RUN );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+300], eax

; 1143 : 	else if (speed > 0)

	jmp	SHORT $L40432
$L40429:
	fld	DWORD PTR _speed$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40431

; 1145 : 		pev->gaitsequence	= LookupActivity( ACT_WALK );

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+300], eax

; 1147 : 	else

	jmp	SHORT $L40432
$L40431:

; 1149 : 		// pev->gaitsequence	= LookupActivity( ACT_WALK );
; 1150 : 		pev->gaitsequence	= LookupSequence( "deep_idle" );

	push	OFFSET FLAT:??_C@_09KCMO@deep_idle?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+300], eax
$L40432:

; 1152 : 
; 1153 : 
; 1154 : 	// Already using the desired animation?
; 1155 : 	if (pev->sequence == animDesired)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+296]
	cmp	edx, DWORD PTR _animDesired$[ebp]
	jne	SHORT $L40434

; 1156 : 		return;

	jmp	SHORT $L40373
$L40434:

; 1157 : 
; 1158 : 	//ALERT( at_console, "Set animation to %d\n", animDesired );
; 1159 : 	// Reset to first frame of desired animation
; 1160 : 	pev->sequence		= animDesired;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _animDesired$[ebp]
	mov	DWORD PTR [ecx+296], edx

; 1161 : 	pev->frame			= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+304], 0

; 1162 : 	ResetSequenceInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetSequenceInfo@CBaseAnimating@@QAEXXZ ; CBaseAnimating::ResetSequenceInfo
$L40373:

; 1163 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L43833:
	DD	$L40392
	DD	$L40392
	DD	$L40382
	DD	$L40383
	DD	$L40384
	DD	$L40385
$L43835:
	DD	$L40390
	DD	$L40391
$L43834:
	DB	0
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ENDP	; CBasePlayer::SetAnimation
_TEXT	ENDS
EXTRN	_sqrt:NEAR
;	COMDAT ?Length2D@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length2D@Vector@@QBEMXZ PROC NEAR			; Vector::Length2D, COMDAT

; 282  : 	inline float Length2D(void) const { return sqrt(x*x + y*y); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length2D@Vector@@QBEMXZ ENDP				; Vector::Length2D
_TEXT	ENDS
PUBLIC	??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@BCPL@player?1pl_swim1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@PCJE@player?1pl_swim2?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@FCLB@player?1pl_swim3?4wav?$AA@	; `string'
PUBLIC	??_C@_0BE@DCEL@player?1pl_swim4?4wav?$AA@	; `string'
PUBLIC	?VARS@@YAPAUentvars_s@@H@Z			; VARS
PUBLIC	?WaterMove@CBasePlayer@@QAEXXZ			; CBasePlayer::WaterMove
PUBLIC	__real@4@40029000000000000000
PUBLIC	__real@4@4002c000000000000000
PUBLIC	__real@4@4001a000000000000000
;	COMDAT ??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ DB 'player/pl_wade1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ DB 'player/pl_wade2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BCPL@player?1pl_swim1?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@BCPL@player?1pl_swim1?4wav?$AA@ DB 'player/pl_swim1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PCJE@player?1pl_swim2?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@PCJE@player?1pl_swim2?4wav?$AA@ DB 'player/pl_swim2.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FCLB@player?1pl_swim3?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@FCLB@player?1pl_swim3?4wav?$AA@ DB 'player/pl_swim3.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DCEL@player?1pl_swim4?4wav?$AA@
CONST	SEGMENT
??_C@_0BE@DCEL@player?1pl_swim4?4wav?$AA@ DB 'player/pl_swim4.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@40029000000000000000
CONST	SEGMENT
__real@4@40029000000000000000 DD 041100000r	; 9
CONST	ENDS
;	COMDAT __real@4@4002c000000000000000
CONST	SEGMENT
__real@4@4002c000000000000000 DD 041400000r	; 12
CONST	ENDS
;	COMDAT __real@4@4001a000000000000000
CONST	SEGMENT
__real@4@4001a000000000000000 DD 040a00000r	; 5
CONST	ENDS
;	COMDAT ?WaterMove@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_air$ = -8
?WaterMove@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::WaterMove, COMDAT

; 1173 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1174 : 	int air;
; 1175 : 
; 1176 : 	if (pev->movetype == MOVETYPE_NOCLIP)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 8
	jne	SHORT $L40440

; 1177 : 		return;

	jmp	$L40438
$L40440:

; 1178 : 
; 1179 : 	if (pev->health < 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40441

; 1180 : 		return;

	jmp	$L40438
$L40441:

; 1181 : 
; 1182 : 	// waterlevel 0 - not in water
; 1183 : 	// waterlevel 1 - feet in water
; 1184 : 	// waterlevel 2 - waist in water
; 1185 : 	// waterlevel 3 - head in water
; 1186 : 
; 1187 : 	if (pev->waterlevel != 3)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 3
	je	$L40442

; 1189 : 		// not underwater
; 1190 : 
; 1191 : 		// play 'up for air' sound
; 1192 : 		if (pev->air_finished < gpGlobals->time)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+508]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40443

; 1193 : 			EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_wade1.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@GELK@player?1pl_wade1?4wav?$AA@ ; `string'
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 1194 : 		else if (pev->air_finished < gpGlobals->time + 9)

	jmp	SHORT $L40447
$L40443:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@40029000000000000000
	fcomp	DWORD PTR [eax+508]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40447

; 1195 : 			EMIT_SOUND(ENT(pev), CHAN_VOICE, "player/pl_wade2.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BE@IENF@player?1pl_wade2?4wav?$AA@ ; `string'
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40447:

; 1196 : 
; 1197 : 		pev->air_finished = gpGlobals->time + AIRTIME;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@4002c000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+508]

; 1198 : 		pev->dmg = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+480], 1073741824		; 40000000H

; 1199 : 
; 1200 : 		// if we took drowning damage, give it back slowly
; 1201 : 		if (m_idrowndmg > m_idrownrestored)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2836]
	cmp	edx, DWORD PTR [ecx+2840]
	jle	SHORT $L40450

; 1203 : 			// set drowning damage bit.  hack - dmg_drownrecover actually
; 1204 : 			// makes the time based damage code 'give back' health over time.
; 1205 : 			// make sure counter is cleared so we start count correctly.
; 1206 : 
; 1207 : 			// NOTE: this actually causes the count to continue restarting
; 1208 : 			// until all drowning damage is healed.
; 1209 : 
; 1210 : 			m_bitsDamageType |= DMG_DROWNRECOVER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2312]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2312], ecx

; 1211 : 			m_bitsDamageType &= ~DMG_DROWN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2312]
	and	ch, -65					; ffffffbfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2312], ecx

; 1212 : 			m_rgbTimeBasedDamage[itbd_DrownRecover] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+2320], 0
$L40450:

; 1216 : 	else

	jmp	$L40455
$L40442:

; 1218 : 		// stop restoring damage while underwater
; 1219 : 		m_bitsDamageType &= ~DMG_DROWNRECOVER;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2312]
	and	edx, -524289				; fff7ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2312], edx

; 1220 : 		m_rgbTimeBasedDamage[itbd_DrownRecover] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+2320], 0

; 1221 : 
; 1222 : 		if (pev->air_finished < gpGlobals->time)		// drown!

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+508]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	$L40452

; 1224 : 			if (pev->pain_finished < gpGlobals->time)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+512]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	$L40453

; 1226 : 				// take drowning damage
; 1227 : 				pev->dmg += 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+480]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+480]

; 1228 : 				if (pev->dmg > 5)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+480]
	fcomp	DWORD PTR __real@4@4001a000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40454

; 1229 : 					pev->dmg = 5;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+480], 1084227584		; 40a00000H
$L40454:

; 1230 : 				TakeDamage(VARS(eoNullEntity), VARS(eoNullEntity), pev->dmg, DMG_DROWN);

	push	16384					; 00004000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+480]
	push	eax
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+96]

; 1231 : 				pev->pain_finished = gpGlobals->time + 1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+512]

; 1232 : 
; 1233 : 				// track drowning damage, give it back when
; 1234 : 				// player finally takes a breath
; 1235 : 
; 1236 : 				m_idrowndmg += pev->dmg;

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+2836]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fadd	DWORD PTR [edx+480]
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2836], eax
$L40453:

; 1239 : 		else

	jmp	SHORT $L40455
$L40452:

; 1241 : 			m_bitsDamageType &= ~DMG_DROWN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2312]
	and	ah, -65					; ffffffbfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2312], eax
$L40455:

; 1244 : 
; 1245 : 	if (!pev->waterlevel)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+448], 0
	jne	SHORT $L40456

; 1247 : 		if (FBitSet(pev->flags, FL_INWATER))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L40457

; 1249 : 			ClearBits(pev->flags, FL_INWATER);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	al, -17					; ffffffefH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+420], eax
$L40457:

; 1251 : 		return;

	jmp	$L40438
$L40456:

; 1253 : 
; 1254 : 	// make bubbles
; 1255 : 
; 1256 : 	air = (int)(pev->air_finished - gpGlobals->time);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+508]
	fsub	DWORD PTR [edx]
	call	__ftol
	mov	DWORD PTR _air$[ebp], eax

; 1257 : 	if (!RANDOM_LONG(0,0x1f) && RANDOM_LONG(0,AIRTIME-1) >= air)

	push	31					; 0000001fH
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	$L40461
	push	11					; 0000000bH
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	cmp	eax, DWORD PTR _air$[ebp]
	jl	$L40461

; 1260 : 			{

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR -12+[ebp], eax
	cmp	DWORD PTR -12+[ebp], 3
	ja	$L40461
	mov	eax, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L43846[eax*4]
$L40464:

; 1261 : 			case 0:	EMIT_SOUND(ENT(pev), CHAN_BODY, "player/pl_swim1.wav", 0.8, ATTN_NORM); break;

	push	1061997773				; 3f4ccccdH
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BE@BCPL@player?1pl_swim1?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	SHORT $L40461
$L40467:

; 1262 : 			case 1:	EMIT_SOUND(ENT(pev), CHAN_BODY, "player/pl_swim2.wav", 0.8, ATTN_NORM); break;

	push	1061997773				; 3f4ccccdH
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BE@PCJE@player?1pl_swim2?4wav?$AA@ ; `string'
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	SHORT $L40461
$L40470:

; 1263 : 			case 2:	EMIT_SOUND(ENT(pev), CHAN_BODY, "player/pl_swim3.wav", 0.8, ATTN_NORM); break;

	push	1061997773				; 3f4ccccdH
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BE@FCLB@player?1pl_swim3?4wav?$AA@ ; `string'
	push	4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
	jmp	SHORT $L40461
$L40473:

; 1264 : 			case 3:	EMIT_SOUND(ENT(pev), CHAN_BODY, "player/pl_swim4.wav", 0.8, ATTN_NORM); break;

	push	1061997773				; 3f4ccccdH
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BE@DCEL@player?1pl_swim4?4wav?$AA@ ; `string'
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40461:

; 1267 : 
; 1268 : 	if (pev->watertype == CONTENT_LAVA)		// do damage

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+452], -5			; fffffffbH
	jne	SHORT $L40476

; 1270 : 		if (pev->dmgtime < gpGlobals->time)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+484]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40477

; 1271 : 			TakeDamage(VARS(eoNullEntity), VARS(eoNullEntity), 10 * pev->waterlevel, DMG_BURN);

	push	8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+448]
	imul	ecx, 10					; 0000000aH
	mov	DWORD PTR -16+[ebp], ecx
	fild	DWORD PTR -16+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+96]
$L40477:

; 1273 : 	else if (pev->watertype == CONTENT_SLIME)		// do damage

	jmp	SHORT $L40479
$L40476:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+452], -4			; fffffffcH
	jne	SHORT $L40479

; 1275 : 		pev->dmgtime = gpGlobals->time + 1;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+484]

; 1276 : 		TakeDamage(VARS(eoNullEntity), VARS(eoNullEntity), 4 * pev->waterlevel, DMG_ACID);

	push	1048576					; 00100000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+448]
	shl	edx, 2
	mov	DWORD PTR -20+[ebp], edx
	fild	DWORD PTR -20+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+96]
$L40479:

; 1278 : 
; 1279 : 	if (!FBitSet(pev->flags, FL_INWATER))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 16					; 00000010H
	test	edx, edx
	jne	SHORT $L40480

; 1281 : 		SetBits(pev->flags, FL_INWATER);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 1282 : 		pev->dmgtime = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+484], 0
$L40480:
$L40438:

; 1284 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L43846:
	DD	$L40464
	DD	$L40467
	DD	$L40470
	DD	$L40473
?WaterMove@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::WaterMove
_TEXT	ENDS
PUBLIC	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z		; VARS
;	COMDAT ?VARS@@YAPAUentvars_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?VARS@@YAPAUentvars_s@@H@Z PROC NEAR			; VARS, COMDAT

; 185  : inline entvars_t* VARS(EOFFSET eoffset)				{ return VARS(ENT(eoffset)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@H@Z ENDP				; VARS
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z PROC NEAR		; VARS, COMDAT

; 178  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 179  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32448

; 180  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L32447
$L32448:

; 181  : 
; 182  : 	return &pent->v; 

	mov	eax, DWORD PTR _pent$[ebp]
	add	eax, 128				; 00000080H
$L32447:

; 183  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z ENDP		; VARS
_TEXT	ENDS
PUBLIC	?IsOnLadder@CBasePlayer@@QAEHXZ			; CBasePlayer::IsOnLadder
;	COMDAT ?IsOnLadder@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsOnLadder@CBasePlayer@@QAEHXZ PROC NEAR		; CBasePlayer::IsOnLadder, COMDAT

; 1289 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1290 : 	return ( pev->movetype == MOVETYPE_FLY );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+264], 5
	sete	al

; 1291 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsOnLadder@CBasePlayer@@QAEHXZ ENDP			; CBasePlayer::IsOnLadder
_TEXT	ENDS
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
PUBLIC	??D@YA?AVVector@@MABV0@@Z			; operator*
PUBLIC	?StartDeathCam@CBasePlayer@@QAEXXZ		; CBasePlayer::StartDeathCam
PUBLIC	?HasWeapons@CBasePlayer@@QAEHXZ			; CBasePlayer::HasWeapons
PUBLIC	__real@4@4003a000000000000000
PUBLIC	__real@4@4005f000000000000000
PUBLIC	__real@4@4001c000000000000000
PUBLIC	?StopAnimation@CBaseMonster@@QAEXXZ		; CBaseMonster::StopAnimation
EXTRN	?StudioFrameAdvance@CBaseAnimating@@QAEMM@Z:NEAR ; CBaseAnimating::StudioFrameAdvance
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
EXTRN	?forcerespawn@@3Ucvar_s@@A:BYTE			; forcerespawn
EXTRN	?respawn@@YAXPAVCBaseEntity@@H@Z:NEAR		; respawn
;	COMDAT __real@4@4003a000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@4003a000000000000000 DD 041a00000r	; 20
CONST	ENDS
;	COMDAT __real@4@4005f000000000000000
CONST	SEGMENT
__real@4@4005f000000000000000 DD 042f00000r	; 120
CONST	ENDS
;	COMDAT __real@4@4001c000000000000000
CONST	SEGMENT
__real@4@4001c000000000000000 DD 040c00000r	; 6
CONST	ENDS
;	COMDAT ?PlayerDeathThink@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_flForward$ = -8
_fAnyButtonDown$ = -12
$T43855 = -24
$T43856 = -36
?PlayerDeathThink@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::PlayerDeathThink, COMDAT

; 1294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1295 : 	float flForward;
; 1296 : 
; 1297 : 	if (FBitSet(pev->flags, FL_ONGROUND))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40492

; 1299 : 		flForward = GetAbsVelocity().Length() - 20;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fsub	DWORD PTR __real@4@4003a000000000000000
	fstp	DWORD PTR _flForward$[ebp]

; 1300 : 		if (flForward <= 0)

	fld	DWORD PTR _flForward$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40491

; 1301 : 			SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1302 : 		else

	jmp	SHORT $L40492
$L40491:

; 1303 : 			SetAbsVelocity( flForward * GetAbsVelocity().Normalize() );

	lea	eax, DWORD PTR $T43855[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	mov	ecx, DWORD PTR _flForward$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T43856[ebp]
	push	edx
	call	??D@YA?AVVector@@MABV0@@Z		; operator*
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L40492:

; 1305 : 
; 1306 : 	if ( HasWeapons() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapons@CBasePlayer@@QAEHXZ		; CBasePlayer::HasWeapons
	test	eax, eax
	je	SHORT $L40495

; 1308 : 		// we drop the guns here because weapons that have an area effect and can kill their user
; 1309 : 		// will sometimes crash coming back from CBasePlayer::Killed() if they kill their owner because the
; 1310 : 		// player class sometimes is freed. It's safer to manipulate the weapons once we know
; 1311 : 		// we aren't calling into any of their code anymore through the player pointer.
; 1312 : 		PackDeadPlayerItems();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PackDeadPlayerItems@CBasePlayer@@QAEXXZ ; CBasePlayer::PackDeadPlayerItems
$L40495:

; 1314 : 
; 1315 : 
; 1316 : 	if (pev->modelindex && (!m_fSequenceFinished) && (pev->deadflag == DEAD_DYING))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+180], 0
	je	SHORT $L40497
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1804], 0
	jne	SHORT $L40497
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 1
	jne	SHORT $L40497

; 1318 : 		StudioFrameAdvance( );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioFrameAdvance@CBaseAnimating@@QAEMM@Z ; CBaseAnimating::StudioFrameAdvance
	fstp	ST(0)

; 1319 : 
; 1320 : 		m_iRespawnFrames++;				// Note, these aren't necessarily real "frames", so behavior is dependent on # of client movement commands

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+3784]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+3784]

; 1321 : 		if ( m_iRespawnFrames < 120 )   // Animations should be no longer than this

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+3784]
	fcomp	DWORD PTR __real@4@4005f000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40497

; 1322 : 			return;

	jmp	$L40488
$L40497:

; 1324 : 
; 1325 : 	// once we're done animating our death and we're on the ground, we want to set movetype to None so our dead body won't do collisions and stuff anymore
; 1326 : 	// this prevents a bug where the dead body would go to a player's head if he walked over it while the dead player was clicking their button to respawn
; 1327 : 	if ( pev->movetype != MOVETYPE_NONE && FBitSet(pev->flags, FL_ONGROUND) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 0
	je	SHORT $L40498
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L40498

; 1328 : 		pev->movetype = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 0
$L40498:

; 1329 : 
; 1330 : 	if (pev->deadflag == DEAD_DYING)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 1
	jne	SHORT $L40499

; 1331 : 		pev->deadflag = DEAD_DEAD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+368], 2
$L40499:

; 1332 : 
; 1333 : 	StopAnimation();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StopAnimation@CBaseMonster@@QAEXXZ	; CBaseMonster::StopAnimation

; 1334 : 
; 1335 : 	pev->effects |= EF_NOINTERP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	al, 32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax

; 1336 : 	pev->framerate = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+312], 0

; 1337 : 
; 1338 : 	BOOL fAnyButtonDown = (pev->button & ~IN_SCORE );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ch, 127					; 0000007fH
	mov	DWORD PTR _fAnyButtonDown$[ebp], ecx

; 1339 : 
; 1340 : 	// wait for all buttons released
; 1341 : 	if (pev->deadflag == DEAD_DEAD)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+368], 2
	jne	SHORT $L40501

; 1343 : 		if (fAnyButtonDown)

	cmp	DWORD PTR _fAnyButtonDown$[ebp], 0
	je	SHORT $L40502

; 1344 : 			return;

	jmp	$L40488
$L40502:

; 1345 : 
; 1346 : 		if ( g_pGameRules->FPlayerCanRespawn( this ) )

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+80]
	test	eax, eax
	je	SHORT $L40503

; 1348 : 			m_fDeadTime = gpGlobals->time;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+2896], eax

; 1349 : 			pev->deadflag = DEAD_RESPAWNABLE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+368], 3
$L40503:

; 1351 : 
; 1352 : 		return;

	jmp	$L40488
$L40501:

; 1354 : 
; 1355 : // if the player has been dead for one second longer than allowed by forcerespawn,
; 1356 : // forcerespawn isn't on. Send the player off to an intermission camera until they
; 1357 : // choose to respawn.
; 1358 : 	if ( g_pGameRules->IsMultiplayer() && ( gpGlobals->time > (m_fDeadTime + 6) ) && !(m_afPhysicsFlags & PFLAG_OBSERVER) )

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L40504
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+2896]
	fadd	DWORD PTR __real@4@4001c000000000000000
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40504
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $L40504

; 1360 : 		// go to dead camera.
; 1361 : 		StartDeathCam();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartDeathCam@CBasePlayer@@QAEXXZ	; CBasePlayer::StartDeathCam
$L40504:

; 1366 : 		&& !( g_pGameRules->IsMultiplayer() && forcerespawn.value > 0 && (gpGlobals->time > (m_fDeadTime + 5))) )

	cmp	DWORD PTR _fAnyButtonDown$[ebp], 0
	jne	SHORT $L40505
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L40506
	fld	DWORD PTR ?forcerespawn@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40506
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+2896]
	fadd	DWORD PTR __real@4@4001a000000000000000
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L40505
$L40506:

; 1367 : 		return;

	jmp	SHORT $L40488
$L40505:

; 1368 : 
; 1369 : 	pev->button = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+384], 0

; 1370 : 	m_iRespawnFrames = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3784], 0

; 1371 : 
; 1372 : 	//ALERT(at_console, "Respawn\n");
; 1373 : 
; 1374 : 	respawn( this, !(m_afPhysicsFlags & PFLAG_OBSERVER) );// don't copy a corpse if we're in deathcam.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	inc	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?respawn@@YAXPAVCBaseEntity@@H@Z	; respawn
	add	esp, 8

; 1375 : 	pev->nextthink = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+260], -1082130432	; bf800000H
$L40488:

; 1376 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayerDeathThink@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::PlayerDeathThink
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T43867 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L24894

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T43867[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24892
$L24894:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24892:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
;	COMDAT ??D@YA?AVVector@@MABV0@@Z
_TEXT	SEGMENT
_fl$ = 12
_v$ = 16
___$ReturnUdt$ = 8
$T43870 = -12
??D@YA?AVVector@@MABV0@@Z PROC NEAR			; operator*, COMDAT

; 288  : inline Vector operator* ( float fl, const Vector& v ) { return v * fl; }

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _fl$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T43870[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??D@YA?AVVector@@MABV0@@Z ENDP				; operator*
_TEXT	ENDS
;	COMDAT ?StopAnimation@CBaseMonster@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopAnimation@CBaseMonster@@QAEXXZ PROC NEAR		; CBaseMonster::StopAnimation, COMDAT

; 179  : 		inline void StopAnimation( void ) { pev->framerate = 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+312], 0
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopAnimation@CBaseMonster@@QAEXXZ ENDP		; CBaseMonster::StopAnimation
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	??_C@_0BC@FEBM@info_intermission?$AA@		; `string'
PUBLIC	?FIND_ENTITY_BY_CLASSNAME@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_CLASSNAME
PUBLIC	?StartObserver@CBasePlayer@@QAEXVVector@@0@Z	; CBasePlayer::StartObserver
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
EXTRN	?CopyToBodyQue@@YAXPAVCBaseEntity@@@Z:NEAR	; CopyToBodyQue
EXTRN	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z:NEAR	; UTIL_VecToAngles
EXTRN	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceLine
;	COMDAT ??_C@_0BC@FEBM@info_intermission?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BC@FEBM@info_intermission?$AA@ DB 'info_intermission', 00H ; `string'
CONST	ENDS
;	COMDAT ?StartDeathCam@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pSpot$ = -8
_pNewSpot$ = -12
_iRand$ = -16
_tr$40524 = -72
$T43877 = -92
$T43878 = -104
$T43880 = -120
$T43881 = -132
?StartDeathCam@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::StartDeathCam, COMDAT

; 1383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 200				; 000000c8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 	edict_t *pSpot, *pNewSpot;
; 1385 : 	int iRand;
; 1386 : 
; 1387 : 	if ( pev->view_ofs == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L40514

; 1389 : 		// don't accept subsequent attempts to StartDeathCam()
; 1390 : 		return;

	jmp	$L40510
$L40514:

; 1392 : 
; 1393 : 	pSpot = FIND_ENTITY_BY_CLASSNAME( NULL, "info_intermission");

	push	OFFSET FLAT:??_C@_0BC@FEBM@info_intermission?$AA@ ; `string'
	push	0
	call	?FIND_ENTITY_BY_CLASSNAME@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_CLASSNAME
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax

; 1394 : 
; 1395 : 	if ( !FNullEnt( pSpot ) )

	mov	ecx, DWORD PTR _pSpot$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L40516

; 1397 : 		// at least one intermission spot in the world.
; 1398 : 		iRand = RANDOM_LONG( 0, 3 );

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR _iRand$[ebp], eax
$L40518:

; 1399 : 
; 1400 : 		while ( iRand > 0 )

	cmp	DWORD PTR _iRand$[ebp], 0
	jle	SHORT $L40519

; 1402 : 			pNewSpot = FIND_ENTITY_BY_CLASSNAME( pSpot, "info_intermission");

	push	OFFSET FLAT:??_C@_0BC@FEBM@info_intermission?$AA@ ; `string'
	mov	edx, DWORD PTR _pSpot$[ebp]
	push	edx
	call	?FIND_ENTITY_BY_CLASSNAME@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_CLASSNAME
	add	esp, 8
	mov	DWORD PTR _pNewSpot$[ebp], eax

; 1403 : 
; 1404 : 			if ( pNewSpot )

	cmp	DWORD PTR _pNewSpot$[ebp], 0
	je	SHORT $L40520

; 1406 : 				pSpot = pNewSpot;

	mov	eax, DWORD PTR _pNewSpot$[ebp]
	mov	DWORD PTR _pSpot$[ebp], eax
$L40520:

; 1408 : 
; 1409 : 			iRand--;

	mov	ecx, DWORD PTR _iRand$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _iRand$[ebp], ecx

; 1410 : 		}

	jmp	SHORT $L40518
$L40519:

; 1411 : 
; 1412 : 		CopyToBodyQue( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?CopyToBodyQue@@YAXPAVCBaseEntity@@@Z	; CopyToBodyQue
	add	esp, 4

; 1413 : 		StartObserver( pSpot->v.origin, pSpot->v.v_angle );

	mov	eax, DWORD PTR _pSpot$[ebp]
	add	eax, 244				; 000000f4H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _pSpot$[ebp]
	add	ecx, 136				; 00000088H
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	push	ecx
	mov	ecx, edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartObserver@CBasePlayer@@QAEXVVector@@0@Z ; CBasePlayer::StartObserver

; 1415 : 	else

	jmp	$L40523
$L40516:

; 1417 : 		// no intermission spot. Push them up in the air, looking down at their corpse
; 1418 : 		TraceResult tr;

	lea	ecx, DWORD PTR _tr$40524[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1419 : 		CopyToBodyQue( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?CopyToBodyQue@@YAXPAVCBaseEntity@@@Z	; CopyToBodyQue
	add	esp, 4

; 1420 : 		UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin() + Vector( 0, 0, 128 ), ignore_monsters, edict(), &tr );

	lea	ecx, DWORD PTR _tr$40524[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	push	1124073472				; 43000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T43877[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T43878[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1421 : 		StartObserver( tr.vecEndPos, UTIL_VecToAngles( tr.vecEndPos - GetAbsOrigin()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T43880[ebp]
	push	eax
	lea	ecx, DWORD PTR _tr$40524[ebp+20]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR $T43881[ebp]
	push	ecx
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, -4					; fffffffcH
	mov	ecx, esp
	push	eax
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	lea	edx, DWORD PTR _tr$40524[ebp+20]
	push	edx
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StartObserver@CBasePlayer@@QAEXVVector@@0@Z ; CBasePlayer::StartObserver
$L40523:
$L40510:

; 1424 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartDeathCam@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::StartDeathCam
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L43885
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L43885
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L43885
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L43886
$L43885:
	mov	DWORD PTR -8+[ebp], 0
$L43886:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T43889 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T43889[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T43892 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T43892[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
PUBLIC	??_C@_09JDJH@classname?$AA@			; `string'
;	COMDAT ??_C@_09JDJH@classname?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_09JDJH@classname?$AA@ DB 'classname', 00H		; `string'
CONST	ENDS
;	COMDAT ?FIND_ENTITY_BY_CLASSNAME@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT
_entStart$ = 8
_pszName$ = 12
?FIND_ENTITY_BY_CLASSNAME@@YAPAUedict_s@@PAU1@PBD@Z PROC NEAR ; FIND_ENTITY_BY_CLASSNAME, COMDAT

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 110  : 	return FIND_ENTITY_BY_STRING(entStart, "classname", pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_09JDJH@classname?$AA@	; `string'
	mov	ecx, DWORD PTR _entStart$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+56
	add	esp, 12					; 0000000cH

; 111  : }	

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FIND_ENTITY_BY_CLASSNAME@@YAPAUedict_s@@PAU1@PBD@Z ENDP ; FIND_ENTITY_BY_CLASSNAME
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L43897
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L43897
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L43898
$L43897:
	mov	DWORD PTR -4+[ebp], 1
$L43898:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
EXTRN	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z:NEAR ; UTIL_SetOrigin
;	COMDAT ?StartObserver@CBasePlayer@@QAEXVVector@@0@Z
_TEXT	SEGMENT
_vecPosition$ = 8
_vecViewAngle$ = 20
_this$ = -4
?StartObserver@CBasePlayer@@QAEXVVector@@0@Z PROC NEAR	; CBasePlayer::StartObserver, COMDAT

; 1427 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1428 : 	m_afPhysicsFlags |= PFLAG_OBSERVER;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], ecx

; 1429 : 
; 1430 : 	pev->view_ofs = g_vecZero;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [ecx+8], edx

; 1431 : 	SetAbsAngles( vecViewAngle );

	lea	eax, DWORD PTR _vecViewAngle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 1432 : 	SnapEyeAngles( vecViewAngle );

	lea	ecx, DWORD PTR _vecViewAngle$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z ; CBasePlayer::SnapEyeAngles

; 1433 : 	pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 1434 : 	pev->takedamage = DAMAGE_NO;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+364], 0

; 1435 : 	pev->movetype = MOVETYPE_NONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 0

; 1436 : 	pev->modelindex = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+180], 0

; 1437 : 	UTIL_SetOrigin( this, vecPosition );

	lea	ecx, DWORD PTR _vecPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 1438 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?StartObserver@CBasePlayer@@QAEXVVector@@0@Z ENDP	; CBasePlayer::StartObserver
_TEXT	ENDS
PUBLIC	?GetSpeed@CFuncTrackTrain@@QAEMXZ		; CFuncTrackTrain::GetSpeed
PUBLIC	?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ		; CFuncTrackTrain::GetMaxSpeed
PUBLIC	?DotProduct@@YAMABVVector@@0@Z			; DotProduct
PUBLIC	??_C@_0BF@HOEM@plats?1train_use1?4wav?$AA@	; `string'
PUBLIC	??_C@_0BG@MCNG@common?1wpn_select?4wav?$AA@	; `string'
PUBLIC	?PlayerUse@CBasePlayer@@QAEXXZ			; CBasePlayer::PlayerUse
PUBLIC	?PickHoldableItem@CBasePlayer@@QAEXPAVCBaseEntity@@@Z ; CBasePlayer::PickHoldableItem
EXTRN	?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z:NEAR ; CFuncTrackTrain::Instance
EXTRN	?UTIL_ClampVectorToBox@@YA?AVVector@@ABV1@0@Z:NEAR ; UTIL_ClampVectorToBox
EXTRN	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z:NEAR ; VecBModelOrigin
EXTRN	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z:NEAR ; CBaseDelay::IsLockedByMaster
EXTRN	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z:NEAR ; UTIL_FindEntityInSphere
EXTRN	?UTIL_MakeVectors@@YAXABVVector@@@Z:NEAR	; UTIL_MakeVectors
;	COMDAT ??_C@_0BF@HOEM@plats?1train_use1?4wav?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BF@HOEM@plats?1train_use1?4wav?$AA@ DB 'plats/train_use1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MCNG@common?1wpn_select?4wav?$AA@
CONST	SEGMENT
??_C@_0BG@MCNG@common?1wpn_select?4wav?$AA@ DB 'common/wpn_select.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?PlayerUse@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTrain$40555 = -8
_pObject$ = -12
_pClosest$ = -16
_flMaxDot$ = -20
_tr$ = -76
_vecLOS$ = -88
_flDot$ = -92
_caps$40582 = -96
_caps$40591 = -100
$T43911 = -112
$T43912 = -124
$T43913 = -136
$T43914 = -148
$T43915 = -160
$T43916 = -172
$T43917 = -184
$T43918 = -196
$T43919 = -208
?PlayerUse@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::PlayerUse, COMDAT

; 1446 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1447 : 	// Was use pressed or released?
; 1448 : 	if ( ! ((pev->button | m_afButtonPressed | m_afButtonReleased) & IN_USE) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+384]
	or	eax, DWORD PTR [edx+2436]
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+2440]
	and	eax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $L40543

; 1449 : 		return;

	jmp	$L40542
$L40543:

; 1450 : 
; 1451 : 	m_afPhysicsFlags &= ~PFLAG_USING;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	al, -17					; ffffffefH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2488], eax

; 1452 : 
; 1453 : 	// Hit Use on a train?
; 1454 : 	if ( m_afButtonPressed & IN_USE )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2436]
	and	eax, 32					; 00000020H
	test	eax, eax
	je	$L40556

; 1456 : 		if ( m_pTank != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40545

; 1458 : 			// Stop controlling the tank
; 1459 : 			// TODO: Send HUD Update
; 1460 : 			m_pTank->Use( this, this, USE_OFF, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -212+[ebp], eax
	mov	eax, DWORD PTR -212+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -212+[ebp]
	call	DWORD PTR [edx+276]

; 1461 : 			m_pTank = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1462 : 			return;

	jmp	$L40542
$L40545:

; 1464 : 		else if ( m_pVehicle != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40547

; 1466 : 			// Trying to leave vehicle
; 1467 : 			m_pVehicle->Use( this, this, USE_OFF, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -216+[ebp], eax
	mov	edx, DWORD PTR -216+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -216+[ebp]
	call	DWORD PTR [eax+276]

; 1468 : 			return;

	jmp	$L40542
$L40547:

; 1470 : 		else if (m_pMonitor != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40549

; 1472 : 			m_pMonitor->Use( this, this, USE_RESET, 0 );

	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -220+[ebp], eax
	mov	eax, DWORD PTR -220+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -220+[ebp]
	call	DWORD PTR [edx+276]

; 1473 : 			m_pMonitor = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 1474 : 			return;

	jmp	$L40542
$L40549:

; 1476 : 		else if (m_pHoldableItem != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40551

; 1478 : 			DropHoldableItem ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DropHoldableItem@CBasePlayer@@QAEXXZ	; CBasePlayer::DropHoldableItem

; 1479 : 			return;

	jmp	$L40542
$L40551:

; 1483 : 			if ( m_afPhysicsFlags & PFLAG_ONTRAIN )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L40553

; 1485 : 				m_afPhysicsFlags &= ~PFLAG_ONTRAIN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	al, -3					; fffffffdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2488], eax

; 1486 : 				m_iTrain = TRAIN_NEW|TRAIN_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2856], 192		; 000000c0H

; 1487 : 				return;

	jmp	$L40542
$L40553:

; 1491 : 				CFuncTrackTrain *pTrain = CFuncTrackTrain::Instance( pev->groundentity );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+412]
	push	edx
	call	?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z ; CFuncTrackTrain::Instance
	add	esp, 4
	mov	DWORD PTR _pTrain$40555[ebp], eax

; 1492 : 
; 1493 : 				if ( pTrain && !(pev->button & IN_JUMP) && FBitSet(pev->flags, FL_ONGROUND) && (pTrain->ObjectCaps() & FCAP_DIRECTIONAL_USE) && pTrain->OnControls( this ))

	cmp	DWORD PTR _pTrain$40555[ebp], 0
	je	$L40556
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+384]
	and	edx, 2
	test	edx, edx
	jne	$L40556
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	$L40556
	mov	eax, DWORD PTR _pTrain$40555[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTrain$40555[ebp]
	call	DWORD PTR [edx+24]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	$L40556
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrain$40555[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTrain$40555[ebp]
	call	DWORD PTR [edx+192]
	test	eax, eax
	je	$L40556

; 1495 : 					m_afPhysicsFlags |= PFLAG_ONTRAIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], ecx

; 1496 : 					m_iTrain = TrainSpeed( pTrain->GetSpeed(), pTrain->GetMaxSpeed());

	mov	ecx, DWORD PTR _pTrain$40555[ebp]
	call	?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ	; CFuncTrackTrain::GetMaxSpeed
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _pTrain$40555[ebp]
	call	?GetSpeed@CFuncTrackTrain@@QAEMXZ	; CFuncTrackTrain::GetSpeed
	call	__ftol
	push	eax
	call	?TrainSpeed@@YAHHH@Z			; TrainSpeed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], eax

; 1497 : 
; 1498 : 					if( pTrain->IsLockedByMaster( this ))

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTrain$40555[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L40557

; 1500 : 						m_iTrain = TRAIN_LOCKED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2856], 8

; 1502 :                                                   else

	jmp	SHORT $L40559
$L40557:

; 1504 : 						if( pTrain->pev->speed == 0 )

	mov	ecx, DWORD PTR _pTrain$40555[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+504]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40559

; 1505 : 							EMIT_SOUND( ENT(pev), CHAN_ITEM, "plats/train_use1.wav", 0.8, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1061997773				; 3f4ccccdH
	push	OFFSET FLAT:??_C@_0BF@HOEM@plats?1train_use1?4wav?$AA@ ; `string'
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40559:

; 1507 : 					m_iTrain |= TRAIN_NEW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2856]
	or	al, -64					; ffffffc0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], eax

; 1508 : 					return;

	jmp	$L40542
$L40556:

; 1513 : 
; 1514 : 	CBaseEntity *pObject = NULL;

	mov	DWORD PTR _pObject$[ebp], 0

; 1515 : 	CBaseEntity *pClosest = NULL;

	mov	DWORD PTR _pClosest$[ebp], 0

; 1516 : 	float flMaxDot = VIEW_FIELD_NARROW;

	mov	DWORD PTR _flMaxDot$[ebp], 1060320051	; 3f333333H

; 1517 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1518 : 	Vector vecLOS;

	lea	ecx, DWORD PTR _vecLOS$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1519 : 	float flDot;
; 1520 : 
; 1521 : 	UTIL_MakeVectors( pev->v_angle ); // so we know which way we are facing

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 116				; 00000074H
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1522 : 
; 1523 : 	// LRC- try to get an exact entity to use.
; 1524 : 	// (is this causing "use-buttons-through-walls" problems? Surely not!)
; 1525 : 	UTIL_TraceLine( EyePosition(), EyePosition() + (gpGlobals->v_forward * PLAYER_SEARCH_RADIUS), dont_ignore_monsters, edict(), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	push	1115684864				; 42800000H
	lea	edx, DWORD PTR $T43912[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T43913[ebp]
	push	eax
	lea	ecx, DWORD PTR $T43911[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR $T43914[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1526 : 
; 1527 : 	if( tr.pHit )

	cmp	DWORD PTR _tr$[ebp+48], 0
	je	SHORT $L40575

; 1529 : 		pObject = CBaseEntity::Instance( tr.pHit );

	mov	ecx, DWORD PTR _tr$[ebp+48]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pObject$[ebp], eax

; 1530 : 		if( !pObject || !(pObject->ObjectCaps() & ( FCAP_IMPULSE_USE|FCAP_CONTINUOUS_USE|FCAP_ONOFF_USE|FCAP_HOLDABLE_ITEM )))

	cmp	DWORD PTR _pObject$[ebp], 0
	je	SHORT $L40576
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	DWORD PTR [eax+24]
	and	eax, 568				; 00000238H
	test	eax, eax
	jne	SHORT $L40575
$L40576:

; 1532 : 			pObject = NULL;

	mov	DWORD PTR _pObject$[ebp], 0
$L40575:

; 1535 : 
; 1536 : 	if( !pObject ) //LRC- couldn't find a direct solid object to use, try the normal method

	cmp	DWORD PTR _pObject$[ebp], 0
	jne	$L40577
$L40579:

; 1538 : 		while(( pObject = UTIL_FindEntityInSphere( pObject, GetAbsOrigin(), PLAYER_SEARCH_RADIUS )) != NULL )

	push	1115684864				; 42800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	push	ecx
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pObject$[ebp], eax
	cmp	DWORD PTR _pObject$[ebp], 0
	je	$L40580

; 1540 : 			int caps = pObject->ObjectCaps();

	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	DWORD PTR [eax+24]
	mov	DWORD PTR _caps$40582[ebp], eax

; 1541 : 			if( caps & (FCAP_IMPULSE_USE|FCAP_CONTINUOUS_USE|FCAP_ONOFF_USE|FCAP_HOLDABLE_ITEM) && !( caps & FCAP_ONLYDIRECT_USE ))

	mov	ecx, DWORD PTR _caps$40582[ebp]
	and	ecx, 568				; 00000238H
	test	ecx, ecx
	je	$L40589
	mov	edx, DWORD PTR _caps$40582[ebp]
	and	edx, 256				; 00000100H
	test	edx, edx
	jne	$L40589

; 1543 : 				// !!!PERFORMANCE- should this check be done on a per case basis AFTER we've determined that
; 1544 : 				// this object is actually usable? This dot is being done for every object within PLAYER_SEARCH_RADIUS
; 1545 : 				// when player hits the use key. How many objects can be in that area, anyway? (sjb)
; 1546 : 				vecLOS = (VecBModelOrigin( pObject->pev ) - EyePosition());

	lea	eax, DWORD PTR $T43916[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	lea	eax, DWORD PTR $T43917[ebp]
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T43915[ebp]
	push	eax
	call	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z ; VecBModelOrigin
	add	esp, 8
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecLOS$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLOS$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLOS$[ebp+8], eax

; 1547 : 
; 1548 : 				// This essentially moves the origin of the target to the corner nearest the player to test to see
; 1549 : 				// if it's "hull" is in the view cone
; 1550 : 				vecLOS = UTIL_ClampVectorToBox( vecLOS, pObject->pev->size * 0.5 );

	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T43918[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 244				; 000000f4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR _vecLOS$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T43919[ebp]
	push	ecx
	call	?UTIL_ClampVectorToBox@@YA?AVVector@@ABV1@0@Z ; UTIL_ClampVectorToBox
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecLOS$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecLOS$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecLOS$[ebp+8], edx

; 1551 : 
; 1552 : 				flDot = DotProduct (vecLOS , gpGlobals->v_forward);

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 40					; 00000028H
	push	eax
	lea	ecx, DWORD PTR _vecLOS$[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fstp	DWORD PTR _flDot$[ebp]

; 1553 : 				if (flDot > flMaxDot )

	fld	DWORD PTR _flDot$[ebp]
	fcomp	DWORD PTR _flMaxDot$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40589

; 1555 : 					// only if the item is in front of the user
; 1556 : 					pClosest = pObject;

	mov	edx, DWORD PTR _pObject$[ebp]
	mov	DWORD PTR _pClosest$[ebp], edx

; 1557 : 					flMaxDot = flDot;

	mov	eax, DWORD PTR _flDot$[ebp]
	mov	DWORD PTR _flMaxDot$[ebp], eax
$L40589:

; 1562 : 		}

	jmp	$L40579
$L40580:

; 1563 : 
; 1564 : 		pObject = pClosest;

	mov	ecx, DWORD PTR _pClosest$[ebp]
	mov	DWORD PTR _pObject$[ebp], ecx
$L40577:

; 1566 : 
; 1567 : 	// Found an object
; 1568 : 	if( pObject )

	cmp	DWORD PTR _pObject$[ebp], 0
	je	$L40602

; 1570 : 		//!!!UNDONE: traceline here to prevent USEing buttons through walls
; 1571 : 		int caps = pObject->ObjectCaps();

	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	DWORD PTR [eax+24]
	mov	DWORD PTR _caps$40591[ebp], eax

; 1572 : 
; 1573 : 		if ( m_afButtonPressed & IN_USE )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2436]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L40592

; 1574 : 			EMIT_SOUND( ENT(pev), CHAN_ITEM, "common/wpn_select.wav", 0.4, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1053609165				; 3ecccccdH
	push	OFFSET FLAT:??_C@_0BG@MCNG@common?1wpn_select?4wav?$AA@ ; `string'
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40592:

; 1577 : 			 ( (m_afButtonPressed & IN_USE) && (caps & (FCAP_IMPULSE_USE|FCAP_ONOFF_USE)) ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L40597
	mov	edx, DWORD PTR _caps$40591[ebp]
	and	edx, 16					; 00000010H
	test	edx, edx
	jne	SHORT $L40596
$L40597:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2436]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L40595
	mov	edx, DWORD PTR _caps$40591[ebp]
	and	edx, 40					; 00000028H
	test	edx, edx
	je	SHORT $L40595
$L40596:

; 1579 : 			if ( caps & FCAP_CONTINUOUS_USE )

	mov	eax, DWORD PTR _caps$40591[ebp]
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L40598

; 1580 : 				m_afPhysicsFlags |= PFLAG_USING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2488]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2488], edx
$L40598:

; 1581 : 
; 1582 : 			pObject->Use( this, this, USE_SET, 1 );

	push	1065353216				; 3f800000H
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pObject$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	DWORD PTR [edx+276]

; 1584 : 		// UNDONE: Send different USE codes for ON/OFF.  Cache last ONOFF_USE object to send 'off' if you turn away
; 1585 : 		else if ( (m_afButtonReleased & IN_USE) && (caps & FCAP_ONOFF_USE) )	// BUGBUG This is an "off" use

	jmp	SHORT $L40602
$L40595:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2440]
	and	ecx, 32					; 00000020H
	test	ecx, ecx
	je	SHORT $L40600
	mov	edx, DWORD PTR _caps$40591[ebp]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L40600

; 1587 : 			pObject->Use( this, this, USE_SET, 0 );

	push	0
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	DWORD PTR [eax+276]

; 1589 : 		else if ( (m_afButtonPressed & IN_USE) && (caps & FCAP_HOLDABLE_ITEM) )

	jmp	SHORT $L40602
$L40600:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2436]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L40602
	mov	eax, DWORD PTR _caps$40591[ebp]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L40602

; 1591 : 			// picked up the item
; 1592 : 			PickHoldableItem( pObject );

	mov	ecx, DWORD PTR _pObject$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PickHoldableItem@CBasePlayer@@QAEXPAVCBaseEntity@@@Z ; CBasePlayer::PickHoldableItem
$L40602:
$L40542:

; 1595 : 	/*else
; 1596 : 	{
; 1597 : 		if ( m_afButtonPressed & IN_USE )
; 1598 : 			EMIT_SOUND( ENT(pev), CHAN_ITEM, "common/wpn_denyselect.wav", 0.4, ATTN_NORM);
; 1599 : 	}*/
; 1600 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PlayerUse@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::PlayerUse
_TEXT	ENDS
;	COMDAT ?DotProduct@@YAMABVVector@@0@Z
_TEXT	SEGMENT
_a$ = 8
_b$ = 12
?DotProduct@@YAMABVVector@@0@Z PROC NEAR		; DotProduct, COMDAT

; 289  : inline float DotProduct(const Vector& a, const Vector& b ) { return( a.x * b.x + a.y * b.y + a.z * b.z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@@YAMABVVector@@0@Z ENDP			; DotProduct
_TEXT	ENDS
;	COMDAT ?GetSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetSpeed@CFuncTrackTrain@@QAEMXZ PROC NEAR		; CFuncTrackTrain::GetSpeed, COMDAT

; 152  : 	float GetSpeed( void ) { return m_flDesiredSpeed; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1896]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSpeed@CFuncTrackTrain@@QAEMXZ ENDP			; CFuncTrackTrain::GetSpeed
_TEXT	ENDS
;	COMDAT ?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ PROC NEAR		; CFuncTrackTrain::GetMaxSpeed, COMDAT

; 153  : 	float GetMaxSpeed( void ) { return m_maxSpeed; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1812]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ ENDP		; CFuncTrackTrain::GetMaxSpeed
_TEXT	ENDS
PUBLIC	?Jump@CBasePlayer@@UAEXXZ			; CBasePlayer::Jump
PUBLIC	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetBaseVelocity
PUBLIC	__real@4@4004c800000000000000
;	COMDAT __real@4@4004c800000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@4004c800000000000000 DD 042480000r	; 50
CONST	ENDS
;	COMDAT ?Jump@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecWallCheckDir$ = -16
_vecAdjustedVelocity$ = -28
_vecSpot$ = -40
_tr$ = -96
_pevGround$ = -100
?Jump@CBasePlayer@@UAEXXZ PROC NEAR			; CBasePlayer::Jump, COMDAT

; 1605 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1606 : 	Vector		vecWallCheckDir;// direction we're tracing a line to find a wall when walljumping

	lea	ecx, DWORD PTR _vecWallCheckDir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1607 : 	Vector		vecAdjustedVelocity;

	lea	ecx, DWORD PTR _vecAdjustedVelocity$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1608 : 	Vector		vecSpot;

	lea	ecx, DWORD PTR _vecSpot$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1609 : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1610 : 
; 1611 : 	if (FBitSet(pev->flags, FL_WATERJUMP))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 2048				; 00000800H
	test	edx, edx
	je	SHORT $L40610

; 1612 : 		return;

	jmp	$L40605
$L40610:

; 1613 : 
; 1614 : 	if (pev->waterlevel >= 2)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 2
	jl	SHORT $L40611

; 1616 : 		return;

	jmp	$L40605
$L40611:

; 1618 : 
; 1619 : 	// jump velocity is sqrt( height * gravity * 2)
; 1620 : 
; 1621 : 	// If this isn't the first frame pressing the jump button, break out.
; 1622 : 	if ( !FBitSet( m_afButtonPressed, IN_JUMP ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2436]
	and	eax, 2
	test	eax, eax
	jne	SHORT $L40612

; 1623 : 		return;         // don't pogo stick

	jmp	$L40605
$L40612:

; 1624 : 
; 1625 : 	if ( !(pev->flags & FL_ONGROUND) || !pev->groundentity )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L40614
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+412], 0
	jne	SHORT $L40613
$L40614:

; 1627 : 		return;

	jmp	$L40605
$L40613:

; 1629 : 
; 1630 : // many features in this function use v_forward, so makevectors now.
; 1631 : 	UTIL_MakeVectors (GetAbsAngles());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1632 : 
; 1633 : 	// ClearBits(pev->flags, FL_ONGROUND);		// don't stairwalk
; 1634 : 
; 1635 : 	SetAnimation( PLAYER_JUMP );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation

; 1638 : 		(pev->button & IN_DUCK) &&
; 1639 : 		( pev->flDuckTime > 0 ) &&
; 1640 : 		GetAbsVelocity().Length() > 50 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2904], 0
	je	SHORT $L40615
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 4
	test	eax, eax
	je	SHORT $L40615
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+556], 0
	jle	SHORT $L40615
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fcomp	DWORD PTR __real@4@4004c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40615

; 1642 : 		SetAnimation( PLAYER_SUPERJUMP );

	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation
$L40615:

; 1644 : 
; 1645 : 	// If you're standing on a conveyor, add it's velocity to yours (for momentum)
; 1646 : 	entvars_t *pevGround = VARS(pev->groundentity);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+412]
	push	edx
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pevGround$[ebp], eax

; 1647 : 	if ( pevGround && (pevGround->flags & FL_CONVEYOR) )

	cmp	DWORD PTR _pevGround$[ebp], 0
	je	SHORT $L40617
	mov	eax, DWORD PTR _pevGround$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 4
	test	ecx, ecx
	je	SHORT $L40617

; 1649 : 		ApplyAbsVelocityImpulse( GetBaseVelocity( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::ApplyAbsVelocityImpulse
$L40617:
$L40605:

; 1651 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Jump@CBasePlayer@@UAEXXZ ENDP				; CBasePlayer::Jump
_TEXT	ENDS
;	COMDAT ?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ PROC NEAR ; CBaseEntity::GetBaseVelocity, COMDAT

; 224  : 	const Vector&	GetBaseVelocity( void ) const { return pev->basevelocity; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, 44					; 0000002cH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetBaseVelocity
_TEXT	ENDS
PUBLIC	?Duck@CBasePlayer@@UAEXXZ			; CBasePlayer::Duck
;	COMDAT ?Duck@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Duck@CBasePlayer@@UAEXXZ PROC NEAR			; CBasePlayer::Duck, COMDAT

; 1654 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1655 : 	if (pev->button & IN_DUCK)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+384]
	and	edx, 4
	test	edx, edx
	je	SHORT $L40622

; 1657 : 		if ( m_IdealActivity != ACT_LEAP )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2072], 8
	je	SHORT $L40622

; 1659 : 			SetAnimation( PLAYER_WALK );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation
$L40622:

; 1662 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Duck@CBasePlayer@@UAEXXZ ENDP				; CBasePlayer::Duck
_TEXT	ENDS
PUBLIC	?Classify@CBasePlayer@@UAEHXZ			; CBasePlayer::Classify
;	COMDAT ?Classify@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBasePlayer@@UAEHXZ PROC NEAR			; CBasePlayer::Classify, COMDAT

; 1668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1669 : 	return CLASS_PLAYER;

	mov	eax, 2

; 1670 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::Classify
_TEXT	ENDS
PUBLIC	?AddPoints@CBasePlayer@@UAEXHH@Z		; CBasePlayer::AddPoints
;	COMDAT ?AddPoints@CBasePlayer@@UAEXHH@Z
_TEXT	SEGMENT
_score$ = 8
_bAllowNegativeScore$ = 12
_this$ = -4
?AddPoints@CBasePlayer@@UAEXHH@Z PROC NEAR		; CBasePlayer::AddPoints, COMDAT

; 1674 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1675 : 	// Positive score always adds
; 1676 : 	if ( score < 0 )

	cmp	DWORD PTR _score$[ebp], 0
	jge	SHORT $L40635

; 1678 : 		if ( !bAllowNegativeScore )

	cmp	DWORD PTR _bAllowNegativeScore$[ebp], 0
	jne	SHORT $L40635

; 1680 : 			if ( pev->frags < 0 )		// Can't go more negative

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+356]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40634

; 1681 : 				return;

	jmp	$L40631
$L40634:

; 1682 : 
; 1683 : 			if ( -score > pev->frags )	// Will this go negative?

	mov	edx, DWORD PTR _score$[ebp]
	neg	edx
	mov	DWORD PTR -8+[ebp], edx
	fild	DWORD PTR -8+[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fcomp	DWORD PTR [ecx+356]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40635

; 1685 : 				score = -pev->frags;		// Sum will be 0

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+356]
	fchs
	call	__ftol
	mov	DWORD PTR _score$[ebp], eax
$L40635:

; 1689 : 
; 1690 : 	pev->frags += score;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fild	DWORD PTR _score$[ebp]
	fadd	DWORD PTR [edx+356]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+356]

; 1691 : 
; 1692 : 	MESSAGE_BEGIN( MSG_ALL, gmsgScoreInfo );

	push	0
	push	0
	mov	edx, DWORD PTR ?gmsgScoreInfo@@3HA	; gmsgScoreInfo
	push	edx
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1693 : 		WRITE_BYTE( ENTINDEX(edict()) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1694 : 		WRITE_SHORT( pev->frags );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+356]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1695 : 		WRITE_SHORT( m_iDeaths );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3780]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1696 : 		WRITE_SHORT( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1697 : 		WRITE_SHORT( g_pGameRules->GetTeamIndex( m_szTeamName ) + 1 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3804				; 00000edcH
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+204]
	add	eax, 1
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1698 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L40631:

; 1699 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBasePlayer@@UAEXHH@Z ENDP			; CBasePlayer::AddPoints
_TEXT	ENDS
PUBLIC	?AddPointsToTeam@CBasePlayer@@UAEXHH@Z		; CBasePlayer::AddPointsToTeam
PUBLIC	?entindex@CBaseEntity@@QAEHXZ			; CBaseEntity::entindex
EXTRN	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z:NEAR	; UTIL_PlayerByIndex
;	COMDAT ?AddPointsToTeam@CBasePlayer@@UAEXHH@Z
_TEXT	SEGMENT
_score$ = 8
_bAllowNegativeScore$ = 12
_this$ = -4
_index$ = -8
_i$ = -12
_pPlayer$40646 = -16
?AddPointsToTeam@CBasePlayer@@UAEXHH@Z PROC NEAR	; CBasePlayer::AddPointsToTeam, COMDAT

; 1703 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1704 : 	int index = entindex();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	mov	DWORD PTR _index$[ebp], eax

; 1705 : 
; 1706 : 	for ( int i = 1; i <= gpGlobals->maxClients; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L40643
$L40644:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40643:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+144]
	jg	SHORT $L40645

; 1708 : 		CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$40646[ebp], eax

; 1709 : 
; 1710 : 		if ( pPlayer && i != index )

	cmp	DWORD PTR _pPlayer$40646[ebp], 0
	je	SHORT $L40648
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _index$[ebp]
	je	SHORT $L40648

; 1712 : 			if ( g_pGameRules->PlayerRelationship( this, pPlayer ) == GR_TEAMMATE )

	mov	edx, DWORD PTR _pPlayer$40646[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+200]
	cmp	eax, 1
	jne	SHORT $L40648

; 1714 : 				pPlayer->AddPoints( score, bAllowNegativeScore );

	mov	eax, DWORD PTR _bAllowNegativeScore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _score$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pPlayer$40646[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pPlayer$40646[ebp]
	call	DWORD PTR [eax+140]
$L40648:

; 1717 : 	}

	jmp	SHORT $L40644
$L40645:

; 1718 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBasePlayer@@UAEXHH@Z ENDP		; CBasePlayer::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?entindex@CBaseEntity@@QAEHXZ PROC NEAR			; CBaseEntity::entindex, COMDAT

; 712  : 	int entindex( ) { return ENTINDEX( edict() ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?entindex@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::entindex
_TEXT	ENDS
PUBLIC	?InitStatusBar@CBasePlayer@@QAEXXZ		; CBasePlayer::InitStatusBar
;	COMDAT ?InitStatusBar@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?InitStatusBar@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::InitStatusBar, COMDAT

; 1722 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1723 : 	m_flStatusBarDisappearDelay = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3872], 0

; 1724 : 	m_SbarString1[0] = m_SbarString0[0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+3876], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4004], 0

; 1725 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?InitStatusBar@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::InitStatusBar
_TEXT	ENDS
PUBLIC	??_C@_0CF@FGJL@1?5?$CFp1?62?5Health?3?5?$CFi2?$CF?$CF?63?5Armor?3?5?$CF@ ; `string'
PUBLIC	?UpdateStatusBar@CBasePlayer@@QAEXXZ		; CBasePlayer::UpdateStatusBar
PUBLIC	__real@8@3fff8000000000000000
PUBLIC	__real@4@4005c800000000000000
EXTRN	_strcmp:NEAR
;	COMDAT ??_C@_0CF@FGJL@1?5?$CFp1?62?5Health?3?5?$CFi2?$CF?$CF?63?5Armor?3?5?$CF@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0CF@FGJL@1?5?$CFp1?62?5Health?3?5?$CFi2?$CF?$CF?63?5Armor?3?5?$CF@ DB '1'
	DB	' %p1', 0aH, '2 Health: %i2%%', 0aH, '3 Armor: %i3%%', 00H ; `string'
CONST	ENDS
;	COMDAT __real@8@3fff8000000000000000
CONST	SEGMENT
__real@8@3fff8000000000000000 DQ 03ff0000000000000r ; 1
CONST	ENDS
;	COMDAT __real@4@4005c800000000000000
CONST	SEGMENT
__real@4@4005c800000000000000 DD 042c80000r	; 100
CONST	ENDS
;	COMDAT ?UpdateStatusBar@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_newSBarState$ = -20
_sbuf0$ = -148
_sbuf1$ = -276
_tr$ = -332
_vecSrc$ = -344
_vecEnd$ = -356
_pEntity$40667 = -360
_bForceResend$ = -364
_i$ = -368
$T43946 = -380
$T43947 = -392
$T43948 = -404
$T43949 = -416
?UpdateStatusBar@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::UpdateStatusBar, COMDAT

; 1728 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 480				; 000001e0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1729 : 	int newSBarState[ SBAR_END ];
; 1730 : 	char sbuf0[ SBAR_STRING_SIZE ];
; 1731 : 	char sbuf1[ SBAR_STRING_SIZE ];
; 1732 : 
; 1733 : 	memset( newSBarState, 0, sizeof(newSBarState) );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _newSBarState$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1734 : 	strcpy( sbuf0, m_SbarString0 );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3876				; 00000f24H
	push	ecx
	lea	edx, DWORD PTR _sbuf0$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1735 : 	strcpy( sbuf1, m_SbarString1 );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4004				; 00000fa4H
	push	eax
	lea	ecx, DWORD PTR _sbuf1$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1736 : 
; 1737 : 	// Find an ID Target
; 1738 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1739 : 	UTIL_MakeVectors( pev->v_angle + pev->punchangle );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 104				; 00000068H
	push	eax
	lea	ecx, DWORD PTR $T43946[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 116				; 00000074H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1740 : 	Vector vecSrc = EyePosition();

	lea	eax, DWORD PTR $T43947[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1741 : 	Vector vecEnd = vecSrc + (gpGlobals->v_forward * MAX_ID_RANGE);

	push	1157627904				; 45000000H
	lea	eax, DWORD PTR $T43948[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T43949[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecEnd$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1742 : 	UTIL_TraceLine( vecSrc, vecEnd, dont_ignore_monsters, edict(), &tr);

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	eax, DWORD PTR _vecEnd$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 1743 : 
; 1744 : 	if (tr.flFraction != 1.0)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L40672

; 1746 : 		if ( !FNullEnt( tr.pHit ) )

	mov	edx, DWORD PTR _tr$[ebp+48]
	push	edx
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L40666

; 1748 : 			CBaseEntity *pEntity = CBaseEntity::Instance( tr.pHit );

	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$40667[ebp], eax

; 1749 : 
; 1750 : 			if (pEntity && pEntity->Classify() == CLASS_PLAYER)

	cmp	DWORD PTR _pEntity$40667[ebp], 0
	je	$L40668
	mov	ecx, DWORD PTR _pEntity$40667[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$40667[ebp]
	call	DWORD PTR [edx+68]
	cmp	eax, 2
	jne	$L40668

; 1752 : 				newSBarState[ SBAR_ID_TARGETNAME ] = ENTINDEX( pEntity->edict() );

	mov	ecx, DWORD PTR _pEntity$40667[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	DWORD PTR _newSBarState$[ebp+4], eax

; 1753 : 				strcpy( sbuf1, "1 %p1\n2 Health: %i2%%\n3 Armor: %i3%%" );

	push	OFFSET FLAT:??_C@_0CF@FGJL@1?5?$CFp1?62?5Health?3?5?$CFi2?$CF?$CF?63?5Armor?3?5?$CF@ ; `string'
	lea	eax, DWORD PTR _sbuf1$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1754 : 
; 1755 : 				// allies and medics get to see the targets health
; 1756 : 				if ( g_pGameRules->PlayerRelationship( this, pEntity ) == GR_TEAMMATE )

	mov	ecx, DWORD PTR _pEntity$40667[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+200]
	cmp	eax, 1
	jne	SHORT $L40670

; 1758 : 					newSBarState[ SBAR_ID_TARGETHEALTH ] = 100 * (pEntity->pev->health / pEntity->pev->max_health);

	mov	eax, DWORD PTR _pEntity$40667[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pEntity$40667[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+352]
	fdiv	DWORD PTR [eax+432]
	fmul	DWORD PTR __real@4@4005c800000000000000
	call	__ftol
	mov	DWORD PTR _newSBarState$[ebp+8], eax

; 1759 : 					newSBarState[ SBAR_ID_TARGETARMOR ] = pEntity->pev->armorvalue; //No need to get it % based since 100 it's the max.

	mov	ecx, DWORD PTR _pEntity$40667[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+444]
	call	__ftol
	mov	DWORD PTR _newSBarState$[ebp+12], eax
$L40670:

; 1761 : 
; 1762 : 				m_flStatusBarDisappearDelay = gpGlobals->time + 1.0;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+3872]
$L40668:

; 1765 : 		else if ( m_flStatusBarDisappearDelay > gpGlobals->time )

	jmp	SHORT $L40672
$L40666:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+3872]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40672

; 1767 : 			// hold the values for a short amount of time after viewing the object
; 1768 : 			newSBarState[ SBAR_ID_TARGETNAME ] = m_izSBarState[ SBAR_ID_TARGETNAME ];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3856]
	mov	DWORD PTR _newSBarState$[ebp+4], edx

; 1769 : 			newSBarState[ SBAR_ID_TARGETHEALTH ] = m_izSBarState[ SBAR_ID_TARGETHEALTH ];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3860]
	mov	DWORD PTR _newSBarState$[ebp+8], ecx

; 1770 : 			newSBarState[ SBAR_ID_TARGETARMOR ] = m_izSBarState[ SBAR_ID_TARGETARMOR ];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3864]
	mov	DWORD PTR _newSBarState$[ebp+12], eax
$L40672:

; 1773 : 
; 1774 : 	BOOL bForceResend = FALSE;

	mov	DWORD PTR _bForceResend$[ebp], 0

; 1775 : 
; 1776 : 	if ( strcmp( sbuf0, m_SbarString0 ) )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3876				; 00000f24H
	push	ecx
	lea	edx, DWORD PTR _sbuf0$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L40674

; 1778 : 		MESSAGE_BEGIN( MSG_ONE, gmsgStatusText, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgStatusText@@3HA	; gmsgStatusText
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1779 : 			WRITE_BYTE( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1780 : 			WRITE_STRING( sbuf0 );

	lea	eax, DWORD PTR _sbuf0$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1781 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1782 : 
; 1783 : 		strcpy( m_SbarString0, sbuf0 );

	lea	ecx, DWORD PTR _sbuf0$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3876				; 00000f24H
	push	edx
	call	_strcpy
	add	esp, 8

; 1784 : 
; 1785 : 		// make sure everything's resent
; 1786 : 		bForceResend = TRUE;

	mov	DWORD PTR _bForceResend$[ebp], 1
$L40674:

; 1788 : 
; 1789 : 	if ( strcmp( sbuf1, m_SbarString1 ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4004				; 00000fa4H
	push	eax
	lea	ecx, DWORD PTR _sbuf1$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L40675

; 1791 : 		MESSAGE_BEGIN( MSG_ONE, gmsgStatusText, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgStatusText@@3HA	; gmsgStatusText
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1792 : 			WRITE_BYTE( 1 );

	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1793 : 			WRITE_STRING( sbuf1 );

	lea	edx, DWORD PTR _sbuf1$[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 1794 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1795 : 
; 1796 : 		strcpy( m_SbarString1, sbuf1 );

	lea	eax, DWORD PTR _sbuf1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4004				; 00000fa4H
	push	ecx
	call	_strcpy
	add	esp, 8

; 1797 : 
; 1798 : 		// make sure everything's resent
; 1799 : 		bForceResend = TRUE;

	mov	DWORD PTR _bForceResend$[ebp], 1
$L40675:

; 1801 : 
; 1802 : 	// Check values and send if they don't match
; 1803 : 	for (int i = 1; i < SBAR_END; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L40677
$L40678:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L40677:
	cmp	DWORD PTR _i$[ebp], 4
	jge	$L40679

; 1805 : 		if ( newSBarState[i] != m_izSBarState[i] || bForceResend )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newSBarState$[ebp+eax*4]
	cmp	eax, DWORD PTR [edx+ecx*4+3852]
	jne	SHORT $L40681
	cmp	DWORD PTR _bForceResend$[ebp], 0
	je	SHORT $L40680
$L40681:

; 1807 : 			MESSAGE_BEGIN( MSG_ONE, gmsgStatusValue, NULL, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgStatusValue@@3HA	; gmsgStatusValue
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1808 : 				WRITE_BYTE( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 1809 : 				WRITE_SHORT( newSBarState[i] );

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _newSBarState$[ebp+edx*4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 1810 : 			MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1811 : 
; 1812 : 			m_izSBarState[i] = newSBarState[i];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _newSBarState$[ebp+eax*4]
	mov	DWORD PTR [edx+ecx*4+3852], eax
$L40680:

; 1814 : 	}

	jmp	$L40678
$L40679:

; 1815 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateStatusBar@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::UpdateStatusBar
_TEXT	ENDS
PUBLIC	?TransferReset@CBasePlayer@@UAEXXZ		; CBasePlayer::TransferReset
PUBLIC	?UpdateKeyCatchers@CBasePlayer@@QAEXXZ		; CBasePlayer::UpdateKeyCatchers
;	COMDAT ?TransferReset@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::TransferReset, COMDAT

; 1818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1819 : 	// rebuild key-catcheres after changelevel
; 1820 : 	// g-cont. may be put in Restore?
; 1821 : 	UpdateKeyCatchers();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateKeyCatchers@CBasePlayer@@QAEXXZ	; CBasePlayer::UpdateKeyCatchers

; 1822 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::TransferReset
_TEXT	ENDS
PUBLIC	??_C@_0BC@KNFC@player_keycatcher?$AA@		; `string'
EXTRN	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByClassname
;	COMDAT ??_C@_0BC@KNFC@player_keycatcher?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BC@KNFC@player_keycatcher?$AA@ DB 'player_keycatcher', 00H ; `string'
CONST	ENDS
;	COMDAT ?UpdateKeyCatchers@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTarget$ = -8
?UpdateKeyCatchers@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::UpdateKeyCatchers, COMDAT

; 1825 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1826 : 	CBaseEntity *pTarget = UTIL_FindEntityByClassname( NULL, "player_keycatcher" );

	push	OFFSET FLAT:??_C@_0BC@KNFC@player_keycatcher?$AA@ ; `string'
	push	0
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 1827 : 	m_iNumKeyCatchers = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3504], 0
$L40693:

; 1828 : 
; 1829 : 	while( pTarget && ( m_iNumKeyCatchers < MAX_KEYCATCHERS ))

	cmp	DWORD PTR _pTarget$[ebp], 0
	je	SHORT $L40694
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3504], 64		; 00000040H
	jge	SHORT $L40694

; 1831 : 		// make sure what key catcher is active
; 1832 : 		if( pTarget->pev->button != 0 )

	mov	edx, DWORD PTR _pTarget$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+384], 0
	je	SHORT $L40695

; 1833 : 			m_hKeyCatchers[m_iNumKeyCatchers++] = pTarget;

	mov	ecx, DWORD PTR _pTarget$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3504]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8+2992]
	mov	DWORD PTR -12+[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3504]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3504], ecx
	mov	ecx, DWORD PTR -12+[ebp]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L40695:

; 1834 : 		pTarget = UTIL_FindEntityByClassname( pTarget, "player_keycatcher" );

	push	OFFSET FLAT:??_C@_0BC@KNFC@player_keycatcher?$AA@ ; `string'
	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 1835 : 	}

	jmp	SHORT $L40693
$L40694:

; 1836 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateKeyCatchers@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::UpdateKeyCatchers
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	?CatchButton@CPlayerKeyCatcher@@QAEXPAVCBaseEntity@@HHH@Z ; CPlayerKeyCatcher::CatchButton
PUBLIC	?PreThink@CBasePlayer@@UAEXXZ			; CBasePlayer::PreThink
PUBLIC	?ItemPreFrame@CBasePlayer@@QAEXXZ		; CBasePlayer::ItemPreFrame
PUBLIC	?CheckSuitUpdate@CBasePlayer@@QAEXXZ		; CBasePlayer::CheckSuitUpdate
PUBLIC	?CheckTimeBasedDamage@CBasePlayer@@QAEXXZ	; CBasePlayer::CheckTimeBasedDamage
PUBLIC	?UpdateHoldableItem@CBasePlayer@@QAEXXZ		; CBasePlayer::UpdateHoldableItem
PUBLIC	__real@8@00000000000000000000
EXTRN	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetAbsOrigin
EXTRN	?MoveUp@CRope@@QAE_NM@Z:NEAR			; CRope::MoveUp
EXTRN	?MoveDown@CRope@@QAE_NM@Z:NEAR			; CRope::MoveDown
EXTRN	?GetAttachedObjectsVelocity@CRope@@QBE?AVVector@@XZ:NEAR ; CRope::GetAttachedObjectsVelocity
EXTRN	?ApplyForceFromPlayer@CRope@@QAEXABVVector@@@Z:NEAR ; CRope::ApplyForceFromPlayer
EXTRN	?DetachObject@CRope@@QAEXXZ:NEAR		; CRope::DetachObject
EXTRN	?GetAttachedObjectsPosition@CRope@@QBE?AVVector@@XZ:NEAR ; CRope::GetAttachedObjectsPosition
EXTRN	?g_fGameOver@@3HA:DWORD				; g_fGameOver
;	COMDAT __real@8@00000000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@8@00000000000000000000 DQ 00000000000000000r ; 0
CONST	ENDS
;	COMDAT ?PreThink@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_buttonsChanged$ = -8
_i$ = -12
_pCatch$40713 = -16
_vecAttachPos$40723 = -28
_vecForce$40725 = -40
_flDelta$40729 = -44
_vecDir$40743 = -56
_vecVelocity$40747 = -68
_pTrain$40754 = -72
_vel$40755 = -76
_trainTrace$40757 = -132
$T43960 = -144
$T43961 = -156
$T43962 = -168
$T43963 = -180
$T43964 = -192
$T43965 = -204
$T43966 = -216
$T43967 = -228
$T43968 = -240
$T43969 = -252
$T43970 = -264
?PreThink@CBasePlayer@@UAEXXZ PROC NEAR			; CBasePlayer::PreThink, COMDAT

; 1845 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 328				; 00000148H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1846 : 	int buttonsChanged = (m_afButtonLast ^ pev->button);	// These buttons have changed this frame

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2432]
	xor	eax, DWORD PTR [ecx+384]
	mov	DWORD PTR _buttonsChanged$[ebp], eax

; 1847 : 
; 1848 : 	// Debounced button codes for pressed/released
; 1849 : 	// UNDONE: Do we need auto-repeat?
; 1850 : 	m_afButtonPressed =  buttonsChanged & pev->button;		// The changed ones still down are "pressed"

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _buttonsChanged$[ebp]
	and	eax, DWORD PTR [edx+384]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2436], eax

; 1851 : 	m_afButtonReleased = buttonsChanged & (~pev->button);	// The ones not down are "released"

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	not	ecx
	mov	edx, DWORD PTR _buttonsChanged$[ebp]
	and	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2440], edx

; 1852 : 
; 1853 : 	g_pGameRules->PlayerThink( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+76]

; 1854 : 
; 1855 : 	if ( g_fGameOver )

	cmp	DWORD PTR ?g_fGameOver@@3HA, 0		; g_fGameOver
	je	SHORT $L40706

; 1856 : 		return;         // intermission or finale

	jmp	$L40704
$L40706:

; 1857 : 
; 1858 : 	for( int i = 0; i < m_iNumKeyCatchers && ( pev->button || buttonsChanged ); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40708
$L40709:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40708:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+3504]
	jge	SHORT $L40710
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+384], 0
	jne	SHORT $L40711
	cmp	DWORD PTR _buttonsChanged$[ebp], 0
	je	SHORT $L40710
$L40711:

; 1860 : 		if( m_hKeyCatchers[i] != NULL )

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax*8+2992]
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40716

; 1862 : 			CPlayerKeyCatcher *pCatch = (CPlayerKeyCatcher *)(CBaseEntity *)m_hKeyCatchers[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx*8+2992]
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pCatch$40713[ebp], eax

; 1863 : 			if( pCatch ) pCatch->CatchButton( this, pev->button, m_afButtonPressed, m_afButtonReleased );

	cmp	DWORD PTR _pCatch$40713[ebp], 0
	je	SHORT $L40716
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2440]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2436]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pCatch$40713[ebp]
	call	?CatchButton@CPlayerKeyCatcher@@QAEXPAVCBaseEntity@@HHH@Z ; CPlayerKeyCatcher::CatchButton
$L40716:

; 1865 : 	}

	jmp	$L40709
$L40710:

; 1866 : 
; 1867 : 	UTIL_MakeVectors(pev->v_angle);             // is this still used?

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 116				; 00000074H
	push	ecx
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 1868 : 
; 1869 : 	ItemPreFrame( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ItemPreFrame@CBasePlayer@@QAEXXZ	; CBasePlayer::ItemPreFrame

; 1870 : 
; 1871 : 	WaterMove();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?WaterMove@CBasePlayer@@QAEXXZ		; CBasePlayer::WaterMove

; 1872 : 
; 1873 : 	if ( g_pGameRules && g_pGameRules->FAllowFlashlight() )

	cmp	DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A, 0 ; g_pGameRules
	je	SHORT $L40717
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $L40717

; 1874 : 		m_iHideHUD &= ~HIDEHUD_FLASHLIGHT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2928]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2928], edx

; 1875 : 	else

	jmp	SHORT $L40718
$L40717:

; 1876 : 		m_iHideHUD |= HIDEHUD_FLASHLIGHT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2928]
	or	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2928], edx
$L40718:

; 1877 : 
; 1878 : 
; 1879 : 	// JOHN: checks if new client data (for HUD and view control) needs to be sent to the client
; 1880 : 	UpdateClientData();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+632]

; 1881 : 
; 1882 : 	CheckTimeBasedDamage();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckTimeBasedDamage@CBasePlayer@@QAEXXZ ; CBasePlayer::CheckTimeBasedDamage

; 1883 : 
; 1884 : 	CheckSuitUpdate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckSuitUpdate@CBasePlayer@@QAEXXZ	; CBasePlayer::CheckSuitUpdate

; 1885 : 
; 1886 : 	if (pev->deadflag >= DEAD_DYING)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 1
	jl	SHORT $L40719

; 1888 : 		PlayerDeathThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlayerDeathThink@CBasePlayer@@QAEXXZ	; CBasePlayer::PlayerDeathThink

; 1889 : 		return;

	jmp	$L40704
$L40719:

; 1891 : 
; 1892 : 	// So the correct flags get sent to client asap.
; 1893 : 	//
; 1894 : 	if ( m_afPhysicsFlags & PFLAG_ONTRAIN )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	eax, 2
	test	eax, eax
	je	SHORT $L40720

; 1895 : 		pev->flags |= FL_ONTRAIN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+420], eax

; 1896 : 	else

	jmp	SHORT $L40721
$L40720:

; 1897 : 		pev->flags &= ~FL_ONTRAIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -16777217				; feffffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx
$L40721:

; 1898 : 
; 1899 : 	//We're on a rope. - Solokiller
; 1900 : 	if( m_afPhysicsFlags & PFLAG_ONROPE && m_pRope )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	$L40722
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4160], 0
	je	$L40722

; 1902 : 		SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 1903 : 
; 1904 : 		const Vector vecAttachPos = m_pRope->GetAttachedObjectsPosition();

	lea	edx, DWORD PTR $T43960[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4160]
	call	?GetAttachedObjectsPosition@CRope@@QBE?AVVector@@XZ ; CRope::GetAttachedObjectsPosition
	push	eax
	lea	ecx, DWORD PTR _vecAttachPos$40723[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1905 : 
; 1906 : 		SetAbsOrigin( vecAttachPos );

	lea	ecx, DWORD PTR _vecAttachPos$40723[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 1907 : 
; 1908 : 		Vector vecForce;

	lea	ecx, DWORD PTR _vecForce$40725[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1909 : 
; 1910 : 		/*
; 1911 : 		//TODO: This causes sideways acceleration that doesn't occur in Op4. - Solokiller
; 1912 : 		//TODO: should be IN_MOVERIGHT and IN_MOVELEFT - Solokiller
; 1913 : 		if( pev->button & IN_DUCK )
; 1914 : 		{
; 1915 : 			vecForce.x = gpGlobals->v_right.x;
; 1916 : 			vecForce.y = gpGlobals->v_right.y;
; 1917 : 			vecForce.z = 0;
; 1918 : 
; 1919 : 			m_pRope->ApplyForceFromPlayer( vecForce );
; 1920 : 		}
; 1921 : 
; 1922 : 		if( pev->button & IN_JUMP )
; 1923 : 		{
; 1924 : 			vecForce.x = -gpGlobals->v_right.x;
; 1925 : 			vecForce.y = -gpGlobals->v_right.y;
; 1926 : 			vecForce.z = 0;
; 1927 : 			m_pRope->ApplyForceFromPlayer( vecForce );
; 1928 : 		}
; 1929 : 		*/
; 1930 : 
; 1931 : 		//Determine if any force should be applied to the rope, or if we should move around. - Solokiller
; 1932 : 		if( pev->button & ( IN_BACK | IN_FORWARD ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 24					; 00000018H
	test	ecx, ecx
	je	$L40726

; 1935 : 				gpGlobals->v_forward.y * gpGlobals->v_forward.y -
; 1936 : 				gpGlobals->v_forward.z * gpGlobals->v_forward.z ) <= 0.0 )

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+40]
	fmul	DWORD PTR [eax+40]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+44]
	fmul	DWORD PTR [edx+44]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+48]
	fmul	DWORD PTR [ecx+48]
	fsubp	ST(1), ST(0)
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L40727

; 1938 : 				if( m_bIsClimbing )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+4168]
	test	eax, eax
	je	$L40728

; 1940 : 					const float flDelta = gpGlobals->time - m_flLastClimbTime;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx+4164]
	fstp	DWORD PTR _flDelta$40729[ebp]

; 1941 : 					m_flLastClimbTime = gpGlobals->time;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4164], edx

; 1942 : 					if( pev->button & IN_FORWARD )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+384]
	and	edx, 8
	test	edx, edx
	je	$L40733

; 1944 : 						if( gpGlobals->v_forward.z < 0.0 )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+48]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40731

; 1946 : 							if( !m_pRope->MoveDown( flDelta ) )

	mov	ecx, DWORD PTR _flDelta$40729[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4160]
	call	?MoveDown@CRope@@QAE_NM@Z		; CRope::MoveDown
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40732

; 1948 : 								//Let go of the rope, detach. - Solokiller
; 1949 : 								pev->movetype = MOVETYPE_WALK;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+264], 3

; 1950 : 								pev->solid = SOLID_SLIDEBOX;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 3

; 1951 : 
; 1952 : 								m_afPhysicsFlags &= ~PFLAG_ONROPE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2488]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2488], edx

; 1953 : 								m_pRope->DetachObject();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4160]
	call	?DetachObject@CRope@@QAEXXZ		; CRope::DetachObject

; 1954 : 								m_pRope = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4160], 0

; 1955 : 								m_bIsClimbing = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4168], 0
$L40732:

; 1958 : 						else

	jmp	SHORT $L40733
$L40731:

; 1960 : 							m_pRope->MoveUp( flDelta );

	mov	ecx, DWORD PTR _flDelta$40729[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4160]
	call	?MoveUp@CRope@@QAE_NM@Z			; CRope::MoveUp
$L40733:

; 1963 : 
; 1964 : 					if( pev->button & IN_BACK )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+384]
	and	edx, 16					; 00000010H
	test	edx, edx
	je	$L40737

; 1966 : 						if( gpGlobals->v_forward.z < 0.0 )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+48]
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40735

; 1968 : 							m_pRope->MoveUp( flDelta );

	mov	ecx, DWORD PTR _flDelta$40729[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4160]
	call	?MoveUp@CRope@@QAE_NM@Z			; CRope::MoveUp

; 1970 : 						else if( !m_pRope->MoveDown( flDelta ) )

	jmp	SHORT $L40737
$L40735:
	mov	eax, DWORD PTR _flDelta$40729[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4160]
	call	?MoveDown@CRope@@QAE_NM@Z		; CRope::MoveDown
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40737

; 1972 : 							//Let go of the rope, detach. - Solokiller
; 1973 : 							pev->movetype = MOVETYPE_WALK;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 3

; 1974 : 							pev->solid = SOLID_SLIDEBOX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 3

; 1975 : 							m_afPhysicsFlags &= ~PFLAG_ONROPE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], ecx

; 1976 : 							m_pRope->DetachObject();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4160]
	call	?DetachObject@CRope@@QAEXXZ		; CRope::DetachObject

; 1977 : 							m_pRope = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4160], 0

; 1978 : 							m_bIsClimbing = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4168], 0
$L40737:

; 1982 : 				else

	jmp	SHORT $L40738
$L40728:

; 1984 : 					m_bIsClimbing = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4168], 1

; 1985 : 					m_flLastClimbTime = gpGlobals->time;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4164], eax
$L40738:

; 1988 : 			else

	jmp	SHORT $L40739
$L40727:

; 1990 : 				vecForce.x = gpGlobals->v_forward.x;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _vecForce$40725[ebp], edx

; 1991 : 				vecForce.y = gpGlobals->v_forward.y;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _vecForce$40725[ebp+4], ecx

; 1992 : 				vecForce.z = 0.0;

	mov	DWORD PTR _vecForce$40725[ebp+8], 0

; 1993 : 				if( pev->button & IN_BACK )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	je	SHORT $L40740

; 1995 : 					vecForce.x = -gpGlobals->v_forward.x;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+40]
	fchs
	fstp	DWORD PTR _vecForce$40725[ebp]

; 1996 : 					vecForce.y = -gpGlobals->v_forward.y;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+44]
	fchs
	fstp	DWORD PTR _vecForce$40725[ebp+4]

; 1997 : 					vecForce.z = 0;

	mov	DWORD PTR _vecForce$40725[ebp+8], 0
$L40740:

; 1999 : 				m_pRope->ApplyForceFromPlayer( vecForce );

	lea	ecx, DWORD PTR _vecForce$40725[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4160]
	call	?ApplyForceFromPlayer@CRope@@QAEXABVVector@@@Z ; CRope::ApplyForceFromPlayer

; 2000 : 				m_bIsClimbing = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4168], 0
$L40739:

; 2003 : 		else

	jmp	SHORT $L40741
$L40726:

; 2005 : 			m_bIsClimbing = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4168], 0
$L40741:

; 2007 : 
; 2008 : 		if( m_afButtonPressed & IN_JUMP )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2436]
	and	eax, 2
	test	eax, eax
	je	$L40742

; 2010 : 			//We've jumped off the rope, give us some momentum - Solokiller
; 2011 : 			pev->movetype = MOVETYPE_WALK;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 3

; 2012 : 			pev->solid = SOLID_SLIDEBOX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 3

; 2013 : 			this->m_afPhysicsFlags &= ~PFLAG_ONROPE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	al, -65					; ffffffbfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2488], eax

; 2014 : 
; 2015 : 			Vector vecDir = gpGlobals->v_up * 165.0 + gpGlobals->v_forward * 150.0;

	push	1125515264				; 43160000H
	lea	edx, DWORD PTR $T43962[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T43963[ebp]
	push	eax
	push	1126498304				; 43250000H
	lea	ecx, DWORD PTR $T43961[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 52					; 00000034H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecDir$40743[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2016 : 
; 2017 : 			Vector vecVelocity = m_pRope->GetAttachedObjectsVelocity() * 2;

	push	1073741824				; 40000000H
	lea	edx, DWORD PTR $T43965[ebp]
	push	edx
	lea	eax, DWORD PTR $T43964[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4160]
	call	?GetAttachedObjectsVelocity@CRope@@QBE?AVVector@@XZ ; CRope::GetAttachedObjectsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR _vecVelocity$40747[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 2018 : 
; 2019 : 			vecVelocity = vecVelocity.Normalize();

	lea	edx, DWORD PTR $T43966[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecVelocity$40747[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecVelocity$40747[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecVelocity$40747[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecVelocity$40747[ebp+8], eax

; 2020 : 
; 2021 : 			vecVelocity = vecVelocity * 200;

	push	1128792064				; 43480000H
	lea	ecx, DWORD PTR $T43967[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecVelocity$40747[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecVelocity$40747[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecVelocity$40747[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecVelocity$40747[ebp+8], edx

; 2022 : 
; 2023 : 			SetAbsVelocity( vecVelocity + vecDir );

	lea	eax, DWORD PTR _vecDir$40743[ebp]
	push	eax
	lea	ecx, DWORD PTR $T43968[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vecVelocity$40747[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2024 : 
; 2025 : 			m_pRope->DetachObject();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4160]
	call	?DetachObject@CRope@@QAEXXZ		; CRope::DetachObject

; 2026 : 			m_pRope = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4160], 0

; 2027 : 			m_bIsClimbing = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4168], 0
$L40742:

; 2029 : 		return;

	jmp	$L40704
$L40722:

; 2031 : 
; 2032 : 	// Train speed control
; 2033 : 	if ( m_afPhysicsFlags & PFLAG_ONTRAIN )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2488]
	and	eax, 2
	test	eax, eax
	je	$L40753

; 2035 : 		CFuncTrackTrain *pTrain = CFuncTrackTrain::Instance( pev->groundentity );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+412]
	push	eax
	call	?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z ; CFuncTrackTrain::Instance
	add	esp, 4
	mov	DWORD PTR _pTrain$40754[ebp], eax

; 2036 : 		float vel;
; 2037 : 
; 2038 : 		if ( !pTrain )

	cmp	DWORD PTR _pTrain$40754[ebp], 0
	jne	$L40756

; 2040 : 			TraceResult trainTrace;

	lea	ecx, DWORD PTR _trainTrace$40757[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 2041 : 			// Maybe this is on the other side of a level transition
; 2042 : 			UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin() + Vector(0,0,-38), ignore_monsters, edict(), &trainTrace );

	lea	ecx, DWORD PTR _trainTrace$40757[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	1
	push	-1038614528				; c2180000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T43969[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	edx, DWORD PTR $T43970[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 2043 : 
; 2044 : 			// HACKHACK - Just look for the func_tracktrain classname
; 2045 : 			if ( trainTrace.flFraction != 1.0 && trainTrace.pHit )

	fld	DWORD PTR _trainTrace$40757[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40760
	cmp	DWORD PTR _trainTrace$40757[ebp+48], 0
	je	SHORT $L40760

; 2046 : 			pTrain = CFuncTrackTrain::Instance( trainTrace.pHit );

	mov	eax, DWORD PTR _trainTrace$40757[ebp+48]
	push	eax
	call	?Instance@CFuncTrackTrain@@SAPAV1@PAUedict_s@@@Z ; CFuncTrackTrain::Instance
	add	esp, 4
	mov	DWORD PTR _pTrain$40754[ebp], eax
$L40760:

; 2047 : 
; 2048 : 			if ( !pTrain || !(pTrain->ObjectCaps() & FCAP_DIRECTIONAL_USE) || !pTrain->OnControls( this ))

	cmp	DWORD PTR _pTrain$40754[ebp], 0
	je	SHORT $L40762
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	call	DWORD PTR [edx+24]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L40762
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	call	DWORD PTR [edx+192]
	test	eax, eax
	jne	SHORT $L40761
$L40762:

; 2050 : 				//ALERT( at_error, "In train mode with no train!\n" );
; 2051 : 				m_afPhysicsFlags &= ~PFLAG_ONTRAIN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], ecx

; 2052 : 				m_iTrain = TRAIN_NEW|TRAIN_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2856], 192		; 000000c0H

; 2053 : 				return;

	jmp	$L40704
$L40761:

; 2056 : 		else if ( !FBitSet( pev->flags, FL_ONGROUND ) || FBitSet( pTrain->pev->spawnflags, SF_TRACKTRAIN_NOCONTROL ) || (pev->button & (IN_MOVELEFT|IN_MOVERIGHT) ) )

	jmp	SHORT $L40764
$L40756:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L40765
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 2
	test	eax, eax
	jne	SHORT $L40765
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 1536				; 00000600H
	test	eax, eax
	je	SHORT $L40764
$L40765:

; 2058 : 			// Turn off the train if you jump, strafe, or the train controls go dead
; 2059 : 			m_afPhysicsFlags &= ~PFLAG_ONTRAIN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2488]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2488], edx

; 2060 : 			m_iTrain = TRAIN_NEW|TRAIN_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], 192		; 000000c0H

; 2061 : 			return;

	jmp	$L40704
$L40764:

; 2063 : 
; 2064 : 		SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2065 : 		vel = 0;

	mov	DWORD PTR _vel$40755[ebp], 0

; 2066 : 		if ( m_afButtonPressed & IN_FORWARD )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2436]
	and	eax, 8
	test	eax, eax
	je	SHORT $L40766

; 2068 : 			vel = 1;

	mov	DWORD PTR _vel$40755[ebp], 1065353216	; 3f800000H

; 2069 : 			pTrain->Use( this, this, USE_SET, (float)vel );

	mov	ecx, DWORD PTR _vel$40755[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	call	DWORD PTR [edx+276]

; 2071 : 		else if ( m_afButtonPressed & IN_BACK )

	jmp	SHORT $L40769
$L40766:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2436]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	je	SHORT $L40769

; 2073 : 			vel = -1;

	mov	DWORD PTR _vel$40755[ebp], -1082130432	; bf800000H

; 2074 : 			pTrain->Use( this, this, USE_SET, (float)vel );

	mov	edx, DWORD PTR _vel$40755[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTrain$40754[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	call	DWORD PTR [eax+276]
$L40769:

; 2076 : 
; 2077 : 		if (vel)

	fld	DWORD PTR _vel$40755[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40771

; 2079 : 			if( pTrain->IsLockedByMaster( this ))

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L40772

; 2081 : 				m_iTrain = TRAIN_LOCKED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2856], 8

; 2083 : 			else

	jmp	SHORT $L40773
$L40772:

; 2085 : 				m_iTrain = TrainSpeed(pTrain->GetSpeed(), pTrain->GetMaxSpeed());

	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	call	?GetMaxSpeed@CFuncTrackTrain@@QAEMXZ	; CFuncTrackTrain::GetMaxSpeed
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _pTrain$40754[ebp]
	call	?GetSpeed@CFuncTrackTrain@@QAEMXZ	; CFuncTrackTrain::GetSpeed
	call	__ftol
	push	eax
	call	?TrainSpeed@@YAHHH@Z			; TrainSpeed
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], eax
$L40773:

; 2087 : 			m_iTrain |= TRAIN_ACTIVE|TRAIN_NEW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2856]
	or	al, -64					; ffffffc0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], eax
$L40771:

; 2089 : 
; 2090 : 	} else if (m_iTrain & TRAIN_ACTIVE)

	jmp	SHORT $L40775
$L40753:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2856]
	and	eax, 128				; 00000080H
	test	eax, eax
	je	SHORT $L40775

; 2091 : 		m_iTrain = TRAIN_NEW; // turn off train

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], 192		; 000000c0H
$L40775:

; 2092 : 
; 2093 : 	if (pev->button & IN_JUMP)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+384]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L40776

; 2095 : 		// If on a ladder, jump off the ladder
; 2096 : 		// else Jump
; 2097 : 		Jump();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+616]
$L40776:

; 2099 : 
; 2100 : 
; 2101 : 	// If trying to duck, already ducked, or in the process of ducking
; 2102 : 	if ((pev->button & IN_DUCK) || FBitSet(pev->flags,FL_DUCKING) || (m_afPhysicsFlags & PFLAG_DUCKING) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 4
	test	eax, eax
	jne	SHORT $L40778
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 16384				; 00004000H
	test	eax, eax
	jne	SHORT $L40778
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2488]
	and	edx, 8
	test	edx, edx
	je	SHORT $L40777
$L40778:

; 2103 : 		Duck();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+620]
$L40777:

; 2104 : 
; 2105 : 	if ( !FBitSet ( pev->flags, FL_ONGROUND ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	jne	SHORT $L40779

; 2107 : 		m_flFallVelocity = -GetAbsVelocity().z;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+8]
	fchs
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2456]
$L40779:

; 2109 : 
; 2110 : 	// StudioFrameAdvance( );//!!!HACKHACK!!! Can't be hit by traceline when not animating?
; 2111 : 
; 2112 : 	// Clear out ladder pointer
; 2113 : 	m_hEnemy = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1960				; 000007a8H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 2114 : 
; 2115 : 	if ( m_afPhysicsFlags & PFLAG_ONBARNACLE )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2488]
	and	edx, 4
	test	edx, edx
	je	SHORT $L40780

; 2117 : 		SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L40780:

; 2119 : 
; 2120 : 	if (m_pHoldableItem != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40781

; 2121 : 		UpdateHoldableItem ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateHoldableItem@CBasePlayer@@QAEXXZ	; CBasePlayer::UpdateHoldableItem
$L40781:
$L40704:

; 2122 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PreThink@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::PreThink
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
PUBLIC	__real@8@40008000000000000000
EXTRN	_abs:NEAR
;	COMDAT __real@8@40008000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@8@40008000000000000000 DQ 04000000000000000r ; 2
CONST	ENDS
;	COMDAT ?CheckTimeBasedDamage@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_bDuration$ = -12
_idif$40805 = -16
?CheckTimeBasedDamage@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::CheckTimeBasedDamage, COMDAT

; 2202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2203 : 	int i;
; 2204 : 	BYTE bDuration = 0;

	mov	BYTE PTR _bDuration$[ebp], 0

; 2205 : 
; 2206 : 	static float gtbdPrev = 0.0;
; 2207 : 
; 2208 : 	if (!(m_bitsDamageType & DMG_TIMEBASED))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2312]
	and	ecx, 16760832				; 00ffc000H
	test	ecx, ecx
	jne	SHORT $L40789

; 2209 : 		return;

	jmp	$L40784
$L40789:

; 2210 : 
; 2211 : 	// only check for time based damage approx. every 2 seconds
; 2212 : 	if (abs(gpGlobals->time - m_tbdPrev) < 2.0)

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fsub	DWORD PTR [eax+2800]
	call	__ftol
	push	eax
	call	_abs
	add	esp, 4
	mov	DWORD PTR -20+[ebp], eax
	fild	DWORD PTR -20+[ebp]
	fcomp	QWORD PTR __real@8@40008000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40790

; 2213 : 		return;

	jmp	$L40784
$L40790:

; 2214 : 
; 2215 : 	m_tbdPrev = gpGlobals->time;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+2800], eax

; 2216 : 
; 2217 : 	for (i = 0; i < CDMG_TIMEBASED; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40791
$L40792:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40791:
	cmp	DWORD PTR _i$[ebp], 8
	jge	$L40793

; 2219 : 		// make sure bit is set for damage type
; 2220 : 		if (m_bitsDamageType & (DMG_PARALYZE << i))

	mov	edx, 32768				; 00008000H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2312]
	and	ecx, edx
	test	ecx, ecx
	je	$L40817

; 2223 : 			{

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR -24+[ebp], edx
	cmp	DWORD PTR -24+[ebp], 7
	ja	$L40809
	mov	eax, DWORD PTR -24+[ebp]
	jmp	DWORD PTR $L43981[eax*4]
$L40799:

; 2224 : 			case itbd_Paralyze:
; 2225 : 				// UNDONE - flag movement as half-speed
; 2226 : 				bDuration = PARALYZE_DURATION;

	mov	BYTE PTR _bDuration$[ebp], 2

; 2227 : 				break;

	jmp	$L40796
$L40800:

; 2228 : 			case itbd_NerveGas:
; 2229 : //				TakeDamage(pev, pev, NERVEGAS_DAMAGE, DMG_GENERIC);
; 2230 : 				bDuration = NERVEGAS_DURATION;

	mov	BYTE PTR _bDuration$[ebp], 2

; 2231 : 				break;

	jmp	$L40796
$L40801:

; 2232 : 			case itbd_Poison:
; 2233 : 				TakeDamage(pev, pev, POISON_DAMAGE, DMG_GENERIC);

	push	0
	push	1073741824				; 40000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+96]

; 2234 : 				bDuration = POISON_DURATION;

	mov	BYTE PTR _bDuration$[ebp], 5

; 2235 : 				break;

	jmp	$L40796
$L40802:

; 2236 : 			case itbd_Radiation:
; 2237 : //				TakeDamage(pev, pev, RADIATION_DAMAGE, DMG_GENERIC);
; 2238 : 				bDuration = RADIATION_DURATION;

	mov	BYTE PTR _bDuration$[ebp], 2

; 2239 : 				break;

	jmp	$L40796
$L40803:

; 2240 : 			case itbd_DrownRecover:
; 2241 : 				// NOTE: this hack is actually used to RESTORE health
; 2242 : 				// after the player has been drowning and finally takes a breath
; 2243 : 				if (m_idrowndmg > m_idrownrestored)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+2836]
	cmp	eax, DWORD PTR [edx+2840]
	jle	SHORT $L40804

; 2245 : 					int idif = Q_min(m_idrowndmg - m_idrownrestored, 10);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+2836]
	sub	eax, DWORD PTR [edx+2840]
	cmp	eax, 10					; 0000000aH
	jge	SHORT $L43977
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+2836]
	sub	eax, DWORD PTR [edx+2840]
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L43978
$L43977:
	mov	DWORD PTR -28+[ebp], 10			; 0000000aH
$L43978:
	mov	ecx, DWORD PTR -28+[ebp]
	mov	DWORD PTR _idif$40805[ebp], ecx

; 2246 : 
; 2247 : 					TakeHealth(idif, DMG_GENERIC);

	push	0
	fild	DWORD PTR _idif$40805[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+100]

; 2248 : 					m_idrownrestored += idif;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2840]
	add	edx, DWORD PTR _idif$40805[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2840], edx
$L40804:

; 2250 : 				bDuration = 4;	// get up to 5*10 = 50 points back

	mov	BYTE PTR _bDuration$[ebp], 4

; 2251 : 				break;

	jmp	SHORT $L40796
$L40806:

; 2252 : 			case itbd_Acid:
; 2253 : //				TakeDamage(pev, pev, ACID_DAMAGE, DMG_GENERIC);
; 2254 : 				bDuration = ACID_DURATION;

	mov	BYTE PTR _bDuration$[ebp], 2

; 2255 : 				break;

	jmp	SHORT $L40796
$L40807:

; 2256 : 			case itbd_SlowBurn:
; 2257 : //				TakeDamage(pev, pev, SLOWBURN_DAMAGE, DMG_GENERIC);
; 2258 : 				bDuration = SLOWBURN_DURATION;

	mov	BYTE PTR _bDuration$[ebp], 2

; 2259 : 				break;

	jmp	SHORT $L40796
$L40808:

; 2260 : 			case itbd_SlowFreeze:
; 2261 : //				TakeDamage(pev, pev, SLOWFREEZE_DAMAGE, DMG_GENERIC);
; 2262 : 				bDuration = SLOWFREEZE_DURATION;

	mov	BYTE PTR _bDuration$[ebp], 2

; 2263 : 				break;

	jmp	SHORT $L40796
$L40809:

; 2264 : 			default:
; 2265 : 				bDuration = 0;

	mov	BYTE PTR _bDuration$[ebp], 0
$L40796:

; 2267 : 
; 2268 : 			if (m_rgbTimeBasedDamage[i])

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+2316]
	test	edx, edx
	je	$L40810

; 2272 : 					((i == itbd_Poison)   && (m_rgbTimeBasedDamage[i] < POISON_DURATION)))

	cmp	DWORD PTR _i$[ebp], 1
	jne	SHORT $L40813
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+2316]
	cmp	ecx, 2
	jl	SHORT $L40812
$L40813:
	cmp	DWORD PTR _i$[ebp], 2
	jne	SHORT $L40814
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2316]
	cmp	eax, 5
	jge	SHORT $L40814
$L40812:

; 2274 : 					if (m_rgItems[ITEM_ANTIDOTE])

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2468], 0
	je	SHORT $L40814

; 2276 : 						m_rgbTimeBasedDamage[i] = 0;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [edx+2316], 0

; 2277 : 						m_rgItems[ITEM_ANTIDOTE]--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2468]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2468], ecx
$L40814:

; 2281 : 
; 2282 : 
; 2283 : 				// decrement damage duration, detect when done.
; 2284 : 				if (!m_rgbTimeBasedDamage[i] || --m_rgbTimeBasedDamage[i] == 0)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+2316]
	test	ecx, ecx
	je	SHORT $L40816
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR [edx+2316]
	sub	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+2316], al
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+2316]
	test	eax, eax
	jne	SHORT $L40815
$L40816:

; 2286 : 					m_rgbTimeBasedDamage[i] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx+2316], 0

; 2287 : 					// if we're done, clear damage bits
; 2288 : 					m_bitsDamageType &= ~(DMG_PARALYZE << i);

	mov	edx, 32768				; 00008000H
	mov	ecx, DWORD PTR _i$[ebp]
	shl	edx, cl
	not	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2312]
	and	ecx, edx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2312], ecx
$L40815:

; 2291 : 			else

	jmp	SHORT $L40817
$L40810:

; 2292 : 				// first time taking this damage type - init damage duration
; 2293 : 				m_rgbTimeBasedDamage[i] = bDuration;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _bDuration$[ebp]
	mov	BYTE PTR [eax+2316], cl
$L40817:

; 2295 : 	}

	jmp	$L40792
$L40793:
$L40784:

; 2296 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L43981:
	DD	$L40799
	DD	$L40800
	DD	$L40801
	DD	$L40802
	DD	$L40803
	DD	$L40806
	DD	$L40807
	DD	$L40808
?CheckTimeBasedDamage@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::CheckTimeBasedDamage
_TEXT	ENDS
PUBLIC	?UpdateGeigerCounter@CBasePlayer@@QAEXXZ	; CBasePlayer::UpdateGeigerCounter
PUBLIC	__real@8@3ffd8000000000000000
PUBLIC	__real@4@40018000000000000000
;	COMDAT __real@8@3ffd8000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@8@3ffd8000000000000000 DQ 03fd0000000000000r ; 0.25
CONST	ENDS
;	COMDAT __real@4@40018000000000000000
CONST	SEGMENT
__real@4@40018000000000000000 DD 040800000r	; 4
CONST	ENDS
;	COMDAT ?UpdateGeigerCounter@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_range$ = -8
?UpdateGeigerCounter@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::UpdateGeigerCounter, COMDAT

; 2370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2371 : 	BYTE range;
; 2372 : 
; 2373 : 	// delay per update ie: don't flood net with these msgs
; 2374 : 	if (gpGlobals->time < m_flgeigerDelay)

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+2808]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40824

; 2375 : 		return;

	jmp	$L40822
$L40824:

; 2376 : 
; 2377 : 	m_flgeigerDelay = gpGlobals->time + GEIGERDELAY;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffd8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2808]

; 2378 : 
; 2379 : 	// send range to radition source to client
; 2380 : 
; 2381 : 	range = (BYTE) (m_flgeigerRange / 4);

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+2804]
	fdiv	DWORD PTR __real@4@40018000000000000000
	call	__ftol
	mov	BYTE PTR _range$[ebp], al

; 2382 : 
; 2383 : 	if (range != m_igeigerRangePrev)

	mov	edx, DWORD PTR _range$[ebp]
	and	edx, 255				; 000000ffH
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+2812]
	je	SHORT $L40826

; 2385 : 		m_igeigerRangePrev = range;

	mov	ecx, DWORD PTR _range$[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2812], ecx

; 2386 : 
; 2387 : 		MESSAGE_BEGIN( MSG_ONE, gmsgGeigerRange, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgGeigerRange@@3HA	; gmsgGeigerRange
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 2388 : 			WRITE_BYTE( range );

	mov	eax, DWORD PTR _range$[ebp]
	and	eax, 255				; 000000ffH
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 2389 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L40826:

; 2391 : 
; 2392 : 	// reset counter and semaphore
; 2393 : 	if (!RANDOM_LONG(0,3))

	push	3
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	test	eax, eax
	jne	SHORT $L40827

; 2394 : 		m_flgeigerRange = 1000;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2804], 1148846080	; 447a0000H
$L40827:
$L40822:

; 2395 : 
; 2396 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateGeigerCounter@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::UpdateGeigerCounter
_TEXT	ENDS
PUBLIC	??_C@_01PIHH@?$CB?$AA@				; `string'
PUBLIC	__real@8@4000e000000000000000
EXTRN	?gszallsentencenames@@3PAY0CA@DA:BYTE		; gszallsentencenames
EXTRN	?EMIT_SOUND_SUIT@@YAXPAUedict_s@@PBD@Z:NEAR	; EMIT_SOUND_SUIT
EXTRN	?EMIT_GROUPID_SUIT@@YAXPAUedict_s@@H@Z:NEAR	; EMIT_GROUPID_SUIT
;	COMDAT ??_C@_01PIHH@?$CB?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_01PIHH@?$CB?$AA@ DB '!', 00H			; `string'
CONST	ENDS
;	COMDAT __real@8@4000e000000000000000
CONST	SEGMENT
__real@8@4000e000000000000000 DQ 0400c000000000000r ; 3.5
CONST	ENDS
;	COMDAT ?CheckSuitUpdate@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_isentence$ = -12
_isearch$ = -16
_sentence$40846 = -52
?CheckSuitUpdate@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::CheckSuitUpdate, COMDAT

; 2410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2411 : 	int i;
; 2412 : 	int isentence = 0;

	mov	DWORD PTR _isentence$[ebp], 0

; 2413 : 	int isearch = m_iSuitPlayNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2536]
	mov	DWORD PTR _isearch$[ebp], ecx

; 2414 : 
; 2415 : 	// Ignore suit updates if no suit
; 2416 : 	if ( !HasWeapon( WEAPON_SUIT ))

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	jne	SHORT $L40836

; 2417 : 		return;

	jmp	$L40832
$L40836:

; 2418 : 
; 2419 : 	// if in range of radiation source, ping geiger counter
; 2420 : 	UpdateGeigerCounter();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateGeigerCounter@CBasePlayer@@QAEXXZ ; CBasePlayer::UpdateGeigerCounter

; 2421 : 
; 2422 : 	if ( g_pGameRules->IsMultiplayer() )

	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+24]
	test	eax, eax
	je	SHORT $L40837

; 2424 : 		// don't bother updating HEV voice in multiplayer.
; 2425 : 		return;

	jmp	$L40832
$L40837:

; 2427 : 
; 2428 : 	if ( gpGlobals->time >= m_flSuitUpdate && m_flSuitUpdate > 0)

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+2516]
	fnstsw	ax
	test	ah, 1
	jne	$L40849
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+2516]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L40849

; 2430 : 		// play a sentence off of the end of the queue
; 2431 : 		for (i = 0; i < CSUITPLAYLIST; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40839
$L40840:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L40839:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L40841

; 2433 : 			if (isentence = m_rgSuitPlayList[isearch])

	mov	edx, DWORD PTR _isearch$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2520]
	mov	DWORD PTR _isentence$[ebp], ecx
	cmp	DWORD PTR _isentence$[ebp], 0
	je	SHORT $L40842

; 2434 : 				break;

	jmp	SHORT $L40841
$L40842:

; 2435 : 
; 2436 : 			if (++isearch == CSUITPLAYLIST)

	mov	edx, DWORD PTR _isearch$[ebp]
	add	edx, 1
	mov	DWORD PTR _isearch$[ebp], edx
	cmp	DWORD PTR _isearch$[ebp], 4
	jne	SHORT $L40843

; 2437 : 				isearch = 0;

	mov	DWORD PTR _isearch$[ebp], 0
$L40843:

; 2438 : 			}

	jmp	SHORT $L40840
$L40841:

; 2439 : 
; 2440 : 		if (isentence)

	cmp	DWORD PTR _isentence$[ebp], 0
	je	$L40844

; 2442 : 			m_rgSuitPlayList[isearch] = 0;

	mov	eax, DWORD PTR _isearch$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+2520], 0

; 2443 : 			if (isentence > 0)

	cmp	DWORD PTR _isentence$[ebp], 0
	jle	SHORT $L40845

; 2445 : 				// play sentence number
; 2446 : 
; 2447 : 				char sentence[CBSENTENCENAME_MAX+1];
; 2448 : 				strcpy(sentence, "!");

	push	OFFSET FLAT:??_C@_01PIHH@?$CB?$AA@	; `string'
	lea	edx, DWORD PTR _sentence$40846[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 2449 : 				strcat(sentence, gszallsentencenames[isentence]);

	mov	eax, DWORD PTR _isentence$[ebp]
	shl	eax, 5
	add	eax, OFFSET FLAT:?gszallsentencenames@@3PAY0CA@DA ; gszallsentencenames
	push	eax
	lea	ecx, DWORD PTR _sentence$40846[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2450 : 				EMIT_SOUND_SUIT(ENT(pev), sentence);

	lea	edx, DWORD PTR _sentence$40846[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_SUIT@@YAXPAUedict_s@@PBD@Z	; EMIT_SOUND_SUIT
	add	esp, 8

; 2452 : 			else

	jmp	SHORT $L40848
$L40845:

; 2454 : 				// play sentence group
; 2455 : 				EMIT_GROUPID_SUIT(ENT(pev), -isentence);

	mov	edx, DWORD PTR _isentence$[ebp]
	neg	edx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_GROUPID_SUIT@@YAXPAUedict_s@@H@Z	; EMIT_GROUPID_SUIT
	add	esp, 8
$L40848:

; 2457 : 		m_flSuitUpdate = gpGlobals->time + SUITUPDATETIME;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@4000e000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2516]

; 2459 : 		else

	jmp	SHORT $L40849
$L40844:

; 2460 : 			// queue is empty, don't check
; 2461 : 			m_flSuitUpdate = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2516], 0
$L40849:
$L40832:

; 2463 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckSuitUpdate@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::CheckSuitUpdate
_TEXT	ENDS
EXTRN	?SENTENCEG_GetIndex@@YAHPBD@Z:NEAR		; SENTENCEG_GetIndex
EXTRN	?SENTENCEG_Lookup@@YAHPBDPAD@Z:NEAR		; SENTENCEG_Lookup
;	COMDAT ?SetSuitUpdate@CBasePlayer@@QAEXPADHH@Z
_TEXT	SEGMENT
_name$ = 8
_fgroup$ = 12
_iNoRepeatTime$ = 16
_this$ = -4
_i$ = -8
_isentence$ = -12
_iempty$ = -16
?SetSuitUpdate@CBasePlayer@@QAEXPADHH@Z PROC NEAR	; CBasePlayer::SetSuitUpdate, COMDAT

; 2472 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2473 : 	int i;
; 2474 : 	int isentence;
; 2475 : 	int iempty = -1;

	mov	DWORD PTR _iempty$[ebp], -1

; 2476 : 
; 2477 : 	// Ignore suit updates if no suit
; 2478 : 	if ( !HasWeapon( WEAPON_SUIT ))

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	jne	SHORT $L40859

; 2479 : 		return;

	jmp	$L40855
$L40859:

; 2480 : 
; 2481 : 	if ( g_pGameRules->IsMultiplayer() )

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L40860

; 2483 : 		// due to static channel design, etc. We don't play HEV sounds in multiplayer right now.
; 2484 : 		return;

	jmp	$L40855
$L40860:

; 2486 : 
; 2487 : 	// if name == NULL, then clear out the queue
; 2488 : 
; 2489 : 	if (!name)

	cmp	DWORD PTR _name$[ebp], 0
	jne	SHORT $L40861

; 2491 : 		for (i = 0; i < CSUITPLAYLIST; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40862
$L40863:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L40862:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L40864

; 2492 : 			m_rgSuitPlayList[i] = 0;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+2520], 0
	jmp	SHORT $L40863
$L40864:

; 2493 : 		return;

	jmp	$L40855
$L40861:

; 2495 : 	// get sentence or group number
; 2496 : 	if (!fgroup)

	cmp	DWORD PTR _fgroup$[ebp], 0
	jne	SHORT $L40865

; 2498 : 		isentence = SENTENCEG_Lookup(name, NULL);

	push	0
	mov	eax, DWORD PTR _name$[ebp]
	push	eax
	call	?SENTENCEG_Lookup@@YAHPBDPAD@Z		; SENTENCEG_Lookup
	add	esp, 8
	mov	DWORD PTR _isentence$[ebp], eax

; 2499 : 		if (isentence < 0)

	cmp	DWORD PTR _isentence$[ebp], 0
	jge	SHORT $L40866

; 2500 : 			return;

	jmp	$L40855
$L40866:

; 2502 : 	else

	jmp	SHORT $L40867
$L40865:

; 2503 : 		// mark group number as negative
; 2504 : 		isentence = -SENTENCEG_GetIndex(name);

	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	call	?SENTENCEG_GetIndex@@YAHPBD@Z		; SENTENCEG_GetIndex
	add	esp, 4
	neg	eax
	mov	DWORD PTR _isentence$[ebp], eax
$L40867:

; 2505 : 
; 2506 : 	// check norepeat list - this list lets us cancel
; 2507 : 	// the playback of words or sentences that have already
; 2508 : 	// been played within a certain time.
; 2509 : 
; 2510 : 	for (i = 0; i < CSUITNOREPEAT; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L40868
$L40869:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L40868:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L40870

; 2512 : 		if (isentence == m_rgiSuitNoRepeat[i])

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _isentence$[ebp]
	cmp	edx, DWORD PTR [ecx+eax*4+2540]
	jne	SHORT $L40873

; 2514 : 			// this sentence or group is already in
; 2515 : 			// the norepeat list
; 2516 : 
; 2517 : 			if (m_rgflSuitNoRepeatTime[i] < gpGlobals->time)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+eax*4+2668]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L40872

; 2519 : 				// norepeat time has expired, clear it out
; 2520 : 				m_rgiSuitNoRepeat[i] = 0;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+2540], 0

; 2521 : 				m_rgflSuitNoRepeatTime[i] = 0.0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+2668], 0

; 2522 : 				iempty = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iempty$[ebp], ecx

; 2523 : 				break;

	jmp	SHORT $L40870
$L40872:

; 2527 : 				// don't play, still marked as norepeat
; 2528 : 				return;

	jmp	$L40855
$L40873:

; 2531 : 		// keep track of empty slot
; 2532 : 		if (!m_rgiSuitNoRepeat[i])

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+2540], 0
	jne	SHORT $L40874

; 2533 : 			iempty = i;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _iempty$[ebp], ecx
$L40874:

; 2534 : 	}

	jmp	$L40869
$L40870:

; 2535 : 
; 2536 : 	// sentence is not in norepeat list, save if norepeat time was given
; 2537 : 
; 2538 : 	if (iNoRepeatTime)

	cmp	DWORD PTR _iNoRepeatTime$[ebp], 0
	je	SHORT $L40875

; 2540 : 		if (iempty < 0)

	cmp	DWORD PTR _iempty$[ebp], 0
	jge	SHORT $L40876

; 2541 : 			iempty = RANDOM_LONG(0, CSUITNOREPEAT-1); // pick random slot to take over

	push	31					; 0000001fH
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR _iempty$[ebp], eax
$L40876:

; 2542 : 		m_rgiSuitNoRepeat[iempty] = isentence;

	mov	edx, DWORD PTR _iempty$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _isentence$[ebp]
	mov	DWORD PTR [eax+edx*4+2540], ecx

; 2543 : 		m_rgflSuitNoRepeatTime[iempty] = iNoRepeatTime + gpGlobals->time;

	fild	DWORD PTR _iNoRepeatTime$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [edx]
	mov	eax, DWORD PTR _iempty$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+eax*4+2668]
$L40875:

; 2545 : 
; 2546 : 	// find empty spot in queue, or overwrite last spot
; 2547 : 
; 2548 : 	m_rgSuitPlayList[m_iSuitPlayNext++] = isentence;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2536]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _isentence$[ebp]
	mov	DWORD PTR [ecx+eax*4+2520], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2536]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2536], ecx

; 2549 : 	if (m_iSuitPlayNext == CSUITPLAYLIST)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2536], 4
	jne	SHORT $L40877

; 2550 : 		m_iSuitPlayNext = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2536], 0
$L40877:

; 2551 : 
; 2552 : 	if (m_flSuitUpdate <= gpGlobals->time)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx+2516]
	fcomp	DWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40880

; 2554 : 		if (m_flSuitUpdate == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+2516]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40879

; 2555 : 			// play queue is empty, don't delay too long before playback
; 2556 : 			m_flSuitUpdate = gpGlobals->time + SUITFIRSTUPDATETIME;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffbccccccccccccd000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2516]

; 2557 : 		else

	jmp	SHORT $L40880
$L40879:

; 2558 : 			m_flSuitUpdate = gpGlobals->time + SUITUPDATETIME;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@4000e000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+2516]
$L40880:
$L40855:

; 2560 : 
; 2561 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetSuitUpdate@CBasePlayer@@QAEXPADHH@Z ENDP		; CBasePlayer::SetSuitUpdate
_TEXT	ENDS
PUBLIC	?UpdatePlayerSound@CBasePlayer@@QAEXXZ		; CBasePlayer::UpdatePlayerSound
PUBLIC	??_C@_0BN@DJPP@Client?5lost?5reserved?5sound?$CB?6?$AA@ ; `string'
PUBLIC	__real@4@4006fa00000000000000
PUBLIC	__real@4@40078000000000000000
;	COMDAT ??_C@_0BN@DJPP@Client?5lost?5reserved?5sound?$CB?6?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BN@DJPP@Client?5lost?5reserved?5sound?$CB?6?$AA@ DB 'Client lost r'
	DB	'eserved sound!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT __real@4@4006fa00000000000000
CONST	SEGMENT
__real@4@4006fa00000000000000 DD 0437a0000r	; 250
CONST	ENDS
;	COMDAT __real@4@40078000000000000000
CONST	SEGMENT
__real@4@40078000000000000000 DD 043800000r	; 256
CONST	ENDS
;	COMDAT ?UpdatePlayerSound@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_iBodyVolume$ = -8
_iVolume$ = -12
_pSound$ = -16
?UpdatePlayerSound@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::UpdatePlayerSound, COMDAT

; 2587 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 	int iBodyVolume;
; 2589 : 	int iVolume;
; 2590 : 	CSound *pSound;
; 2591 : 
; 2592 : 	pSound = CSoundEnt::SoundPointerForIndex( CSoundEnt :: ClientSoundIndex( edict() ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ClientSoundIndex@CSoundEnt@@SAHPAUedict_s@@@Z ; CSoundEnt::ClientSoundIndex
	add	esp, 4
	push	eax
	call	?SoundPointerForIndex@CSoundEnt@@SAPAVCSound@@H@Z ; CSoundEnt::SoundPointerForIndex
	add	esp, 4
	mov	DWORD PTR _pSound$[ebp], eax

; 2593 : 
; 2594 : 	if ( !pSound )

	cmp	DWORD PTR _pSound$[ebp], 0
	jne	SHORT $L40892

; 2596 : 		ALERT ( at_console, "Client lost reserved sound!\n" );

	push	OFFSET FLAT:??_C@_0BN@DJPP@Client?5lost?5reserved?5sound?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2597 : 		return;

	jmp	$L40888
$L40892:

; 2599 : 
; 2600 : 	pSound->m_iType = bits_SOUND_NONE;

	mov	eax, DWORD PTR _pSound$[ebp]
	mov	DWORD PTR [eax+12], 0

; 2601 : 
; 2602 : 	// now calculate the best target volume for the sound. If the player's weapon
; 2603 : 	// is louder than his body/movement, use the weapon volume, else, use the body volume.
; 2604 : 
; 2605 : 	if ( FBitSet ( pev->flags, FL_ONGROUND ) )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L40894

; 2607 : 		iBodyVolume = GetAbsVelocity().Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	call	__ftol
	mov	DWORD PTR _iBodyVolume$[ebp], eax

; 2608 : 
; 2609 : 		// clamp the noise that can be made by the body, in case a push trigger,
; 2610 : 		// weapon recoil, or anything shoves the player abnormally fast.
; 2611 : 		if ( iBodyVolume > 512 )

	cmp	DWORD PTR _iBodyVolume$[ebp], 512	; 00000200H
	jle	SHORT $L40895

; 2613 : 			iBodyVolume = 512;

	mov	DWORD PTR _iBodyVolume$[ebp], 512	; 00000200H
$L40895:

; 2616 : 	else

	jmp	SHORT $L40896
$L40894:

; 2618 : 		iBodyVolume = 0;

	mov	DWORD PTR _iBodyVolume$[ebp], 0
$L40896:

; 2620 : 
; 2621 : 	if ( pev->button & IN_JUMP )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+384]
	and	eax, 2
	test	eax, eax
	je	SHORT $L40897

; 2623 : 		iBodyVolume += 100;

	mov	ecx, DWORD PTR _iBodyVolume$[ebp]
	add	ecx, 100				; 00000064H
	mov	DWORD PTR _iBodyVolume$[ebp], ecx
$L40897:

; 2625 : 
; 2626 : 	// convert player move speed and actions into sound audible by monsters.
; 2627 : 	if ( m_iWeaponVolume > iBodyVolume )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2408]
	cmp	eax, DWORD PTR _iBodyVolume$[ebp]
	jle	SHORT $L40898

; 2629 : 		m_iTargetVolume = m_iWeaponVolume;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2408]
	mov	DWORD PTR [ecx+2404], eax

; 2630 : 
; 2631 : 		// OR in the bits for COMBAT sound if the weapon is being louder than the player.
; 2632 : 		pSound->m_iType |= bits_SOUND_COMBAT;

	mov	ecx, DWORD PTR _pSound$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	or	edx, 1
	mov	eax, DWORD PTR _pSound$[ebp]
	mov	DWORD PTR [eax+12], edx

; 2634 : 	else

	jmp	SHORT $L40899
$L40898:

; 2636 : 		m_iTargetVolume = iBodyVolume;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iBodyVolume$[ebp]
	mov	DWORD PTR [ecx+2404], edx
$L40899:

; 2638 : 
; 2639 : 	// decay weapon volume over time so bits_SOUND_COMBAT stays set for a while
; 2640 : 	m_iWeaponVolume -= 250 * gpGlobals->frametime;

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+2408]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR __real@4@4006fa00000000000000
	fmul	DWORD PTR [ecx+4]
	fsubp	ST(1), ST(0)
	call	__ftol
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2408], eax

; 2641 : 	if ( m_iWeaponVolume < 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2408], 0
	jge	SHORT $L40900

; 2643 : 		iVolume = 0;

	mov	DWORD PTR _iVolume$[ebp], 0
$L40900:

; 2645 : 
; 2646 : 
; 2647 : 	// if target volume is greater than the player sound's current volume, we paste the new volume in
; 2648 : 	// immediately. If target is less than the current volume, current volume is not set immediately to the
; 2649 : 	// lower volume, rather works itself towards target volume over time. This gives monsters a much better chance
; 2650 : 	// to hear a sound, especially if they don't listen every frame.
; 2651 : 	iVolume = pSound->m_iVolume;

	mov	ecx, DWORD PTR _pSound$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _iVolume$[ebp], edx

; 2652 : 
; 2653 : 	if ( m_iTargetVolume > iVolume )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2404]
	cmp	ecx, DWORD PTR _iVolume$[ebp]
	jle	SHORT $L40901

; 2655 : 		iVolume = m_iTargetVolume;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2404]
	mov	DWORD PTR _iVolume$[ebp], eax

; 2657 : 	else if ( iVolume > m_iTargetVolume )

	jmp	SHORT $L40904
$L40901:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iVolume$[ebp]
	cmp	edx, DWORD PTR [ecx+2404]
	jle	SHORT $L40904

; 2659 : 		iVolume -= 250 * gpGlobals->frametime;

	fild	DWORD PTR _iVolume$[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR __real@4@4006fa00000000000000
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	call	__ftol
	mov	DWORD PTR _iVolume$[ebp], eax

; 2660 : 
; 2661 : 		if ( iVolume < m_iTargetVolume )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _iVolume$[ebp]
	cmp	edx, DWORD PTR [ecx+2404]
	jge	SHORT $L40904

; 2663 : 			iVolume = 0;

	mov	DWORD PTR _iVolume$[ebp], 0
$L40904:

; 2666 : 
; 2667 : 	if ( m_fNoPlayerSound )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2900], 0
	je	SHORT $L40905

; 2669 : 		// debugging flag, lets players move around and shoot without monsters hearing.
; 2670 : 		iVolume = 0;

	mov	DWORD PTR _iVolume$[ebp], 0
$L40905:

; 2672 : 
; 2673 : 	if ( gpGlobals->time > m_flStopExtraSoundTime )

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcomp	DWORD PTR [edx+2420]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40906

; 2675 : 		// since the extra sound that a weapon emits only lasts for one client frame, we keep that sound around for a server frame or two
; 2676 : 		// after actual emission to make sure it gets heard.
; 2677 : 		m_iExtraSoundTypes = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2412], 0
$L40906:

; 2679 : 
; 2680 : 	if ( pSound )

	cmp	DWORD PTR _pSound$[ebp], 0
	je	SHORT $L40907

; 2682 : 		pSound->m_vecOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _pSound$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 2683 : 		pSound->m_iType |= ( bits_SOUND_PLAYER | m_iExtraSoundTypes );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2412]
	or	edx, 4
	mov	eax, DWORD PTR _pSound$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	or	ecx, edx
	mov	edx, DWORD PTR _pSound$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 2684 : 		pSound->m_iVolume = iVolume;

	mov	eax, DWORD PTR _pSound$[ebp]
	mov	ecx, DWORD PTR _iVolume$[ebp]
	mov	DWORD PTR [eax+16], ecx
$L40907:

; 2686 : 
; 2687 : 	// keep track of virtual muzzle flash
; 2688 : 	m_iWeaponFlash -= 256 * gpGlobals->frametime;

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+2416]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR __real@4@40078000000000000000
	fmul	DWORD PTR [eax+4]
	fsubp	ST(1), ST(0)
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2416], eax

; 2689 : 	if (m_iWeaponFlash < 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2416], 0
	jge	SHORT $L40908

; 2690 : 		m_iWeaponFlash = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2416], 0
$L40908:
$L40888:

; 2691 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdatePlayerSound@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::UpdatePlayerSound
_TEXT	ENDS
PUBLIC	?PostThink@CBasePlayer@@UAEXXZ			; CBasePlayer::PostThink
PUBLIC	?ItemPostFrame@CBasePlayer@@QAEXXZ		; CBasePlayer::ItemPostFrame
PUBLIC	??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@	; `string'
PUBLIC	__real@4@4007af00000000000000
PUBLIC	__real@4@40089100000000000000
PUBLIC	__real@4@40058000000000000000
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?StudioGaitFrameAdvance@CBaseAnimating@@QAEMXZ:NEAR ; CBaseAnimating::StudioGaitFrameAdvance
EXTRN	?InsertSound@CSoundEnt@@SAXHABVVector@@HM@Z:NEAR ; CSoundEnt::InsertSound
;	COMDAT ??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@ DB 'common/bodysplat.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4@4007af00000000000000
CONST	SEGMENT
__real@4@4007af00000000000000 DD 043af0000r	; 350
CONST	ENDS
;	COMDAT __real@4@40089100000000000000
CONST	SEGMENT
__real@4@40089100000000000000 DD 044110000r	; 580
CONST	ENDS
;	COMDAT __real@4@40058000000000000000
CONST	SEGMENT
__real@4@40058000000000000000 DD 042800000r	; 64
CONST	ENDS
;	COMDAT ?PostThink@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_flFallDamage$40924 = -8
?PostThink@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::PostThink, COMDAT

; 2694 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2695 : 	if ( g_fGameOver )

	cmp	DWORD PTR ?g_fGameOver@@3HA, 0		; g_fGameOver
	je	SHORT $L40912

; 2696 : 		return;         // intermission or finale

	jmp	$L40911
$L40912:

; 2697 : 
; 2698 : 	if (!IsAlive())

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L40913

; 2699 : 		return;

	jmp	$L40911
$L40913:

; 2700 : 
; 2701 : 	// update player variables for parent system
; 2702 : 	SetAbsAngles( pev->angles );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 2703 : 	SetAbsOrigin( pev->origin );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 2704 : 	SetAbsVelocity( pev->velocity );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 2705 : 
; 2706 : 	WorldPhysic->MoveCharacter( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+152]

; 2707 : 
; 2708 : 	// Handle Tank controlling
; 2709 : 	if ( m_pTank != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40916

; 2711 : 		if ( m_pTank->OnControls( this ) && !pev->weaponmodel )

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -12+[ebp], eax
	mov	ecx, DWORD PTR -12+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -12+[ebp]
	call	DWORD PTR [edx+192]
	test	eax, eax
	je	SHORT $L40915
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+192], 0
	jne	SHORT $L40915

; 2714 : 		else

	jmp	SHORT $L40916
$L40915:

; 2716 : 			m_pTank->Use( this, this, USE_OFF, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -16+[ebp], eax
	mov	ecx, DWORD PTR -16+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -16+[ebp]
	call	DWORD PTR [edx+276]

; 2717 : 			m_pTank = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L40916:

; 2720 : 
; 2721 : 	if ( m_pMonitor != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L40918

; 2723 : 		if ( !m_pMonitor->OnControls( this ))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -20+[ebp], eax
	mov	ecx, DWORD PTR -20+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -20+[ebp]
	call	DWORD PTR [edx+192]
	test	eax, eax
	jne	SHORT $L40918

; 2725 : 			// they've moved off the platform
; 2726 : 			m_pMonitor->Use( this, this, USE_RESET, 0 );

	push	0
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -24+[ebp], eax
	mov	edx, DWORD PTR -24+[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR -24+[ebp]
	call	DWORD PTR [eax+276]

; 2727 : 			m_pMonitor = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2872				; 00000b38H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L40918:

; 2730 : 
; 2731 : // do weapon stuff
; 2732 : 	ItemPostFrame( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ItemPostFrame@CBasePlayer@@QAEXXZ	; CBasePlayer::ItemPostFrame

; 2733 : 
; 2734 : // check to see if player landed hard enough to make a sound
; 2735 : // falling farther than half of the maximum safe distance, but not as far a max safe distance will
; 2736 : // play a bootscrape sound, and no damage will be inflicted. Fallling a distance shorter than half
; 2737 : // of maximum safe distance will make no sound. Falling farther than max safe distance will play a
; 2738 : // fallpain sound, and damage will be inflicted based on how far the player fell
; 2739 : 
; 2740 : 	if ( (FBitSet(pev->flags, FL_ONGROUND)) && (pev->health > 0) && m_flFallVelocity >= PLAYER_FALL_PUNCH_THRESHHOLD )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	$L40929
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L40929
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+2456]
	fcomp	DWORD PTR __real@4@4007af00000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L40929

; 2742 : 		// ALERT ( at_console, "%f\n", m_flFallVelocity );
; 2743 : 
; 2744 : 		if (pev->watertype == CONTENT_WATER)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+452], -3			; fffffffdH
	jne	SHORT $L40921

; 2752 : 		else if ( m_flFallVelocity > PLAYER_MAX_SAFE_FALL_SPEED )

	jmp	$L40928
$L40921:
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+2456]
	fcomp	DWORD PTR __real@4@40089100000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L40928

; 2754 : 
; 2755 : 			float flFallDamage = g_pGameRules->FlPlayerFallDamage( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+60]
	fstp	DWORD PTR _flFallDamage$40924[ebp]

; 2756 : 
; 2757 : 			if ( flFallDamage > pev->health )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR _flFallDamage$40924[ebp]
	fcomp	DWORD PTR [edx+352]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40925

; 2759 : 				// note: play on item channel because we play footstep landing on body channel
; 2760 : 				EMIT_SOUND(ENT(pev), CHAN_ITEM, "common/bodysplat.wav", 1, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BF@CHLM@common?1bodysplat?4wav?$AA@ ; `string'
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H
$L40925:

; 2762 : 
; 2763 : 			if ( flFallDamage > 0 )

	fld	DWORD PTR _flFallDamage$40924[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40928

; 2765 : 				TakeDamage(VARS(eoNullEntity), VARS(eoNullEntity), flFallDamage, DMG_FALL );

	push	32					; 00000020H
	mov	edx, DWORD PTR _flFallDamage$40924[ebp]
	push	edx
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	push	0
	call	?VARS@@YAPAUentvars_s@@H@Z		; VARS
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+96]

; 2766 : 				pev->punchangle.x = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+104], 0
$L40928:

; 2769 : 
; 2770 : 		if ( IsAlive() )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+200]
	test	eax, eax
	je	SHORT $L40929

; 2772 : 			SetAnimation( PLAYER_WALK );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation
$L40929:

; 2775 : 
; 2776 : 	if (FBitSet(pev->flags, FL_ONGROUND))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 512				; 00000200H
	test	eax, eax
	je	SHORT $L40930

; 2778 : 		if (m_flFallVelocity > 64 && !g_pGameRules->IsMultiplayer())

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+2456]
	fcomp	DWORD PTR __real@4@40058000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40931
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+24]
	test	eax, eax
	jne	SHORT $L40931

; 2780 : 			CSoundEnt::InsertSound ( bits_SOUND_PLAYER, GetAbsOrigin(), m_flFallVelocity, 0.2 );

	push	1045220557				; 3e4ccccdH
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+2456]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	4
	call	?InsertSound@CSoundEnt@@SAXHABVVector@@HM@Z ; CSoundEnt::InsertSound
	add	esp, 16					; 00000010H
$L40931:

; 2783 : 		m_flFallVelocity = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2456], 0
$L40930:

; 2785 : 
; 2786 : 	// select the proper animation for the player character
; 2787 : 	if ( IsAlive() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	je	$L40938

; 2789 : 		if (!GetAbsVelocity().x && !GetAbsVelocity().y)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40933
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40933

; 2790 : 			SetAnimation( PLAYER_IDLE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation

; 2791 : 		else if ((GetAbsVelocity().x || GetAbsVelocity().y) && (FBitSet(pev->flags, FL_ONGROUND)))

	jmp	SHORT $L40938
$L40933:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40936
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L40935
$L40936:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 512				; 00000200H
	test	edx, edx
	je	SHORT $L40935

; 2792 : 			SetAnimation( PLAYER_WALK );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation

; 2793 : 		else if (pev->waterlevel > 1)

	jmp	SHORT $L40938
$L40935:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 1
	jle	SHORT $L40938

; 2794 : 			SetAnimation( PLAYER_WALK );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAnimation@CBasePlayer@@QAEXW4PLAYER_ANIM@@@Z ; CBasePlayer::SetAnimation
$L40938:

; 2796 : 
; 2797 : 	// calc gait animation
; 2798 : 	StudioGaitFrameAdvance( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioGaitFrameAdvance@CBaseAnimating@@QAEMXZ ; CBaseAnimating::StudioGaitFrameAdvance
	fstp	ST(0)

; 2799 : 
; 2800 : 	// calc player animation
; 2801 : 	StudioFrameAdvance( );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?StudioFrameAdvance@CBaseAnimating@@QAEMM@Z ; CBaseAnimating::StudioFrameAdvance
	fstp	ST(0)

; 2802 : 
; 2803 : 	CheckPowerups(pev);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?CheckPowerups@@YAXPAUentvars_s@@@Z	; CheckPowerups
	add	esp, 4

; 2804 : 
; 2805 : 	UpdatePlayerSound();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdatePlayerSound@CBasePlayer@@QAEXXZ	; CBasePlayer::UpdatePlayerSound

; 2806 : 
; 2807 : 	// Track button info so we can detect 'pressed' and 'released' buttons next frame
; 2808 : 	m_afButtonLast = pev->button;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+384]
	mov	DWORD PTR [eax+2432], ecx
$L40911:

; 2809 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PostThink@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::PostThink
_TEXT	ENDS
;	COMDAT ?CheckPowerups@@YAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?CheckPowerups@@YAXPAUentvars_s@@@Z PROC NEAR		; CheckPowerups, COMDAT

; 2574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 2575 : 	if (pev->health <= 0)

	mov	eax, DWORD PTR _pev$[ebp]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L40884

; 2576 : 		return;

	jmp	SHORT $L40883
$L40884:

; 2577 : 
; 2578 : 	pev->modelindex = g_ulModelIndexPlayer;    // don't use eyes

	mov	ecx, DWORD PTR _pev$[ebp]
	mov	edx, DWORD PTR ?g_ulModelIndexPlayer@@3KA ; g_ulModelIndexPlayer
	mov	DWORD PTR [ecx+180], edx
$L40883:

; 2579 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckPowerups@@YAXPAUentvars_s@@@Z ENDP		; CheckPowerups
_TEXT	ENDS
PUBLIC	?IsSpawnPointValid@@YAHPAVCBaseEntity@@0@Z	; IsSpawnPointValid
;	COMDAT ?IsSpawnPointValid@@YAHPAVCBaseEntity@@0@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_pSpot$ = 12
_ent$ = -4
?IsSpawnPointValid@@YAHPAVCBaseEntity@@0@Z PROC NEAR	; IsSpawnPointValid, COMDAT

; 2813 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 2814 : 	CBaseEntity *ent = NULL;

	mov	DWORD PTR _ent$[ebp], 0

; 2815 : 
; 2816 : 	if( !pSpot->IsTriggered( pPlayer ))

	mov	eax, DWORD PTR _pPlayer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSpot$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pSpot$[ebp]
	call	DWORD PTR [edx+120]
	test	eax, eax
	jne	SHORT $L40944

; 2818 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L40942
$L40944:

; 2820 : 
; 2821 : 	while(( ent = UTIL_FindEntityInSphere( ent, pSpot->GetAbsOrigin(), 128 )) != NULL )

	push	1124073472				; 43000000H
	mov	ecx, DWORD PTR _pSpot$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ent$[ebp], eax
	cmp	DWORD PTR _ent$[ebp], 0
	je	SHORT $L40947

; 2823 : 		// if ent is a client, don't spawn on 'em
; 2824 : 		if( ent->IsPlayer() && ent != pPlayer )

	mov	ecx, DWORD PTR _ent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L40948
	mov	eax, DWORD PTR _ent$[ebp]
	cmp	eax, DWORD PTR _pPlayer$[ebp]
	je	SHORT $L40948

; 2825 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L40942
$L40948:

; 2826 : 	}

	jmp	SHORT $L40944
$L40947:

; 2827 : 
; 2828 : 	return TRUE;

	mov	eax, 1
$L40942:

; 2829 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSpawnPointValid@@YAHPAVCBaseEntity@@0@Z ENDP		; IsSpawnPointValid
_TEXT	ENDS
PUBLIC	??_C@_0BC@MCPA@info_player_start?$AA@		; `string'
PUBLIC	??_C@_0BH@MKJP@info_player_deathmatch?$AA@	; `string'
PUBLIC	??_C@_0DB@HALC@PutClientInServer?3?5no?5info_playe@ ; `string'
PUBLIC	?INDEXENT@@YAPAUedict_s@@H@Z			; INDEXENT
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?EntSelectSpawnPoint@@YAPAUedict_s@@PAVCBaseEntity@@@Z ; EntSelectSpawnPoint
PUBLIC	??_C@_0BB@HJAP@info_player_coop?$AA@		; `string'
EXTRN	?FNullEnt@@YAHPAVCBaseEntity@@@Z:NEAR		; FNullEnt
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByTargetname
;	COMDAT ??_C@_0BB@HJAP@info_player_coop?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BB@HJAP@info_player_coop?$AA@ DB 'info_player_coop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MCPA@info_player_start?$AA@
CONST	SEGMENT
??_C@_0BC@MCPA@info_player_start?$AA@ DB 'info_player_start', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MKJP@info_player_deathmatch?$AA@
CONST	SEGMENT
??_C@_0BH@MKJP@info_player_deathmatch?$AA@ DB 'info_player_deathmatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@HALC@PutClientInServer?3?5no?5info_playe@
CONST	SEGMENT
??_C@_0DB@HALC@PutClientInServer?3?5no?5info_playe@ DB 'PutClientInServer'
	DB	': no info_player_start on level', 00H	; `string'
CONST	ENDS
;	COMDAT ?EntSelectSpawnPoint@@YAPAUedict_s@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
_i$40965 = -12
_pFirstSpot$40971 = -16
_ent$40980 = -20
_pPlayer$ = 8
_pSpot$ = -4
_player$ = -8
?EntSelectSpawnPoint@@YAPAUedict_s@@PAVCBaseEntity@@@Z PROC NEAR ; EntSelectSpawnPoint, COMDAT

; 2844 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi

; 2845 : 	CBaseEntity *pSpot;
; 2846 : 	edict_t		*player;
; 2847 : 
; 2848 : 	player = pPlayer->edict();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	DWORD PTR _player$[ebp], eax

; 2849 : 
; 2850 : // choose a info_player_deathmatch point
; 2851 : 	if (g_pGameRules->IsCoOp())

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+36]
	test	eax, eax
	je	SHORT $L40955

; 2853 : 		pSpot = UTIL_FindEntityByClassname( g_pLastSpawn, "info_player_coop");

	push	OFFSET FLAT:??_C@_0BB@HJAP@info_player_coop?$AA@ ; `string'
	mov	eax, DWORD PTR ?g_pLastSpawn@@3PAVCBaseEntity@@A ; g_pLastSpawn
	push	eax
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax

; 2854 : 		if ( !FNullEnt(pSpot) )

	mov	ecx, DWORD PTR _pSpot$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40957

; 2855 : 			goto ReturnSpot;

	jmp	$L40959
$L40957:

; 2856 : 		pSpot = UTIL_FindEntityByClassname( g_pLastSpawn, "info_player_start");

	push	OFFSET FLAT:??_C@_0BC@MCPA@info_player_start?$AA@ ; `string'
	mov	edx, DWORD PTR ?g_pLastSpawn@@3PAVCBaseEntity@@A ; g_pLastSpawn
	push	edx
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax

; 2857 : 		if ( !FNullEnt(pSpot) )

	mov	eax, DWORD PTR _pSpot$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40961

; 2858 : 			goto ReturnSpot;

	jmp	$L40962
$L40961:

; 2860 : 	else if ( g_pGameRules->IsDeathmatch() )

	jmp	$L40979
$L40955:
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+28]
	test	eax, eax
	je	$L40979

; 2862 : 		pSpot = g_pLastSpawn;

	mov	eax, DWORD PTR ?g_pLastSpawn@@3PAVCBaseEntity@@A ; g_pLastSpawn
	mov	DWORD PTR _pSpot$[ebp], eax

; 2863 : 		// Randomize the start spot
; 2864 : 		for ( int i = RANDOM_LONG(1,5); i > 0; i-- )

	push	5
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
	mov	DWORD PTR _i$40965[ebp], eax
	jmp	SHORT $L40966
$L40967:
	mov	ecx, DWORD PTR _i$40965[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$40965[ebp], ecx
$L40966:
	cmp	DWORD PTR _i$40965[ebp], 0
	jle	SHORT $L40968

; 2865 : 			pSpot = UTIL_FindEntityByClassname( pSpot, "info_player_deathmatch" );

	push	OFFSET FLAT:??_C@_0BH@MKJP@info_player_deathmatch?$AA@ ; `string'
	mov	edx, DWORD PTR _pSpot$[ebp]
	push	edx
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax
	jmp	SHORT $L40967
$L40968:

; 2866 : 		if ( FNullEnt( pSpot ) )  // skip over the null point

	mov	eax, DWORD PTR _pSpot$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L40970

; 2867 : 			pSpot = UTIL_FindEntityByClassname( pSpot, "info_player_deathmatch" );

	push	OFFSET FLAT:??_C@_0BH@MKJP@info_player_deathmatch?$AA@ ; `string'
	mov	ecx, DWORD PTR _pSpot$[ebp]
	push	ecx
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax
$L40970:

; 2868 : 
; 2869 : 		CBaseEntity *pFirstSpot = pSpot;

	mov	edx, DWORD PTR _pSpot$[ebp]
	mov	DWORD PTR _pFirstSpot$40971[ebp], edx
$L40972:

; 2873 : 			if ( pSpot )

	cmp	DWORD PTR _pSpot$[ebp], 0
	je	SHORT $L40976

; 2875 : 				// check if pSpot is valid
; 2876 : 				if ( IsSpawnPointValid( pPlayer, pSpot ) )

	mov	eax, DWORD PTR _pSpot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	push	ecx
	call	?IsSpawnPointValid@@YAHPAVCBaseEntity@@0@Z ; IsSpawnPointValid
	add	esp, 8
	test	eax, eax
	je	SHORT $L40976

; 2878 : 					if ( pSpot->GetAbsOrigin() == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pSpot$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L40977

; 2880 : 						pSpot = UTIL_FindEntityByClassname( pSpot, "info_player_deathmatch" );

	push	OFFSET FLAT:??_C@_0BH@MKJP@info_player_deathmatch?$AA@ ; `string'
	mov	edx, DWORD PTR _pSpot$[ebp]
	push	edx
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax

; 2881 : 						continue;

	jmp	SHORT $L40973
$L40977:

; 2883 : 
; 2884 : 					// if so, go to pSpot
; 2885 : 					goto ReturnSpot;

	jmp	$L40978
$L40976:

; 2888 : 			// increment pSpot
; 2889 : 			pSpot = UTIL_FindEntityByClassname( pSpot, "info_player_deathmatch" );

	push	OFFSET FLAT:??_C@_0BH@MKJP@info_player_deathmatch?$AA@ ; `string'
	mov	eax, DWORD PTR _pSpot$[ebp]
	push	eax
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax
$L40973:

; 2890 : 		} while ( pSpot != pFirstSpot ); // loop if we're not back to the start

	mov	ecx, DWORD PTR _pSpot$[ebp]
	cmp	ecx, DWORD PTR _pFirstSpot$40971[ebp]
	jne	SHORT $L40972

; 2891 : 
; 2892 : 		// we haven't found a place to spawn yet,  so kill any guy at the first spawn point and spawn there
; 2893 : 		if ( !FNullEnt( pSpot ) )

	mov	edx, DWORD PTR _pSpot$[ebp]
	push	edx
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L40979

; 2895 : 			CBaseEntity *ent = NULL;

	mov	DWORD PTR _ent$40980[ebp], 0
$L40982:

; 2896 : 			while(( ent = UTIL_FindEntityInSphere( ent, pSpot->GetAbsOrigin(), 128 )) != NULL )

	push	1124073472				; 43000000H
	mov	ecx, DWORD PTR _pSpot$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	eax, DWORD PTR _ent$40980[ebp]
	push	eax
	call	?UTIL_FindEntityInSphere@@YAPAVCBaseEntity@@PAV1@ABVVector@@M@Z ; UTIL_FindEntityInSphere
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ent$40980[ebp], eax
	cmp	DWORD PTR _ent$40980[ebp], 0
	je	SHORT $L40983

; 2898 : 				// if ent is a client, kill em (unless they are ourselves)
; 2899 : 				if ( ent->IsPlayer() && !(ent->edict() == player) )

	mov	ecx, DWORD PTR _ent$40980[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ent$40980[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L40984
	mov	ecx, DWORD PTR _ent$40980[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	cmp	eax, DWORD PTR _player$[ebp]
	je	SHORT $L40984

; 2900 : 					ent->TakeDamage( VARS(INDEXENT(0)), VARS(INDEXENT(0)), 300, DMG_GENERIC );

	push	0
	push	1133903872				; 43960000H
	push	0
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	push	eax
	push	0
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _ent$40980[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _ent$40980[ebp]
	call	DWORD PTR [edx+96]
$L40984:

; 2901 : 			}

	jmp	SHORT $L40982
$L40983:

; 2902 : 			goto ReturnSpot;

	jmp	$L40985
$L40979:

; 2905 : 
; 2906 : 	// If startspot is set, (re)spawn there.
; 2907 : 	if ( FStringNull( gpGlobals->startspot ) || !strlen(STRING(gpGlobals->startspot)))

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40987
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40986
$L40987:

; 2909 : 		pSpot = UTIL_FindEntityByClassname(NULL, "info_player_start");

	push	OFFSET FLAT:??_C@_0BC@MCPA@info_player_start?$AA@ ; `string'
	push	0
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax

; 2910 : 		if ( !FNullEnt(pSpot) )

	mov	ecx, DWORD PTR _pSpot$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L40988

; 2911 : 			goto ReturnSpot;

	jmp	SHORT $L40989
$L40988:

; 2913 : 	else

	jmp	SHORT $ReturnSpot$40958
$L40986:

; 2915 : 		pSpot = UTIL_FindEntityByTargetname( NULL, STRING(gpGlobals->startspot) );

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pSpot$[ebp], eax

; 2916 : 		if ( !FNullEnt(pSpot) )

	mov	ecx, DWORD PTR _pSpot$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $ReturnSpot$40958

; 2917 : 			goto ReturnSpot;

	jmp	SHORT $L40992
$ReturnSpot$40958:

; 2919 : 
; 2920 : ReturnSpot:
; 2921 : 	if ( FNullEnt( pSpot ) )

	mov	edx, DWORD PTR _pSpot$[ebp]
	push	edx
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L40993

; 2923 : 		ALERT(at_error, "PutClientInServer: no info_player_start on level");

	push	OFFSET FLAT:??_C@_0DB@HALC@PutClientInServer?3?5no?5info_playe@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 2924 : 		return INDEXENT(0);

	push	0
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	jmp	SHORT $L40952
$L40993:

; 2926 : 
; 2927 : 	g_pLastSpawn = pSpot;

	mov	eax, DWORD PTR _pSpot$[ebp]
	mov	DWORD PTR ?g_pLastSpawn@@3PAVCBaseEntity@@A, eax ; g_pLastSpawn

; 2928 : 	return pSpot->edict();

	mov	ecx, DWORD PTR _pSpot$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	jmp	SHORT $L40952
$L40992:

; 2929 : }

	jmp	SHORT $ReturnSpot$40958
$L40989:
	jmp	SHORT $ReturnSpot$40958
$L40985:
	jmp	SHORT $ReturnSpot$40958
$L40978:
	jmp	SHORT $ReturnSpot$40958
$L40962:
	jmp	SHORT $ReturnSpot$40958
$L40959:
	jmp	SHORT $ReturnSpot$40958
$L40952:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EntSelectSpawnPoint@@YAPAUedict_s@@PAVCBaseEntity@@@Z ENDP ; EntSelectSpawnPoint
_TEXT	ENDS
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_iEdictNum$ = 8
?INDEXENT@@YAPAUedict_s@@H@Z PROC NEAR			; INDEXENT, COMDAT

; 187  : inline edict_t* INDEXENT( int iEdictNum )		{ return (*g_engfuncs.pfnPEntityOfEntIndex)(iEdictNum); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _iEdictNum$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+288
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?INDEXENT@@YAPAUedict_s@@H@Z ENDP			; INDEXENT
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
PUBLIC	??_C@_07DGNG@?$CKplayer?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	??_C@_03HGJB@slj?$AA@				; `string'
PUBLIC	??_C@_01FBAH@1?$AA@				; `string'
PUBLIC	??_C@_02MDGH@hl?$AA@				; `string'
PUBLIC	??_C@_05PECN@incar?$AA@				; `string'
PUBLIC	??_C@_0BC@DMHA@models?1player?4mdl?$AA@		; `string'
PUBLIC	??_C@_0CD@JFAD@Couldn?8t?5alloc?5player?5sound?5slot@ ; `string'
PUBLIC	?Spawn@CBasePlayer@@UAEXXZ			; CBasePlayer::Spawn
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT ??_C@_07DGNG@?$CKplayer?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_07DGNG@?$CKplayer?$AA@ DB '*player', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03HGJB@slj?$AA@
CONST	SEGMENT
??_C@_03HGJB@slj?$AA@ DB 'slj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FBAH@1?$AA@
CONST	SEGMENT
??_C@_01FBAH@1?$AA@ DB '1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDGH@hl?$AA@
CONST	SEGMENT
??_C@_02MDGH@hl?$AA@ DB 'hl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PECN@incar?$AA@
CONST	SEGMENT
??_C@_05PECN@incar?$AA@ DB 'incar', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DMHA@models?1player?4mdl?$AA@
CONST	SEGMENT
??_C@_0BC@DMHA@models?1player?4mdl?$AA@ DB 'models/player.mdl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JFAD@Couldn?8t?5alloc?5player?5sound?5slot@
CONST	SEGMENT
??_C@_0CD@JFAD@Couldn?8t?5alloc?5player?5sound?5slot@ DB 'Couldn''t alloc'
	DB	' player sound slot!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?Spawn@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
$T44020 = -20
$T44021 = -32
$T44022 = -44
$T44023 = -56
$T44024 = -68
$T44025 = -80
?Spawn@CBasePlayer@@UAEXXZ PROC NEAR			; CBasePlayer::Spawn, COMDAT

; 2932 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 2933 : 	pev->classname		= MAKE_STRING("player");

	push	OFFSET FLAT:??_C@_06MNOE@player?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 2934 : 	pev->health		= 100;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+352], 1120403456		; 42c80000H

; 2935 : 	pev->armorvalue		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+444], 0

; 2936 : 	pev->takedamage		= DAMAGE_AIM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+364], 1073741824		; 40000000H

; 2937 : 	pev->solid		= SOLID_SLIDEBOX;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 3

; 2938 : 	pev->movetype		= MOVETYPE_WALK;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 3

; 2939 : 	pev->max_health		= pev->health;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+352]
	mov	DWORD PTR [ecx+432], edx

; 2940 : 	pev->flags		   &= FL_PROXY;	// keep proxy flag sey by engine

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 1048576				; 00100000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 2941 : 	pev->flags		   |= FL_CLIENT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 2942 : 	pev->air_finished	= gpGlobals->time + 12;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@4002c000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+508]

; 2943 : 	pev->dmg			= 2;				// initial water damage

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+480], 1073741824		; 40000000H

; 2944 : 	pev->effects		= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], 0

; 2945 : 	pev->deadflag		= DEAD_NO;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+368], 0

; 2946 : 	pev->dmg_take		= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+472], 0

; 2947 : 	pev->dmg_save		= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+476], 0

; 2948 : 	pev->friction		= 1.0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+288], 1065353216		; 3f800000H

; 2949 : 	pev->gravity		= 1.0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+284], 1065353216		; 3f800000H

; 2950 : 	m_bitsHUDDamage		= -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2844], -1

; 2951 : 	m_bitsDamageType		= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2312], 0

; 2952 : 	m_afPhysicsFlags		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], 0

; 2953 : 	m_fLongJump		= FALSE;// no longjump module.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2904], 0

; 2954 : 	m_iInCarState		= VEHICLE_INACTIVE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2908], 0

; 2955 : 
; 2956 : 	pev->targetname		= MAKE_STRING( "*player" );

	push	OFFSET FLAT:??_C@_07DGNG@?$CKplayer?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+460], eax

; 2957 : 
; 2958 : 	m_iRainDripsPerSecond = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4172], 0

; 2959 : 	m_flRainWindX = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4176], 0

; 2960 : 	m_flRainWindY = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4180], 0

; 2961 : 	m_flRainRandX = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4184], 0

; 2962 : 	m_flRainRandY = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4188], 0

; 2963 : 	m_iRainIdealDripsPerSecond = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4192], 0

; 2964 : 	m_flRainIdealWindX = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4196], 0

; 2965 : 	m_flRainIdealWindY = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4200], 0

; 2966 : 	m_flRainIdealRandX = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4204], 0

; 2967 : 	m_flRainIdealRandY = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4208], 0

; 2968 : 	m_flRainEndFade = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4212], 0

; 2969 : 	m_flRainNextFadeUpdate = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4216], 0

; 2970 : 
; 2971 : 	g_engfuncs.pfnSetPhysicsKeyValue( edict(), "slj", "0" );

	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_03HGJB@slj?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 2972 : 	g_engfuncs.pfnSetPhysicsKeyValue( edict(), "hl", "1" );

	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_02MDGH@hl?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 2973 : 	g_engfuncs.pfnSetPhysicsKeyValue( edict(), "incar", "0" );

	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_05PECN@incar?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 2974 : 
; 2975 : 	pev->fov = m_iFOV				= 0;// init field of view.

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2936], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+532], 0

; 2976 : 	m_iClientFOV		= -1; // make sure fov reset is sent

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2940], -1

; 2977 : 	memset( m_iClientWeapons, -1, MAX_WEAPON_BYTES );

	push	8
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2944				; 00000b80H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2978 : 
; 2979 : 	m_flNextDecalTime	= 0;// let this player decal as soon as he spawns.

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3800], 0

; 2980 : 
; 2981 : 	m_flgeigerDelay = gpGlobals->time + 2.0;	// wait a few seconds until user-defined message registrations

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@40008000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2808]

; 2982 : 												// are recieved by all clients
; 2983 : 
; 2984 : 	m_flTimeStepSound	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2496], 0

; 2985 : 	m_iStepLeft = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2816], 0

; 2986 : 	m_flFieldOfView		= 0.5;// some monsters use this to determine whether or not the player is looking at them.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2056], 1056964608	; 3f000000H

; 2987 : 
; 2988 : 	m_bloodColor	= BLOOD_COLOR_RED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2328], 247		; 000000f7H

; 2989 : 	m_flNextAttack	= gpGlobals->time;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+2308], ecx

; 2990 : 	StartSneaking();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+184]

; 2991 : 
; 2992 : 	m_iFlashBattery = 99;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2428], 99		; 00000063H

; 2993 : 	m_flFlashLightTime = 1; // force first message

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2424], 1065353216	; 3f800000H

; 2994 : 	m_iClientSndRoomtype = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2952], -1

; 2995 : 
; 2996 : // dont let uninitialized value here hurt the player
; 2997 : 	m_flFallVelocity = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2456], 0

; 2998 : 
; 2999 : 	g_pGameRules->SetDefaultPlayerTeam( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+220]

; 3000 : 	g_pGameRules->GetPlayerSpawnSpot( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+88]

; 3001 : 
; 3002 : 	SET_MODEL(ENT(pev), "models/player.mdl");

	push	OFFSET FLAT:??_C@_0BC@DMHA@models?1player?4mdl?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 3003 : 	g_ulModelIndexPlayer = pev->modelindex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+180]
	mov	DWORD PTR ?g_ulModelIndexPlayer@@3KA, ecx ; g_ulModelIndexPlayer

; 3004 : 
; 3005 : 	pev->sequence = LookupActivity( ACT_IDLE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupActivity@CBaseAnimating@@QAEHH@Z	; CBaseAnimating::LookupActivity
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+296], eax

; 3006 : 
; 3007 : 	if ( FBitSet(pev->flags, FL_DUCKING) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 16384				; 00004000H
	test	ecx, ecx
	je	SHORT $L41007

; 3008 : 		UTIL_SetSize(pev, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX);

	push	1099956224				; 41900000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T44020[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	-1047527424				; c1900000H
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T44021[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 3009 : 	else

	jmp	SHORT $L41010
$L41007:

; 3010 : 		UTIL_SetSize(pev, VEC_HULL_MIN, VEC_HULL_MAX);

	push	1108344832				; 42100000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T44022[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	-1039138816				; c2100000H
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T44023[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH
$L41010:

; 3011 : 
; 3012 : 	pev->view_ofs = VEC_VIEW;

	push	1105199104				; 41e00000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T44024[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 372				; 00000174H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 3013 : 	Precache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]

; 3014 : 	m_HackedGunPos		= Vector( 0, 32, 0 );

	push	0
	push	1107296256				; 42000000H
	push	0
	lea	ecx, DWORD PTR $T44025[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2364				; 0000093cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3015 : 
; 3016 : 	if ( m_iPlayerSound == SOUNDLIST_EMPTY )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2400], -1
	jne	SHORT $L41015

; 3018 : 		ALERT ( at_console, "Couldn't alloc player sound slot!\n" );

	push	OFFSET FLAT:??_C@_0CD@JFAD@Couldn?8t?5alloc?5player?5sound?5slot@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L41015:

; 3020 : 
; 3021 : 	m_fNoPlayerSound = FALSE;// normal sound behavior.

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2900], 0

; 3022 : 
; 3023 : 	m_pLastItem = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2988], 0

; 3024 : 	m_fInitHUD = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2848], 1

; 3025 : 	m_iClientHideHUD = -1;  // force this to be recalculated

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2932], -1

; 3026 : 	m_fWeapon = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2860], 0

; 3027 : 	m_pClientActiveItem = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2984], 0

; 3028 : 	m_iClientBattery = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2924], -1

; 3029 : 	m_iClientSndRoomtype = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2952], -1

; 3030 : 
; 3031 : 	UpdateKeyCatchers ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateKeyCatchers@CBasePlayer@@QAEXXZ	; CBasePlayer::UpdateKeyCatchers

; 3032 : 
; 3033 : 	// reset all ammo values to 0
; 3034 : 	for ( int i = 0; i < MAX_AMMO_SLOTS; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41018
$L41019:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L41018:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L41020

; 3036 : 		m_rgAmmo[i] = 0;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+3508], 0

; 3037 : 		m_rgAmmoLast[i] = 0;  // client ammo values also have to be reset  (the death hud clear messages does on the client side)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+3636], 0

; 3038 : 	}

	jmp	SHORT $L41019
$L41020:

; 3039 : 
; 3040 : 	m_lastx = m_lasty = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3792], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3788], 0

; 3041 : 
; 3042 : 	m_flNextChatTime = gpGlobals->time;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+4132], ecx

; 3043 : 
; 3044 : 	g_pGameRules->PlayerSpawn( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+72]

; 3045 : 
; 3046 : 	// create a cinematic collision box
; 3047 : 	m_pUserData = WorldPhysic->CreateBoxFromEntity( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 3048 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBasePlayer@@UAEXXZ ENDP				; CBasePlayer::Spawn
_TEXT	ENDS
PUBLIC	??_C@_0FC@DGFM@You?5use?5is?5too?5old?5version?5of?5Xa@ ; `string'
PUBLIC	?CheckCompatibility@CBasePlayer@@QAEXXZ		; CBasePlayer::CheckCompatibility
EXTRN	?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z:NEAR ; UTIL_HudMessage
EXTRN	?g_fPhysicInitialized@@3HA:DWORD		; g_fPhysicInitialized
;	COMDAT ??_C@_0FC@DGFM@You?5use?5is?5too?5old?5version?5of?5Xa@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0FC@DGFM@You?5use?5is?5too?5old?5version?5of?5Xa@ DB 'You use is to'
	DB	'o old version of Xash3D engine.', 0aH, 'Visit www.hlfx.ru/for'
	DB	'um for updates.', 00H			; `string'
CONST	ENDS
;	COMDAT ?CheckCompatibility@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_m_textParms$ = -44
?CheckCompatibility@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::CheckCompatibility, COMDAT

; 3051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3052 : 	hudtextparms_t	m_textParms;
; 3053 : 
; 3054 : 	m_textParms.channel = 0;

	mov	DWORD PTR _m_textParms$[ebp+36], 0

; 3055 : 	m_textParms.x = -1;

	mov	DWORD PTR _m_textParms$[ebp], -1082130432 ; bf800000H

; 3056 : 	m_textParms.y = -1;

	mov	DWORD PTR _m_textParms$[ebp+4], -1082130432 ; bf800000H

; 3057 : 	m_textParms.effect = 0;

	mov	DWORD PTR _m_textParms$[ebp+8], 0

; 3058 : 
; 3059 : 	m_textParms.r1 = 255;

	mov	BYTE PTR _m_textParms$[ebp+12], 255	; 000000ffH

; 3060 : 	m_textParms.g1 = 255;

	mov	BYTE PTR _m_textParms$[ebp+13], 255	; 000000ffH

; 3061 : 	m_textParms.b1 = 255;

	mov	BYTE PTR _m_textParms$[ebp+14], 255	; 000000ffH

; 3062 : 	m_textParms.a1 = 200;

	mov	BYTE PTR _m_textParms$[ebp+15], 200	; 000000c8H

; 3063 : 
; 3064 : 	m_textParms.r2 = 255;

	mov	BYTE PTR _m_textParms$[ebp+16], 255	; 000000ffH

; 3065 : 	m_textParms.g2 = 160;

	mov	BYTE PTR _m_textParms$[ebp+17], 160	; 000000a0H

; 3066 : 	m_textParms.b2 = 0;

	mov	BYTE PTR _m_textParms$[ebp+18], 0

; 3067 : 	m_textParms.a2 = 200;

	mov	BYTE PTR _m_textParms$[ebp+19], 200	; 000000c8H

; 3068 : 	m_textParms.fadeinTime = 3;

	mov	DWORD PTR _m_textParms$[ebp+20], 1077936128 ; 40400000H

; 3069 : 	m_textParms.fadeoutTime = 3;

	mov	DWORD PTR _m_textParms$[ebp+24], 1077936128 ; 40400000H

; 3070 : 	m_textParms.holdTime = 10;

	mov	DWORD PTR _m_textParms$[ebp+28], 1092616192 ; 41200000H

; 3071 : 	m_textParms.fxTime = 0.25;

	mov	DWORD PTR _m_textParms$[ebp+32], 1048576000 ; 3e800000H

; 3072 : 
; 3073 : 	if( !g_fPhysicInitialized )

	cmp	DWORD PTR ?g_fPhysicInitialized@@3HA, 0	; g_fPhysicInitialized
	jne	SHORT $L41026

; 3075 : 		UTIL_HudMessage( this, m_textParms, "You use is too old version of Xash3D engine.\nVisit www.hlfx.ru/forum for updates." );

	push	OFFSET FLAT:??_C@_0FC@DGFM@You?5use?5is?5too?5old?5version?5of?5Xa@ ; `string'
	lea	eax, DWORD PTR _m_textParms$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_HudMessage@@YAXPAVCBaseEntity@@ABUhudtextparms_s@@PBD@Z ; UTIL_HudMessage
	add	esp, 12					; 0000000cH
$L41026:

; 3077 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckCompatibility@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::CheckCompatibility
_TEXT	ENDS
PUBLIC	??_C@_0CA@HLMG@?$CK?$CKGraph?5pointers?5were?5not?5set?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@OMEJ@?$CK?$CKGraph?5Pointers?5Set?$CB?6?$AA@ ; `string'
PUBLIC	?Precache@CBasePlayer@@UAEXXZ			; CBasePlayer::Precache
EXTRN	?FSetGraphPointers@CGraph@@QAEHXZ:NEAR		; CGraph::FSetGraphPointers
EXTRN	?WorldGraph@@3VCGraph@@A:BYTE			; WorldGraph
;	COMDAT ??_C@_0CA@HLMG@?$CK?$CKGraph?5pointers?5were?5not?5set?$CB?6?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0CA@HLMG@?$CK?$CKGraph?5pointers?5were?5not?5set?$CB?6?$AA@ DB '**G'
	DB	'raph pointers were not set!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OMEJ@?$CK?$CKGraph?5Pointers?5Set?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BH@OMEJ@?$CK?$CKGraph?5Pointers?5Set?$CB?6?$AA@ DB '**Graph Pointe'
	DB	'rs Set!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?Precache@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBasePlayer@@UAEXXZ PROC NEAR			; CBasePlayer::Precache, COMDAT

; 3080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3081 : 	// in the event that the player JUST spawned, and the level node graph
; 3082 : 	// was loaded, fix all of the node graph pointers before the game starts.
; 3083 : 
; 3084 : 	// !!!BUGBUG - now that we have multiplayer, this needs to be moved!
; 3085 : 	if ( WorldGraph.m_fGraphPresent && !WorldGraph.m_fGraphPointersSet )

	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A, 0
	je	SHORT $L41035
	cmp	DWORD PTR ?WorldGraph@@3VCGraph@@A+4, 0
	jne	SHORT $L41035

; 3087 : 		if ( !WorldGraph.FSetGraphPointers() )

	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FSetGraphPointers@CGraph@@QAEHXZ	; CGraph::FSetGraphPointers
	test	eax, eax
	jne	SHORT $L41033

; 3089 : 			ALERT ( at_console, "**Graph pointers were not set!\n");

	push	OFFSET FLAT:??_C@_0CA@HLMG@?$CK?$CKGraph?5pointers?5were?5not?5set?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3091 : 		else

	jmp	SHORT $L41035
$L41033:

; 3093 : 			ALERT ( at_console, "**Graph Pointers Set!\n" );

	push	OFFSET FLAT:??_C@_0BH@OMEJ@?$CK?$CKGraph?5Pointers?5Set?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L41035:

; 3096 : 
; 3097 : 	// SOUNDS / MODELS ARE PRECACHED in ClientPrecache() (game specific)
; 3098 : 	// because they need to precache before any clients have connected
; 3099 : 
; 3100 : 	// init geiger counter vars during spawn and each time
; 3101 : 	// we cross a level transition
; 3102 : 
; 3103 : 	m_flgeigerRange = 1000;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2804], 1148846080	; 447a0000H

; 3104 : 	m_igeigerRangePrev = 1000;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2812], 1000		; 000003e8H

; 3105 : 
; 3106 : 	memset( m_iClientWeapons, -1, MAX_WEAPON_BYTES );

	push	8
	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2944				; 00000b80H
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3107 : 
; 3108 : 	m_bitsDamageType = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2312], 0

; 3109 : 	m_bitsHUDDamage = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2844], -1

; 3110 : 
; 3111 : 	m_iClientBattery = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2924], -1

; 3112 : 	m_iClientSndRoomtype = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2952], -1

; 3113 : 	m_flFlashLightTime = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2424], 1065353216	; 3f800000H

; 3114 : 
; 3115 : 	m_bRainNeedsUpdate = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4220], 1

; 3116 : 
; 3117 : 	m_iTrain |= TRAIN_NEW;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2856]
	or	cl, -64					; ffffffc0H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2856], ecx

; 3118 : 
; 3119 : 	m_iStartMessage = 1;// send player init messages

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4136], 1

; 3120 : 	m_iUpdateTime = 5;  // won't update for 1/2 a second

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2916], 5

; 3121 : 
; 3122 : 	if ( gInitHUD )

	cmp	DWORD PTR ?gInitHUD@@3HA, 0		; gInitHUD
	je	SHORT $L41037

; 3123 : 		m_fInitHUD = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2848], 1
$L41037:

; 3124 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::Precache
_TEXT	ENDS
PUBLIC	?RenewItems@CBasePlayer@@QAEXXZ			; CBasePlayer::RenewItems
;	COMDAT ?RenewItems@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RenewItems@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::RenewItems, COMDAT

; 3130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3131 : 
; 3132 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RenewItems@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::RenewItems
_TEXT	ENDS
PUBLIC	?CanEnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z ; CBasePlayer::CanEnterVehicle
;	COMDAT ?CanEnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
?CanEnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z PROC NEAR ; CBasePlayer::CanEnterVehicle, COMDAT

; 3135 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3136 : 	// Must be alive
; 3137 : 	if ( IsAlive() == false )

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L41046

; 3138 : 		return false;

	xor	al, al
	jmp	SHORT $L41045
$L41046:

; 3139 : 
; 3140 : 	// Can't be pulled by a barnacle
; 3141 : 	if ( FBitSet( m_afPhysicsFlags, PFLAG_ONBARNACLE|PFLAG_ONROPE ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	and	ecx, 68					; 00000044H
	test	ecx, ecx
	je	SHORT $L41047

; 3142 : 		return false;

	xor	al, al
	jmp	SHORT $L41045
$L41047:

; 3143 : 
; 3144 : 	return true;

	mov	al, 1
$L41045:

; 3145 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanEnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z ENDP ; CBasePlayer::CanEnterVehicle
_TEXT	ENDS
PUBLIC	?EnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z ; CBasePlayer::EnterVehicle
PUBLIC	?MakeNonSolid@CBaseEntity@@QAEXXZ		; CBaseEntity::MakeNonSolid
EXTRN	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalOrigin
EXTRN	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z:NEAR ; CBaseEntity::SetLocalAngles
EXTRN	?SetParent@CBaseEntity@@QAEXPAV1@H@Z:NEAR	; CBaseEntity::SetParent
EXTRN	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z:NEAR ; CBaseEntity::RelinkEntity
;	COMDAT ?EnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pVehicle$ = 8
_this$ = -4
?EnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z PROC NEAR ; CBasePlayer::EnterVehicle, COMDAT

; 3151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3152 : 	if( !CanEnterVehicle( pVehicle ))

	mov	eax, DWORD PTR _pVehicle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanEnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z ; CBasePlayer::CanEnterVehicle
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41052

; 3153 : 		return false;

	xor	al, al
	jmp	$L41051
$L41052:

; 3154 : 
; 3155 : 	SET_VIEW( edict(), pVehicle->edict() );

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+368
	add	esp, 8

; 3156 : 	MakeNonSolid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeNonSolid@CBaseEntity@@QAEXXZ	; CBaseEntity::MakeNonSolid

; 3157 : 	RelinkEntity();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 3158 : 	g_engfuncs.pfnSetPhysicsKeyValue( edict(), "incar", "1" );

	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_05PECN@incar?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 3159 : 	m_iInCarState = VEHICLE_ENTERING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2908], 1

; 3160 : 	pev->movetype = MOVETYPE_NONE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 0

; 3161 : 	SetLocalAngles( pVehicle->GetAbsAngles() );

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 3162 : 	SetLocalOrigin( pVehicle->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pVehicle$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 3163 : 	SetParent( pVehicle );

	push	0
	mov	ecx, DWORD PTR _pVehicle$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent

; 3164 : 
; 3165 : 	if( m_pActiveItem )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2980], 0
	je	SHORT $L41053

; 3167 : 		m_pActiveItem->Holster();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+368]

; 3168 : 		pev->weaponmodel = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+192], 0
$L41053:

; 3170 : 
; 3171 : 	m_iHideHUD |= HIDEHUD_WEAPONS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2928]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2928], eax

; 3172 : 	m_pVehicle = pVehicle;

	mov	edx, DWORD PTR _pVehicle$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3173 : 
; 3174 : 	return true;

	mov	al, 1
$L41051:

; 3175 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EnterVehicle@CBasePlayer@@QAE_NPAVCBaseEntity@@@Z ENDP	; CBasePlayer::EnterVehicle
_TEXT	ENDS
;	COMDAT ?MakeNonSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeNonSolid@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::MakeNonSolid, COMDAT

; 637  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		if( m_iOldSolid == SOLID_NOT && pev->solid != SOLID_NOT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $L35080
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	je	SHORT $L35080

; 640  : 			WorldPhysic->EnableCollision( this, FALSE );

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 641  : 			m_iOldSolid = pev->solid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+268]
	mov	DWORD PTR [edx+16], eax

; 642  : 			pev->solid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+268], 0
$L35080:

; 644  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeNonSolid@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::MakeNonSolid
_TEXT	ENDS
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	?LeaveVehicle@CBasePlayer@@QAEXABVVector@@0@Z	; CBasePlayer::LeaveVehicle
PUBLIC	?RestoreSolid@CBaseEntity@@QAEXXZ		; CBaseEntity::RestoreSolid
EXTRN	?SetParent@CBaseEntity@@QAEXHH@Z:NEAR		; CBaseEntity::SetParent
;	COMDAT ?LeaveVehicle@CBasePlayer@@QAEXABVVector@@0@Z
_TEXT	SEGMENT
_vecExitPoint$ = 8
_vecExitAngles$ = 12
_this$ = -4
_qAngles$ = -16
?LeaveVehicle@CBasePlayer@@QAEXABVVector@@0@Z PROC NEAR	; CBasePlayer::LeaveVehicle, COMDAT

; 3181 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3182 : 	SetParent( NULL );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@CBaseEntity@@QAEXHH@Z	; CBaseEntity::SetParent

; 3183 : 
; 3184 : 	g_engfuncs.pfnSetPhysicsKeyValue( edict(), "incar", "0" );

	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_05PECN@incar?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 3185 : 	m_iInCarState = VEHICLE_INACTIVE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2908], 0

; 3186 : 
; 3187 : 	SetAbsOrigin( vecExitPoint );

	mov	ecx, DWORD PTR _vecExitPoint$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 3188 : 	SetAbsAngles( vecExitAngles );

	mov	edx, DWORD PTR _vecExitAngles$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 3189 : 	// Clear out any leftover velocity
; 3190 : 	SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 3191 : 
; 3192 : 	Vector qAngles = vecExitAngles;

	mov	eax, DWORD PTR _vecExitAngles$[ebp]
	push	eax
	lea	ecx, DWORD PTR _qAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3193 : 	qAngles[ROLL] = 0;

	lea	ecx, DWORD PTR _qAngles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0

; 3194 : 	SnapEyeAngles( qAngles );

	lea	ecx, DWORD PTR _qAngles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SnapEyeAngles@CBasePlayer@@QAEXABVVector@@@Z ; CBasePlayer::SnapEyeAngles

; 3195 : 
; 3196 : 	m_iHideHUD &= ~HIDEHUD_WEAPONS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2928]
	and	al, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2928], eax

; 3197 : 	m_pVehicle = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2888				; 00000b48H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3198 : 
; 3199 : 	RestoreSolid();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RestoreSolid@CBaseEntity@@QAEXXZ	; CBaseEntity::RestoreSolid

; 3200 : 	RelinkEntity();

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 3201 : 	pev->movetype = MOVETYPE_WALK;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 3

; 3202 : 
; 3203 : 	SET_VIEW( edict(), edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+368
	add	esp, 8

; 3204 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?LeaveVehicle@CBasePlayer@@QAEXABVVector@@0@Z ENDP	; CBasePlayer::LeaveVehicle
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
;	COMDAT ?RestoreSolid@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RestoreSolid@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::RestoreSolid, COMDAT

; 647  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 648  : 		if( m_iOldSolid != SOLID_NOT && pev->solid == SOLID_NOT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L35083
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	jne	SHORT $L35083

; 650  : 			WorldPhysic->EnableCollision( this, TRUE );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+92]

; 651  : 			pev->solid = m_iOldSolid;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+268], eax

; 652  : 			m_iOldSolid = SOLID_NOT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
$L35083:

; 654  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreSolid@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::RestoreSolid
_TEXT	ENDS
EXTRN	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ:NEAR ; CBaseEntity::GetLocalAngles
EXTRN	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceHull
;	COMDAT ?UpdateHoldableItem@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
$T44046 = -120
$T44047 = -132
$T44048 = -144
_this$ = -4
_vecSrc$ = -16
_vecDst$ = -28
_tr$ = -84
_newOrigin$ = -96
_vecAngles$ = -108
?UpdateHoldableItem@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::UpdateHoldableItem, COMDAT

; 3207 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3208 : 	if (m_pHoldableItem == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L41064

; 3209 : 		return;

	jmp	$L41063
$L41064:

; 3210 : 
; 3211 : 	UTIL_MakeVectors ( pev->v_angle );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 116				; 00000074H
	push	ecx
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3212 : 
; 3213 : 	Vector vecSrc = EyePosition ();

	lea	edx, DWORD PTR $T44046[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3214 : 	Vector vecDst = vecSrc + gpGlobals->v_forward * m_flHoldableItemDistance;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4144]
	push	ecx
	lea	edx, DWORD PTR $T44047[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T44048[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecDst$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3215 : 
; 3216 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3217 : 	if( m_pHoldableItem->m_iActorType == ACTOR_DYNAMIC )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 1
	jne	SHORT $L41071

; 3218 : 		UTIL_TraceHull( vecSrc, vecDst, dont_ignore_monsters, head_hull, m_pHoldableItem->edict(), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	3
	push	0
	lea	eax, DWORD PTR _vecDst$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	call	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
	add	esp, 24					; 00000018H

; 3219 : 	else TRACE_MONSTER_HULL( m_pHoldableItem->edict(), vecSrc, vecDst, dont_ignore_monsters, m_pHoldableItem->edict(), &tr );

	jmp	SHORT $L41072
$L41071:
	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _vecDst$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H
$L41072:

; 3220 : 
; 3221 : 	Vector newOrigin = tr.vecEndPos;

	lea	eax, DWORD PTR _tr$[ebp+20]
	push	eax
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3222 : 
; 3223 : 	UTIL_SetOrigin( m_pHoldableItem, newOrigin );

	lea	ecx, DWORD PTR _newOrigin$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 3224 : 
; 3225 : 	// make sure what new position is valid
; 3226 : 	if( m_pHoldableItem->m_iActorType == ACTOR_DYNAMIC )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	xor	edx, edx
	mov	dl, BYTE PTR [eax+1604]
	cmp	edx, 1
	jne	SHORT $L41074

; 3227 : 		UTIL_TraceHull( newOrigin, newOrigin, dont_ignore_monsters, head_hull, m_pHoldableItem->edict(), &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	3
	push	0
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	push	ecx
	lea	edx, DWORD PTR _newOrigin$[ebp]
	push	edx
	call	?UTIL_TraceHull@@YAXABVVector@@0W4IGNORE_MONSTERS@@HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceHull
	add	esp, 24					; 00000018H

; 3228 : 	else TRACE_MONSTER_HULL( m_pHoldableItem->edict(), newOrigin, newOrigin, dont_ignore_monsters, m_pHoldableItem->edict(), &tr );

	jmp	SHORT $L41075
$L41074:
	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _newOrigin$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+132
	add	esp, 24					; 00000018H
$L41075:

; 3229 : 
; 3230 : 	if (tr.fStartSolid || tr.fAllSolid)

	cmp	DWORD PTR _tr$[ebp+4], 0
	jne	SHORT $L41077
	cmp	DWORD PTR _tr$[ebp], 0
	je	SHORT $L41076
$L41077:

; 3232 : 		// this is bad place. Restore old valid origin
; 3233 : 		UTIL_SetOrigin( m_pHoldableItem, m_vecHoldableItemPosition );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4148				; 00001034H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	call	?UTIL_SetOrigin@@YAXPAVCBaseEntity@@ABVVector@@@Z ; UTIL_SetOrigin
	add	esp, 8

; 3234 : 
; 3235 : 		if( m_pHoldableItem->m_iActorType == ACTOR_DYNAMIC )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	xor	edx, edx
	mov	dl, BYTE PTR [eax+1604]
	cmp	edx, 1
	jne	SHORT $L41078

; 3236 : 			WorldPhysic->UpdateActorPos( m_pHoldableItem );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+124]
$L41078:

; 3237 : #if 0
; 3238 : 		// a pseudocode here:
; 3239 : 		if (m_flLastBlockedTime < gpGlobals->time)
; 3240 : 		{
; 3241 : 			EMIT_SOUND ("common\item_stuck.wav");
; 3242 : 			m_flLastBlockedTime = gpGlobals->time + 1.0;
; 3243 : 		}
; 3244 : #endif
; 3245 : 		return;

	jmp	$L41063
$L41076:

; 3247 : 
; 3248 : 	Vector vecAngles = m_pHoldableItem->GetLocalAngles ();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	lea	ecx, DWORD PTR _vecAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3249 : 
; 3250 : 	// NOTE: we not afraid gimball lock here because only YAW rotation is used
; 3251 : 	vecAngles.y = m_pHoldableItem->pev->fuser2 + pev->v_angle.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+600]
	fadd	DWORD PTR [edx+120]
	fstp	DWORD PTR _vecAngles$[ebp+4]

; 3252 : 	m_pHoldableItem->SetLocalAngles ( vecAngles );

	lea	eax, DWORD PTR _vecAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 3253 : 
; 3254 : 	// refresh the last valid position
; 3255 : 	m_vecHoldableItemPosition = m_pHoldableItem->GetAbsOrigin ();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4148				; 00001034H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3256 : 
; 3257 : 	if( m_pHoldableItem->m_iActorType == ACTOR_DYNAMIC )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	cmp	ecx, 1
	jne	SHORT $L41080

; 3258 : 		WorldPhysic->UpdateActorPos( m_pHoldableItem );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+124]
$L41080:
$L41063:

; 3259 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateHoldableItem@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::UpdateHoldableItem
_TEXT	ENDS
PUBLIC	?ClearGroundEntity@CBaseEntity@@QAEXXZ		; CBaseEntity::ClearGroundEntity
PUBLIC	?MakeNonMoving@CBaseEntity@@QAEXXZ		; CBaseEntity::MakeNonMoving
;	COMDAT ?PickHoldableItem@CBasePlayer@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T44051 = -16
$T44052 = -28
_pObject$ = 8
_this$ = -4
?PickHoldableItem@CBasePlayer@@QAEXPAVCBaseEntity@@@Z PROC NEAR ; CBasePlayer::PickHoldableItem, COMDAT

; 3262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3263 : 	if (pObject->m_fPicked || pObject->m_hParent != NULL)

	mov	eax, DWORD PTR _pObject$[ebp]
	cmp	DWORD PTR [eax+68], 0
	jne	SHORT $L41086
	mov	ecx, DWORD PTR _pObject$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L41085
$L41086:

; 3265 : 		// item is already picked by another player, play use sound and return
; 3266 : 		EMIT_SOUND( ENT(pev), CHAN_ITEM, "common/wpn_select.wav", 0.4, ATTN_NORM);

	push	1061997773				; 3f4ccccdH
	push	1053609165				; 3ecccccdH
	push	OFFSET FLAT:??_C@_0BG@MCNG@common?1wpn_select?4wav?$AA@ ; `string'
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 3267 : 		return;

	jmp	$L41084
$L41085:

; 3269 : 
; 3270 : 	// member distance and the last valid origin
; 3271 : 	m_vecHoldableItemPosition = pObject->GetAbsOrigin();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4148				; 00001034H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 3272 : 	m_flHoldableItemDistance = (m_vecHoldableItemPosition - EyePosition()).Length();

	lea	ecx, DWORD PTR $T44051[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	push	eax
	lea	ecx, DWORD PTR $T44052[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4148				; 00001034H
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4144]

; 3273 : 
; 3274 : 	pObject->MakeNonMoving ();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?MakeNonMoving@CBaseEntity@@QAEXXZ	; CBaseEntity::MakeNonMoving

; 3275 : 	pObject->ClearGroundEntity ();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity

; 3276 : 	m_pHoldableItem = pObject;

	mov	eax, DWORD PTR _pObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3277 : 	pObject->m_fPicked = TRUE;

	mov	ecx, DWORD PTR _pObject$[ebp]
	mov	DWORD PTR [ecx+68], 1

; 3278 : 	if( m_pHoldableItem->m_iActorType == ACTOR_DYNAMIC )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	xor	edx, edx
	mov	dl, BYTE PTR [eax+1604]
	cmp	edx, 1
	jne	SHORT $L41090

; 3279 : 		WorldPhysic->MakeKinematic( m_pHoldableItem, TRUE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+96]
$L41090:

; 3280 : 	pObject->pev->fuser2 = pObject->GetLocalAngles().y - pev->v_angle.y;

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+4]
	fsub	DWORD PTR [edx+120]
	mov	eax, DWORD PTR _pObject$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+600]
$L41084:

; 3281 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PickHoldableItem@CBasePlayer@@QAEXPAVCBaseEntity@@@Z ENDP ; CBasePlayer::PickHoldableItem
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ClearGroundEntity@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::ClearGroundEntity, COMDAT

; 631  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 		pev->groundentity = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+412], 0

; 633  : 		pev->flags &= ~FL_ONGROUND;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -3					; fffffffdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx

; 634  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearGroundEntity@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::ClearGroundEntity
_TEXT	ENDS
;	COMDAT ?MakeNonMoving@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeNonMoving@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::MakeNonMoving, COMDAT

; 657  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 658  : 		if( m_iOldMoveType == MOVETYPE_NONE && pev->movetype != MOVETYPE_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $L35086
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 0
	je	SHORT $L35086

; 660  : 			m_iOldMoveType = pev->movetype;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+264]
	mov	DWORD PTR [edx+20], eax

; 661  : 			pev->movetype = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 0
$L35086:

; 663  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeNonMoving@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::MakeNonMoving
_TEXT	ENDS
PUBLIC	?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetBaseVelocity
PUBLIC	?RestoreMoveType@CBaseEntity@@QAEXXZ		; CBaseEntity::RestoreMoveType
;	COMDAT ?DropHoldableItem@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
$T44059 = -20
_this$ = -4
_pObject$ = -8
?DropHoldableItem@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::DropHoldableItem, COMDAT

; 3284 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3285 : 	CBaseEntity *pObject = m_pHoldableItem;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pObject$[ebp], eax

; 3286 : 
; 3287 : 	m_pHoldableItem = NULL;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2880				; 00000b40H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 3288 : 
; 3289 : 	pObject->RestoreMoveType();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?RestoreMoveType@CBaseEntity@@QAEXXZ	; CBaseEntity::RestoreMoveType

; 3290 : 	pObject->ClearGroundEntity ();

	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?ClearGroundEntity@CBaseEntity@@QAEXXZ	; CBaseEntity::ClearGroundEntity

; 3291 : 	pObject->m_fPicked = FALSE;

	mov	eax, DWORD PTR _pObject$[ebp]
	mov	DWORD PTR [eax+68], 0

; 3292 : 	pObject->SetAbsVelocity( GetAbsVelocity() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 3293 : 	pObject->SetBaseVelocity( GetBaseVelocity() );	// in case player is standing on the conveyor belt

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBaseVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetBaseVelocity
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	call	?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetBaseVelocity

; 3294 : 
; 3295 : 	if( pObject->m_iActorType == ACTOR_DYNAMIC )

	mov	ecx, DWORD PTR _pObject$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	cmp	edx, 1
	jne	SHORT $L41096

; 3297 : 		WorldPhysic->MakeKinematic( pObject, FALSE );

	push	0
	mov	eax, DWORD PTR _pObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+96]

; 3298 : 		WorldPhysic->AddForce( pObject, GetAbsVelocity() * 3000.0f );

	push	1161527296				; 453b8000H
	lea	eax, DWORD PTR $T44059[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _pObject$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [eax+88]
$L41096:

; 3300 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DropHoldableItem@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::DropHoldableItem
_TEXT	ENDS
;	COMDAT ?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
_v$ = 8
?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetBaseVelocity, COMDAT

; 390  : 	void SetBaseVelocity( const Vector& v ) { pev->basevelocity = v; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 44					; 0000002cH
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetBaseVelocity@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetBaseVelocity
_TEXT	ENDS
;	COMDAT ?RestoreMoveType@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RestoreMoveType@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::RestoreMoveType, COMDAT

; 666  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 667  : 		if( m_iOldMoveType != MOVETYPE_NONE && pev->movetype == MOVETYPE_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $L35089
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 0
	jne	SHORT $L35089

; 669  : 			pev->movetype = m_iOldMoveType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+264], eax

; 670  : 			m_iOldMoveType = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
$L35089:

; 672  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreMoveType@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::RestoreMoveType
_TEXT	ENDS
PUBLIC	??_C@_0BA@ILEC@No?5Landmark?3?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_02MECO@?$CFd?$AA@				; `string'
PUBLIC	?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z	; CBasePlayer::Restore
EXTRN	?va@@YAPADPBDZZ:NEAR				; va
EXTRN	?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z:NEAR	; CBaseMonster::Restore
;	COMDAT ??_C@_0BA@ILEC@No?5Landmark?3?$CFs?6?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BA@ILEC@No?5Landmark?3?$CFs?6?$AA@ DB 'No Landmark:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MECO@?$CFd?$AA@
CONST	SEGMENT
??_C@_02MECO@?$CFd?$AA@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT
$T44066 = -32
$T44067 = -44
$T44068 = -56
$T44069 = -68
$T44070 = -80
$T44071 = -92
_restore$ = 8
_this$ = -4
_status$ = -8
_pSaveData$ = -12
_pentSpawnSpot$41108 = -16
_pSpawnSpot$41109 = -20
?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z PROC NEAR	; CBasePlayer::Restore, COMDAT

; 3303 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 156				; 0000009cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3304 : 	int status = BaseClass::Restore(restore);

	mov	eax, DWORD PTR _restore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z ; CBaseMonster::Restore
	mov	DWORD PTR _status$[ebp], eax

; 3305 : 	if ( !status )

	cmp	DWORD PTR _status$[ebp], 0
	jne	SHORT $L41103

; 3306 : 		return 0;

	xor	eax, eax
	jmp	$L41101
$L41103:

; 3307 : 
; 3308 : 	SAVERESTOREDATA *pSaveData = (SAVERESTOREDATA *)gpGlobals->pSaveData;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR [ecx+156]
	mov	DWORD PTR _pSaveData$[ebp], edx

; 3309 : 
; 3310 : 	// landmark isn't present.
; 3311 : 	if( !pSaveData->fUseLandmark )

	mov	eax, DWORD PTR _pSaveData$[ebp]
	cmp	DWORD PTR [eax+1324], 0
	jne	SHORT $L41106

; 3313 : 		ALERT( at_console, "No Landmark:%s\n", pSaveData->szLandmarkName );

	mov	ecx, DWORD PTR _pSaveData$[ebp]
	add	ecx, 1328				; 00000530H
	push	ecx
	push	OFFSET FLAT:??_C@_0BA@ILEC@No?5Landmark?3?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 3314 : 
; 3315 : 		// default to normal spawn
; 3316 : 		edict_t *pentSpawnSpot = EntSelectSpawnPoint( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntSelectSpawnPoint@@YAPAUedict_s@@PAVCBaseEntity@@@Z ; EntSelectSpawnPoint
	add	esp, 4
	mov	DWORD PTR _pentSpawnSpot$41108[ebp], eax

; 3317 : 		CBaseEntity *pSpawnSpot = CBaseEntity::Instance( pentSpawnSpot );

	mov	eax, DWORD PTR _pentSpawnSpot$41108[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pSpawnSpot$41109[ebp], eax

; 3318 : 		SetAbsOrigin( pSpawnSpot->GetAbsOrigin() + Vector( 0, 0, 1 ));

	push	1065353216				; 3f800000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T44066[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	ecx, DWORD PTR $T44067[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pSpawnSpot$41109[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 3319 : 		SetAbsAngles( pSpawnSpot->GetAbsAngles( ));

	mov	ecx, DWORD PTR _pSpawnSpot$41109[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles
$L41106:

; 3321 : 
; 3322 : 	pev->v_angle.z = 0;		// Clear out roll

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+124], 0

; 3323 : 
; 3324 : 	SetAbsAngles( pev->v_angle );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 3325 : 	pev->fixangle = TRUE;	// turn this way immediately

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+160], 1

; 3326 : 
; 3327 : 	// Copied from spawn() for now
; 3328 : 	m_bloodColor = BLOOD_COLOR_RED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2328], 247		; 000000f7H

; 3329 : 
; 3330 : 	g_ulModelIndexPlayer = pev->modelindex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	mov	DWORD PTR ?g_ulModelIndexPlayer@@3KA, edx ; g_ulModelIndexPlayer

; 3331 : 
; 3332 : 	if ( FBitSet(pev->flags, FL_DUCKING) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 16384				; 00004000H
	test	edx, edx
	je	SHORT $L41113

; 3334 : 		UTIL_SetSize(pev, VEC_DUCK_HULL_MIN, VEC_DUCK_HULL_MAX);

	push	1099956224				; 41900000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T44068[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	-1047527424				; c1900000H
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T44069[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH

; 3336 : 	else

	jmp	SHORT $L41116
$L41113:

; 3338 : 		UTIL_SetSize(pev, VEC_HULL_MIN, VEC_HULL_MAX);

	push	1108344832				; 42100000H
	push	1098907648				; 41800000H
	push	1098907648				; 41800000H
	lea	ecx, DWORD PTR $T44070[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	push	-1039138816				; c2100000H
	push	-1048576000				; c1800000H
	push	-1048576000				; c1800000H
	lea	ecx, DWORD PTR $T44071[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH
$L41116:

; 3340 : 
; 3341 : 	g_engfuncs.pfnSetPhysicsKeyValue( edict(), "hl", "1" );

	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_02MDGH@hl?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 3342 : 
; 3343 : 	if ( m_fLongJump )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2904], 0
	je	SHORT $L41119

; 3345 : 		g_engfuncs.pfnSetPhysicsKeyValue( edict(), "slj", "1" );

	push	OFFSET FLAT:??_C@_01FBAH@1?$AA@		; `string'
	push	OFFSET FLAT:??_C@_03HGJB@slj?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 3347 : 	else

	jmp	SHORT $L41120
$L41119:

; 3349 : 		g_engfuncs.pfnSetPhysicsKeyValue( edict(), "slj", "0" );

	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	push	OFFSET FLAT:??_C@_03HGJB@slj?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH
$L41120:

; 3351 : 
; 3352 : 	g_engfuncs.pfnSetPhysicsKeyValue( edict(), "incar", va( "%d", m_iInCarState ));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2908]
	push	eax
	push	OFFSET FLAT:??_C@_02MECO@?$CFd?$AA@	; `string'
	call	?va@@YAPADPBDZZ				; va
	add	esp, 8
	push	eax
	push	OFFSET FLAT:??_C@_05PECN@incar?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+480
	add	esp, 12					; 0000000cH

; 3353 : 
; 3354 : 	RenewItems();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RenewItems@CBasePlayer@@QAEXXZ		; CBasePlayer::RenewItems

; 3355 : 
; 3356 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$L41101:

; 3357 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z ENDP		; CBasePlayer::Restore
_TEXT	ENDS
PUBLIC	?SelectNextItem@CBasePlayer@@QAEXH@Z		; CBasePlayer::SelectNextItem
;	COMDAT ?SelectNextItem@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT
_iItem$ = 8
_this$ = -4
_pItem$ = -8
_pLast$41130 = -12
?SelectNextItem@CBasePlayer@@QAEXH@Z PROC NEAR		; CBasePlayer::SelectNextItem, COMDAT

; 3360 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3361 : 	CBasePlayerItem *pItem;
; 3362 : 
; 3363 : 	pItem = m_rgpPlayerItems[ iItem ];

	mov	eax, DWORD PTR _iItem$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2956]
	mov	DWORD PTR _pItem$[ebp], edx

; 3364 : 
; 3365 : 	if (!pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	jne	SHORT $L41127

; 3366 : 		return;

	jmp	$L41125
$L41127:

; 3367 : 
; 3368 : 	if (pItem == m_pActiveItem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pItem$[ebp]
	cmp	ecx, DWORD PTR [eax+2980]
	jne	SHORT $L41128

; 3370 : 		// select the next one in the chain
; 3371 : 		pItem = m_pActiveItem->m_pNext;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	ecx, DWORD PTR [eax+1820]
	mov	DWORD PTR _pItem$[ebp], ecx

; 3372 : 		if (! pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	jne	SHORT $L41129

; 3374 : 			return;

	jmp	$L41125
$L41129:

; 3378 : 		pLast = pItem;

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	DWORD PTR _pLast$41130[ebp], edx
$L41132:

; 3379 : 		while (pLast->m_pNext)

	mov	eax, DWORD PTR _pLast$41130[ebp]
	cmp	DWORD PTR [eax+1820], 0
	je	SHORT $L41133

; 3380 : 			pLast = pLast->m_pNext;

	mov	ecx, DWORD PTR _pLast$41130[ebp]
	mov	edx, DWORD PTR [ecx+1820]
	mov	DWORD PTR _pLast$41130[ebp], edx
	jmp	SHORT $L41132
$L41133:

; 3381 : 
; 3382 : 		// relink chain
; 3383 : 		pLast->m_pNext = m_pActiveItem;

	mov	eax, DWORD PTR _pLast$41130[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2980]
	mov	DWORD PTR [eax+1820], edx

; 3384 : 		m_pActiveItem->m_pNext = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	DWORD PTR [ecx+1820], 0

; 3385 : 		m_rgpPlayerItems[ iItem ] = pItem;

	mov	edx, DWORD PTR _iItem$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	DWORD PTR [eax+edx*4+2956], ecx
$L41128:

; 3387 : 
; 3388 : 	ResetAutoaim( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetAutoaim@CBasePlayer@@QAEXXZ	; CBasePlayer::ResetAutoaim

; 3389 : 
; 3390 : 	// FIX, this needs to queue them up and delay
; 3391 : 	if (m_pActiveItem)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2980], 0
	je	SHORT $L41134

; 3393 : 		m_pActiveItem->Holster( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+368]
$L41134:

; 3395 : 
; 3396 : 	m_pActiveItem = pItem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	DWORD PTR [eax+2980], ecx

; 3397 : 
; 3398 : 	if (m_pActiveItem)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2980], 0
	je	SHORT $L41135

; 3400 : 		m_pActiveItem->Deploy( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+360]

; 3401 : 		m_pActiveItem->UpdateItemInfo( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+372]
$L41135:
$L41125:

; 3403 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SelectNextItem@CBasePlayer@@QAEXH@Z ENDP		; CBasePlayer::SelectNextItem
_TEXT	ENDS
PUBLIC	?SelectItem@CBasePlayer@@QAEXPBD@Z		; CBasePlayer::SelectItem
PUBLIC	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z		; FClassnameIs
;	COMDAT ?SelectItem@CBasePlayer@@QAEXPBD@Z
_TEXT	SEGMENT
_pstr$ = 8
_this$ = -4
_pItem$ = -8
_i$ = -12
?SelectItem@CBasePlayer@@QAEXPBD@Z PROC NEAR		; CBasePlayer::SelectItem, COMDAT

; 3406 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3407 : 	if (!pstr)

	cmp	DWORD PTR _pstr$[ebp], 0
	jne	SHORT $L41140

; 3408 : 		return;

	jmp	$L41139
$L41140:

; 3409 : 
; 3410 : 	CBasePlayerItem *pItem = NULL;

	mov	DWORD PTR _pItem$[ebp], 0

; 3411 : 
; 3412 : 	for (int i = 0; i < MAX_ITEM_TYPES; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41143
$L41144:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41143:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L41145

; 3414 : 		if (m_rgpPlayerItems[i])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+2956], 0
	je	SHORT $L41149

; 3416 : 			pItem = m_rgpPlayerItems[i];

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2956]
	mov	DWORD PTR _pItem$[ebp], edx
$L41148:

; 3417 : 
; 3418 : 			while (pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	je	SHORT $L41149

; 3420 : 				if (FClassnameIs(pItem->pev, pstr))

	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L41150

; 3421 : 					break;

	jmp	SHORT $L41149
$L41150:

; 3422 : 				pItem = pItem->m_pNext;

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	ecx, DWORD PTR [eax+1820]
	mov	DWORD PTR _pItem$[ebp], ecx

; 3423 : 			}

	jmp	SHORT $L41148
$L41149:

; 3425 : 
; 3426 : 		if (pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	je	SHORT $L41151

; 3427 : 			break;

	jmp	SHORT $L41145
$L41151:

; 3428 : 	}

	jmp	SHORT $L41144
$L41145:

; 3429 : 
; 3430 : 	if (!pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	jne	SHORT $L41152

; 3431 : 		return;

	jmp	$L41139
$L41152:

; 3432 : 
; 3433 : 
; 3434 : 	if (pItem == m_pActiveItem)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pItem$[ebp]
	cmp	eax, DWORD PTR [edx+2980]
	jne	SHORT $L41153

; 3435 : 		return;

	jmp	$L41139
$L41153:

; 3436 : 
; 3437 : 	ResetAutoaim( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetAutoaim@CBasePlayer@@QAEXXZ	; CBasePlayer::ResetAutoaim

; 3438 : 
; 3439 : 	// FIX, this needs to queue them up and delay
; 3440 : 	if (m_pActiveItem)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2980], 0
	je	SHORT $L41154

; 3441 : 		m_pActiveItem->Holster( );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+368]
$L41154:

; 3442 : 
; 3443 : 	m_pLastItem = m_pActiveItem;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	DWORD PTR [ecx+2988], eax

; 3444 : 	m_pActiveItem = pItem;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pItem$[ebp]
	mov	DWORD PTR [ecx+2980], edx

; 3445 : 
; 3446 : 	if (m_pActiveItem)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L41155

; 3448 : 		m_pActiveItem->Deploy( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+360]

; 3449 : 		m_pActiveItem->UpdateItemInfo( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+372]
$L41155:
$L41139:

; 3451 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SelectItem@CBasePlayer@@QAEXPBD@Z ENDP			; CBasePlayer::SelectItem
_TEXT	ENDS
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?FStrEq@@YAHPBD0@Z				; FStrEq
;	COMDAT ?FClassnameIs@@YAHPAUentvars_s@@PBD@Z
_TEXT	SEGMENT
_pev$ = 8
_szClassname$ = 12
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z PROC NEAR		; FClassnameIs, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 295  : 	if( FNullEnt( pev )) return FALSE;

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L32565
	xor	eax, eax
	jmp	SHORT $L32564
$L32565:

; 296  : 	return FStrEq( STRING( pev->classname ), szClassname );

	mov	ecx, DWORD PTR _szClassname$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pev$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
$L32564:

; 297  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FClassnameIs@@YAHPAUentvars_s@@PBD@Z ENDP		; FClassnameIs
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L44080
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L44080
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L44081
$L44080:
	mov	DWORD PTR -4+[ebp], 1
$L44081:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
EXTRN	?Q_strncmp@@YAHPBD0H@Z:NEAR			; Q_strncmp
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT
_sz1$ = 8
_sz2$ = 12
?FStrEq@@YAHPBD0@Z PROC NEAR				; FStrEq, COMDAT

; 286  : 	{ return (Q_strcmp( sz1, sz2 ) == 0); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	99999					; 0001869fH
	mov	eax, DWORD PTR _sz2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sz1$[ebp]
	push	ecx
	call	?Q_strncmp@@YAHPBD0H@Z			; Q_strncmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStrEq@@YAHPBD0@Z ENDP					; FStrEq
_TEXT	ENDS
PUBLIC	?SelectLastItem@CBasePlayer@@QAEXXZ		; CBasePlayer::SelectLastItem
;	COMDAT ?SelectLastItem@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pTemp$ = -8
?SelectLastItem@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::SelectLastItem, COMDAT

; 3455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3456 : 	if (!m_pLastItem)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2988], 0
	jne	SHORT $L41160

; 3458 : 		return;

	jmp	$L41159
$L41160:

; 3460 : 
; 3461 : 	if ( m_pActiveItem && !m_pActiveItem->CanHolster() )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2980], 0
	je	SHORT $L41161
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+364]
	test	eax, eax
	jne	SHORT $L41161

; 3463 : 		return;

	jmp	$L41159
$L41161:

; 3465 : 
; 3466 : 	ResetAutoaim( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetAutoaim@CBasePlayer@@QAEXXZ	; CBasePlayer::ResetAutoaim

; 3467 : 
; 3468 : 	// FIX, this needs to queue them up and delay
; 3469 : 	if (m_pActiveItem)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2980], 0
	je	SHORT $L41162

; 3470 : 		m_pActiveItem->Holster( );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+368]
$L41162:

; 3471 : 
; 3472 : 	CBasePlayerItem *pTemp = m_pActiveItem;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2980]
	mov	DWORD PTR _pTemp$[ebp], edx

; 3473 : 	m_pActiveItem = m_pLastItem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2988]
	mov	DWORD PTR [eax+2980], edx

; 3474 : 	m_pLastItem = pTemp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pTemp$[ebp]
	mov	DWORD PTR [eax+2988], ecx

; 3475 : 	m_pActiveItem->Deploy( );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+360]

; 3476 : 	m_pActiveItem->UpdateItemInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+372]
$L41159:

; 3477 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SelectLastItem@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::SelectLastItem
_TEXT	ENDS
;	COMDAT ?HasWeapons@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?HasWeapons@CBasePlayer@@QAEHXZ PROC NEAR		; CBasePlayer::HasWeapons, COMDAT

; 3483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3484 : 	int i;
; 3485 : 
; 3486 : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41169
$L41170:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41169:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L41171

; 3488 : 		if ( m_rgpPlayerItems[ i ] )

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+2956], 0
	je	SHORT $L41172

; 3490 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L41167
$L41172:

; 3492 : 	}

	jmp	SHORT $L41170
$L41171:

; 3493 : 
; 3494 : 	return FALSE;

	xor	eax, eax
$L41167:

; 3495 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HasWeapons@CBasePlayer@@QAEHXZ ENDP			; CBasePlayer::HasWeapons
_TEXT	ENDS
PUBLIC	?SelectPrevItem@CBasePlayer@@QAEXH@Z		; CBasePlayer::SelectPrevItem
;	COMDAT ?SelectPrevItem@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SelectPrevItem@CBasePlayer@@QAEXH@Z PROC NEAR		; CBasePlayer::SelectPrevItem, COMDAT

; 3498 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3499 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SelectPrevItem@CBasePlayer@@QAEXH@Z ENDP		; CBasePlayer::SelectPrevItem
_TEXT	ENDS
PUBLIC	?TeamID@CBasePlayer@@UAEPBDXZ			; CBasePlayer::TeamID
;	COMDAT ?TeamID@CBasePlayer@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBasePlayer@@UAEPBDXZ PROC NEAR			; CBasePlayer::TeamID, COMDAT

; 3503 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3504 : 	if ( pev == NULL )		// Not fully connected yet

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L41181

; 3505 : 		return "";

	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	jmp	SHORT $L41180
$L41181:

; 3506 : 
; 3507 : 	// return their team name
; 3508 : 	return m_szTeamName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3804				; 00000edcH
$L41180:

; 3509 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBasePlayer@@UAEPBDXZ ENDP			; CBasePlayer::TeamID
_TEXT	ENDS
PUBLIC	?Spawn@CSprayCan@@QAEXPAVCBaseEntity@@@Z	; CSprayCan::Spawn
PUBLIC	??_C@_0BD@NACB@player?1sprayer?4wav?$AA@	; `string'
;	COMDAT ??_C@_0BD@NACB@player?1sprayer?4wav?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BD@NACB@player?1sprayer?4wav?$AA@ DB 'player/sprayer.wav', 00H ; `string'
CONST	ENDS
;	COMDAT ?Spawn@CSprayCan@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T44096 = -16
$T44097 = -28
_pOwner$ = 8
_this$ = -4
?Spawn@CSprayCan@@QAEXPAVCBaseEntity@@@Z PROC NEAR	; CSprayCan::Spawn, COMDAT

; 3527 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3528 : 	SetAbsOrigin( pOwner->GetAbsOrigin() + Vector ( 0, 0, 32 ));

	push	1107296256				; 42000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T44096[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T44097[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOwner$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 3529 : 	SetAbsAngles( pOwner->pev->v_angle );

	mov	ecx, DWORD PTR _pOwner$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 3530 : 	pev->owner = pOwner->edict();

	mov	ecx, DWORD PTR _pOwner$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+408], eax

; 3531 : 	pev->frame = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+304], 0

; 3532 : 
; 3533 : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+80]

; 3534 : 	EMIT_SOUND( edict(), CHAN_VOICE, "player/sprayer.wav", 1, ATTN_NORM );

	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BD@NACB@player?1sprayer?4wav?$AA@ ; `string'
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?EMIT_SOUND@@YAXPAUedict_s@@HPBDMM@Z	; EMIT_SOUND
	add	esp, 20					; 00000014H

; 3535 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Spawn@CSprayCan@@QAEXPAVCBaseEntity@@@Z ENDP		; CSprayCan::Spawn
_TEXT	ENDS
PUBLIC	?Think@CSprayCan@@UAEXXZ			; CSprayCan::Think
PUBLIC	?GetCustomDecalFrames@CBasePlayer@@QAEHXZ	; CBasePlayer::GetCustomDecalFrames
EXTRN	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z:NEAR	; UTIL_DecalTrace
EXTRN	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z:NEAR ; UTIL_StudioDecalTrace
EXTRN	?UTIL_PlayerDecalTrace@@YAXPAUgametrace_s@@HHH@Z:NEAR ; UTIL_PlayerDecalTrace
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ?Think@CSprayCan@@UAEXXZ
_TEXT	SEGMENT
$T44100 = -88
$T44101 = -100
_this$ = -4
_tr$ = -60
_playernum$ = -64
_nFrames$ = -68
_pPlayer$ = -72
_pEntity$41228 = -76
?Think@CSprayCan@@UAEXXZ PROC NEAR			; CSprayCan::Think, COMDAT

; 3538 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3539 : 	TraceResult	tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3540 : 	int playernum;
; 3541 : 	int nFrames;
; 3542 : 	CBasePlayer *pPlayer;
; 3543 : 
; 3544 : 	pPlayer = (CBasePlayer *)GET_PRIVATE(pev->owner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+408]
	push	edx
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pPlayer$[ebp], eax

; 3545 : 
; 3546 : 	if (pPlayer)

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $L41223

; 3547 : 		nFrames = pPlayer->GetCustomDecalFrames();

	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?GetCustomDecalFrames@CBasePlayer@@QAEHXZ ; CBasePlayer::GetCustomDecalFrames
	mov	DWORD PTR _nFrames$[ebp], eax

; 3548 : 	else

	jmp	SHORT $L41224
$L41223:

; 3549 : 		nFrames = -1;

	mov	DWORD PTR _nFrames$[ebp], -1
$L41224:

; 3550 : 
; 3551 : 	playernum = ENTINDEX(pev->owner);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+408]
	push	edx
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	DWORD PTR _playernum$[ebp], eax

; 3552 : 
; 3553 : 	// ALERT(at_console, "Spray by player %i, %i of %i\n", playernum, (int)(pev->frame + 1), nFrames);
; 3554 : 
; 3555 : 	UTIL_MakeVectors( GetAbsAngles( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3556 : 	UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin() + gpGlobals->v_forward * 128, dont_ignore_monsters, pev->owner, &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+408]
	push	eax
	push	0
	push	1124073472				; 43000000H
	lea	ecx, DWORD PTR $T44100[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T44101[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3557 : 
; 3558 : 	// No customization present.
; 3559 : 	if (nFrames == -1)

	cmp	DWORD PTR _nFrames$[ebp], -1
	jne	SHORT $L41227

; 3561 : 		CBaseEntity *pEntity = CBaseEntity::Instance( tr.pHit );

	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$41228[ebp], eax

; 3562 : 
; 3563 : 		if( pEntity && UTIL_GetModelType( pEntity->pev->modelindex ) == mod_studio )

	cmp	DWORD PTR _pEntity$41228[ebp], 0
	je	SHORT $L41229
	mov	ecx, DWORD PTR _pEntity$41228[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	cmp	eax, 3
	jne	SHORT $L41229

; 3564 : 			UTIL_StudioDecalTrace( &tr, DECAL_LAMBDA6 );

	push	0
	push	10					; 0000000aH
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?UTIL_StudioDecalTrace@@YAXPAUgametrace_s@@HH@Z ; UTIL_StudioDecalTrace
	add	esp, 12					; 0000000cH

; 3565 : 		else UTIL_DecalTrace( &tr, DECAL_LAMBDA6 );

	jmp	SHORT $L41230
$L41229:
	push	10					; 0000000aH
	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	call	?UTIL_DecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_DecalTrace
	add	esp, 8
$L41230:

; 3566 : 
; 3567 : 		UTIL_Remove( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 3569 : 	else

	jmp	SHORT $L41232
$L41227:

; 3571 : 		UTIL_PlayerDecalTrace( &tr, playernum, pev->frame, TRUE );

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+304]
	call	__ftol
	push	eax
	mov	eax, DWORD PTR _playernum$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?UTIL_PlayerDecalTrace@@YAXPAUgametrace_s@@HHH@Z ; UTIL_PlayerDecalTrace
	add	esp, 16					; 00000010H

; 3572 : 		// Just painted last custom frame.
; 3573 : 		if( pev->frame++ >= (nFrames - 1))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nFrames$[ebp]
	sub	ecx, 1
	mov	DWORD PTR -104+[ebp], ecx
	fild	DWORD PTR -104+[ebp]
	fld	DWORD PTR [eax+304]
	fcompp
	fnstsw	ax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+304]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	fstp	DWORD PTR [ecx+304]
	test	ah, 1
	jne	SHORT $L41232

; 3574 : 			UTIL_Remove( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L41232:

; 3576 : 
; 3577 : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 3578 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CSprayCan@@UAEXXZ ENDP				; CSprayCan::Think
_TEXT	ENDS
PUBLIC	?Spawn@CBloodSplat@@QAEXPAVCBaseEntity@@@Z	; CBloodSplat::Spawn
PUBLIC	?Spray@CBloodSplat@@QAEXXZ			; CBloodSplat::Spray
PUBLIC	??_C@_05MLJC@Spray?$AA@				; `string'
;	COMDAT ??_C@_05MLJC@Spray?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_05MLJC@Spray?$AA@ DB 'Spray', 00H			; `string'
CONST	ENDS
;	COMDAT ?Spawn@CBloodSplat@@QAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
$T44104 = -16
$T44105 = -28
_pOwner$ = 8
_this$ = -4
?Spawn@CBloodSplat@@QAEXPAVCBaseEntity@@@Z PROC NEAR	; CBloodSplat::Spawn, COMDAT

; 3589 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3590 : 	SetAbsOrigin( pOwner->GetAbsOrigin() + Vector ( 0, 0, 32 ));

	push	1107296256				; 42000000H
	push	0
	push	0
	lea	ecx, DWORD PTR $T44104[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	lea	eax, DWORD PTR $T44105[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOwner$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 3591 : 	SetAbsAngles( pOwner->pev->v_angle );

	mov	ecx, DWORD PTR _pOwner$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 3592 : 	pev->owner = pOwner->edict();

	mov	ecx, DWORD PTR _pOwner$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+408], eax

; 3593 : 
; 3594 : 	SetThink( Spray );

	push	OFFSET FLAT:??_C@_05MLJC@Spray?$AA@	; `string'
	push	OFFSET FLAT:?Spray@CBloodSplat@@QAEXXZ	; CBloodSplat::Spray
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 3595 : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 3596 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Spawn@CBloodSplat@@QAEXPAVCBaseEntity@@@Z ENDP		; CBloodSplat::Spawn
_TEXT	ENDS
PUBLIC	??_C@_0L@KHDH@SUB_Remove?$AA@			; `string'
EXTRN	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z:NEAR ; UTIL_BloodDecalTrace
EXTRN	?UTIL_BloodStudioDecalTrace@@YAXPAUgametrace_s@@H@Z:NEAR ; UTIL_BloodStudioDecalTrace
EXTRN	?g_Language@@3HA:DWORD				; g_Language
EXTRN	?SUB_Remove@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_Remove
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0L@KHDH@SUB_Remove?$AA@ DB 'SUB_Remove', 00H	; `string'
CONST	ENDS
;	COMDAT ?Spray@CBloodSplat@@QAEXXZ
_TEXT	SEGMENT
$T44108 = -76
$T44109 = -88
_this$ = -4
_tr$ = -60
_pEntity$41270 = -64
?Spray@CBloodSplat@@QAEXXZ PROC NEAR			; CBloodSplat::Spray, COMDAT

; 3599 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3600 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3601 : 
; 3602 : 	if( g_Language != LANGUAGE_GERMAN )

	cmp	DWORD PTR ?g_Language@@3HA, 1		; g_Language
	je	$L41273

; 3604 : 		UTIL_MakeVectors( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3605 : 		UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin() + gpGlobals->v_forward * 128, dont_ignore_monsters, pev->owner, &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+408]
	push	eax
	push	0
	push	1124073472				; 43000000H
	lea	ecx, DWORD PTR $T44108[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T44109[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3606 : 
; 3607 : 		CBaseEntity *pEntity = CBaseEntity::Instance( tr.pHit );

	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$41270[ebp], eax

; 3608 : 
; 3609 : 		if( pEntity && UTIL_GetModelType( pEntity->pev->modelindex ) == mod_studio )

	cmp	DWORD PTR _pEntity$41270[ebp], 0
	je	SHORT $L41271
	mov	ecx, DWORD PTR _pEntity$41270[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	cmp	eax, 3
	jne	SHORT $L41271

; 3610 : 			UTIL_BloodStudioDecalTrace( &tr, BLOOD_COLOR_RED );

	push	247					; 000000f7H
	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	call	?UTIL_BloodStudioDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_BloodStudioDecalTrace
	add	esp, 8

; 3611 : 		else UTIL_BloodDecalTrace( &tr, BLOOD_COLOR_RED );

	jmp	SHORT $L41273
$L41271:
	push	247					; 000000f7H
	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	call	?UTIL_BloodDecalTrace@@YAXPAUgametrace_s@@H@Z ; UTIL_BloodDecalTrace
	add	esp, 8
$L41273:

; 3613 : 
; 3614 : 	SetThink( SUB_Remove );

	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	push	OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 3615 : 	SetNextThink( 0.1 );

	push	1036831949				; 3dcccccdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+80]

; 3616 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spray@CBloodSplat@@QAEXXZ ENDP				; CBloodSplat::Spray
_TEXT	ENDS
PUBLIC	??_C@_0BM@PIHH@NULL?5Ent?5in?5GiveNamedItem?$CB?6?$AA@ ; `string'
PUBLIC	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z		; CBasePlayer::GiveNamedItem
EXTRN	?DispatchSpawn@@YAHPAUedict_s@@@Z:NEAR		; DispatchSpawn
EXTRN	?DispatchTouch@@YAXPAUedict_s@@0@Z:NEAR		; DispatchTouch
EXTRN	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z:NEAR ; CreateEntityByName
;	COMDAT ??_C@_0BM@PIHH@NULL?5Ent?5in?5GiveNamedItem?$CB?6?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BM@PIHH@NULL?5Ent?5in?5GiveNamedItem?$CB?6?$AA@ DB 'NULL Ent in Gi'
	DB	'veNamedItem!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?GiveNamedItem@CBasePlayer@@QAEXPBD@Z
_TEXT	SEGMENT
_pszName$ = 8
_this$ = -4
_pEnt$ = -8
?GiveNamedItem@CBasePlayer@@QAEXPBD@Z PROC NEAR		; CBasePlayer::GiveNamedItem, COMDAT

; 3621 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3622 : 	CBaseEntity *pEnt = CreateEntityByName( pszName );

	push	0
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CreateEntityByName
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 3623 : 
; 3624 : 	if( !pEnt )

	cmp	DWORD PTR _pEnt$[ebp], 0
	jne	SHORT $L41282

; 3626 : 		ALERT ( at_console, "NULL Ent in GiveNamedItem!\n" );

	push	OFFSET FLAT:??_C@_0BM@PIHH@NULL?5Ent?5in?5GiveNamedItem?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3627 : 		return;

	jmp	SHORT $L41280
$L41282:

; 3629 : 
; 3630 : 	pEnt->SetAbsOrigin( GetAbsOrigin() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 3631 : 	pEnt->pev->spawnflags |= SF_NORESPAWN;

	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	or	eax, 1073741824				; 40000000H
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax

; 3632 : 
; 3633 : 	DispatchSpawn( pEnt->edict() );

	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchSpawn@@YAHPAUedict_s@@@Z	; DispatchSpawn
	add	esp, 4

; 3634 : 	DispatchTouch( pEnt->edict(), ENT( pev ) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchTouch@@YAXPAUedict_s@@0@Z	; DispatchTouch
	add	esp, 8
$L41280:

; 3635 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GiveNamedItem@CBasePlayer@@QAEXPBD@Z ENDP		; CBasePlayer::GiveNamedItem
_TEXT	ENDS
PUBLIC	?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z	; FindEntityForward
;	COMDAT ?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
$T44114 = -72
$T44115 = -84
$T44116 = -96
$T44117 = -108
_pMe$ = 8
_tr$ = -56
_pHit$41293 = -60
?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z PROC NEAR	; FindEntityForward, COMDAT

; 3638 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	esi
	push	edi

; 3639 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3640 : 
; 3641 : 	UTIL_MakeVectors( pMe->pev->v_angle );

	mov	eax, DWORD PTR _pMe$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 116				; 00000074H
	push	ecx
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3642 : 	UTIL_TraceLine( pMe->EyePosition(), pMe->EyePosition() + gpGlobals->v_forward * 8192, dont_ignore_monsters, pMe->edict(), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pMe$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	push	1174405120				; 46000000H
	lea	eax, DWORD PTR $T44115[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T44116[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44114[ebp]
	push	edx
	mov	eax, DWORD PTR _pMe$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pMe$[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	eax, DWORD PTR $T44117[ebp]
	push	eax
	mov	ecx, DWORD PTR _pMe$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pMe$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3643 : 
; 3644 : 	if( tr.flFraction != 1.0 && !FNullEnt( tr.pHit ))

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41292
	mov	eax, DWORD PTR _tr$[ebp+48]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41292

; 3646 : 		CBaseEntity *pHit = CBaseEntity::Instance( tr.pHit );

	mov	ecx, DWORD PTR _tr$[ebp+48]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pHit$41293[ebp], eax

; 3647 : 		return pHit;

	mov	eax, DWORD PTR _pHit$41293[ebp]
	jmp	SHORT $L41286
$L41292:

; 3649 : 	return NULL;

	xor	eax, eax
$L41286:

; 3650 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z ENDP	; FindEntityForward
_TEXT	ENDS
PUBLIC	?FlashlightIsOn@CBasePlayer@@QAEHXZ		; CBasePlayer::FlashlightIsOn
;	COMDAT ?FlashlightIsOn@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FlashlightIsOn@CBasePlayer@@QAEHXZ PROC NEAR		; CBasePlayer::FlashlightIsOn, COMDAT

; 3654 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3655 : 	return FBitSet(pev->effects, EF_DIMLIGHT);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+280]
	and	eax, 8

; 3656 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlashlightIsOn@CBasePlayer@@QAEHXZ ENDP		; CBasePlayer::FlashlightIsOn
_TEXT	ENDS
PUBLIC	__real@8@3fff9999999999999800
PUBLIC	??_C@_0BG@BKIG@items?1flashlight1?4wav?$AA@	; `string'
PUBLIC	?FlashlightTurnOn@CBasePlayer@@QAEXXZ		; CBasePlayer::FlashlightTurnOn
;	COMDAT ??_C@_0BG@BKIG@items?1flashlight1?4wav?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BG@BKIG@items?1flashlight1?4wav?$AA@ DB 'items/flashlight1.wav', 00H ; `string'
CONST	ENDS
;	COMDAT __real@8@3fff9999999999999800
CONST	SEGMENT
__real@8@3fff9999999999999800 DQ 03ff3333333333333r ; 1.2
CONST	ENDS
;	COMDAT ?FlashlightTurnOn@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?FlashlightTurnOn@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::FlashlightTurnOn, COMDAT

; 3660 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3661 : 	if ( !g_pGameRules->FAllowFlashlight() )

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+12]
	test	eax, eax
	jne	SHORT $L41302

; 3663 : 		return;

	jmp	$L41301
$L41302:

; 3665 : 
; 3666 : 	if ( HasWeapon( WEAPON_SUIT ))

	push	63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasWeapon@CBaseMonster@@QAEHH@Z	; CBaseMonster::HasWeapon
	test	eax, eax
	je	$L41303

; 3668 : 		EMIT_SOUND_DYN( ENT(pev), CHAN_WEAPON, SOUND_FLASHLIGHT_ON, 1.0, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BG@BKIG@items?1flashlight1?4wav?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 3669 : 		SetBits(pev->effects, EF_DIMLIGHT);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx

; 3670 : 		MESSAGE_BEGIN( MSG_ONE, gmsgFlashlight, NULL, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgFlashlight@@3HA	; gmsgFlashlight
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 3671 : 		WRITE_BYTE(1);

	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3672 : 		WRITE_BYTE(m_iFlashBattery);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2428]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3673 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 3674 : 
; 3675 : 		m_flFlashLightTime = FLASH_DRAIN_TIME + gpGlobals->time;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3fff9999999999999800
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2424]
$L41303:
$L41301:

; 3678 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlashlightTurnOn@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::FlashlightTurnOn
_TEXT	ENDS
PUBLIC	__real@8@3ffcccccccccccccd000
PUBLIC	?FlashlightTurnOff@CBasePlayer@@QAEXXZ		; CBasePlayer::FlashlightTurnOff
;	COMDAT __real@8@3ffcccccccccccccd000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@8@3ffcccccccccccccd000 DQ 03fc999999999999ar ; 0.2
CONST	ENDS
;	COMDAT ?FlashlightTurnOff@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?FlashlightTurnOff@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::FlashlightTurnOff, COMDAT

; 3682 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3683 : 	EMIT_SOUND_DYN( ENT(pev), CHAN_WEAPON, SOUND_FLASHLIGHT_OFF, 1.0, ATTN_NORM, 0, PITCH_NORM );

	push	100					; 00000064H
	push	0
	push	1061997773				; 3f4ccccdH
	push	1065353216				; 3f800000H
	push	OFFSET FLAT:??_C@_0BG@BKIG@items?1flashlight1?4wav?$AA@ ; `string'
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?EMIT_SOUND_DYN@@YAXPAUedict_s@@HPBDMMHH@Z ; EMIT_SOUND_DYN
	add	esp, 28					; 0000001cH

; 3684 :     ClearBits(pev->effects, EF_DIMLIGHT);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+280]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], ecx

; 3685 : 	MESSAGE_BEGIN( MSG_ONE, gmsgFlashlight, NULL, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgFlashlight@@3HA	; gmsgFlashlight
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 3686 : 	WRITE_BYTE(0);

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3687 : 	WRITE_BYTE(m_iFlashBattery);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2428]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3688 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 3689 : 
; 3690 : 	m_flFlashLightTime = FLASH_CHARGE_TIME + gpGlobals->time;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	QWORD PTR __real@8@3ffcccccccccccccd000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2424]

; 3691 : 
; 3692 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FlashlightTurnOff@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::FlashlightTurnOff
_TEXT	ENDS
PUBLIC	?ForceClientDllUpdate@CBasePlayer@@QAEXXZ	; CBasePlayer::ForceClientDllUpdate
;	COMDAT ?ForceClientDllUpdate@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ForceClientDllUpdate@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::ForceClientDllUpdate, COMDAT

; 3704 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3705 : 	m_iClientHealth  = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2920], -1

; 3706 : 	m_iClientBattery = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2924], -1

; 3707 : 	m_iClientSndRoomtype = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2952], -1

; 3708 : 	memset( m_iClientWeapons, -1, MAX_WEAPON_BYTES );

	push	8
	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2944				; 00000b80H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3709 : 	m_iStartMessage = 1; // send player init messages

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4136], 1

; 3710 : 	m_iTrain |= TRAIN_NEW;  // Force new train message.

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2856]
	or	al, -64					; ffffffc0H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], eax

; 3711 : 	m_fWeapon = FALSE;          // Force weapon send

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2860], 0

; 3712 : 	m_fKnownItem = FALSE;    // Force weaponinit messages.

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2480], 0

; 3713 : 	m_bRainNeedsUpdate = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4220], 1

; 3714 : 	m_fInitHUD = TRUE;		// Force HUD gmsgResetHUD message

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2848], 1

; 3715 : 
; 3716 : 	// Now force all the necessary messages
; 3717 : 	//  to be sent.
; 3718 : 	UpdateClientData();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+632]

; 3719 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ForceClientDllUpdate@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::ForceClientDllUpdate
_TEXT	ENDS
PUBLIC	??_C@_0BA@MPDL@game_firetarget?$AA@		; `string'
PUBLIC	??_C@_04OKCJ@Logo?$AA@				; `string'
PUBLIC	?__LINE__Var@?1??ImpulseCommands@CBasePlayer@@UAEXXZ@4FA ; `CBasePlayer::ImpulseCommands'::`2'::__LINE__Var
PUBLIC	??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0N@LDKC@gmsgLogo?5?$DO?50?$AA@		; `string'
PUBLIC	?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z		; GetClassPtr
PUBLIC	?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::SwitchWeapon
PUBLIC	?ImpulseCommands@CBasePlayer@@UAEXXZ		; CBasePlayer::ImpulseCommands
PUBLIC	?CheatImpulseCommands@CBasePlayer@@QAEXH@Z	; CBasePlayer::CheatImpulseCommands
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	?decalfrequency@@3Ucvar_s@@A:BYTE		; decalfrequency
EXTRN	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ?__LINE__Var@?1??ImpulseCommands@CBasePlayer@@UAEXXZ@4FA
; File z:\xashxtsrc\server\player.cpp
_DATA	SEGMENT
?__LINE__Var@?1??ImpulseCommands@CBasePlayer@@UAEXXZ@4FA DW 0e91H ; `CBasePlayer::ImpulseCommands'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@MPDL@game_firetarget?$AA@
CONST	SEGMENT
??_C@_0BA@MPDL@game_firetarget?$AA@ DB 'game_firetarget', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04OKCJ@Logo?$AA@
CONST	SEGMENT
??_C@_04OKCJ@Logo?$AA@ DB 'Logo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@
CONST	SEGMENT
??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@ DB 'z:\xashxtsrc\'
	DB	'server\player.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LDKC@gmsgLogo?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0N@LDKC@gmsgLogo?5?$DO?50?$AA@ DB 'gmsgLogo > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ?ImpulseCommands@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
$T44132 = -88
$T44133 = -100
$T44134 = -112
$T44135 = -124
_this$ = -4
_tr$ = -60
_iImpulse$ = -64
_grenade$41330 = -68
_iOn$41335 = -72
_pCan$41353 = -76
?ImpulseCommands@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::ImpulseCommands, COMDAT

; 3729 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3730 : 	TraceResult	tr;// UNDONE: kill me! This is temporary for PreAlpha CDs

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3731 : 
; 3732 : 	// Handle use events
; 3733 : 	PlayerUse();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlayerUse@CBasePlayer@@QAEXXZ		; CBasePlayer::PlayerUse

; 3734 : 
; 3735 : 	int iImpulse = (int)pev->impulse;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR _iImpulse$[ebp], edx

; 3736 : 
; 3737 : 	// custom handled buttons
; 3738 : 	if( iImpulse >= 1 && iImpulse <= 50 )

	cmp	DWORD PTR _iImpulse$[ebp], 1
	jl	SHORT $L41322
	cmp	DWORD PTR _iImpulse$[ebp], 50		; 00000032H
	jg	SHORT $L41322

; 3740 : 		UTIL_FireTargets( "game_firetarget", this, this, USE_TOGGLE, iImpulse );

	fild	DWORD PTR _iImpulse$[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BA@MPDL@game_firetarget?$AA@ ; `string'
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 3741 : 		pev->impulse = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+388], 0

; 3742 : 		return;

	jmp	$L41318
$L41322:

; 3746 : 	{

	mov	ecx, DWORD PTR _iImpulse$[ebp]
	mov	DWORD PTR -128+[ebp], ecx
	mov	edx, DWORD PTR -128+[ebp]
	sub	edx, 70					; 00000046H
	mov	DWORD PTR -128+[ebp], edx
	cmp	DWORD PTR -128+[ebp], 131		; 00000083H
	ja	$L41359
	mov	ecx, DWORD PTR -128+[ebp]
	xor	eax, eax
	mov	al, BYTE PTR $L44136[ecx]
	jmp	DWORD PTR $L44137[eax*4]
$L41328:

; 3747 : 	case 70:
; 3748 : 		//кидание гранаты на "G"
; 3749 : 		if ( m_rgpPlayerItems[5] != NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2976], 0
	je	SHORT $L41333

; 3751 : 			CBasePlayerWeapon *grenade = (CBasePlayerWeapon *)m_rgpPlayerItems[5];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2976]
	mov	DWORD PTR _grenade$41330[ebp], ecx

; 3752 : 			if ( m_rgpPlayerItems[5] != m_pActiveItem )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2976]
	cmp	ecx, DWORD PTR [eax+2980]
	je	SHORT $L41332

; 3753 : 				SwitchWeapon( grenade );

	mov	edx, DWORD PTR _grenade$41330[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::SwitchWeapon
$L41332:

; 3754 : 			if (m_pActiveItem && grenade->m_flNextPrimaryAttack <= gpGlobals->time)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L41333
	mov	ecx, DWORD PTR _grenade$41330[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+1844]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L41333

; 3756 : 				grenade->PrimaryAttack();

	mov	eax, DWORD PTR _grenade$41330[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _grenade$41330[ebp]
	call	DWORD PTR [edx+444]
$L41333:

; 3759 : 		break;

	jmp	$L41325
$L41334:

; 3762 : 
; 3763 : 		int iOn;
; 3764 : 
; 3765 : 		if (!gmsgLogo)

	cmp	DWORD PTR ?gmsgLogo@@3HA, 0		; gmsgLogo
	jne	SHORT $L41336

; 3767 : 			iOn = 1;

	mov	DWORD PTR _iOn$41335[ebp], 1

; 3768 : 			gmsgLogo = REG_USER_MSG("Logo", 1);

	push	1
	push	OFFSET FLAT:??_C@_04OKCJ@Logo?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+300
	add	esp, 8
	mov	DWORD PTR ?gmsgLogo@@3HA, eax		; gmsgLogo

; 3770 : 		else

	jmp	SHORT $L41338
$L41336:

; 3772 : 			iOn = 0;

	mov	DWORD PTR _iOn$41335[ebp], 0
$L41338:

; 3774 : 
; 3775 : 		ASSERT( gmsgLogo > 0 );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??ImpulseCommands@CBasePlayer@@UAEXXZ@4FA ; `CBasePlayer::ImpulseCommands'::`2'::__LINE__Var
	add	eax, 46					; 0000002eH
	push	eax
	push	OFFSET FLAT:??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@LDKC@gmsgLogo?5?$DO?50?$AA@ ; `string'
	xor	ecx, ecx
	cmp	DWORD PTR ?gmsgLogo@@3HA, 0		; gmsgLogo
	setg	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 3776 : 		// send "health" update message
; 3777 : 		MESSAGE_BEGIN( MSG_ONE, gmsgLogo, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgLogo@@3HA		; gmsgLogo
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 3778 : 			WRITE_BYTE(iOn);

	mov	edx, DWORD PTR _iOn$41335[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 3779 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 3780 : 
; 3781 : 		if(!iOn)

	cmp	DWORD PTR _iOn$41335[ebp], 0
	jne	SHORT $L41342

; 3782 : 			gmsgLogo = 0;

	mov	DWORD PTR ?gmsgLogo@@3HA, 0		; gmsgLogo
$L41342:

; 3783 : 		break;

	jmp	$L41325
$L41343:

; 3785 : 	case 100:
; 3786 : 		// temporary flashlight for level designers
; 3787 : 		if( FlashlightIsOn() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlashlightIsOn@CBasePlayer@@QAEHXZ	; CBasePlayer::FlashlightIsOn
	test	eax, eax
	je	SHORT $L41344

; 3789 : 			FlashlightTurnOff();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlashlightTurnOff@CBasePlayer@@QAEXXZ	; CBasePlayer::FlashlightTurnOff

; 3791 : 		else

	jmp	SHORT $L41345
$L41344:

; 3793 : 			FlashlightTurnOn();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlashlightTurnOn@CBasePlayer@@QAEXXZ	; CBasePlayer::FlashlightTurnOn
$L41345:

; 3795 : 		break;

	jmp	$L41325
$L41346:

; 3796 : 	case 201:// paint decal
; 3797 : 		if ( gpGlobals->time < m_flNextDecalTime )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+3800]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41347

; 3799 : 			// too early!
; 3800 : 			break;

	jmp	$L41325
$L41347:

; 3802 : 
; 3803 : 		UTIL_MakeVectors( pev->v_angle );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 116				; 00000074H
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3804 : 		UTIL_TraceLine( EyePosition(), EyePosition() + gpGlobals->v_forward * 128, dont_ignore_monsters, edict(), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	push	1124073472				; 43000000H
	lea	edx, DWORD PTR $T44133[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T44134[ebp]
	push	eax
	lea	ecx, DWORD PTR $T44132[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR $T44135[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3805 : 
; 3806 : 		if ( tr.flFraction != 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41352

; 3808 : 			// line hit something, so paint a decal
; 3809 : 			m_flNextDecalTime = gpGlobals->time + decalfrequency.value;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR ?decalfrequency@@3Ucvar_s@@A+12
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+3800]

; 3810 : 			CSprayCan *pCan = GetClassPtr((CSprayCan *)NULL);

	push	0
	call	?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pCan$41353[ebp], eax

; 3811 : 			pCan->Spawn( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCan$41353[ebp]
	call	?Spawn@CSprayCan@@QAEXPAVCBaseEntity@@@Z ; CSprayCan::Spawn
$L41352:

; 3813 : 
; 3814 : 		break;

	jmp	SHORT $L41325
$L41359:

; 3815 : 
; 3816 : 	default:
; 3817 : 		// check all of the cheat impulse commands now
; 3818 : 		CheatImpulseCommands( iImpulse );

	mov	ecx, DWORD PTR _iImpulse$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheatImpulseCommands@CBasePlayer@@QAEXH@Z ; CBasePlayer::CheatImpulseCommands
$L41325:

; 3821 : 
; 3822 : 	pev->impulse = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+388], 0
$L41318:

; 3823 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L44137:
	DD	$L41328
	DD	$L41334
	DD	$L41343
	DD	$L41346
	DD	$L41359
$L44136:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?ImpulseCommands@CBasePlayer@@UAEXXZ ENDP		; CBasePlayer::ImpulseCommands
_TEXT	ENDS
PUBLIC	??_C@_0BE@HADJ@monster_human_grunt?$AA@		; `string'
PUBLIC	??_C@_0P@KBEE@monster_zombie?$AA@		; `string'
PUBLIC	??_C@_09IMIN@item_suit?$AA@			; `string'
PUBLIC	??_C@_0P@LMGJ@item_healthkit?$AA@		; `string'
PUBLIC	??_C@_0N@CIMM@item_battery?$AA@			; `string'
PUBLIC	??_C@_0P@NAIF@weapon_crowbar?$AA@		; `string'
PUBLIC	??_C@_0L@NFGM@weapon_axe?$AA@			; `string'
PUBLIC	??_C@_0BA@FNBB@weapon_chainsaw?$AA@		; `string'
PUBLIC	??_C@_09LNJP@ammo_fuel?$AA@			; `string'
PUBLIC	??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@		; `string'
PUBLIC	??_C@_0N@MPPM@ammo_9mmclip?$AA@			; `string'
PUBLIC	??_C@_0P@PHLB@weapon_shotgun?$AA@		; `string'
PUBLIC	??_C@_0O@FHCF@ammo_buckshot?$AA@		; `string'
PUBLIC	??_C@_0N@JNOE@weapon_9mmAR?$AA@			; `string'
PUBLIC	??_C@_0L@HEPA@ammo_9mmAR?$AA@			; `string'
PUBLIC	??_C@_0BD@HGIA@weapon_handgrenade?$AA@		; `string'
PUBLIC	??_C@_0L@NPOO@weapon_357?$AA@			; `string'
PUBLIC	??_C@_08BGGJ@ammo_357?$AA@			; `string'
PUBLIC	??_C@_0BA@HAEF@weapon_crossbow?$AA@		; `string'
PUBLIC	??_C@_0O@OFDM@ammo_crossbow?$AA@		; `string'
PUBLIC	??_C@_0L@OCEH@weapon_rpg?$AA@			; `string'
PUBLIC	??_C@_0N@BIME@ammo_rpgclip?$AA@			; `string'
PUBLIC	??_C@_0BD@GFEK@Player?5is?5audible?6?$AA@	; `string'
PUBLIC	??_C@_0BC@IGLL@Player?5is?5silent?6?$AA@	; `string'
PUBLIC	??_C@_0N@HPKB@Texture?3?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0O@JIOJ@Hitgroup?3?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0BA@ILEJ@node_viewer_fly?$AA@		; `string'
PUBLIC	??_C@_0BC@BACI@node_viewer_large?$AA@		; `string'
PUBLIC	??_C@_0BC@IDJE@node_viewer_human?$AA@		; `string'
PUBLIC	??_C@_03HMFC@?$CFd?6?$AA@			; `string'
PUBLIC	?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z		; GetClassPtr
EXTRN	?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z:NEAR ; CGib::SpawnRandomGibs
EXTRN	?FindNearestNode@CGraph@@QAEHABVVector@@H@Z:NEAR ; CGraph::FindNearestNode
EXTRN	?g_flWeaponCheat@@3MA:DWORD			; g_flWeaponCheat
EXTRN	?ShowNodeConnections@CGraph@@QAEXH@Z:NEAR	; CGraph::ShowNodeConnections
EXTRN	?g_pWorld@@3PAVCBaseEntity@@A:DWORD		; g_pWorld
EXTRN	?ReportInfo@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::ReportInfo
EXTRN	?DumpGlobals@CGlobalState@@QAEXXZ:NEAR		; CGlobalState::DumpGlobals
EXTRN	?gGlobalState@@3VCGlobalState@@A:QWORD		; gGlobalState
;	COMDAT ??_C@_0BE@HADJ@monster_human_grunt?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BE@HADJ@monster_human_grunt?$AA@ DB 'monster_human_grunt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KBEE@monster_zombie?$AA@
CONST	SEGMENT
??_C@_0P@KBEE@monster_zombie?$AA@ DB 'monster_zombie', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IMIN@item_suit?$AA@
CONST	SEGMENT
??_C@_09IMIN@item_suit?$AA@ DB 'item_suit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMGJ@item_healthkit?$AA@
CONST	SEGMENT
??_C@_0P@LMGJ@item_healthkit?$AA@ DB 'item_healthkit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CIMM@item_battery?$AA@
CONST	SEGMENT
??_C@_0N@CIMM@item_battery?$AA@ DB 'item_battery', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NAIF@weapon_crowbar?$AA@
CONST	SEGMENT
??_C@_0P@NAIF@weapon_crowbar?$AA@ DB 'weapon_crowbar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFGM@weapon_axe?$AA@
CONST	SEGMENT
??_C@_0L@NFGM@weapon_axe?$AA@ DB 'weapon_axe', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FNBB@weapon_chainsaw?$AA@
CONST	SEGMENT
??_C@_0BA@FNBB@weapon_chainsaw?$AA@ DB 'weapon_chainsaw', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LNJP@ammo_fuel?$AA@
CONST	SEGMENT
??_C@_09LNJP@ammo_fuel?$AA@ DB 'ammo_fuel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@
CONST	SEGMENT
??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@ DB 'weapon_9mmhandgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MPPM@ammo_9mmclip?$AA@
CONST	SEGMENT
??_C@_0N@MPPM@ammo_9mmclip?$AA@ DB 'ammo_9mmclip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PHLB@weapon_shotgun?$AA@
CONST	SEGMENT
??_C@_0P@PHLB@weapon_shotgun?$AA@ DB 'weapon_shotgun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHCF@ammo_buckshot?$AA@
CONST	SEGMENT
??_C@_0O@FHCF@ammo_buckshot?$AA@ DB 'ammo_buckshot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JNOE@weapon_9mmAR?$AA@
CONST	SEGMENT
??_C@_0N@JNOE@weapon_9mmAR?$AA@ DB 'weapon_9mmAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HEPA@ammo_9mmAR?$AA@
CONST	SEGMENT
??_C@_0L@HEPA@ammo_9mmAR?$AA@ DB 'ammo_9mmAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HGIA@weapon_handgrenade?$AA@
CONST	SEGMENT
??_C@_0BD@HGIA@weapon_handgrenade?$AA@ DB 'weapon_handgrenade', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPOO@weapon_357?$AA@
CONST	SEGMENT
??_C@_0L@NPOO@weapon_357?$AA@ DB 'weapon_357', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BGGJ@ammo_357?$AA@
CONST	SEGMENT
??_C@_08BGGJ@ammo_357?$AA@ DB 'ammo_357', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HAEF@weapon_crossbow?$AA@
CONST	SEGMENT
??_C@_0BA@HAEF@weapon_crossbow?$AA@ DB 'weapon_crossbow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OFDM@ammo_crossbow?$AA@
CONST	SEGMENT
??_C@_0O@OFDM@ammo_crossbow?$AA@ DB 'ammo_crossbow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OCEH@weapon_rpg?$AA@
CONST	SEGMENT
??_C@_0L@OCEH@weapon_rpg?$AA@ DB 'weapon_rpg', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BIME@ammo_rpgclip?$AA@
CONST	SEGMENT
??_C@_0N@BIME@ammo_rpgclip?$AA@ DB 'ammo_rpgclip', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GFEK@Player?5is?5audible?6?$AA@
CONST	SEGMENT
??_C@_0BD@GFEK@Player?5is?5audible?6?$AA@ DB 'Player is audible', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IGLL@Player?5is?5silent?6?$AA@
CONST	SEGMENT
??_C@_0BC@IGLL@Player?5is?5silent?6?$AA@ DB 'Player is silent', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPKB@Texture?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0N@HPKB@Texture?3?5?$CFs?6?$AA@ DB 'Texture: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIOJ@Hitgroup?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0O@JIOJ@Hitgroup?3?5?$CFs?6?$AA@ DB 'Hitgroup: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILEJ@node_viewer_fly?$AA@
CONST	SEGMENT
??_C@_0BA@ILEJ@node_viewer_fly?$AA@ DB 'node_viewer_fly', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BACI@node_viewer_large?$AA@
CONST	SEGMENT
??_C@_0BC@BACI@node_viewer_large?$AA@ DB 'node_viewer_large', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IDJE@node_viewer_human?$AA@
CONST	SEGMENT
??_C@_0BC@IDJE@node_viewer_human?$AA@ DB 'node_viewer_human', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HMFC@?$CFd?6?$AA@
CONST	SEGMENT
??_C@_03HMFC@?$CFd?6?$AA@ DB '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?CheatImpulseCommands@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT
$T44140 = -172
$T44141 = -184
$T44142 = -196
$T44143 = -208
$T44144 = -220
$T44145 = -232
$T44146 = -244
$T44147 = -256
$T44148 = -268
$T44149 = -280
$T44150 = -292
$T44151 = -304
$T44152 = -316
_iImpulse$ = 8
_this$ = -4
_pEntity$ = -8
_tr$ = -64
_pMonster$41422 = -68
_tr$41433 = -124
_pWorld$41434 = -128
_start$41435 = -140
_end$41437 = -152
_pTextureName$41442 = -156
_pBlood$41461 = -160
?CheatImpulseCommands@CBasePlayer@@QAEXH@Z PROC NEAR	; CBasePlayer::CheatImpulseCommands, COMDAT

; 3849 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 384				; 00000180H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 3850 : 	if( g_flWeaponCheat == 0.0 )

	fld	DWORD PTR ?g_flWeaponCheat@@3MA		; g_flWeaponCheat
	fcomp	QWORD PTR __real@8@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41381

; 3852 : 		return;

	jmp	$L41380
$L41381:

; 3856 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3859 : 	{

	mov	eax, DWORD PTR _iImpulse$[ebp]
	mov	DWORD PTR -320+[ebp], eax
	mov	ecx, DWORD PTR -320+[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR -320+[ebp], ecx
	cmp	DWORD PTR -320+[ebp], 127		; 0000007fH
	ja	$L41385
	mov	eax, DWORD PTR -320+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L44153[eax]
	jmp	DWORD PTR $L44154[edx*4]
$L41388:

; 3860 : 	case 76:
; 3861 : 		UTIL_MakeVectors( Vector( 0, pev->v_angle.y, 0 ));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	push	0
	lea	ecx, DWORD PTR $T44140[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3862 : 		Create( "monster_human_grunt", GetAbsOrigin() + gpGlobals->v_forward * 128, GetAbsAngles( ));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	push	1124073472				; 43000000H
	lea	ecx, DWORD PTR $T44141[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T44142[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	push	OFFSET FLAT:??_C@_0BE@HADJ@monster_human_grunt?$AA@ ; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H

; 3863 : 		break;

	jmp	$L41385
$L41393:

; 3864 : 	case 77:
; 3865 : 		UTIL_MakeVectors( Vector( 0, pev->v_angle.y, 0 ));

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+120]
	push	edx
	push	0
	lea	ecx, DWORD PTR $T44143[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 3866 : 		Create( "monster_zombie", GetAbsOrigin() + gpGlobals->v_forward * 128, GetAbsAngles( ));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	push	1124073472				; 43000000H
	lea	eax, DWORD PTR $T44144[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T44145[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	push	OFFSET FLAT:??_C@_0P@KBEE@monster_zombie?$AA@ ; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H

; 3867 : 		break;

	jmp	$L41385
$L41398:

; 3868 : 	case 101:
; 3869 : 		gEvilImpulse101 = TRUE;

	mov	DWORD PTR ?gEvilImpulse101@@3HA, 1	; gEvilImpulse101

; 3870 : 		GiveNamedItem( "item_suit" );

	push	OFFSET FLAT:??_C@_09IMIN@item_suit?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3871 : 		GiveNamedItem( "item_healthkit" );

	push	OFFSET FLAT:??_C@_0P@LMGJ@item_healthkit?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3872 : 		GiveNamedItem( "item_battery" );

	push	OFFSET FLAT:??_C@_0N@CIMM@item_battery?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3873 : 		GiveNamedItem( "weapon_crowbar" );

	push	OFFSET FLAT:??_C@_0P@NAIF@weapon_crowbar?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3874 : 		GiveNamedItem( "weapon_axe" );

	push	OFFSET FLAT:??_C@_0L@NFGM@weapon_axe?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3875 : 		GiveNamedItem( "weapon_chainsaw" );

	push	OFFSET FLAT:??_C@_0BA@FNBB@weapon_chainsaw?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3876 : 		GiveNamedItem( "ammo_fuel" );

	push	OFFSET FLAT:??_C@_09LNJP@ammo_fuel?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3877 : 		GiveNamedItem( "weapon_9mmhandgun" );

	push	OFFSET FLAT:??_C@_0BC@MNAJ@weapon_9mmhandgun?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3878 : 		GiveNamedItem( "ammo_9mmclip" );

	push	OFFSET FLAT:??_C@_0N@MPPM@ammo_9mmclip?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3879 : 		GiveNamedItem( "weapon_shotgun" );

	push	OFFSET FLAT:??_C@_0P@PHLB@weapon_shotgun?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3880 : 		GiveNamedItem( "ammo_buckshot" );

	push	OFFSET FLAT:??_C@_0O@FHCF@ammo_buckshot?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3881 : 		GiveNamedItem( "weapon_9mmAR" );

	push	OFFSET FLAT:??_C@_0N@JNOE@weapon_9mmAR?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3882 : 		GiveNamedItem( "ammo_9mmAR" );

	push	OFFSET FLAT:??_C@_0L@HEPA@ammo_9mmAR?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3883 : 		//GiveNamedItem( "ammo_ARgrenades" );
; 3884 : 		GiveNamedItem( "weapon_handgrenade" );

	push	OFFSET FLAT:??_C@_0BD@HGIA@weapon_handgrenade?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3885 : 		//GiveNamedItem( "weapon_tripmine" );
; 3886 : 		GiveNamedItem( "weapon_357" );

	push	OFFSET FLAT:??_C@_0L@NPOO@weapon_357?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3887 : 		GiveNamedItem( "ammo_357" );

	push	OFFSET FLAT:??_C@_08BGGJ@ammo_357?$AA@	; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3888 : 		GiveNamedItem( "weapon_crossbow" );

	push	OFFSET FLAT:??_C@_0BA@HAEF@weapon_crossbow?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3889 : 		GiveNamedItem( "ammo_crossbow" );

	push	OFFSET FLAT:??_C@_0O@OFDM@ammo_crossbow?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3890 : 		//GiveNamedItem( "weapon_egon" );
; 3891 : 		//GiveNamedItem( "weapon_gauss" );
; 3892 : 		//GiveNamedItem( "ammo_gaussclip" );
; 3893 : 		GiveNamedItem( "weapon_rpg" );

	push	OFFSET FLAT:??_C@_0L@OCEH@weapon_rpg?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3894 : 		GiveNamedItem( "ammo_rpgclip" );

	push	OFFSET FLAT:??_C@_0N@BIME@ammo_rpgclip?$AA@ ; `string'
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GiveNamedItem@CBasePlayer@@QAEXPBD@Z	; CBasePlayer::GiveNamedItem

; 3895 : 		//GiveNamedItem( "weapon_satchel" );
; 3896 : 		//GiveNamedItem( "weapon_snark" );
; 3897 : 		//GiveNamedItem( "weapon_hornetgun" );
; 3898 : 		gEvilImpulse101 = FALSE;

	mov	DWORD PTR ?gEvilImpulse101@@3HA, 0	; gEvilImpulse101

; 3899 : 
; 3900 : 		/*hudtextparms_t	m_textParms;
; 3901 : 
; 3902 : 		m_textParms.channel = 0;
; 3903 : 		m_textParms.x = 0.05;
; 3904 : 		m_textParms.y = 0.5;
; 3905 : 		m_textParms.effect = 0;
; 3906 : 
; 3907 : 		m_textParms.r1 = 255;
; 3908 : 		m_textParms.g1 = 255;
; 3909 : 		m_textParms.b1 = 255;
; 3910 : 		m_textParms.a1 = 200;
; 3911 : 
; 3912 : 		m_textParms.r2 = 255;
; 3913 : 		m_textParms.g2 = 160;
; 3914 : 		m_textParms.b2 = 0;
; 3915 : 		m_textParms.a2 = 200;
; 3916 : 		m_textParms.fadeinTime = 0.5;
; 3917 : 		m_textParms.fadeoutTime = 3;
; 3918 : 		m_textParms.holdTime = 10;
; 3919 : 		m_textParms.fxTime = 0.25;
; 3920 : 		UTIL_HudMessage( this, m_textParms, "Buy item\n\n1. Melee weapons\n2. Pistols\n3. Shotguns\n4. Sub-Machine guns\n5. Assault Rifles\n6. Sniper rifles\n7. Demolition\n\n8. Equipment\n\n0. Exit" );*/
; 3921 : 		break;

	jmp	$L41385
$L41419:

; 3922 : 	case 102:
; 3923 : 		// Gibbage!!!
; 3924 : 		CGib::SpawnRandomGibs( pev, 1, 1 );

	push	1
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?SpawnRandomGibs@CGib@@SAXPAUentvars_s@@HH@Z ; CGib::SpawnRandomGibs
	add	esp, 12					; 0000000cH

; 3925 : 		break;

	jmp	$L41385
$L41420:

; 3926 : 
; 3927 : 	case 103:
; 3928 : 		// What the hell are you doing?
; 3929 : 		pEntity = FindEntityForward( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z ; FindEntityForward
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 3930 : 		if ( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41423

; 3932 : 			CBaseMonster *pMonster = pEntity->MyMonsterPointer();

	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [eax+124]
	mov	DWORD PTR _pMonster$41422[ebp], eax

; 3933 : 			if ( pMonster )

	cmp	DWORD PTR _pMonster$41422[ebp], 0
	je	SHORT $L41423

; 3934 : 				pMonster->ReportAIState();

	mov	ecx, DWORD PTR _pMonster$41422[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pMonster$41422[ebp]
	call	DWORD PTR [edx+488]
$L41423:

; 3936 : 		break;

	jmp	$L41385
$L41424:

; 3937 : 
; 3938 : 	case 104:
; 3939 : 		// Dump all of the global state varaibles (and global entity names)
; 3940 : 		gGlobalState.DumpGlobals();

	mov	ecx, OFFSET FLAT:?gGlobalState@@3VCGlobalState@@A
	call	?DumpGlobals@CGlobalState@@QAEXXZ	; CGlobalState::DumpGlobals

; 3941 : 		break;

	jmp	$L41385
$L41425:

; 3945 : 			if ( m_fNoPlayerSound )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2900], 0
	je	SHORT $L41426

; 3947 : 				ALERT ( at_console, "Player is audible\n" );

	push	OFFSET FLAT:??_C@_0BD@GFEK@Player?5is?5audible?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3948 : 				m_fNoPlayerSound = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2900], 0

; 3950 : 			else

	jmp	SHORT $L41428
$L41426:

; 3952 : 				ALERT ( at_console, "Player is silent\n" );

	push	OFFSET FLAT:??_C@_0BC@IGLL@Player?5is?5silent?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 3953 : 				m_fNoPlayerSound = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2900], 1
$L41428:

; 3955 : 			break;

	jmp	$L41385
$L41430:

; 3957 : 
; 3958 : 	case 106:
; 3959 : 		// Give me the classname and targetname of this entity.
; 3960 : 		pEntity = FindEntityForward( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z ; FindEntityForward
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 3961 : 		if ( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41431

; 3962 : 			pEntity->ReportInfo();

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?ReportInfo@CBaseEntity@@QAEXXZ		; CBaseEntity::ReportInfo
$L41431:

; 3963 : 		break;

	jmp	$L41385
$L41432:

; 3967 : 			TraceResult tr;

	lea	ecx, DWORD PTR _tr$41433[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 3968 : 
; 3969 : 			edict_t *pWorld = INDEXENT( 0 );

	push	0
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pWorld$41434[ebp], eax

; 3970 : 
; 3971 : 			Vector start = EyePosition();

	lea	ecx, DWORD PTR $T44146[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	push	eax
	lea	ecx, DWORD PTR _start$41435[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3972 : 			Vector end = start + gpGlobals->v_forward * 1024;

	push	1149239296				; 44800000H
	lea	ecx, DWORD PTR $T44147[ebp]
	push	ecx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T44148[ebp]
	push	edx
	lea	ecx, DWORD PTR _start$41435[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _end$41437[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 3973 : 			UTIL_TraceLine( start, end, dont_ignore_monsters, edict(), &tr );

	lea	eax, DWORD PTR _tr$41433[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _end$41437[ebp]
	push	ecx
	lea	edx, DWORD PTR _start$41435[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 3974 : 			if ( tr.pHit )

	cmp	DWORD PTR _tr$41433[ebp+48], 0
	je	SHORT $L41440

; 3975 : 				pWorld = tr.pHit;

	mov	eax, DWORD PTR _tr$41433[ebp+48]
	mov	DWORD PTR _pWorld$41434[ebp], eax
$L41440:

; 3976 : 
; 3977 : 			if( pWorld->v.solid == SOLID_BSP )

	mov	ecx, DWORD PTR _pWorld$41434[ebp]
	cmp	DWORD PTR [ecx+396], 4
	jne	SHORT $L41441

; 3979 : 				const char *pTextureName = TRACE_TEXTURE( pWorld, start, end );

	lea	ecx, DWORD PTR _end$41437[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	lea	ecx, DWORD PTR _start$41435[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	edx, DWORD PTR _pWorld$41434[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+144
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pTextureName$41442[ebp], eax

; 3980 : 				if ( pTextureName )

	cmp	DWORD PTR _pTextureName$41442[ebp], 0
	je	SHORT $L41443

; 3981 : 					ALERT( at_console, "Texture: %s\n", pTextureName );

	mov	eax, DWORD PTR _pTextureName$41442[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@HPKB@Texture?3?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L41443:

; 3983 : 			else ALERT( at_console, "Hitgroup: %s\n", pHitboxNames[tr.iHitgroup] );

	jmp	SHORT $L41445
$L41441:
	mov	ecx, DWORD PTR _tr$41433[ebp+52]
	mov	edx, DWORD PTR ?pHitboxNames@@3PAPBDA[ecx*4]
	push	edx
	push	OFFSET FLAT:??_C@_0O@JIOJ@Hitgroup?3?5?$CFs?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L41445:

; 3985 : 		break;

	jmp	$L41385
$L41447:

; 3988 : 			Create( "node_viewer_fly", GetAbsOrigin(), GetAbsAngles( ));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	OFFSET FLAT:??_C@_0BA@ILEJ@node_viewer_fly?$AA@ ; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H

; 3990 : 		break;

	jmp	$L41385
$L41449:

; 3993 : 			Create( "node_viewer_large", GetAbsOrigin(), GetAbsAngles( ));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	OFFSET FLAT:??_C@_0BC@BACI@node_viewer_large?$AA@ ; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H

; 3995 : 		break;

	jmp	$L41385
$L41451:

; 3998 : 			Create( "node_viewer_human", GetAbsOrigin(), GetAbsAngles( ));

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	push	OFFSET FLAT:??_C@_0BC@IDJE@node_viewer_human?$AA@ ; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H

; 4000 : 		break;

	jmp	$L41385
$L41453:

; 4003 : 			ALERT( at_console, "%d\n", WorldGraph.FindNearestNode( GetAbsOrigin(), bits_NODE_GROUP_REALM ));

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@H@Z ; CGraph::FindNearestNode
	push	eax
	push	OFFSET FLAT:??_C@_03HMFC@?$CFd?6?$AA@	; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 4004 : 			WorldGraph.ShowNodeConnections( WorldGraph.FindNearestNode ( GetAbsOrigin(), bits_NODE_GROUP_REALM ));

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?FindNearestNode@CGraph@@QAEHABVVector@@H@Z ; CGraph::FindNearestNode
	push	eax
	mov	ecx, OFFSET FLAT:?WorldGraph@@3VCGraph@@A
	call	?ShowNodeConnections@CGraph@@QAEXH@Z	; CGraph::ShowNodeConnections

; 4006 : 		break;

	jmp	$L41385
$L41455:

; 4007 : 	case	202:// Random blood splatter
; 4008 : 		UTIL_MakeVectors(pev->v_angle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 116				; 00000074H
	push	ecx
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 4009 : 		UTIL_TraceLine ( EyePosition(), EyePosition() + gpGlobals->v_forward * 128, dont_ignore_monsters, edict(), &tr );

	lea	edx, DWORD PTR _tr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	push	1124073472				; 43000000H
	lea	eax, DWORD PTR $T44150[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T44151[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44149[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	eax, DWORD PTR $T44152[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+308]
	push	eax
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 4010 : 
; 4011 : 		if ( tr.flFraction != 1.0 )

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41460

; 4013 : 			CBloodSplat *pBlood = GetClassPtr((CBloodSplat *)NULL);

	push	0
	call	?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z	; GetClassPtr
	add	esp, 4
	mov	DWORD PTR _pBlood$41461[ebp], eax

; 4014 : 			pBlood->Spawn( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBlood$41461[ebp]
	call	?Spawn@CBloodSplat@@QAEXPAVCBaseEntity@@@Z ; CBloodSplat::Spawn
$L41460:

; 4016 : 		break;

	jmp	SHORT $L41385
$L41467:

; 4017 : 	case	203:// remove creature.
; 4018 : 		pEntity = FindEntityForward( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?FindEntityForward@@YAPAVCBaseEntity@@PAV1@@Z ; FindEntityForward
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 4019 : 		if ( pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L41469

; 4021 : 			if( pEntity != g_pWorld )

	mov	edx, DWORD PTR _pEntity$[ebp]
	cmp	edx, DWORD PTR ?g_pWorld@@3PAVCBaseEntity@@A ; g_pWorld
	je	SHORT $L41469

; 4022 : 				UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4
$L41469:
$L41385:
$L41380:

; 4026 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L44154:
	DD	$L41388
	DD	$L41393
	DD	$L41398
	DD	$L41419
	DD	$L41420
	DD	$L41424
	DD	$L41425
	DD	$L41430
	DD	$L41432
	DD	$L41447
	DD	$L41449
	DD	$L41451
	DD	$L41453
	DD	$L41455
	DD	$L41467
	DD	$L41385
$L44153:
	DB	0
	DB	1
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	15					; 0000000fH
	DB	12					; 0000000cH
	DB	15					; 0000000fH
	DB	15					; 0000000fH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
?CheatImpulseCommands@CBasePlayer@@QAEXH@Z ENDP		; CBasePlayer::CheatImpulseCommands
_TEXT	ENDS
PUBLIC	?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::AddPlayerItem
EXTRN	?CheckRespawn@CBasePlayerItem@@QAEXXZ:NEAR	; CBasePlayerItem::CheckRespawn
;	COMDAT ?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8
_this$ = -4
_pInsert$ = -8
?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBasePlayer::AddPlayerItem, COMDAT

; 4032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4033 : 	CBasePlayerItem *pInsert;
; 4034 : 
; 4035 : 	pInsert = m_rgpPlayerItems[pItem->iItemSlot()];

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2956]
	mov	DWORD PTR _pInsert$[ebp], edx
$L41476:

; 4036 : 
; 4037 : 	while (pInsert)

	cmp	DWORD PTR _pInsert$[ebp], 0
	je	$L41477

; 4039 : 		if (FClassnameIs( pInsert->pev, STRING( pItem->pev->classname) ))

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pInsert$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	$L41478

; 4041 : 			if( pItem->AddDuplicate( pInsert ))

	mov	edx, DWORD PTR _pInsert$[ebp]
	push	edx
	mov	eax, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+348]
	test	eax, eax
	je	SHORT $L41479

; 4043 : 				g_pGameRules->PlayerGotWeapon ( this, pItem );

	mov	eax, DWORD PTR _pItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+120]

; 4044 : 				pItem->CheckRespawn();

	mov	ecx, DWORD PTR _pItem$[ebp]
	call	?CheckRespawn@CBasePlayerItem@@QAEXXZ	; CBasePlayerItem::CheckRespawn

; 4045 : 
; 4046 : 				// ugly hack to update clip w/o an update clip message
; 4047 : 				pInsert->UpdateItemInfo( );

	mov	ecx, DWORD PTR _pInsert$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pInsert$[ebp]
	call	DWORD PTR [edx+372]

; 4048 : 				if (m_pActiveItem)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L41480

; 4049 : 					m_pActiveItem->UpdateItemInfo( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+372]
$L41480:

; 4050 : 
; 4051 : 				pItem->Kill( );

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+388]

; 4053 : 			else if( gEvilImpulse101 )

	jmp	SHORT $L41482
$L41479:
	cmp	DWORD PTR ?gEvilImpulse101@@3HA, 0	; gEvilImpulse101
	je	SHORT $L41482

; 4055 : 				pItem->Kill( );

	mov	eax, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+388]
$L41482:

; 4057 : 			return FALSE;

	xor	eax, eax
	jmp	$L41473
$L41478:

; 4059 : 		pInsert = pInsert->m_pNext;

	mov	eax, DWORD PTR _pInsert$[ebp]
	mov	ecx, DWORD PTR [eax+1820]
	mov	DWORD PTR _pInsert$[ebp], ecx

; 4060 : 	}

	jmp	$L41476
$L41477:

; 4061 : 
; 4062 : 
; 4063 : 	if( pItem->AddToPlayer( this ))

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+344]
	test	eax, eax
	je	$L41483

; 4065 : 		g_pGameRules->PlayerGotWeapon ( this, pItem );

	mov	eax, DWORD PTR _pItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+120]

; 4066 : 		pItem->CheckRespawn();

	mov	ecx, DWORD PTR _pItem$[ebp]
	call	?CheckRespawn@CBasePlayerItem@@QAEXXZ	; CBasePlayerItem::CheckRespawn

; 4067 : 
; 4068 : 		pItem->m_pNext = m_rgpPlayerItems[pItem->iItemSlot()];

	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+2956]
	mov	DWORD PTR [ecx+1820], eax

; 4069 : 		m_rgpPlayerItems[pItem->iItemSlot()] = pItem;

	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pItem$[ebp]
	mov	DWORD PTR [ecx+eax*4+2956], edx

; 4070 : 
; 4071 : 		// should we switch to this item?
; 4072 : 		if ( g_pGameRules->FShouldSwitchWeapon( this, pItem ) )

	mov	eax, DWORD PTR _pItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [eax+16]
	test	eax, eax
	je	SHORT $L41484

; 4074 : 			SwitchWeapon( pItem );

	mov	ecx, DWORD PTR _pItem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::SwitchWeapon
$L41484:

; 4076 : 
; 4077 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41473
$L41483:

; 4079 : 	else if( gEvilImpulse101 )

	cmp	DWORD PTR ?gEvilImpulse101@@3HA, 0	; gEvilImpulse101
	je	SHORT $L41486

; 4081 : 		pItem->Kill( );

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [eax+388]
$L41486:

; 4083 : 	return FALSE;

	xor	eax, eax
$L41473:

; 4084 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBasePlayer::AddPlayerItem
_TEXT	ENDS
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
PUBLIC	?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::RemovePlayerItem
;	COMDAT ??_C@_04BAK@NULL?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
CONST	ENDS
;	COMDAT ?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pItem$ = 8
_this$ = -4
_pPrev$ = -8
?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBasePlayer::RemovePlayerItem, COMDAT

; 4089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4090 : 	if (m_pActiveItem == pItem)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	cmp	ecx, DWORD PTR _pItem$[ebp]
	jne	SHORT $L41491

; 4092 : 		ResetAutoaim( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetAutoaim@CBasePlayer@@QAEXXZ	; CBasePlayer::ResetAutoaim

; 4093 : 		pItem->Holster( );

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [eax+368]

; 4094 : 		pItem->pev->nextthink = 0;// crowbar may be trying to swing again, etc.

	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+260], 0

; 4095 : 		pItem->SetThink( NULL );

	push	OFFSET FLAT:??_C@_04BAK@NULL?$AA@	; `string'
	push	0
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 4096 : 		m_pActiveItem = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2980], 0

; 4097 : 		pev->viewmodel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+188], 0

; 4098 : 		pev->weaponmodel = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+192], 0

; 4100 : 	else if ( m_pLastItem == pItem )

	jmp	SHORT $L41496
$L41491:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2988]
	cmp	eax, DWORD PTR _pItem$[ebp]
	jne	SHORT $L41496

; 4101 : 		m_pLastItem = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2988], 0
$L41496:

; 4102 : 
; 4103 : 	CBasePlayerItem *pPrev = m_rgpPlayerItems[pItem->iItemSlot()];

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [eax+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2956]
	mov	DWORD PTR _pPrev$[ebp], edx

; 4104 : 
; 4105 : 	if (pPrev == pItem)

	mov	eax, DWORD PTR _pPrev$[ebp]
	cmp	eax, DWORD PTR _pItem$[ebp]
	jne	SHORT $L41498

; 4107 : 		m_rgpPlayerItems[pItem->iItemSlot()] = pItem->m_pNext;

	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pItem$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [edx+1820]
	mov	DWORD PTR [ecx+eax*4+2956], edx

; 4108 : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L41490
$L41498:

; 4112 : 		while (pPrev && pPrev->m_pNext != pItem)

	cmp	DWORD PTR _pPrev$[ebp], 0
	je	SHORT $L41502
	mov	eax, DWORD PTR _pPrev$[ebp]
	mov	ecx, DWORD PTR [eax+1820]
	cmp	ecx, DWORD PTR _pItem$[ebp]
	je	SHORT $L41502

; 4114 : 			pPrev = pPrev->m_pNext;

	mov	edx, DWORD PTR _pPrev$[ebp]
	mov	eax, DWORD PTR [edx+1820]
	mov	DWORD PTR _pPrev$[ebp], eax

; 4115 : 		}

	jmp	SHORT $L41498
$L41502:

; 4116 : 		if (pPrev)

	cmp	DWORD PTR _pPrev$[ebp], 0
	je	SHORT $L41503

; 4118 : 			pPrev->m_pNext = pItem->m_pNext;

	mov	ecx, DWORD PTR _pPrev$[ebp]
	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx+1820]
	mov	DWORD PTR [ecx+1820], eax

; 4119 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L41490
$L41503:

; 4122 : 	return FALSE;

	xor	eax, eax
$L41490:

; 4123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBasePlayer::RemovePlayerItem
_TEXT	ENDS
PUBLIC	?GiveAmmo@CBasePlayer@@UAEHHPADH@Z		; CBasePlayer::GiveAmmo
PUBLIC	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z		; CBasePlayer::GetAmmoIndex
;	COMDAT ?GiveAmmo@CBasePlayer@@UAEHHPADH@Z
_TEXT	SEGMENT
_iCount$ = 8
_szName$ = 12
_iMax$ = 16
_this$ = -4
_i$ = -8
_iAdd$ = -12
?GiveAmmo@CBasePlayer@@UAEHHPADH@Z PROC NEAR		; CBasePlayer::GiveAmmo, COMDAT

; 4130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4131 : 	if ( !szName )

	cmp	DWORD PTR _szName$[ebp], 0
	jne	SHORT $L41510

; 4133 : 		// no ammo.
; 4134 : 		return -1;

	or	eax, -1
	jmp	$L41509
$L41510:

; 4136 : 
; 4137 : 	if ( !g_pGameRules->CanHaveAmmo( this, szName, iMax ) )

	mov	eax, DWORD PTR _iMax$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+160]
	test	eax, eax
	jne	SHORT $L41511

; 4139 : 		// game rules say I can't have any more of this ammo type.
; 4140 : 		return -1;

	or	eax, -1
	jmp	$L41509
$L41511:

; 4142 : 
; 4143 : 	int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 4144 : 
; 4145 : 	i = GetAmmoIndex( szName );

	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z	; CBasePlayer::GetAmmoIndex
	add	esp, 4
	mov	DWORD PTR _i$[ebp], eax

; 4146 : 
; 4147 : 	if ( i < 0 || i >= MAX_AMMO_SLOTS )

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41514
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jl	SHORT $L41513
$L41514:

; 4148 : 		return -1;

	or	eax, -1
	jmp	$L41509
$L41513:

; 4149 : 
; 4150 : 	int iAdd = Q_min( iCount, iMax - m_rgAmmo[i] );

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _iMax$[ebp]
	sub	eax, DWORD PTR [edx+ecx*4+3508]
	cmp	DWORD PTR _iCount$[ebp], eax
	jge	SHORT $L44161
	mov	ecx, DWORD PTR _iCount$[ebp]
	mov	DWORD PTR -16+[ebp], ecx
	jmp	SHORT $L44162
$L44161:
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iMax$[ebp]
	sub	ecx, DWORD PTR [eax+edx*4+3508]
	mov	DWORD PTR -16+[ebp], ecx
$L44162:
	mov	edx, DWORD PTR -16+[ebp]
	mov	DWORD PTR _iAdd$[ebp], edx

; 4151 : 	if ( iAdd < 1 )

	cmp	DWORD PTR _iAdd$[ebp], 1
	jge	SHORT $L41516

; 4152 : 		return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L41509
$L41516:

; 4153 : 
; 4154 : 	m_rgAmmo[ i ] += iAdd;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+3508]
	add	edx, DWORD PTR _iAdd$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+3508], edx

; 4155 : 
; 4156 : 
; 4157 : 	if ( gmsgAmmoPickup )  // make sure the ammo messages have been linked first

	cmp	DWORD PTR ?gmsgAmmoPickup@@3HA, 0	; gmsgAmmoPickup
	je	SHORT $L41517

; 4159 : 		// Send the message that ammo has been picked up
; 4160 : 		MESSAGE_BEGIN( MSG_ONE, gmsgAmmoPickup, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgAmmoPickup@@3HA	; gmsgAmmoPickup
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4161 : 			WRITE_BYTE( GetAmmoIndex(szName) );		// ammo ID

	mov	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z	; CBasePlayer::GetAmmoIndex
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4162 : 			WRITE_BYTE( iAdd );		// amount

	mov	eax, DWORD PTR _iAdd$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4163 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41517:

; 4165 : 
; 4166 : 	return i;

	mov	eax, DWORD PTR _i$[ebp]
$L41509:

; 4167 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBasePlayer@@UAEHHPADH@Z ENDP			; CBasePlayer::GiveAmmo
_TEXT	ENDS
;	COMDAT ?ItemPreFrame@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ItemPreFrame@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::ItemPreFrame, COMDAT

; 4178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4179 : 	if ( gpGlobals->time < m_flNextAttack )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+2308]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41521

; 4181 : 		return;

	jmp	SHORT $L41520
$L41521:

; 4183 : 
; 4184 : 	if (!m_pActiveItem)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2980], 0
	jne	SHORT $L41522

; 4185 : 		return;

	jmp	SHORT $L41520
$L41522:

; 4186 : 
; 4187 : 	m_pActiveItem->ItemPreFrame( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+376]
$L41520:

; 4188 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ItemPreFrame@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::ItemPreFrame
_TEXT	ENDS
;	COMDAT ?ItemPostFrame@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ItemPostFrame@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::ItemPostFrame, COMDAT

; 4199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4200 : 	static int fInSelect = FALSE;
; 4201 : 
; 4202 : 	// check if the player is using a tank
; 4203 : 	if ( m_pTank != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2864				; 00000b30H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L41528

; 4204 : 		return;

	jmp	SHORT $L41525
$L41528:

; 4205 : 
; 4206 : 	ImpulseCommands();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+636]

; 4207 : 
; 4208 : 	if ( gpGlobals->time < m_flNextAttack )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx+2308]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41529

; 4209 : 		return;

	jmp	SHORT $L41525
$L41529:

; 4210 : 
; 4211 : 	if( FBitSet( m_iHideHUD, HIDEHUD_WEAPONS ))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2928]
	and	eax, 1
	test	eax, eax
	je	SHORT $L41530

; 4212 : 		return;

	jmp	SHORT $L41525
$L41530:

; 4213 : 
; 4214 : 	if (!m_pActiveItem)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2980], 0
	jne	SHORT $L41531

; 4215 : 		return;

	jmp	SHORT $L41525
$L41531:

; 4216 : 
; 4217 : 	m_pActiveItem->ItemPostFrame( );

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2980]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2980]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+380]
$L41525:

; 4218 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ItemPostFrame@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::ItemPostFrame
_TEXT	ENDS
PUBLIC	?AmmoInventory@CBasePlayer@@QAEHH@Z		; CBasePlayer::AmmoInventory
;	COMDAT ?AmmoInventory@CBasePlayer@@QAEHH@Z
_TEXT	SEGMENT
_iAmmoIndex$ = 8
_this$ = -4
?AmmoInventory@CBasePlayer@@QAEHH@Z PROC NEAR		; CBasePlayer::AmmoInventory, COMDAT

; 4221 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4222 : 	if (iAmmoIndex == -1)

	cmp	DWORD PTR _iAmmoIndex$[ebp], -1
	jne	SHORT $L41536

; 4224 : 		return -1;

	or	eax, -1
	jmp	SHORT $L41535
$L41536:

; 4226 : 
; 4227 : 	return m_rgAmmo[ iAmmoIndex ];

	mov	eax, DWORD PTR _iAmmoIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+3508]
$L41535:

; 4228 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AmmoInventory@CBasePlayer@@QAEHH@Z ENDP		; CBasePlayer::AmmoInventory
_TEXT	ENDS
EXTRN	_stricmp:NEAR
;	COMDAT ?GetAmmoIndex@CBasePlayer@@SAHPBD@Z
_TEXT	SEGMENT
_psz$ = 8
_i$ = -4
?GetAmmoIndex@CBasePlayer@@SAHPBD@Z PROC NEAR		; CBasePlayer::GetAmmoIndex, COMDAT

; 4231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 4232 : 	int i;
; 4233 : 
; 4234 : 	if (!psz)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $L41541

; 4235 : 		return -1;

	or	eax, -1
	jmp	SHORT $L41539
$L41541:

; 4236 : 
; 4237 : 	for (i = 1; i < MAX_AMMO_SLOTS; i++)

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L41542
$L41543:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41542:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	SHORT $L41544

; 4239 : 		if ( !CBasePlayerItem::AmmoInfoArray[i].pszName )

	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR ?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A[ecx*8], 0
	jne	SHORT $L41545

; 4240 : 			continue;

	jmp	SHORT $L41543
$L41545:

; 4241 : 
; 4242 : 		if (stricmp( psz, CBasePlayerItem::AmmoInfoArray[i].pszName ) == 0)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR ?AmmoInfoArray@CBasePlayerItem@@2PAUAmmoInfo@@A[edx*8]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L41546

; 4243 : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L41539
$L41546:

; 4244 : 	}

	jmp	SHORT $L41543
$L41544:

; 4245 : 
; 4246 : 	return -1;

	or	eax, -1
$L41539:

; 4247 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAmmoIndex@CBasePlayer@@SAHPBD@Z ENDP		; CBasePlayer::GetAmmoIndex
_TEXT	ENDS
PUBLIC	?__LINE__Var@?1??SendAmmoUpdate@CBasePlayer@@QAEXXZ@4FA ; `CBasePlayer::SendAmmoUpdate'::`2'::__LINE__Var
PUBLIC	??_C@_0BB@LINJ@m_rgAmmo?$FLi?$FN?5?$DO?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_0BD@MENA@m_rgAmmo?$FLi?$FN?5?$DM?51000?$AA@ ; `string'
PUBLIC	?SendAmmoUpdate@CBasePlayer@@QAEXXZ		; CBasePlayer::SendAmmoUpdate
;	COMDAT ?__LINE__Var@?1??SendAmmoUpdate@CBasePlayer@@QAEXXZ@4FA
; File z:\xashxtsrc\server\player.cpp
_DATA	SEGMENT
?__LINE__Var@?1??SendAmmoUpdate@CBasePlayer@@QAEXXZ@4FA DW 0109cH ; `CBasePlayer::SendAmmoUpdate'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BB@LINJ@m_rgAmmo?$FLi?$FN?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BB@LINJ@m_rgAmmo?$FLi?$FN?5?$DO?$DN?50?$AA@ DB 'm_rgAmmo[i] >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MENA@m_rgAmmo?$FLi?$FN?5?$DM?51000?$AA@
CONST	SEGMENT
??_C@_0BD@MENA@m_rgAmmo?$FLi?$FN?5?$DM?51000?$AA@ DB 'm_rgAmmo[i] < 1000', 00H ; `string'
CONST	ENDS
;	COMDAT ?SendAmmoUpdate@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?SendAmmoUpdate@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::SendAmmoUpdate, COMDAT

; 4252 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4253 : 	for (int i=0; i < MAX_AMMO_SLOTS;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41552
$L41553:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41552:
	cmp	DWORD PTR _i$[ebp], 32			; 00000020H
	jge	$L41554

; 4255 : 		if (m_rgAmmo[i] != m_rgAmmoLast[i])

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+3508]
	cmp	ecx, DWORD PTR [esi+eax*4+3636]
	je	$L41555

; 4257 : 			m_rgAmmoLast[i] = m_rgAmmo[i];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+3508]
	mov	DWORD PTR [eax+edx*4+3636], ecx

; 4258 : 
; 4259 : 			ASSERT( m_rgAmmo[i] >= 0 );

	push	0
	movsx	edx, WORD PTR ?__LINE__Var@?1??SendAmmoUpdate@CBasePlayer@@QAEXXZ@4FA ; `CBasePlayer::SendAmmoUpdate'::`2'::__LINE__Var
	add	edx, 7
	push	edx
	push	OFFSET FLAT:??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BB@LINJ@m_rgAmmo?$FLi?$FN?5?$DO?$DN?50?$AA@ ; `string'
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	DWORD PTR [ecx+eax*4+3508], 0
	setge	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 4260 : 			//ASSERT( m_rgAmmo[i] < 255 );
; 4261 : 			ASSERT( m_rgAmmo[i] < 1000 );

	push	0
	movsx	eax, WORD PTR ?__LINE__Var@?1??SendAmmoUpdate@CBasePlayer@@QAEXXZ@4FA ; `CBasePlayer::SendAmmoUpdate'::`2'::__LINE__Var
	add	eax, 9
	push	eax
	push	OFFSET FLAT:??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@MENA@m_rgAmmo?$FLi?$FN?5?$DM?51000?$AA@ ; `string'
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+ecx*4+3508], 1000	; 000003e8H
	setl	al
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 4262 : 
; 4263 : 			// send "Ammo" update message
; 4264 : 			MESSAGE_BEGIN( MSG_ONE, gmsgAmmoX, NULL, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgAmmoX@@3HA		; gmsgAmmoX
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4265 : 				/*WRITE_BYTE( i );
; 4266 : 				WRITE_BYTE( Q_max( Q_min( m_rgAmmo[i], 254 ), 0 ) );  // clamp the value to one byte*/
; 4267 : 				WRITE_SHORT( i );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 4268 : 				WRITE_SHORT( Q_max( Q_min( m_rgAmmo[i], 999 ), 0 ) );

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+3508], 999		; 000003e7H
	jge	SHORT $L44173
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+3508]
	mov	DWORD PTR -12+[ebp], eax
	jmp	SHORT $L44174
$L44173:
	mov	DWORD PTR -12+[ebp], 999		; 000003e7H
$L44174:
	cmp	DWORD PTR -12+[ebp], 0
	jle	SHORT $L44177
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+3508], 999		; 000003e7H
	jge	SHORT $L44175
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+3508]
	mov	DWORD PTR -16+[ebp], edx
	jmp	SHORT $L44176
$L44175:
	mov	DWORD PTR -16+[ebp], 999		; 000003e7H
$L44176:
	mov	eax, DWORD PTR -16+[ebp]
	mov	DWORD PTR -20+[ebp], eax
	jmp	SHORT $L44178
$L44177:
	mov	DWORD PTR -20+[ebp], 0
$L44178:
	mov	ecx, DWORD PTR -20+[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 4269 : 			MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41555:

; 4271 : 	}

	jmp	$L41553
$L41554:

; 4272 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SendAmmoUpdate@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::SendAmmoUpdate
_TEXT	ENDS
PUBLIC	??_C@_0BA@CAEF@game_playerjoin?$AA@		; `string'
PUBLIC	??_C@_0BB@DOHN@game_playerspawn?$AA@		; `string'
PUBLIC	?WRITE_BYTES@@YAXPBEH@Z				; WRITE_BYTES
PUBLIC	?__LINE__Var@?1??UpdateClientData@CBasePlayer@@UAEXXZ@4FA ; `CBasePlayer::UpdateClientData'::`2'::__LINE__Var
PUBLIC	??_C@_0BA@JCJ@gmsgBattery?5?$DO?50?$AA@		; `string'
PUBLIC	?UpdateClientData@CBasePlayer@@UAEXXZ		; CBasePlayer::UpdateClientData
PUBLIC	??_C@_0CK@DEAA@Rain?5fading?3?5curdrips?3?5?$CFi?0?5ideal@ ; `string'
PUBLIC	??_C@_0CC@NEFF@Rain?5fading?5finished?5at?5?$CFi?5drips@ ; `string'
PUBLIC	??_C@_08OHDJ@env_rain?$AA@			; `string'
PUBLIC	??_C@_0P@JDGE@env_rainmodify?$AA@		; `string'
PUBLIC	??_C@_0BP@PHGK@Sending?5enabling?5rain?5message?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@HLGI@Sending?5disabling?5rain?5message?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@CKKA@Clearing?5rain?5data?6?$AA@	; `string'
PUBLIC	??_C@_0O@DJKJ@gmsgTrain?5?$DO?50?$AA@		; `string'
PUBLIC	??_C@_05EEDH@Empty?$AA@				; `string'
PUBLIC	?SendStartMessages@CBasePlayer@@QAEXXZ		; CBasePlayer::SendStartMessages
EXTRN	?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A:BYTE ; CBasePlayerItem::ItemInfoArray
EXTRN	_memcpy:NEAR
EXTRN	_memcmp:NEAR
EXTRN	?gDisplayTitle@@3HA:DWORD			; gDisplayTitle
;	COMDAT ?__LINE__Var@?1??UpdateClientData@CBasePlayer@@UAEXXZ@4FA
; File z:\xashxtsrc\server\player.cpp
_DATA	SEGMENT
?__LINE__Var@?1??UpdateClientData@CBasePlayer@@UAEXXZ@4FA DW 010beH ; `CBasePlayer::UpdateClientData'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@CAEF@game_playerjoin?$AA@
CONST	SEGMENT
??_C@_0BA@CAEF@game_playerjoin?$AA@ DB 'game_playerjoin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOHN@game_playerspawn?$AA@
CONST	SEGMENT
??_C@_0BB@DOHN@game_playerspawn?$AA@ DB 'game_playerspawn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCJ@gmsgBattery?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0BA@JCJ@gmsgBattery?5?$DO?50?$AA@ DB 'gmsgBattery > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DEAA@Rain?5fading?3?5curdrips?3?5?$CFi?0?5ideal@
CONST	SEGMENT
??_C@_0CK@DEAA@Rain?5fading?3?5curdrips?3?5?$CFi?0?5ideal@ DB 'Rain fadin'
	DB	'g: curdrips: %i, idealdrips %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NEFF@Rain?5fading?5finished?5at?5?$CFi?5drips@
CONST	SEGMENT
??_C@_0CC@NEFF@Rain?5fading?5finished?5at?5?$CFi?5drips@ DB 'Rain fading '
	DB	'finished at %i drips', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OHDJ@env_rain?$AA@
CONST	SEGMENT
??_C@_08OHDJ@env_rain?$AA@ DB 'env_rain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JDGE@env_rainmodify?$AA@
CONST	SEGMENT
??_C@_0P@JDGE@env_rainmodify?$AA@ DB 'env_rainmodify', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PHGK@Sending?5enabling?5rain?5message?6?$AA@
CONST	SEGMENT
??_C@_0BP@PHGK@Sending?5enabling?5rain?5message?6?$AA@ DB 'Sending enabli'
	DB	'ng rain message', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HLGI@Sending?5disabling?5rain?5message?6?$AA@
CONST	SEGMENT
??_C@_0CA@HLGI@Sending?5disabling?5rain?5message?6?$AA@ DB 'Sending disab'
	DB	'ling rain message', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CKKA@Clearing?5rain?5data?6?$AA@
CONST	SEGMENT
??_C@_0BE@CKKA@Clearing?5rain?5data?6?$AA@ DB 'Clearing rain data', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJKJ@gmsgTrain?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0O@DJKJ@gmsgTrain?5?$DO?50?$AA@ DB 'gmsgTrain > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EEDH@Empty?$AA@
CONST	SEGMENT
??_C@_05EEDH@Empty?$AA@ DB 'Empty', 00H			; `string'
CONST	ENDS
;	COMDAT ?UpdateClientData@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
$T44183 = -84
_this$ = -4
_iHealth$41575 = -8
_damageOrigin$41582 = -20
_other$41583 = -24
_pEntity$41585 = -28
_visibleDamageBits$41588 = -32
_secondsLeft$41599 = -36
_pFind$41608 = -40
_pEnt$41611 = -44
_raindistance$41612 = -48
_rainheight$41613 = -52
_rainmode$41614 = -56
_i$41629 = -60
_II$41633 = -64
_pszName$41635 = -68
_i$ = -72
?UpdateClientData@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::UpdateClientData, COMDAT

; 4286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4287 : 	if (m_fInitHUD)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2848], 0
	je	$L41563

; 4289 : 		m_fInitHUD = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2848], 0

; 4290 : 		gInitHUD = FALSE;

	mov	DWORD PTR ?gInitHUD@@3HA, 0		; gInitHUD

; 4291 : 
; 4292 : 		MESSAGE_BEGIN( MSG_ONE, gmsgResetHUD, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgResetHUD@@3HA	; gmsgResetHUD
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4293 : 			WRITE_BYTE( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4294 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4295 : 
; 4296 : 		if ( !m_fGameHUDInitialized )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2852], 0
	jne	$L41564

; 4298 : 			MESSAGE_BEGIN( MSG_ONE, gmsgInitHUD, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgInitHUD@@3HA	; gmsgInitHUD
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4299 : 			MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4300 : 
; 4301 : 			g_pGameRules->InitHUD( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+48]

; 4302 : 			m_fGameHUDInitialized = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2852], 1

; 4303 : 			if ( g_pGameRules->IsMultiplayer() )

	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L41565

; 4305 : 				UTIL_FireTargets( "game_playerjoin", this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BA@CAEF@game_playerjoin?$AA@ ; `string'
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L41565:

; 4307 : 
; 4308 : 			CheckCompatibility();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckCompatibility@CBasePlayer@@QAEXXZ	; CBasePlayer::CheckCompatibility

; 4309 : 			m_iStartMessage = 1; //send player init messages

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4136], 1
$L41564:

; 4311 : 
; 4312 : 		UTIL_FireTargets( "game_playerspawn", this, this, USE_TOGGLE, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BB@DOHN@game_playerspawn?$AA@ ; `string'
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 4313 : 
; 4314 : 		InitStatusBar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?InitStatusBar@CBasePlayer@@QAEXXZ	; CBasePlayer::InitStatusBar
$L41563:

; 4316 : 
; 4317 : 	if ( m_iHideHUD != m_iClientHideHUD )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+2928]
	cmp	ecx, DWORD PTR [eax+2932]
	je	SHORT $L41568

; 4319 : 		MESSAGE_BEGIN( MSG_ONE, gmsgHideWeapon, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgHideWeapon@@3HA	; gmsgHideWeapon
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4320 : 			WRITE_BYTE( m_iHideHUD );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2928]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4321 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4322 : 
; 4323 : 		m_iClientHideHUD = m_iHideHUD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2928]
	mov	DWORD PTR [ecx+2932], eax
$L41568:

; 4325 : 
; 4326 : 	if ( memcmp( m_iWeapons, m_iClientWeapons, MAX_WEAPON_BYTES ))

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2944				; 00000b80H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2348				; 0000092cH
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L41569

; 4328 : 		MESSAGE_BEGIN( MSG_ONE, gmsgWeapons, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgWeapons@@3HA	; gmsgWeapons
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4329 : 			WRITE_BYTES( m_iWeapons, MAX_WEAPON_BYTES );

	push	8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2348				; 0000092cH
	push	eax
	call	?WRITE_BYTES@@YAXPBEH@Z			; WRITE_BYTES
	add	esp, 8

; 4330 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4331 : 
; 4332 : 		memcpy( m_iClientWeapons, m_iWeapons, MAX_WEAPON_BYTES );

	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2348				; 0000092cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2944				; 00000b80H
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$L41569:

; 4334 : 
; 4335 : 	if ( m_iFOV != m_iClientFOV )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+2936]
	cmp	edx, DWORD PTR [ecx+2940]
	je	SHORT $L41570

; 4337 : 		MESSAGE_BEGIN( MSG_ONE, gmsgSetFOV, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgSetFOV@@3HA		; gmsgSetFOV
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4338 : 			WRITE_BYTE( m_iFOV );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2936]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4339 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41570:

; 4343 : 
; 4344 :           if( m_iSndRoomtype != m_iClientSndRoomtype )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4140]
	cmp	ecx, DWORD PTR [eax+2952]
	je	SHORT $L41571

; 4346 : 		//update dsp sound
; 4347 :           	MESSAGE_BEGIN( MSG_ONE, SVC_ROOMTYPE, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	push	37					; 00000025H
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4348 : 			WRITE_SHORT( m_iSndRoomtype );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4140]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 4349 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4350 :           	m_iClientSndRoomtype = m_iSndRoomtype;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4140]
	mov	DWORD PTR [eax+2952], edx
$L41571:

; 4352 : 
; 4353 : 	// HACKHACK -- send the message to display the game title
; 4354 : 	if (gDisplayTitle)

	cmp	DWORD PTR ?gDisplayTitle@@3HA, 0	; gDisplayTitle
	je	SHORT $L41572

; 4356 : 		MESSAGE_BEGIN( MSG_ONE, gmsgShowGameTitle, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgShowGameTitle@@3HA	; gmsgShowGameTitle
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4357 : 		WRITE_BYTE( 0 );

	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4358 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4359 : 		gDisplayTitle = 0;

	mov	DWORD PTR ?gDisplayTitle@@3HA, 0	; gDisplayTitle
$L41572:

; 4361 : 
; 4362 : 	if (m_iStartMessage != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4136], 0
	je	SHORT $L41573

; 4364 : 		SendStartMessages();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendStartMessages@CBasePlayer@@QAEXXZ	; CBasePlayer::SendStartMessages

; 4365 : 		m_iStartMessage = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4136], 0
$L41573:

; 4367 : 
; 4368 : 	if (pev->health != m_iClientHealth)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+2920]
	fcomp	DWORD PTR [eax+352]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L41574

; 4370 : 		int iHealth = Q_max( pev->health, 0 );  // make sure that no negative health values are sent

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L44181
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fstp	DWORD PTR -88+[ebp]
	jmp	SHORT $L44182
$L44181:
	mov	DWORD PTR -88+[ebp], 0
$L44182:
	fld	DWORD PTR -88+[ebp]
	call	__ftol
	mov	DWORD PTR _iHealth$41575[ebp], eax

; 4371 : 
; 4372 : 		// send "health" update message
; 4373 : 		MESSAGE_BEGIN( MSG_ONE, gmsgHealth, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgHealth@@3HA		; gmsgHealth
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4374 : 			WRITE_BYTE( iHealth );

	mov	eax, DWORD PTR _iHealth$41575[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4375 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4376 : 
; 4377 : 		m_iClientHealth = pev->health;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2920], eax
$L41574:

; 4379 : 
; 4380 : 	if (pev->armorvalue != m_iClientBattery)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+2924]
	fcomp	DWORD PTR [eax+444]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L41576

; 4382 : 		m_iClientBattery = pev->armorvalue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+444]
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2924], eax

; 4383 : 
; 4384 : 		ASSERT( gmsgBattery > 0 );

	push	0
	movsx	edx, WORD PTR ?__LINE__Var@?1??UpdateClientData@CBasePlayer@@UAEXXZ@4FA ; `CBasePlayer::UpdateClientData'::`2'::__LINE__Var
	add	edx, 98					; 00000062H
	push	edx
	push	OFFSET FLAT:??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@JCJ@gmsgBattery?5?$DO?50?$AA@ ; `string'
	xor	eax, eax
	cmp	DWORD PTR ?gmsgBattery@@3HA, 0		; gmsgBattery
	setg	al
	push	eax
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 4385 : 		// send "health" update message
; 4386 : 		MESSAGE_BEGIN( MSG_ONE, gmsgBattery, NULL, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgBattery@@3HA	; gmsgBattery
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4387 : 			WRITE_SHORT( (int)pev->armorvalue);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+444]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 4388 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41576:

; 4390 : 
; 4391 : 	if (pev->dmg_take || pev->dmg_save || m_bitsHUDDamage != m_bitsDamageType)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+472]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41581
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+476]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41581
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+2844]
	cmp	eax, DWORD PTR [edx+2312]
	je	$L41580
$L41581:

; 4393 : 		// Comes from inside me if not set
; 4394 : 		Vector damageOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _damageOrigin$41582[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 4395 : 		// send "damage" message
; 4396 : 		// causes screen to flash, and pain compass to show direction of damage
; 4397 : 		edict_t *other = pev->dmg_inflictor;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+396]
	mov	DWORD PTR _other$41583[ebp], eax

; 4398 : 		if ( other )

	cmp	DWORD PTR _other$41583[ebp], 0
	je	SHORT $L41586

; 4400 : 			CBaseEntity *pEntity = CBaseEntity::Instance(other);

	mov	ecx, DWORD PTR _other$41583[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$41585[ebp], eax

; 4401 : 			if ( pEntity )

	cmp	DWORD PTR _pEntity$41585[ebp], 0
	je	SHORT $L41586

; 4402 : 				damageOrigin = pEntity->Center();

	lea	edx, DWORD PTR $T44183[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$41585[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$41585[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _damageOrigin$41582[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _damageOrigin$41582[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _damageOrigin$41582[ebp+8], eax
$L41586:

; 4404 : 
; 4405 : 		// only send down damage type that have hud art
; 4406 : 		int visibleDamageBits = m_bitsDamageType & DMG_SHOWNHUD;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2312]
	and	edx, 16204056				; 00f74118H
	mov	DWORD PTR _visibleDamageBits$41588[ebp], edx

; 4407 : 
; 4408 : 		MESSAGE_BEGIN( MSG_ONE, gmsgDamage, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgDamage@@3HA		; gmsgDamage
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4409 : 			WRITE_BYTE( pev->dmg_save );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+476]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4410 : 			WRITE_BYTE( pev->dmg_take );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+472]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4411 : 			WRITE_LONG( visibleDamageBits );

	mov	ecx, DWORD PTR _visibleDamageBits$41588[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+204
	add	esp, 4

; 4412 : 			WRITE_COORD( damageOrigin.x );

	mov	edx, DWORD PTR _damageOrigin$41582[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4413 : 			WRITE_COORD( damageOrigin.y );

	mov	eax, DWORD PTR _damageOrigin$41582[ebp+4]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4414 : 			WRITE_COORD( damageOrigin.z );

	mov	ecx, DWORD PTR _damageOrigin$41582[ebp+8]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4415 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4416 : 
; 4417 : 		pev->dmg_take = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+472], 0

; 4418 : 		pev->dmg_save = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+476], 0

; 4419 : 		m_bitsHUDDamage = m_bitsDamageType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2312]
	mov	DWORD PTR [eax+2844], edx

; 4420 : 
; 4421 : 		// Clear off non-time-based damage indicators
; 4422 : 		m_bitsDamageType &= DMG_TIMEBASED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2312]
	and	ecx, 16760832				; 00ffc000H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2312], ecx
$L41580:

; 4424 : 
; 4425 : 	// Update Flashlight
; 4426 : 	if ((m_flFlashLightTime) && (m_flFlashLightTime <= gpGlobals->time))

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+2424]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L41589
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+2424]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L41589

; 4428 : 		if (FlashlightIsOn())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlashlightIsOn@CBasePlayer@@QAEHXZ	; CBasePlayer::FlashlightIsOn
	test	eax, eax
	je	SHORT $L41590

; 4430 : 			if (m_iFlashBattery)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2428], 0
	je	SHORT $L41592

; 4432 : 				m_flFlashLightTime = FLASH_DRAIN_TIME + gpGlobals->time;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	QWORD PTR __real@8@3fff9999999999999800
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+2424]

; 4433 : 				m_iFlashBattery--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2428]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2428], ecx

; 4434 : 
; 4435 : 				if (!m_iFlashBattery)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2428], 0
	jne	SHORT $L41592

; 4436 : 					FlashlightTurnOff();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FlashlightTurnOff@CBasePlayer@@QAEXXZ	; CBasePlayer::FlashlightTurnOff
$L41592:

; 4439 : 		else

	jmp	SHORT $L41595
$L41590:

; 4441 : 			if (m_iFlashBattery < 100)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2428], 100		; 00000064H
	jge	SHORT $L41594

; 4443 : 				m_flFlashLightTime = FLASH_CHARGE_TIME + gpGlobals->time;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffcccccccccccccd000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+2424]

; 4444 : 				m_iFlashBattery++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2428]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2428], edx

; 4446 : 			else

	jmp	SHORT $L41595
$L41594:

; 4447 : 				m_flFlashLightTime = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2424], 0
$L41595:

; 4449 : 
; 4450 : 		MESSAGE_BEGIN( MSG_ONE, gmsgFlashBattery, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgFlashBattery@@3HA	; gmsgFlashBattery
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4451 : 		WRITE_BYTE(m_iFlashBattery);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2428]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4452 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L41589:

; 4454 : 
; 4455 : 	// calculate and update rain fading
; 4456 : 	if( m_flRainEndFade > 0.0f )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4212]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L41605

; 4458 : 		if( gpGlobals->time < m_flRainEndFade )

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fcomp	DWORD PTR [eax+4212]
	fnstsw	ax
	test	ah, 1
	je	$L41597

; 4460 : 			// we're in fading process
; 4461 : 			if( m_flRainNextFadeUpdate <= gpGlobals->time )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx+4216]
	fcomp	DWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L41598

; 4463 : 				int secondsLeft = m_flRainEndFade - gpGlobals->time + 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+4212]
	fsub	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	call	__ftol
	mov	DWORD PTR _secondsLeft$41599[ebp], eax

; 4464 : 
; 4465 : 				m_iRainDripsPerSecond += (m_iRainIdealDripsPerSecond - m_iRainDripsPerSecond) / secondsLeft;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4192]
	sub	ecx, DWORD PTR [eax+4172]
	mov	eax, ecx
	cdq
	idiv	DWORD PTR _secondsLeft$41599[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4172]
	add	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4172], ecx

; 4466 : 				m_flRainWindX += (m_flRainIdealWindX - m_flRainWindX) / (float)secondsLeft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4196]
	fsub	DWORD PTR [ecx+4176]
	fidiv	DWORD PTR _secondsLeft$41599[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+4176]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4176]

; 4467 : 				m_flRainWindY += (m_flRainIdealWindY - m_flRainWindY) / (float)secondsLeft;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4200]
	fsub	DWORD PTR [edx+4180]
	fidiv	DWORD PTR _secondsLeft$41599[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+4180]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+4180]

; 4468 : 				m_flRainRandX += (m_flRainIdealRandX - m_flRainRandX) / (float)secondsLeft;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4204]
	fsub	DWORD PTR [eax+4184]
	fidiv	DWORD PTR _secondsLeft$41599[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+4184]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4184]

; 4469 : 				m_flRainRandY += (m_flRainIdealRandY - m_flRainRandY) / (float)secondsLeft;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4208]
	fsub	DWORD PTR [ecx+4188]
	fidiv	DWORD PTR _secondsLeft$41599[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+4188]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4188]

; 4470 : 
; 4471 : 				m_flRainNextFadeUpdate = gpGlobals->time + 1; // update once per second

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4216]

; 4472 : 				m_bRainNeedsUpdate = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+4220], 1

; 4473 : 
; 4474 : 				ALERT( at_aiconsole, "Rain fading: curdrips: %i, idealdrips %i\n", m_iRainDripsPerSecond, m_iRainIdealDripsPerSecond );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4192]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4172]
	push	ecx
	push	OFFSET FLAT:??_C@_0CK@DEAA@Rain?5fading?3?5curdrips?3?5?$CFi?0?5ideal@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L41598:

; 4477 : 		else

	jmp	$L41605
$L41597:

; 4479 : 			// finish fading process
; 4480 : 			m_flRainNextFadeUpdate = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4216], 0

; 4481 : 			m_flRainEndFade = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4212], 0

; 4482 : 
; 4483 : 			m_iRainDripsPerSecond = m_iRainIdealDripsPerSecond;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4192]
	mov	DWORD PTR [ecx+4172], eax

; 4484 : 			m_flRainWindX = m_flRainIdealWindX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4196]
	mov	DWORD PTR [ecx+4176], eax

; 4485 : 			m_flRainWindY = m_flRainIdealWindY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4200]
	mov	DWORD PTR [ecx+4180], eax

; 4486 : 			m_flRainRandX = m_flRainIdealRandX;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4204]
	mov	DWORD PTR [ecx+4184], eax

; 4487 : 			m_flRainRandY = m_flRainIdealRandY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4208]
	mov	DWORD PTR [ecx+4188], eax

; 4488 : 			m_bRainNeedsUpdate = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4220], 1

; 4489 : 
; 4490 : 			ALERT( at_aiconsole, "Rain fading finished at %i drips\n", m_iRainDripsPerSecond );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4172]
	push	eax
	push	OFFSET FLAT:??_C@_0CC@NEFF@Rain?5fading?5finished?5at?5?$CFi?5drips@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L41605:

; 4493 : 
; 4494 : 	// send rain message
; 4495 : 	if( m_bRainNeedsUpdate )

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+4220]
	test	edx, edx
	je	$L41607

; 4497 : 		// search for env_rain entity
; 4498 : 		CBaseEntity *pFind;
; 4499 : 		pFind = UTIL_FindEntityByClassname( NULL, "env_rain" );

	push	OFFSET FLAT:??_C@_08OHDJ@env_rain?$AA@	; `string'
	push	0
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pFind$41608[ebp], eax

; 4500 : 		if( !FNullEnt( pFind ))

	mov	eax, DWORD PTR _pFind$41608[ebp]
	push	eax
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L41610

; 4502 : 			// rain allowed on this map
; 4503 : 			CBaseEntity *pEnt = CBaseEntity::Instance( pFind->edict() );

	mov	ecx, DWORD PTR _pFind$41608[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEnt$41611[ebp], eax

; 4504 : 
; 4505 : 			float raindistance = pEnt->pev->frags;

	mov	ecx, DWORD PTR _pEnt$41611[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+356]
	mov	DWORD PTR _raindistance$41612[ebp], eax

; 4506 : 			float rainheight = pEnt->pev->origin[2];

	mov	ecx, DWORD PTR _pEnt$41611[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 8
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _rainheight$41613[ebp], edx

; 4507 : 			int rainmode = pEnt->pev->impulse;

	mov	eax, DWORD PTR _pEnt$41611[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+388]
	mov	DWORD PTR _rainmode$41614[ebp], edx

; 4508 : 
; 4509 : 			// search for constant rain_modifies
; 4510 : 			pFind = UTIL_FindEntityByClassname( NULL, "env_rainmodify" );

	push	OFFSET FLAT:??_C@_0P@JDGE@env_rainmodify?$AA@ ; `string'
	push	0
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pFind$41608[ebp], eax
$L41617:

; 4511 : 			while( !FNullEnt( pFind ))

	mov	eax, DWORD PTR _pFind$41608[ebp]
	push	eax
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L41618

; 4513 : 				if( FBitSet( pFind->pev->spawnflags, 1 ))

	mov	ecx, DWORD PTR _pFind$41608[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $L41619

; 4515 : 					// copy settings to player's data and clear fading
; 4516 : 					m_iRainDripsPerSecond = pFind->pev->impulse;

	mov	ecx, DWORD PTR _pFind$41608[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+388]
	mov	DWORD PTR [eax+4172], ecx

; 4517 : 					m_flRainWindX = pFind->pev->fuser1;

	mov	edx, DWORD PTR _pFind$41608[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+596]
	mov	DWORD PTR [ecx+4176], edx

; 4518 : 					m_flRainWindY = pFind->pev->fuser2;

	mov	eax, DWORD PTR _pFind$41608[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+600]
	mov	DWORD PTR [edx+4180], eax

; 4519 : 					m_flRainRandX = pFind->pev->fuser3;

	mov	ecx, DWORD PTR _pFind$41608[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+604]
	mov	DWORD PTR [eax+4184], ecx

; 4520 : 					m_flRainRandY = pFind->pev->fuser4;

	mov	edx, DWORD PTR _pFind$41608[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+608]
	mov	DWORD PTR [ecx+4188], edx

; 4521 : 
; 4522 : 					m_flRainEndFade = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4212], 0

; 4523 : 					break;

	jmp	SHORT $L41618
$L41619:

; 4525 : 				pFind = UTIL_FindEntityByClassname( pFind, "env_rainmodify" );

	push	OFFSET FLAT:??_C@_0P@JDGE@env_rainmodify?$AA@ ; `string'
	mov	ecx, DWORD PTR _pFind$41608[ebp]
	push	ecx
	call	?UTIL_FindEntityByClassname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByClassname
	add	esp, 8
	mov	DWORD PTR _pFind$41608[ebp], eax

; 4526 : 			}

	jmp	$L41617
$L41618:

; 4527 : 
; 4528 : 			MESSAGE_BEGIN( MSG_ONE, gmsgRainData, NULL, pev );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgRainData@@3HA	; gmsgRainData
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4529 : 				WRITE_SHORT( m_iRainDripsPerSecond );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4172]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 4530 : 				WRITE_COORD( raindistance );

	mov	ecx, DWORD PTR _raindistance$41612[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4531 : 				WRITE_COORD( m_flRainWindX );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4176]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4532 : 				WRITE_COORD( m_flRainWindY );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4180]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4533 : 				WRITE_COORD( m_flRainRandX );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4184]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4534 : 				WRITE_COORD( m_flRainRandY );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4188]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4535 : 				WRITE_SHORT( rainmode );

	mov	ecx, DWORD PTR _rainmode$41614[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+200
	add	esp, 4

; 4536 : 				WRITE_COORD( rainheight );

	mov	edx, DWORD PTR _rainheight$41613[ebp]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+212
	add	esp, 4

; 4537 : 			MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4538 : 
; 4539 : 			if( m_iRainDripsPerSecond )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4172], 0
	je	SHORT $L41620

; 4540 : 				ALERT( at_aiconsole, "Sending enabling rain message\n" );

	push	OFFSET FLAT:??_C@_0BP@PHGK@Sending?5enabling?5rain?5message?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 4541 : 			else

	jmp	SHORT $L41622
$L41620:

; 4542 : 				ALERT( at_aiconsole, "Sending disabling rain message\n" );

	push	OFFSET FLAT:??_C@_0CA@HLGI@Sending?5disabling?5rain?5message?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L41622:

; 4544 : 		else

	jmp	$L41624
$L41610:

; 4546 : 			// no rain on this map
; 4547 : 			m_iRainDripsPerSecond = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4172], 0

; 4548 : 			m_flRainWindX = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4176], 0

; 4549 : 			m_flRainWindY = 0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4180], 0

; 4550 : 			m_flRainRandX = 0.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4184], 0

; 4551 : 			m_flRainRandY = 0.0f;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4188], 0

; 4552 : 			m_iRainIdealDripsPerSecond = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4192], 0

; 4553 : 			m_flRainIdealWindX = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4196], 0

; 4554 : 			m_flRainIdealWindY = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4200], 0

; 4555 : 			m_flRainIdealRandX = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4204], 0

; 4556 : 			m_flRainIdealRandY = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4208], 0

; 4557 : 			m_flRainEndFade = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4212], 0

; 4558 : 			m_flRainNextFadeUpdate = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4216], 0

; 4559 : 
; 4560 : 			ALERT( at_aiconsole, "Clearing rain data\n" );

	push	OFFSET FLAT:??_C@_0BE@CKKA@Clearing?5rain?5data?6?$AA@ ; `string'
	push	2
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L41624:

; 4562 : 		m_bRainNeedsUpdate = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4220], 0
$L41607:

; 4564 : 
; 4565 : 	if (m_iTrain & TRAIN_NEW)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2856]
	and	eax, 192				; 000000c0H
	test	eax, eax
	je	SHORT $L41626

; 4567 : 		ASSERT( gmsgTrain > 0 );

	push	0
	movsx	ecx, WORD PTR ?__LINE__Var@?1??UpdateClientData@CBasePlayer@@UAEXXZ@4FA ; `CBasePlayer::UpdateClientData'::`2'::__LINE__Var
	add	ecx, 281				; 00000119H
	push	ecx
	push	OFFSET FLAT:??_C@_0BP@LEMF@z?3?2xashxtsrc?2server?2player?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0O@DJKJ@gmsgTrain?5?$DO?50?$AA@ ; `string'
	xor	edx, edx
	cmp	DWORD PTR ?gmsgTrain@@3HA, 0		; gmsgTrain
	setg	dl
	push	edx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 4568 : 		// send "health" update message
; 4569 : 		MESSAGE_BEGIN( MSG_ONE, gmsgTrain, NULL, pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgTrain@@3HA		; gmsgTrain
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4570 : 			WRITE_BYTE(m_iTrain & 0xF);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2856]
	and	ecx, 15					; 0000000fH
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4571 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4572 : 
; 4573 : 		m_iTrain &= ~TRAIN_NEW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2856]
	and	al, 63					; 0000003fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2856], eax
$L41626:

; 4575 : 
; 4576 : 	//
; 4577 : 	// New Weapon?
; 4578 : 	//
; 4579 : 	if (!m_fKnownItem)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2480], 0
	jne	$L41632

; 4581 : 		m_fKnownItem = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2480], 1

; 4582 : 
; 4583 : 	// WeaponInit Message
; 4584 : 	// byte  = # of weapons
; 4585 : 	//
; 4586 : 	// for each weapon:
; 4587 : 	// byte		name str length (not including null)
; 4588 : 	// bytes... name
; 4589 : 	// byte		Ammo Type
; 4590 : 	// byte		Ammo2 Type
; 4591 : 	// byte		bucket
; 4592 : 	// byte		bucket pos
; 4593 : 	// byte		flags
; 4594 : 	// ????		Icons
; 4595 : 
; 4596 : 		// Send ALL the weapon info now
; 4597 : 		int i;
; 4598 : 
; 4599 : 		for (i = 0; i < MAX_WEAPONS; i++)

	mov	DWORD PTR _i$41629[ebp], 0
	jmp	SHORT $L41630
$L41631:
	mov	ecx, DWORD PTR _i$41629[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$41629[ebp], ecx
$L41630:
	cmp	DWORD PTR _i$41629[ebp], 64		; 00000040H
	jge	$L41632

; 4601 : 			ItemInfo& II = CBasePlayerItem::ItemInfoArray[i];

	mov	edx, DWORD PTR _i$41629[ebp]
	imul	edx, 44					; 0000002cH
	add	edx, OFFSET FLAT:?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A ; CBasePlayerItem::ItemInfoArray
	mov	DWORD PTR _II$41633[ebp], edx

; 4602 : 
; 4603 : 			if ( !II.iId )

	mov	eax, DWORD PTR _II$41633[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $L41634

; 4604 : 				continue;

	jmp	SHORT $L41631
$L41634:

; 4607 : 			if (!II.pszName)

	mov	ecx, DWORD PTR _II$41633[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $L41636

; 4608 : 				pszName = "Empty";

	mov	DWORD PTR _pszName$41635[ebp], OFFSET FLAT:??_C@_05EEDH@Empty?$AA@ ; `string'

; 4609 : 			else

	jmp	SHORT $L41638
$L41636:

; 4610 : 				pszName = II.pszName;

	mov	edx, DWORD PTR _II$41633[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _pszName$41635[ebp], eax
$L41638:

; 4611 : 
; 4612 : 			MESSAGE_BEGIN( MSG_ONE, gmsgWeaponList, NULL, pev );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	0
	mov	eax, DWORD PTR ?gmsgWeaponList@@3HA	; gmsgWeaponList
	push	eax
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 4613 : 				WRITE_STRING(pszName);			// string	weapon name

	mov	ecx, DWORD PTR _pszName$41635[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 4614 : 				WRITE_BYTE(GetAmmoIndex(II.pszAmmo1));	// byte		Ammo Type

	mov	edx, DWORD PTR _II$41633[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z	; CBasePlayer::GetAmmoIndex
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4615 : 				WRITE_BYTE(II.iMaxAmmo1);				// byte     Max Ammo 1

	mov	ecx, DWORD PTR _II$41633[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4616 : 				WRITE_BYTE(GetAmmoIndex(II.pszAmmo2));	// byte		Ammo2 Type

	mov	eax, DWORD PTR _II$41633[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z	; CBasePlayer::GetAmmoIndex
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4617 : 				WRITE_BYTE(II.iMaxAmmo2);				// byte     Max Ammo 2

	mov	edx, DWORD PTR _II$41633[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4618 : 				WRITE_BYTE(II.iSlot);					// byte		bucket

	mov	ecx, DWORD PTR _II$41633[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4619 : 				WRITE_BYTE(II.iPosition);				// byte		bucket pos

	mov	eax, DWORD PTR _II$41633[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4620 : 				WRITE_BYTE(II.iId);						// byte		id (bit index into m_iWeapons)

	mov	edx, DWORD PTR _II$41633[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4621 : 				WRITE_BYTE(II.iFlags);					// byte		Flags

	mov	ecx, DWORD PTR _II$41633[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 4622 : 			MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 4623 : 		}

	jmp	$L41631
$L41632:

; 4625 : 
; 4626 : 
; 4627 : 	SendAmmoUpdate();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SendAmmoUpdate@CBasePlayer@@QAEXXZ	; CBasePlayer::SendAmmoUpdate

; 4628 : 
; 4629 : 	// Update all the items
; 4630 : 	for ( int i = 0; i < MAX_ITEM_TYPES; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41640
$L41641:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41640:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L41642

; 4632 : 		if ( m_rgpPlayerItems[i] )  // each item updates it's successors

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+2956], 0
	je	SHORT $L41643

; 4633 : 			m_rgpPlayerItems[i]->UpdateClientData( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2956]
	mov	eax, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+eax*4+2956]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+404]
$L41643:

; 4634 : 	}

	jmp	SHORT $L41641
$L41642:

; 4635 : 
; 4636 : 	// Cache and client weapon change
; 4637 : 	m_pClientActiveItem = m_pActiveItem;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2980]
	mov	DWORD PTR [eax+2984], edx

; 4638 : 	m_iClientFOV = m_iFOV;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2936]
	mov	DWORD PTR [eax+2940], edx

; 4639 : 
; 4640 : 	// Update Status Bar
; 4641 : 	if ( m_flNextSBarUpdateTime < gpGlobals->time )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+3868]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41644

; 4643 : 		UpdateStatusBar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UpdateStatusBar@CBasePlayer@@QAEXXZ	; CBasePlayer::UpdateStatusBar

; 4644 : 		m_flNextSBarUpdateTime = gpGlobals->time + 0.2;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [edx]
	fadd	QWORD PTR __real@8@3ffcccccccccccccd000
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+3868]
$L41644:

; 4646 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateClientData@CBasePlayer@@UAEXXZ ENDP		; CBasePlayer::UpdateClientData
_TEXT	ENDS
;	COMDAT ?WRITE_BYTES@@YAXPBEH@Z
_TEXT	SEGMENT
_data$ = 8
_nBytes$ = 12
_i$ = -4
?WRITE_BYTES@@YAXPBEH@Z PROC NEAR			; WRITE_BYTES, COMDAT

; 78   : inline void WRITE_BYTES( const byte *data, int nBytes ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 79   : 	for( int i = 0; i < nBytes; i++, data++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L28259
$L28260:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _data$[ebp]
	add	ecx, 1
	mov	DWORD PTR _data$[ebp], ecx
$L28259:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _nBytes$[ebp]
	jge	SHORT $L28261

; 80   : 		WRITE_BYTE( *data );

	mov	eax, DWORD PTR _data$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4
	jmp	SHORT $L28260
$L28261:

; 81   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?WRITE_BYTES@@YAXPBEH@Z ENDP				; WRITE_BYTES
_TEXT	ENDS
;	COMDAT ?SendStartMessages@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
_pEdict$41653 = -12
_pEntity$41656 = -16
?SendStartMessages@CBasePlayer@@QAEXXZ PROC NEAR	; CBasePlayer::SendStartMessages, COMDAT

; 4649 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4650 : 	for( int i = 1; i < gpGlobals->maxEntities; i++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L41650
$L41651:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41650:
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+148]
	jge	SHORT $L41652

; 4652 : 		edict_t *pEdict = INDEXENT( i );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pEdict$41653[ebp], eax

; 4653 : 		if( !pEdict || pEdict->free || pEdict->v.flags & FL_KILLME )

	cmp	DWORD PTR _pEdict$41653[ebp], 0
	je	SHORT $L41655
	mov	ecx, DWORD PTR _pEdict$41653[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L41655
	mov	edx, DWORD PTR _pEdict$41653[ebp]
	mov	eax, DWORD PTR [edx+548]
	and	eax, 1073741824				; 40000000H
	test	eax, eax
	je	SHORT $L41654
$L41655:

; 4654 : 			continue;

	jmp	SHORT $L41651
$L41654:

; 4655 : 
; 4656 : 		CBaseEntity *pEntity = CBaseEntity::Instance( pEdict );

	mov	ecx, DWORD PTR _pEdict$41653[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$41656[ebp], eax

; 4657 : 		if( !pEntity ) continue;

	cmp	DWORD PTR _pEntity$41656[ebp], 0
	jne	SHORT $L41657
	jmp	SHORT $L41651
$L41657:

; 4658 : 
; 4659 : 		pEntity->StartMessage( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntity$41656[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pEntity$41656[ebp]
	call	DWORD PTR [edx+44]

; 4660 : 	}

	jmp	SHORT $L41651
$L41652:

; 4661 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SendStartMessages@CBasePlayer@@QAEXXZ ENDP		; CBasePlayer::SendStartMessages
_TEXT	ENDS
PUBLIC	?FBecomeProne@CBasePlayer@@UAEHXZ		; CBasePlayer::FBecomeProne
;	COMDAT ?FBecomeProne@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::FBecomeProne, COMDAT

; 4668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4669 : 	m_afPhysicsFlags |= PFLAG_ONBARNACLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], ecx

; 4670 : 	return TRUE;

	mov	eax, 1

; 4671 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::FBecomeProne
_TEXT	ENDS
PUBLIC	?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z ; CBasePlayer::BarnacleVictimBitten
;	COMDAT ?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pevBarnacle$ = 8
_this$ = -4
?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBasePlayer::BarnacleVictimBitten, COMDAT

; 4679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4680 : 	TakeDamage ( pevBarnacle, pevBarnacle, pev->health + pev->armorvalue, DMG_SLASH | DMG_ALWAYSGIB );

	push	8196					; 00002004H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+352]
	fadd	DWORD PTR [eax+444]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pevBarnacle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevBarnacle$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+96]

; 4681 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z ENDP ; CBasePlayer::BarnacleVictimBitten
_TEXT	ENDS
PUBLIC	?BarnacleVictimReleased@CBasePlayer@@UAEXXZ	; CBasePlayer::BarnacleVictimReleased
;	COMDAT ?BarnacleVictimReleased@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?BarnacleVictimReleased@CBasePlayer@@UAEXXZ PROC NEAR	; CBasePlayer::BarnacleVictimReleased, COMDAT

; 4688 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4689 : 	m_afPhysicsFlags &= ~PFLAG_ONBARNACLE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2488]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2488], ecx

; 4690 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BarnacleVictimReleased@CBasePlayer@@UAEXXZ ENDP	; CBasePlayer::BarnacleVictimReleased
_TEXT	ENDS
PUBLIC	?Illumination@CBaseEntity@@UAEHXZ		; CBaseEntity::Illumination
PUBLIC	?Illumination@CBasePlayer@@UAEHXZ		; CBasePlayer::Illumination
;	COMDAT ?Illumination@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
_iIllum$ = -8
?Illumination@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::Illumination, COMDAT

; 4698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4699 : 	int iIllum = CBaseEntity::Illumination( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Illumination@CBaseEntity@@UAEHXZ	; CBaseEntity::Illumination
	mov	DWORD PTR _iIllum$[ebp], eax

; 4700 : 
; 4701 : 	iIllum += m_iWeaponFlash;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _iIllum$[ebp]
	add	ecx, DWORD PTR [eax+2416]
	mov	DWORD PTR _iIllum$[ebp], ecx

; 4702 : 	if (iIllum > 255)

	cmp	DWORD PTR _iIllum$[ebp], 255		; 000000ffH
	jle	SHORT $L41675

; 4703 : 		return 255;

	mov	eax, 255				; 000000ffH
	jmp	SHORT $L41673
$L41675:

; 4704 : 	return iIllum;

	mov	eax, DWORD PTR _iIllum$[ebp]
$L41673:

; 4705 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::Illumination
_TEXT	ENDS
;	COMDAT ?Illumination@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Illumination@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::Illumination, COMDAT

; 720  : 	virtual int Illumination( ) { return GETENTITYILLUM( ENT( pev ) ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+60
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Illumination@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Illumination
_TEXT	ENDS
PUBLIC	?EnableControl@CBasePlayer@@QAEXH@Z		; CBasePlayer::EnableControl
;	COMDAT ?EnableControl@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT
_fControl$ = 8
_this$ = -4
?EnableControl@CBasePlayer@@QAEXH@Z PROC NEAR		; CBasePlayer::EnableControl, COMDAT

; 4709 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4710 : 	if (!fControl)

	cmp	DWORD PTR _fControl$[ebp], 0
	jne	SHORT $L41680

; 4712 : 		pev->flags |= FL_FROZEN;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	dh, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 4713 : 		SetAbsVelocity( g_vecZero );

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 4715 : 	else

	jmp	SHORT $L41681
$L41680:

; 4716 : 		pev->flags &= ~FL_FROZEN;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ch, -17					; ffffffefH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+420], ecx
$L41681:

; 4717 : 
; 4718 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EnableControl@CBasePlayer@@QAEXH@Z ENDP		; CBasePlayer::EnableControl
_TEXT	ENDS
PUBLIC	?HideWeapons@CBasePlayer@@QAEXH@Z		; CBasePlayer::HideWeapons
;	COMDAT ?HideWeapons@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT
_fHideWeapons$ = 8
_this$ = -4
?HideWeapons@CBasePlayer@@QAEXH@Z PROC NEAR		; CBasePlayer::HideWeapons, COMDAT

; 4721 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4722 : 	if( fHideWeapons )

	cmp	DWORD PTR _fHideWeapons$[ebp], 0
	je	SHORT $L41686

; 4724 : 		if( m_pActiveItem )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L41687

; 4726 : 			m_pActiveItem->Holster();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+368]

; 4727 : 			pev->weaponmodel = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+192], 0
$L41687:

; 4730 : 
; 4731 : 		m_iHideHUD |= HIDEHUD_WEAPONS;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2928]
	or	al, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2928], eax

; 4733 : 	else

	jmp	SHORT $L41688
$L41686:

; 4735 : 		// bring back player's weapons
; 4736 : 		if( m_pActiveItem )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2980], 0
	je	SHORT $L41689

; 4737 : 			m_pActiveItem->Deploy();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+360]
$L41689:

; 4738 : 
; 4739 : 		m_iHideHUD &= ~HIDEHUD_WEAPONS;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2928]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2928], ecx
$L41688:

; 4741 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HideWeapons@CBasePlayer@@QAEXH@Z ENDP			; CBasePlayer::HideWeapons
_TEXT	ENDS
PUBLIC	__real@4@4006b400000000000000
PUBLIC	__real@4@4007b400000000000000
PUBLIC	__real@4@c006b400000000000000
PUBLIC	__real@4@4003c800000000000000
PUBLIC	__real@4@c003c800000000000000
PUBLIC	__real@4@c002c000000000000000
PUBLIC	?GetAutoaimVector@CBasePlayer@@QAE?AVVector@@M@Z ; CBasePlayer::GetAutoaimVector
PUBLIC	?AutoaimDeflection@CBasePlayer@@QAE?AVVector@@AAV2@MM@Z ; CBasePlayer::AutoaimDeflection
EXTRN	?g_psv_aim@@3PAUcvar_s@@A:DWORD			; g_psv_aim
EXTRN	?g_iSkillLevel@@3HA:DWORD			; g_iSkillLevel
;	COMDAT __real@4@4006b400000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@4006b400000000000000 DD 043340000r	; 180
CONST	ENDS
;	COMDAT __real@4@4007b400000000000000
CONST	SEGMENT
__real@4@4007b400000000000000 DD 043b40000r	; 360
CONST	ENDS
;	COMDAT __real@4@c006b400000000000000
CONST	SEGMENT
__real@4@c006b400000000000000 DD 0c3340000r	; -180
CONST	ENDS
;	COMDAT __real@4@4003c800000000000000
CONST	SEGMENT
__real@4@4003c800000000000000 DD 041c80000r	; 25
CONST	ENDS
;	COMDAT __real@4@c003c800000000000000
CONST	SEGMENT
__real@4@c003c800000000000000 DD 0c1c80000r	; -25
CONST	ENDS
;	COMDAT __real@4@c002c000000000000000
CONST	SEGMENT
__real@4@c002c000000000000000 DD 0c1400000r	; -12
CONST	ENDS
;	COMDAT ?GetAutoaimVector@CBasePlayer@@QAE?AVVector@@M@Z
_TEXT	SEGMENT
$T44204 = -48
$T44205 = -60
$T44206 = -72
$T44207 = -84
$T44208 = -96
$T44209 = -108
$T44210 = -120
$T44211 = -132
$T44212 = -144
$T44213 = -156
_flDelta$ = 12
___$ReturnUdt$ = 8
_this$ = -4
_vecSrc$ = -16
_flDist$ = -20
_m_fOldTargeting$ = -24
_angles$ = -36
?GetAutoaimVector@CBasePlayer@@QAE?AVVector@@M@Z PROC NEAR ; CBasePlayer::GetAutoaimVector, COMDAT

; 4762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4763 : 	if (g_iSkillLevel == SKILL_HARD)

	cmp	DWORD PTR ?g_iSkillLevel@@3HA, 3	; g_iSkillLevel
	jne	SHORT $L41708

; 4765 : 		UTIL_MakeVectors( pev->v_angle + pev->punchangle );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 104				; 00000068H
	push	ecx
	lea	edx, DWORD PTR $T44204[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 116				; 00000074H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 4766 : 		return gpGlobals->v_forward;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$L41707
$L41708:

; 4768 : 
; 4769 : 	Vector vecSrc = GetGunPosition( );

	lea	edx, DWORD PTR $T44205[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+588]
	push	eax
	lea	ecx, DWORD PTR _vecSrc$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 4770 : 	float flDist = 8192;

	mov	DWORD PTR _flDist$[ebp], 1174405120	; 46000000H

; 4771 : 
; 4772 : 	// always use non-sticky autoaim
; 4773 : 	// UNDONE: use server variable to chose!
; 4774 : 	if (1 || g_iSkillLevel == SKILL_MEDIUM)

	mov	eax, 1
	test	eax, eax
	je	SHORT $L41713

; 4776 : 		m_vecAutoAim = Vector( 0, 0, 0 );

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T44206[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3764				; 00000eb4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L41713:

; 4779 : 
; 4780 : 	BOOL m_fOldTargeting = m_fOnTarget;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3776]
	mov	DWORD PTR _m_fOldTargeting$[ebp], edx

; 4781 : 	Vector angles = AutoaimDeflection(vecSrc, flDist, flDelta );

	mov	eax, DWORD PTR _flDelta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flDist$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR $T44207[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AutoaimDeflection@CBasePlayer@@QAE?AVVector@@AAV2@MM@Z ; CBasePlayer::AutoaimDeflection
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 4782 : 
; 4783 : 	// update ontarget if changed
; 4784 : 	if ( !g_pGameRules->AllowAutoTargetCrosshair() )

	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+92]
	test	eax, eax
	jne	SHORT $L41718

; 4785 : 		m_fOnTarget = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3776], 0

; 4786 : 	else if (m_fOldTargeting != m_fOnTarget)

	jmp	SHORT $L41720
$L41718:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _m_fOldTargeting$[ebp]
	cmp	edx, DWORD PTR [ecx+3776]
	je	SHORT $L41720

; 4788 : 		m_pActiveItem->UpdateItemInfo( );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+372]
$L41720:

; 4790 : 
; 4791 : 	if (angles.x > 180)

	fld	DWORD PTR _angles$[ebp]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41721

; 4792 : 		angles.x -= 360;

	fld	DWORD PTR _angles$[ebp]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angles$[ebp]
$L41721:

; 4793 : 	if (angles.x < -180)

	fld	DWORD PTR _angles$[ebp]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41722

; 4794 : 		angles.x += 360;

	fld	DWORD PTR _angles$[ebp]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angles$[ebp]
$L41722:

; 4795 : 	if (angles.y > 180)

	fld	DWORD PTR _angles$[ebp+4]
	fcomp	DWORD PTR __real@4@4006b400000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41723

; 4796 : 		angles.y -= 360;

	fld	DWORD PTR _angles$[ebp+4]
	fsub	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angles$[ebp+4]
$L41723:

; 4797 : 	if (angles.y < -180)

	fld	DWORD PTR _angles$[ebp+4]
	fcomp	DWORD PTR __real@4@c006b400000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41724

; 4798 : 		angles.y += 360;

	fld	DWORD PTR _angles$[ebp+4]
	fadd	DWORD PTR __real@4@4007b400000000000000
	fstp	DWORD PTR _angles$[ebp+4]
$L41724:

; 4799 : 
; 4800 : 	if (angles.x > 25)

	fld	DWORD PTR _angles$[ebp]
	fcomp	DWORD PTR __real@4@4003c800000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41725

; 4801 : 		angles.x = 25;

	mov	DWORD PTR _angles$[ebp], 1103626240	; 41c80000H
$L41725:

; 4802 : 	if (angles.x < -25)

	fld	DWORD PTR _angles$[ebp]
	fcomp	DWORD PTR __real@4@c003c800000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41726

; 4803 : 		angles.x = -25;

	mov	DWORD PTR _angles$[ebp], -1043857408	; c1c80000H
$L41726:

; 4804 : 	if (angles.y > 12)

	fld	DWORD PTR _angles$[ebp+4]
	fcomp	DWORD PTR __real@4@4002c000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41727

; 4805 : 		angles.y = 12;

	mov	DWORD PTR _angles$[ebp+4], 1094713344	; 41400000H
$L41727:

; 4806 : 	if (angles.y < -12)

	fld	DWORD PTR _angles$[ebp+4]
	fcomp	DWORD PTR __real@4@c002c000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41728

; 4807 : 		angles.y = -12;

	mov	DWORD PTR _angles$[ebp+4], -1052770304	; c1400000H
$L41728:

; 4808 : 
; 4809 : 
; 4810 : 	// always use non-sticky autoaim
; 4811 : 	// UNDONE: use sever variable to chose!
; 4812 : 	if (0 || g_iSkillLevel == SKILL_EASY)

	xor	eax, eax
	test	eax, eax
	jne	SHORT $L41730
	cmp	DWORD PTR ?g_iSkillLevel@@3HA, 1	; g_iSkillLevel
	jne	SHORT $L41729
$L41730:

; 4814 : 		m_vecAutoAim = m_vecAutoAim * 0.67 + angles * 0.33;

	push	1051260355				; 3ea8f5c3H
	lea	ecx, DWORD PTR $T44209[ebp]
	push	ecx
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T44210[ebp]
	push	edx
	push	1059816735				; 3f2b851fH
	lea	eax, DWORD PTR $T44208[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3764				; 00000eb4H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3764				; 00000eb4H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 4816 : 	else

	jmp	SHORT $L41734
$L41729:

; 4818 : 		m_vecAutoAim = angles * 0.9;

	push	1063675494				; 3f666666H
	lea	ecx, DWORD PTR $T44211[ebp]
	push	ecx
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3764				; 00000eb4H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L41734:

; 4820 : 
; 4821 : 	// m_vecAutoAim = m_vecAutoAim * 0.99;
; 4822 : 
; 4823 : 	// Don't send across network if sv_aim is 0
; 4824 : 	if ( g_psv_aim->value != 0 )

	mov	ecx, DWORD PTR ?g_psv_aim@@3PAUcvar_s@@A ; g_psv_aim
	fld	DWORD PTR [ecx+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L41737

; 4826 : 		if ( m_vecAutoAim.x != m_lastx || m_vecAutoAim.y != m_lasty )

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+3788]
	mov	eax, DWORD PTR _this$[ebp]
	fcomp	DWORD PTR [eax+3764]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41738
	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+3792]
	mov	edx, DWORD PTR _this$[ebp]
	fcomp	DWORD PTR [edx+3768]
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41737
$L41738:

; 4828 : 			SET_CROSSHAIRANGLE( edict(), -m_vecAutoAim.x, m_vecAutoAim.y );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3768]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+3764]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+376
	add	esp, 12					; 0000000cH

; 4829 : 
; 4830 : 			m_lastx = m_vecAutoAim.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+3764]
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3788], eax

; 4831 : 			m_lasty = m_vecAutoAim.y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+3768]
	call	__ftol
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3792], eax
$L41737:

; 4834 : 
; 4835 : 	// ALERT( at_console, "%f %f\n", angles.x, angles.y );
; 4836 : 
; 4837 : 	UTIL_MakeVectors( pev->v_angle + pev->punchangle + m_vecAutoAim );

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3764				; 00000eb4H
	push	edx
	lea	eax, DWORD PTR $T44213[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 104				; 00000068H
	push	edx
	lea	eax, DWORD PTR $T44212[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 116				; 00000074H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 4838 : 	return gpGlobals->v_forward;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L41707:

; 4839 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?GetAutoaimVector@CBasePlayer@@QAE?AVVector@@M@Z ENDP	; CBasePlayer::GetAutoaimVector
_TEXT	ENDS
PUBLIC	__real@8@3ffe8000000000000000
PUBLIC	__real@4@40008000000000000000
;	COMDAT __real@4@40008000000000000000
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
__real@4@40008000000000000000 DD 040000000r	; 2
CONST	ENDS
;	COMDAT __real@8@3ffe8000000000000000
CONST	SEGMENT
__real@8@3ffe8000000000000000 DQ 03fe0000000000000r ; 0.5
CONST	ENDS
;	COMDAT ?AutoaimDeflection@CBasePlayer@@QAE?AVVector@@AAV2@MM@Z
_TEXT	SEGMENT
$T44228 = -132
$T44229 = -144
$T44230 = -156
$T44231 = -168
$T44232 = -180
$T44233 = -192
$T44234 = -204
$T44235 = -216
$T44236 = -228
$T44237 = -240
$T44238 = -252
$T44239 = -264
_vecSrc$ = 12
_flDist$ = 16
_flDelta$ = 20
___$ReturnUdt$ = 8
_this$ = -4
_pEdict$ = -8
_pEntity$ = -12
_bestdot$ = -16
_bestdir$ = -28
_bestent$ = -32
_tr$ = -88
_i$ = -92
_center$41768 = -104
_dir$41769 = -116
_dot$41770 = -120
?AutoaimDeflection@CBasePlayer@@QAE?AVVector@@AAV2@MM@Z PROC NEAR ; CBasePlayer::AutoaimDeflection, COMDAT

; 4843 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4844 : 	edict_t		*pEdict = INDEXENT( 1 );

	push	1
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	mov	DWORD PTR _pEdict$[ebp], eax

; 4845 : 	CBaseEntity	*pEntity;
; 4846 : 	float		bestdot;
; 4847 : 	Vector		bestdir;

	lea	ecx, DWORD PTR _bestdir$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 4848 : 	edict_t		*bestent;
; 4849 : 	TraceResult tr;

	lea	ecx, DWORD PTR _tr$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 4850 : 
; 4851 : 	if ( g_psv_aim->value == 0 )

	mov	eax, DWORD PTR ?g_psv_aim@@3PAUcvar_s@@A ; g_psv_aim
	fld	DWORD PTR [eax+12]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41754

; 4853 : 		ResetAutoaim ();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetAutoaim@CBasePlayer@@QAEXXZ	; CBasePlayer::ResetAutoaim

; 4854 : 		return g_vecZero;

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$L41747
$L41754:

; 4856 : 
; 4857 : 	UTIL_MakeVectors( pev->v_angle + pev->punchangle + m_vecAutoAim );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3764				; 00000eb4H
	push	ecx
	lea	edx, DWORD PTR $T44229[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 104				; 00000068H
	push	ecx
	lea	edx, DWORD PTR $T44228[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 116				; 00000074H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 4858 : 
; 4859 : 	// try all possible entities
; 4860 : 	bestdir = gpGlobals->v_forward;

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _bestdir$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _bestdir$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _bestdir$[ebp+8], ecx

; 4861 : 	bestdot = flDelta; // +- 10 degrees

	mov	edx, DWORD PTR _flDelta$[ebp]
	mov	DWORD PTR _bestdot$[ebp], edx

; 4862 : 	bestent = NULL;

	mov	DWORD PTR _bestent$[ebp], 0

; 4863 : 
; 4864 : 	m_fOnTarget = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3776], 0

; 4865 : 
; 4866 : 	UTIL_TraceLine( vecSrc, vecSrc + bestdir * flDist, dont_ignore_monsters, edict(), &tr );

	lea	ecx, DWORD PTR _tr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	mov	edx, DWORD PTR _flDist$[ebp]
	push	edx
	lea	eax, DWORD PTR $T44230[ebp]
	push	eax
	lea	ecx, DWORD PTR _bestdir$[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T44231[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vecSrc$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 4867 : 
; 4868 : 
; 4869 : 	if ( tr.pHit && tr.pHit->v.takedamage != DAMAGE_NO)

	cmp	DWORD PTR _tr$[ebp+48], 0
	je	$L41760
	mov	eax, DWORD PTR _tr$[ebp+48]
	fld	DWORD PTR [eax+492]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41760

; 4873 : 			|| (pev->waterlevel == 3 && tr.pHit->v.waterlevel == 0)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 3
	je	SHORT $L41761
	mov	eax, DWORD PTR _tr$[ebp+48]
	cmp	DWORD PTR [eax+576], 3
	je	SHORT $L41760
$L41761:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 3
	jne	SHORT $L41762
	mov	eax, DWORD PTR _tr$[ebp+48]
	cmp	DWORD PTR [eax+576], 0
	je	SHORT $L41760
$L41762:

; 4875 : 			if (tr.pHit->v.takedamage == DAMAGE_AIM)

	mov	ecx, DWORD PTR _tr$[ebp+48]
	fld	DWORD PTR [ecx+492]
	fcomp	DWORD PTR __real@4@40008000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41763

; 4876 : 				m_fOnTarget = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3776], 1
$L41763:

; 4877 : 
; 4878 : 			return m_vecAutoAim;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3764				; 00000eb4H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$L41747
$L41760:

; 4881 : 
; 4882 : 	for ( int i = 1; i < gpGlobals->maxEntities; i++, pEdict++ )

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L41765
$L41766:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
	mov	edx, DWORD PTR _pEdict$[ebp]
	add	edx, 804				; 00000324H
	mov	DWORD PTR _pEdict$[ebp], edx
$L41765:
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+148]
	jge	$L41767

; 4884 : 		Vector center;

	lea	ecx, DWORD PTR _center$41768[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 4885 : 		Vector dir;

	lea	ecx, DWORD PTR _dir$41769[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 4886 : 		float dot;
; 4887 : 
; 4888 : 		if ( pEdict->free )	// Not in use

	mov	edx, DWORD PTR _pEdict$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L41771

; 4889 : 			continue;

	jmp	SHORT $L41766
$L41771:

; 4890 : 
; 4891 : 		if (pEdict->v.takedamage != DAMAGE_AIM)

	mov	eax, DWORD PTR _pEdict$[ebp]
	fld	DWORD PTR [eax+492]
	fcomp	DWORD PTR __real@4@40008000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41772

; 4892 : 			continue;

	jmp	SHORT $L41766
$L41772:

; 4893 : 		if (pEdict == edict())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	cmp	DWORD PTR _pEdict$[ebp], eax
	jne	SHORT $L41773

; 4894 : 			continue;

	jmp	SHORT $L41766
$L41773:

; 4895 : //		if (pev->team > 0 && pEdict->v.team == pev->team)
; 4896 : //			continue;	// don't aim at teammate
; 4897 : 		if ( !g_pGameRules->ShouldAutoAim( this, pEdict ) )

	mov	ecx, DWORD PTR _pEdict$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+68]
	test	eax, eax
	jne	SHORT $L41774

; 4898 : 			continue;

	jmp	$L41766
$L41774:

; 4899 : 
; 4900 : 		pEntity = Instance( pEdict );

	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEntity$[ebp], eax

; 4901 : 		if (pEntity == NULL)

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L41775

; 4902 : 			continue;

	jmp	$L41766
$L41775:

; 4903 : 
; 4904 : 		if (!pEntity->IsAlive())

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+200]
	test	eax, eax
	jne	SHORT $L41776

; 4905 : 			continue;

	jmp	$L41766
$L41776:

; 4909 : 			|| (pev->waterlevel == 3 && pEntity->pev->waterlevel == 0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 3
	je	SHORT $L41779
	mov	edx, DWORD PTR _pEntity$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+448], 3
	je	SHORT $L41778
$L41779:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+448], 3
	jne	SHORT $L41777
	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+448], 0
	jne	SHORT $L41777
$L41778:

; 4910 : 			continue;

	jmp	$L41766
$L41777:

; 4911 : 
; 4912 : 		center = pEntity->BodyTarget( vecSrc );

	mov	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR $T44232[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+316]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _center$41768[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _center$41768[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _center$41768[ebp+8], eax

; 4913 : 
; 4914 : 		dir = (center - vecSrc).Normalize( );

	lea	ecx, DWORD PTR $T44234[ebp]
	push	ecx
	mov	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR $T44233[ebp]
	push	eax
	lea	ecx, DWORD PTR _center$41768[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _dir$41769[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _dir$41769[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _dir$41769[ebp+8], eax

; 4915 : 
; 4916 : 		// make sure it's in front of the player
; 4917 : 		if (DotProduct (dir, gpGlobals->v_forward ) < 0)

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	push	ecx
	lea	edx, DWORD PTR _dir$41769[ebp]
	push	edx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	add	esp, 8
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41783

; 4918 : 			continue;

	jmp	$L41766
$L41783:

; 4921 : 			+ fabs( DotProduct (dir, gpGlobals->v_up ) ) * 0.5;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	eax, 64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _dir$41769[ebp]
	push	ecx
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	QWORD PTR [esp]
	call	_fabs
	fstp	QWORD PTR -272+[ebp]
	add	esp, 8
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 52					; 00000034H
	push	edx
	lea	eax, DWORD PTR _dir$41769[ebp]
	push	eax
	call	?DotProduct@@YAMABVVector@@0@Z		; DotProduct
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fmul	QWORD PTR __real@8@3ffe8000000000000000
	fadd	QWORD PTR -272+[ebp]
	fstp	DWORD PTR _dot$41770[ebp]

; 4922 : 
; 4923 : 		// tweek for distance
; 4924 : 		dot *= 1.0 + 0.2 * ((center - vecSrc).Length() / flDist);

	fld	DWORD PTR _dot$41770[ebp]
	fstp	QWORD PTR -280+[ebp]
	mov	ecx, DWORD PTR _vecSrc$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T44235[ebp]
	push	edx
	lea	ecx, DWORD PTR _center$41768[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fdiv	DWORD PTR _flDist$[ebp]
	fmul	QWORD PTR __real@8@3ffcccccccccccccd000
	fadd	QWORD PTR __real@8@3fff8000000000000000
	fmul	QWORD PTR -280+[ebp]
	fstp	DWORD PTR _dot$41770[ebp]

; 4925 : 
; 4926 : 		if (dot > bestdot)

	fld	DWORD PTR _dot$41770[ebp]
	fcomp	DWORD PTR _bestdot$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41785

; 4927 : 			continue;	// to far to turn

	jmp	$L41766
$L41785:

; 4928 : 
; 4929 : 		UTIL_TraceLine( vecSrc, center, dont_ignore_monsters, edict(), &tr );

	lea	eax, DWORD PTR _tr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	push	0
	lea	ecx, DWORD PTR _center$41768[ebp]
	push	ecx
	mov	edx, DWORD PTR _vecSrc$[ebp]
	push	edx
	call	?UTIL_TraceLine@@YAXABVVector@@0W4IGNORE_MONSTERS@@PAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceLine
	add	esp, 20					; 00000014H

; 4930 : 		if (tr.flFraction != 1.0 && tr.pHit != pEdict)

	fld	DWORD PTR _tr$[ebp+16]
	fcomp	QWORD PTR __real@8@3fff8000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41786
	mov	eax, DWORD PTR _tr$[ebp+48]
	cmp	eax, DWORD PTR _pEdict$[ebp]
	je	SHORT $L41786

; 4932 : 			// ALERT( at_console, "hit %s, can't see %s\n", STRING( tr.pHit->v.classname ), STRING( pEdict->v.classname ) );
; 4933 : 			continue;

	jmp	$L41766
$L41786:

; 4935 : 
; 4936 : 		// don't shoot at friends
; 4937 : 		if (IRelationship( pEntity ) < 0)

	mov	ecx, DWORD PTR _pEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+364]
	test	eax, eax
	jge	SHORT $L41788

; 4939 : 			if ( !pEntity->IsPlayer() && !g_pGameRules->IsDeathmatch())

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L41788
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+28]
	test	eax, eax
	jne	SHORT $L41788

; 4940 : 				// ALERT( at_console, "friend\n");
; 4941 : 				continue;

	jmp	$L41766
$L41788:

; 4943 : 
; 4944 : 		// can shoot at this one
; 4945 : 		bestdot = dot;

	mov	eax, DWORD PTR _dot$41770[ebp]
	mov	DWORD PTR _bestdot$[ebp], eax

; 4946 : 		bestent = pEdict;

	mov	ecx, DWORD PTR _pEdict$[ebp]
	mov	DWORD PTR _bestent$[ebp], ecx

; 4947 : 		bestdir = dir;

	mov	edx, DWORD PTR _dir$41769[ebp]
	mov	DWORD PTR _bestdir$[ebp], edx
	mov	eax, DWORD PTR _dir$41769[ebp+4]
	mov	DWORD PTR _bestdir$[ebp+4], eax
	mov	ecx, DWORD PTR _dir$41769[ebp+8]
	mov	DWORD PTR _bestdir$[ebp+8], ecx

; 4948 : 	}

	jmp	$L41766
$L41767:

; 4949 : 
; 4950 : 	if (bestent)

	cmp	DWORD PTR _bestent$[ebp], 0
	je	$L41789

; 4952 : 		bestdir = UTIL_VecToAngles (bestdir);

	lea	edx, DWORD PTR _bestdir$[ebp]
	push	edx
	lea	eax, DWORD PTR $T44236[ebp]
	push	eax
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bestdir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _bestdir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _bestdir$[ebp+8], eax

; 4953 : 		bestdir = bestdir - pev->v_angle - pev->punchangle;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 104				; 00000068H
	push	edx
	lea	eax, DWORD PTR $T44238[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	push	edx
	lea	eax, DWORD PTR $T44237[ebp]
	push	eax
	lea	ecx, DWORD PTR _bestdir$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _bestdir$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _bestdir$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _bestdir$[ebp+8], eax

; 4954 : 
; 4955 : 		if (bestent->v.takedamage == DAMAGE_AIM)

	mov	ecx, DWORD PTR _bestent$[ebp]
	fld	DWORD PTR [ecx+492]
	fcomp	DWORD PTR __real@4@40008000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41793

; 4956 : 			m_fOnTarget = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3776], 1
$L41793:

; 4957 : 
; 4958 : 		return bestdir;

	lea	eax, DWORD PTR _bestdir$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L41747
$L41789:

; 4960 : 
; 4961 : 	return Vector( 0, 0, 0 );

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR $T44239[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L41747:

; 4962 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AutoaimDeflection@CBasePlayer@@QAE?AVVector@@AAV2@MM@Z ENDP ; CBasePlayer::AutoaimDeflection
_TEXT	ENDS
;	COMDAT ?ResetAutoaim@CBasePlayer@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetAutoaim@CBasePlayer@@QAEXXZ PROC NEAR		; CBasePlayer::ResetAutoaim, COMDAT

; 4966 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4967 : 	if( m_vecAutoAim.x != 0 || m_vecAutoAim.y != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+3764]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L41800
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+3768]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L41799
$L41800:

; 4969 : 		SET_CROSSHAIRANGLE( edict(), 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+376
	add	esp, 12					; 0000000cH

; 4970 : 		m_vecAutoAim = g_vecZero;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3764				; 00000eb4H
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax

; 4971 : 		m_lastx = m_lastx = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3788], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3788], 0
$L41799:

; 4973 : 
; 4974 : 	m_fOnTarget = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3776], 0

; 4975 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetAutoaim@CBasePlayer@@QAEXXZ ENDP			; CBasePlayer::ResetAutoaim
_TEXT	ENDS
PUBLIC	?SetCustomDecalFrames@CBasePlayer@@QAEXH@Z	; CBasePlayer::SetCustomDecalFrames
;	COMDAT ?SetCustomDecalFrames@CBasePlayer@@QAEXH@Z
_TEXT	SEGMENT
_nFrames$ = 8
_this$ = -4
?SetCustomDecalFrames@CBasePlayer@@QAEXH@Z PROC NEAR	; CBasePlayer::SetCustomDecalFrames, COMDAT

; 4986 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 4988 : 		nFrames < 8)

	cmp	DWORD PTR _nFrames$[ebp], 0
	jle	SHORT $L41805
	cmp	DWORD PTR _nFrames$[ebp], 8
	jge	SHORT $L41805

; 4989 : 		m_nCustomSprayFrames = nFrames;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nFrames$[ebp]
	mov	DWORD PTR [eax+3796], ecx

; 4990 : 	else

	jmp	SHORT $L41806
$L41805:

; 4991 : 		m_nCustomSprayFrames = -1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3796], -1
$L41806:

; 4992 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetCustomDecalFrames@CBasePlayer@@QAEXH@Z ENDP		; CBasePlayer::SetCustomDecalFrames
_TEXT	ENDS
;	COMDAT ?GetCustomDecalFrames@CBasePlayer@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetCustomDecalFrames@CBasePlayer@@QAEHXZ PROC NEAR	; CBasePlayer::GetCustomDecalFrames, COMDAT

; 5002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5003 : 	return m_nCustomSprayFrames;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+3796]

; 5004 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCustomDecalFrames@CBasePlayer@@QAEHXZ ENDP		; CBasePlayer::GetCustomDecalFrames
_TEXT	ENDS
PUBLIC	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ		; CBasePlayerItem::pszAmmo1
PUBLIC	?iFlags@CBasePlayerItem@@QAEHXZ			; CBasePlayerItem::iFlags
PUBLIC	?DropPlayerItem@CBasePlayer@@QAEXPAD@Z		; CBasePlayer::DropPlayerItem
PUBLIC	?RemoveWeapon@CBaseMonster@@QAEXH@Z		; CBaseMonster::RemoveWeapon
EXTRN	?weaponstay@@3Ucvar_s@@A:BYTE			; weaponstay
;	COMDAT ?DropPlayerItem@CBasePlayer@@QAEXPAD@Z
_TEXT	SEGMENT
$T44250 = -44
$T44251 = -56
$T44252 = -68
_pszItemName$ = 8
_this$ = -4
_pWeapon$ = -8
_i$ = -12
_pWeaponBox$41831 = -16
_vecAngles$41835 = -28
_iAmmoIndex$41837 = -32
?DropPlayerItem@CBasePlayer@@QAEXPAD@Z PROC NEAR	; CBasePlayer::DropPlayerItem, COMDAT

; 5012 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5013 : 	if ( !g_pGameRules->IsMultiplayer() || (weaponstay.value > 0) )

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L41816
	fld	DWORD PTR ?weaponstay@@3Ucvar_s@@A+12
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L41815
$L41816:

; 5015 : 		// no dropping in single player.
; 5016 : 		return;

	jmp	$L41814
$L41815:

; 5018 : 
; 5019 : 	if ( !strlen( pszItemName ) )

	mov	eax, DWORD PTR _pszItemName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41817

; 5021 : 		// if this string has no length, the client didn't type a name!
; 5022 : 		// assume player wants to drop the active item.
; 5023 : 		// make the string null to make future operations in this function easier
; 5024 : 		pszItemName = NULL;

	mov	DWORD PTR _pszItemName$[ebp], 0
$L41817:

; 5028 : 	int i;
; 5029 : 
; 5030 : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41820
$L41821:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L41820:
	cmp	DWORD PTR _i$[ebp], 6
	jge	$L41822

; 5032 : 		pWeapon = m_rgpPlayerItems[ i ];

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2956]
	mov	DWORD PTR _pWeapon$[ebp], ecx
$L41824:

; 5033 : 
; 5034 : 		while ( pWeapon )

	cmp	DWORD PTR _pWeapon$[ebp], 0
	je	SHORT $L41825

; 5036 : 			if ( pszItemName )

	cmp	DWORD PTR _pszItemName$[ebp], 0
	je	SHORT $L41826

; 5038 : 				// try to match by name.
; 5039 : 				if ( !strcmp( pszItemName, STRING( pWeapon->pev->classname ) ) )

	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pszItemName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L41827

; 5041 : 					// match!
; 5042 : 					break;

	jmp	SHORT $L41825
$L41827:

; 5045 : 			else

	jmp	SHORT $L41829
$L41826:

; 5047 : 				// trying to drop active item
; 5048 : 				if ( pWeapon == m_pActiveItem )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	cmp	ecx, DWORD PTR [eax+2980]
	jne	SHORT $L41829

; 5050 : 					// active item!
; 5051 : 					break;

	jmp	SHORT $L41825
$L41829:

; 5054 : 
; 5055 : 			pWeapon = pWeapon->m_pNext;

	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx+1820]
	mov	DWORD PTR _pWeapon$[ebp], eax

; 5056 : 		}

	jmp	SHORT $L41824
$L41825:

; 5057 : 
; 5058 : 
; 5059 : 		// if we land here with a valid pWeapon pointer, that's because we found the
; 5060 : 		// item we want to drop and hit a BREAK;  pWeapon is the item.
; 5061 : 		if ( pWeapon )

	cmp	DWORD PTR _pWeapon$[ebp], 0
	je	$L41830

; 5063 : 			g_pGameRules->GetNextBestWeapon( this, pWeapon );

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+20]

; 5064 : 
; 5065 : 			UTIL_MakeVectors ( GetAbsAngles() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	call	?UTIL_MakeVectors@@YAXABVVector@@@Z	; UTIL_MakeVectors
	add	esp, 4

; 5066 : 
; 5067 : 			RemoveWeapon( pWeapon->m_iId );	// take item off hud

	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveWeapon@CBaseMonster@@QAEXH@Z	; CBaseMonster::RemoveWeapon

; 5068 : 
; 5069 : 			CWeaponBox *pWeaponBox = (CWeaponBox *)CBaseEntity::Create( "weaponbox", GetAbsOrigin() + gpGlobals->v_forward * 10, GetAbsAngles(), edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	push	1092616192				; 41200000H
	lea	edx, DWORD PTR $T44250[ebp]
	push	edx
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T44251[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	push	OFFSET FLAT:??_C@_09KMAI@weaponbox?$AA@	; `string'
	call	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pWeaponBox$41831[ebp], eax

; 5070 : 			Vector vecAngles = pWeaponBox->GetAbsAngles();

	mov	ecx, DWORD PTR _pWeaponBox$41831[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _vecAngles$41835[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 5071 : 			vecAngles.x = 0;

	mov	DWORD PTR _vecAngles$41835[ebp], 0

; 5072 : 			vecAngles.z = 0;

	mov	DWORD PTR _vecAngles$41835[ebp+8], 0

; 5073 : 			pWeaponBox->SetAbsAngles( vecAngles );

	lea	ecx, DWORD PTR _vecAngles$41835[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWeaponBox$41831[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 5074 : 			pWeaponBox->PackWeapon( pWeapon );

	mov	edx, DWORD PTR _pWeapon$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pWeaponBox$41831[ebp]
	call	?PackWeapon@CWeaponBox@@QAEHPAVCBasePlayerItem@@@Z ; CWeaponBox::PackWeapon

; 5075 : 			pWeaponBox->SetAbsVelocity( gpGlobals->v_forward * 400 );

	push	1137180672				; 43c80000H
	lea	eax, DWORD PTR $T44252[ebp]
	push	eax
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	ecx, 40					; 00000028H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR _pWeaponBox$41831[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity

; 5076 : 
; 5077 : 			// drop half of the ammo for this weapon.
; 5078 : 			int	iAmmoIndex;
; 5079 : 
; 5080 : 			iAmmoIndex = GetAmmoIndex ( pWeapon->pszAmmo1() ); // ???

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	push	eax
	call	?GetAmmoIndex@CBasePlayer@@SAHPBD@Z	; CBasePlayer::GetAmmoIndex
	add	esp, 4
	mov	DWORD PTR _iAmmoIndex$41837[ebp], eax

; 5081 : 
; 5082 : 			if ( iAmmoIndex != -1 )

	cmp	DWORD PTR _iAmmoIndex$41837[ebp], -1
	je	$L41840

; 5084 : 				// this weapon weapon uses ammo, so pack an appropriate amount.
; 5085 : 				if ( pWeapon->iFlags() & ITEM_FLAG_EXHAUSTIBLE )

	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?iFlags@CBasePlayerItem@@QAEHXZ		; CBasePlayerItem::iFlags
	and	eax, 16					; 00000010H
	test	eax, eax
	je	SHORT $L41839

; 5087 : 					// pack up all the ammo, this weapon is its own ammo type
; 5088 : 					pWeaponBox->PackAmmo( MAKE_STRING(pWeapon->pszAmmo1()), m_rgAmmo[ iAmmoIndex ] );

	mov	ecx, DWORD PTR _iAmmoIndex$41837[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+3508]
	push	eax
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pWeaponBox$41831[ebp]
	call	?PackAmmo@CWeaponBox@@QAEHHH@Z		; CWeaponBox::PackAmmo

; 5089 : 					m_rgAmmo[ iAmmoIndex ] = 0;

	mov	ecx, DWORD PTR _iAmmoIndex$41837[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+3508], 0

; 5092 : 				else

	jmp	SHORT $L41840
$L41839:

; 5094 : 					// pack half of the ammo
; 5095 : 					pWeaponBox->PackAmmo( MAKE_STRING(pWeapon->pszAmmo1()), m_rgAmmo[ iAmmoIndex ] / 2 );

	mov	eax, DWORD PTR _iAmmoIndex$41837[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4+3508]
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	?pszAmmo1@CBasePlayerItem@@QAEPBDXZ	; CBasePlayerItem::pszAmmo1
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pWeaponBox$41831[ebp]
	call	?PackAmmo@CWeaponBox@@QAEHHH@Z		; CWeaponBox::PackAmmo

; 5096 : 					m_rgAmmo[ iAmmoIndex ] /= 2;

	mov	edx, DWORD PTR _iAmmoIndex$41837[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+edx*4+3508]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _iAmmoIndex$41837[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+3508], eax
$L41840:

; 5100 : 
; 5101 : 			return;// we're done, so stop searching with the FOR loop.

	jmp	SHORT $L41814
$L41830:

; 5103 : 	}

	jmp	$L41821
$L41822:
$L41814:

; 5104 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DropPlayerItem@CBasePlayer@@QAEXPAD@Z ENDP		; CBasePlayer::DropPlayerItem
_TEXT	ENDS
;	COMDAT ?RemoveWeapon@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4
_weaponnum$ = 8
?RemoveWeapon@CBaseMonster@@QAEXH@Z PROC NEAR		; CBaseMonster::RemoveWeapon, COMDAT

; 144  : 	void		RemoveWeapon( int weaponnum ) { ClearBits( m_iWeapons[weaponnum >> 3], BIT( weaponnum & 7 )); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _weaponnum$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+eax+2348]
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	and	ecx, 7
	mov	eax, 1
	shl	eax, cl
	not	eax
	and	edx, eax
	mov	ecx, DWORD PTR _weaponnum$[ebp]
	sar	ecx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+ecx+2348], dl
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemoveWeapon@CBaseMonster@@QAEXH@Z ENDP		; CBaseMonster::RemoveWeapon
_TEXT	ENDS
;	COMDAT ?pszAmmo1@CBasePlayerItem@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?pszAmmo1@CBasePlayerItem@@QAEPBDXZ PROC NEAR		; CBasePlayerItem::pszAmmo1, COMDAT

; 277  : 	const char	*pszAmmo1( void )	{ return ItemInfoArray[ m_iId ].pszAmmo1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?pszAmmo1@CBasePlayerItem@@QAEPBDXZ ENDP		; CBasePlayerItem::pszAmmo1
_TEXT	ENDS
;	COMDAT ?iFlags@CBasePlayerItem@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?iFlags@CBasePlayerItem@@QAEHXZ PROC NEAR		; CBasePlayerItem::iFlags, COMDAT

; 284  : 	int		iFlags( void )	{ return ItemInfoArray[ m_iId ].iFlags; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1824]
	imul	ecx, 44					; 0000002cH
	mov	eax, DWORD PTR ?ItemInfoArray@CBasePlayerItem@@2PAUItemInfo@@A[ecx+36]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?iFlags@CBasePlayerItem@@QAEHXZ ENDP			; CBasePlayerItem::iFlags
_TEXT	ENDS
PUBLIC	?HasPlayerItem@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ; CBasePlayer::HasPlayerItem
;	COMDAT ?HasPlayerItem@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pCheckItem$ = 8
_this$ = -4
_pItem$ = -8
?HasPlayerItem@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBasePlayer::HasPlayerItem, COMDAT

; 5110 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5111 : 	CBasePlayerItem *pItem = m_rgpPlayerItems[pCheckItem->iItemSlot()];

	mov	eax, DWORD PTR _pCheckItem$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pCheckItem$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2956]
	mov	DWORD PTR _pItem$[ebp], edx
$L41847:

; 5112 : 
; 5113 : 	while (pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	je	SHORT $L41848

; 5115 : 		if (FClassnameIs( pItem->pev, STRING( pCheckItem->pev->classname) ))

	mov	eax, DWORD PTR _pCheckItem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _pItem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FClassnameIs@@YAHPAUentvars_s@@PBD@Z	; FClassnameIs
	add	esp, 8
	test	eax, eax
	je	SHORT $L41849

; 5117 : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L41844
$L41849:

; 5119 : 		pItem = pItem->m_pNext;

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx+1820]
	mov	DWORD PTR _pItem$[ebp], eax

; 5120 : 	}

	jmp	SHORT $L41847
$L41848:

; 5121 : 
; 5122 : 	return FALSE;

	xor	eax, eax
$L41844:

; 5123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasPlayerItem@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ENDP ; CBasePlayer::HasPlayerItem
_TEXT	ENDS
PUBLIC	?HasNamedPlayerItem@CBasePlayer@@QAEHPBD@Z	; CBasePlayer::HasNamedPlayerItem
;	COMDAT ?HasNamedPlayerItem@CBasePlayer@@QAEHPBD@Z
_TEXT	SEGMENT
_pszItemName$ = 8
_this$ = -4
_pItem$ = -8
_i$ = -12
?HasNamedPlayerItem@CBasePlayer@@QAEHPBD@Z PROC NEAR	; CBasePlayer::HasNamedPlayerItem, COMDAT

; 5129 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5130 : 	CBasePlayerItem *pItem;
; 5131 : 	int i;
; 5132 : 
; 5133 : 	for ( i = 0 ; i < MAX_ITEM_TYPES ; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L41856
$L41857:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L41856:
	cmp	DWORD PTR _i$[ebp], 6
	jge	SHORT $L41858

; 5135 : 		pItem = m_rgpPlayerItems[ i ];

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+2956]
	mov	DWORD PTR _pItem$[ebp], eax
$L41860:

; 5136 : 
; 5137 : 		while (pItem)

	cmp	DWORD PTR _pItem$[ebp], 0
	je	SHORT $L41861

; 5139 : 			if ( !strcmp( pszItemName, STRING( pItem->pev->classname ) ) )

	mov	ecx, DWORD PTR _pItem$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pszItemName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L41862

; 5141 : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L41853
$L41862:

; 5143 : 			pItem = pItem->m_pNext;

	mov	edx, DWORD PTR _pItem$[ebp]
	mov	eax, DWORD PTR [edx+1820]
	mov	DWORD PTR _pItem$[ebp], eax

; 5144 : 		}

	jmp	SHORT $L41860
$L41861:

; 5145 : 	}

	jmp	SHORT $L41857
$L41858:

; 5146 : 
; 5147 : 	return FALSE;

	xor	eax, eax
$L41853:

; 5148 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasNamedPlayerItem@CBasePlayer@@QAEHPBD@Z ENDP		; CBasePlayer::HasNamedPlayerItem
_TEXT	ENDS
;	COMDAT ?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_pWeapon$ = 8
_this$ = -4
?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBasePlayer::SwitchWeapon, COMDAT

; 5154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5155 : 	if ( !pWeapon->CanDeploy() )

	mov	eax, DWORD PTR _pWeapon$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	DWORD PTR [edx+356]
	test	eax, eax
	jne	SHORT $L41867

; 5157 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L41866
$L41867:

; 5159 : 
; 5160 : 	ResetAutoaim( );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetAutoaim@CBasePlayer@@QAEXXZ	; CBasePlayer::ResetAutoaim

; 5161 : 
; 5162 : 	if (m_pActiveItem)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2980], 0
	je	SHORT $L41868

; 5164 : 		m_pActiveItem->Holster( );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+2980]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2980]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+368]
$L41868:

; 5166 : 
; 5167 : 	m_pActiveItem = pWeapon;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	mov	DWORD PTR [eax+2980], ecx

; 5168 : 	pWeapon->Deploy( );

	mov	edx, DWORD PTR _pWeapon$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pWeapon$[ebp]
	call	DWORD PTR [eax+360]

; 5169 : 
; 5170 : 	return TRUE;

	mov	eax, 1
$L41866:

; 5171 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SwitchWeapon@CBasePlayer@@QAEHPAVCBasePlayerItem@@@Z ENDP ; CBasePlayer::SwitchWeapon
_TEXT	ENDS
PUBLIC	?KeyValue@CDeadHEV@@UAEXPAUKeyValueData_s@@@Z	; CDeadHEV::KeyValue
PUBLIC	??_C@_04JLAH@pose?$AA@				; `string'
EXTRN	_atoi:NEAR
EXTRN	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseMonster::KeyValue
;	COMDAT ??_C@_04JLAH@pose?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_04JLAH@pose?$AA@ DB 'pose', 00H			; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CDeadHEV@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CDeadHEV@@UAEXPAUKeyValueData_s@@@Z PROC NEAR	; CDeadHEV::KeyValue, COMDAT

; 5192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5193 : 	if (FStrEq(pkvd->szKeyName, "pose"))

	push	OFFSET FLAT:??_C@_04JLAH@pose?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L41904

; 5195 : 		m_iPose = atoi(pkvd->szValue);

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2396], eax

; 5196 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 5198 : 	else

	jmp	SHORT $L41906
$L41904:

; 5199 : 		BaseClass::KeyValue( pkvd );

	mov	eax, DWORD PTR _pkvd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z ; CBaseMonster::KeyValue
$L41906:

; 5200 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CDeadHEV@@UAEXPAUKeyValueData_s@@@Z ENDP	; CDeadHEV::KeyValue
_TEXT	ENDS
;	COMDAT _$E47
_TEXT	SEGMENT
_$E47	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E46
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E47	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCDeadHEV@@@@QAE@PBD@Z	; CEntityFactory<CDeadHEV>::CEntityFactory<CDeadHEV>
PUBLIC	??_C@_0BF@BGGJ@monster_hevsuit_dead?$AA@	; `string'
_BSS	SEGMENT
_monster_hevsuit_dead DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BF@BGGJ@monster_hevsuit_dead?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BF@BGGJ@monster_hevsuit_dead?$AA@ DB 'monster_hevsuit_dead', 00H ; `string'
CONST	ENDS
;	COMDAT _$E46
_TEXT	SEGMENT
_$E46	PROC NEAR					; COMDAT

; 5202 : LINK_ENTITY_TO_CLASS( monster_hevsuit_dead, CDeadHEV );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BF@BGGJ@monster_hevsuit_dead?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_monster_hevsuit_dead
	call	??0?$CEntityFactory@VCDeadHEV@@@@QAE@PBD@Z ; CEntityFactory<CDeadHEV>::CEntityFactory<CDeadHEV>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E46	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CDeadHEV@@UAEXXZ				; CDeadHEV::Spawn
PUBLIC	??_C@_0BM@FAED@Dead?5hevsuit?5with?5bad?5pose?6?$AA@ ; `string'
;	COMDAT ??_C@_0BM@FAED@Dead?5hevsuit?5with?5bad?5pose?6?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BM@FAED@Dead?5hevsuit?5with?5bad?5pose?6?$AA@ DB 'Dead hevsuit wit'
	DB	'h bad pose', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?Spawn@CDeadHEV@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CDeadHEV@@UAEXXZ PROC NEAR			; CDeadHEV::Spawn, COMDAT

; 5208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5209 : 	PRECACHE_MODEL("models/player.mdl");

	push	OFFSET FLAT:??_C@_0BC@DMHA@models?1player?4mdl?$AA@ ; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 5210 : 	SET_MODEL(ENT(pev), "models/player.mdl");

	push	OFFSET FLAT:??_C@_0BC@DMHA@models?1player?4mdl?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 8

; 5211 : 
; 5212 : 	pev->effects		= 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], 0

; 5213 : 	pev->yaw_speed		= 8;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+176], 1090519040		; 41000000H

; 5214 : 	pev->sequence		= 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+296], 0

; 5215 : 	pev->body			= 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+276], 1

; 5216 : 	m_bloodColor		= BLOOD_COLOR_RED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2328], 247		; 000000f7H

; 5217 : 
; 5218 : 	pev->sequence = LookupSequence( m_szPoses[m_iPose] );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2396]
	mov	ecx, DWORD PTR ?m_szPoses@CDeadHEV@@2PAPADA[eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LookupSequence@CBaseAnimating@@QAEHPBD@Z ; CBaseAnimating::LookupSequence
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+296], eax

; 5219 : 
; 5220 : 	if (pev->sequence == -1)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+296], -1
	jne	SHORT $L41937

; 5222 : 		ALERT ( at_console, "Dead hevsuit with bad pose\n" );

	push	OFFSET FLAT:??_C@_0BM@FAED@Dead?5hevsuit?5with?5bad?5pose?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 5223 : 		pev->sequence = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+296], 0

; 5224 : 		pev->effects = EF_BRIGHTFIELD;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], 1
$L41937:

; 5226 : 
; 5227 : 	// Corpses have less health
; 5228 : 	pev->health			= 8;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+352], 1090519040		; 41000000H

; 5229 : 
; 5230 : 	MonsterInitDead();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+372]

; 5231 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CDeadHEV@@UAEXXZ ENDP				; CDeadHEV::Spawn
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CPlayerKeyCatcher@@UAEPAUdatamap_s@@XZ ; CPlayerKeyCatcher::GetDataDescMap
;	COMDAT ?GetDataDescMap@CPlayerKeyCatcher@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CPlayerKeyCatcher@@UAEPAUdatamap_s@@XZ PROC NEAR ; CPlayerKeyCatcher::GetDataDescMap, COMDAT

; 5253 : BEGIN_DATADESC( CPlayerKeyCatcher )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A ; CPlayerKeyCatcher::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CPlayerKeyCatcher@@UAEPAUdatamap_s@@XZ ENDP ; CPlayerKeyCatcher::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CPlayerKeyCatcher@@SAPAUdatamap_s@@XZ ; CPlayerKeyCatcher::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CPlayerKeyCatcher@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CPlayerKeyCatcher@@SAPAUdatamap_s@@XZ PROC NEAR ; CPlayerKeyCatcher::GetBaseMap, COMDAT

; 5253 : BEGIN_DATADESC( CPlayerKeyCatcher )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CPlayerKeyCatcher@@SAPAUdatamap_s@@XZ ENDP	; CPlayerKeyCatcher::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E50
_TEXT	SEGMENT
_$E50	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E49
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E50	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z ; DataMapInit
;	COMDAT _$E49
_TEXT	SEGMENT
_$E49	PROC NEAR					; COMDAT

; 5253 : BEGIN_DATADESC( CPlayerKeyCatcher )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CPlayerKeyCatcher_DataDescInit@@3PAUdatamap_s@@A, eax ; CPlayerKeyCatcher_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E49	ENDP
_TEXT	ENDS
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S52@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z PROC NEAR ; DataMapInit, COMDAT

; 5253 : BEGIN_DATADESC( CPlayerKeyCatcher )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S52@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L41994
	mov	cl, BYTE PTR _?$S52@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S52@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0BC@GIDL@CPlayerKeyCatcher?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E53
	call	_atexit
	add	esp, 4
$L41994:
	call	?GetBaseMap@CPlayerKeyCatcher@@SAPAUdatamap_s@@XZ ; CPlayerKeyCatcher::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A+12, eax

; 5254 : 	DEFINE_KEYFIELD( m_iszKeyPressed, FIELD_STRING, "m_iszKeyPressed" ),
; 5255 : 	DEFINE_KEYFIELD( m_iszKeyReleased, FIELD_STRING, "m_iszKeyReleased" ),
; 5256 : 	DEFINE_KEYFIELD( m_iszKeyHoldDown, FIELD_STRING, "m_iszKeyHoldDown" ),
; 5257 : END_DATADESC()

	mov	edx, 1
	test	edx, edx
	je	SHORT $L42007
	mov	DWORD PTR ?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A+4, 3
	mov	DWORD PTR ?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L42008
$L42007:
	mov	DWORD PTR ?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4PAUtypedescription_s@@A
$L42008:
	mov	eax, OFFSET FLAT:?m_DataMap@CPlayerKeyCatcher@@2Udatamap_s@@A ; CPlayerKeyCatcher::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z ENDP ; DataMapInit
_TEXT	ENDS
;	COMDAT _$E53
_TEXT	SEGMENT
_$E53	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCPlayerKeyCatcher@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E53	ENDP
_TEXT	ENDS
;	COMDAT _$E55
_TEXT	SEGMENT
_$E55	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E54
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E55	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCPlayerKeyCatcher@@@@QAE@PBD@Z ; CEntityFactory<CPlayerKeyCatcher>::CEntityFactory<CPlayerKeyCatcher>
_BSS	SEGMENT
	ALIGN	4

_player_keycatcher DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _$E54
_TEXT	SEGMENT
_$E54	PROC NEAR					; COMDAT

; 5259 : LINK_ENTITY_TO_CLASS( player_keycatcher, CPlayerKeyCatcher );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BC@KNFC@player_keycatcher?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_player_keycatcher
	call	??0?$CEntityFactory@VCPlayerKeyCatcher@@@@QAE@PBD@Z ; CEntityFactory<CPlayerKeyCatcher>::CEntityFactory<CPlayerKeyCatcher>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E54	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CPlayerKeyCatcher@@UAEXXZ		; CPlayerKeyCatcher::Spawn
;	COMDAT ?Spawn@CPlayerKeyCatcher@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CPlayerKeyCatcher@@UAEXXZ PROC NEAR		; CPlayerKeyCatcher::Spawn, COMDAT

; 5262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5263 : 	m_iState = STATE_OFF;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 0

; 5264 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CPlayerKeyCatcher@@UAEXXZ ENDP			; CPlayerKeyCatcher::Spawn
_TEXT	ENDS
PUBLIC	?Restore@CPlayerKeyCatcher@@UAEHAAVCRestore@@@Z	; CPlayerKeyCatcher::Restore
EXTRN	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z:NEAR	; CBaseEntity::Restore
;	COMDAT ?Restore@CPlayerKeyCatcher@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT
_restore$ = 8
_this$ = -4
_status$ = -8
?Restore@CPlayerKeyCatcher@@UAEHAAVCRestore@@@Z PROC NEAR ; CPlayerKeyCatcher::Restore, COMDAT

; 5267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5268 : 	int status = BaseClass::Restore(restore);

	mov	eax, DWORD PTR _restore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z ; CBaseEntity::Restore
	mov	DWORD PTR _status$[ebp], eax

; 5269 : 
; 5270 : 	m_iState = STATE_OFF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 0

; 5271 : 
; 5272 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 5273 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Restore@CPlayerKeyCatcher@@UAEHAAVCRestore@@@Z ENDP	; CPlayerKeyCatcher::Restore
_TEXT	ENDS
PUBLIC	??_C@_0BA@BEGF@m_iszKeyToCatch?$AA@		; `string'
PUBLIC	??_C@_0BL@FCGB@?$CFs?5has?5invalid?5keyname?5?$CFs?6?$AA@ ; `string'
PUBLIC	?KeyValue@CPlayerKeyCatcher@@UAEXPAUKeyValueData_s@@@Z ; CPlayerKeyCatcher::KeyValue
EXTRN	?Q_strnicmp@@YAHPBD0H@Z:NEAR			; Q_strnicmp
EXTRN	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseDelay::KeyValue
;	COMDAT ??_C@_0BA@BEGF@m_iszKeyToCatch?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BA@BEGF@m_iszKeyToCatch?$AA@ DB 'm_iszKeyToCatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FCGB@?$CFs?5has?5invalid?5keyname?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@FCGB@?$CFs?5has?5invalid?5keyname?5?$CFs?6?$AA@ DB '%s has inva'
	DB	'lid keyname %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CPlayerKeyCatcher@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
_i$42055 = -8
?KeyValue@CPlayerKeyCatcher@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CPlayerKeyCatcher::KeyValue, COMDAT

; 5276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5277 : 	if( FStrEq( pkvd->szKeyName, "m_iszKeyPressed" ))

	push	OFFSET FLAT:??_C@_0BA@HGJK@m_iszKeyPressed?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L42047

; 5279 : 		m_iszKeyPressed = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1792], eax

; 5280 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 5282 : 	else if( FStrEq( pkvd->szKeyName, "m_iszKeyReleased" ))

	jmp	$L42062
$L42047:
	push	OFFSET FLAT:??_C@_0BB@LCPM@m_iszKeyReleased?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L42049

; 5284 : 		m_iszKeyReleased = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1796], eax

; 5285 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 5287 : 	else if( FStrEq( pkvd->szKeyName, "m_iszKeyHoldDown" ))

	jmp	$L42062
$L42049:
	push	OFFSET FLAT:??_C@_0BB@MNCI@m_iszKeyHoldDown?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L42051

; 5289 : 		m_iszKeyHoldDown = ALLOC_STRING( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1800], eax

; 5290 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 5292 : 	else if( FStrEq( pkvd->szKeyName, "m_iszKeyToCatch" ))

	jmp	$L42062
$L42051:
	push	OFFSET FLAT:??_C@_0BA@BEGF@m_iszKeyToCatch?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	$L42053

; 5294 : 		for( int i = 0; i < ARRAYSIZE( gPlayerButtonTable ); i++ )

	mov	DWORD PTR _i$42055[ebp], 0
	jmp	SHORT $L42056
$L42057:
	mov	edx, DWORD PTR _i$42055[ebp]
	add	edx, 1
	mov	DWORD PTR _i$42055[ebp], edx
$L42056:
	cmp	DWORD PTR _i$42055[ebp], 15		; 0000000fH
	jae	SHORT $L42058

; 5296 : 			if( !Q_stricmp( pkvd->szValue, gPlayerButtonTable[i].buttonName ))

	push	99999					; 0001869fH
	mov	eax, DWORD PTR _i$42055[ebp]
	mov	ecx, DWORD PTR _gPlayerButtonTable[eax*8]
	push	ecx
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_strnicmp@@YAHPBD0H@Z			; Q_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L42059

; 5298 : 				pev->button = gPlayerButtonTable[i].buttonCode;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _i$42055[ebp]
	mov	ecx, DWORD PTR _gPlayerButtonTable[eax*8+4]
	mov	DWORD PTR [edx+384], ecx

; 5299 : 				break;

	jmp	SHORT $L42058
$L42059:

; 5301 : 		}

	jmp	SHORT $L42057
$L42058:

; 5302 : 
; 5303 : 		if( i == ARRAYSIZE( gPlayerButtonTable ))

	cmp	DWORD PTR _i$42055[ebp], 15		; 0000000fH
	jne	SHORT $L42060

; 5304 : 			ALERT( at_error, "%s has invalid keyname %s\n", GetClassname(), pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0BL@FCGB@?$CFs?5has?5invalid?5keyname?5?$CFs?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H
$L42060:

; 5305 : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 5307 : 	else CBaseDelay::KeyValue( pkvd );

	jmp	SHORT $L42062
$L42053:
	mov	edx, DWORD PTR _pkvd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z ; CBaseDelay::KeyValue
$L42062:

; 5308 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CPlayerKeyCatcher@@UAEXPAUKeyValueData_s@@@Z ENDP ; CPlayerKeyCatcher::KeyValue
_TEXT	ENDS
EXTRN	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ?CatchButton@CPlayerKeyCatcher@@QAEXPAVCBaseEntity@@HHH@Z
_TEXT	SEGMENT
_pActivator$ = 8
_buttons$ = 12
_pressed$ = 16
_released$ = 20
_this$ = -4
?CatchButton@CPlayerKeyCatcher@@QAEXPAVCBaseEntity@@HHH@Z PROC NEAR ; CPlayerKeyCatcher::CatchButton, COMDAT

; 5311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5312 : 	if( !( pressed & pev->button ) && !( released & pev->button ) && !( buttons & pev->button ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pressed$[ebp]
	and	edx, DWORD PTR [ecx+384]
	test	edx, edx
	jne	SHORT $L42070
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _released$[ebp]
	and	edx, DWORD PTR [ecx+384]
	test	edx, edx
	jne	SHORT $L42070
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _buttons$[ebp]
	and	edx, DWORD PTR [ecx+384]
	test	edx, edx
	jne	SHORT $L42070

; 5313 : 		return;	// ignore other buttons

	jmp	$L42069
$L42070:

; 5314 : 
; 5315 : 	if( IsLockedByMaster( pActivator ))

	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsLockedByMaster@CBaseDelay@@QAEHPAVCBaseEntity@@@Z ; CBaseDelay::IsLockedByMaster
	test	eax, eax
	je	SHORT $L42071

; 5316 : 		return;	// temporare blocked

	jmp	$L42069
$L42071:

; 5317 : 
; 5318 : 	if( pressed & pev->button )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pressed$[ebp]
	and	eax, DWORD PTR [edx+384]
	test	eax, eax
	je	SHORT $L42072

; 5320 : 		m_iState = STATE_ON;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1788], 1

; 5321 : 		UTIL_FireTargets( m_iszKeyPressed, pActivator, this, USE_ON );

	push	0
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1792]
	push	edx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L42072:

; 5323 : 
; 5324 : 	if( buttons & pev->button )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _buttons$[ebp]
	and	edx, DWORD PTR [ecx+384]
	test	edx, edx
	je	SHORT $L42073

; 5326 : 		m_iState = STATE_ON;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1788], 1

; 5327 : 		UTIL_FireTargets( m_iszKeyHoldDown, pActivator, this, USE_TOGGLE );

	push	0
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pActivator$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1800]
	push	ecx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L42073:

; 5329 : 
; 5330 : 	if( released & pev->button )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _released$[ebp]
	and	ecx, DWORD PTR [eax+384]
	test	ecx, ecx
	je	SHORT $L42074

; 5332 : 		m_iState = STATE_OFF;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1788], 0

; 5333 : 		UTIL_FireTargets( m_iszKeyReleased, pActivator, this, USE_OFF );

	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1796]
	push	eax
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L42074:
$L42069:

; 5335 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CatchButton@CPlayerKeyCatcher@@QAEXPAVCBaseEntity@@HHH@Z ENDP ; CPlayerKeyCatcher::CatchButton
_TEXT	ENDS
;	COMDAT _$E58
_TEXT	SEGMENT
_$E58	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E57
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E58	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCStripWeapons@@@@QAE@PBD@Z	; CEntityFactory<CStripWeapons>::CEntityFactory<CStripWeapons>
PUBLIC	??_C@_0BD@LCP@player_weaponstrip?$AA@		; `string'
_BSS	SEGMENT
_player_weaponstrip DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@LCP@player_weaponstrip?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BD@LCP@player_weaponstrip?$AA@ DB 'player_weaponstrip', 00H ; `string'
CONST	ENDS
;	COMDAT _$E57
_TEXT	SEGMENT
_$E57	PROC NEAR					; COMDAT

; 5347 : LINK_ENTITY_TO_CLASS( player_weaponstrip, CStripWeapons );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BD@LCP@player_weaponstrip?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_player_weaponstrip
	call	??0?$CEntityFactory@VCStripWeapons@@@@QAE@PBD@Z ; CEntityFactory<CStripWeapons>::CEntityFactory<CStripWeapons>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E57	ENDP
_TEXT	ENDS
PUBLIC	?Use@CStripWeapons@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CStripWeapons::Use
;	COMDAT ?Use@CStripWeapons@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_this$ = -4
_pPlayer$ = -8
?Use@CStripWeapons@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CStripWeapons::Use, COMDAT

; 5350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5351 : 	CBasePlayer *pPlayer = NULL;

	mov	DWORD PTR _pPlayer$[ebp], 0

; 5352 : 
; 5353 : 	if ( pActivator && pActivator->IsPlayer() )

	cmp	DWORD PTR _pActivator$[ebp], 0
	je	SHORT $L42131
	mov	eax, DWORD PTR _pActivator$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActivator$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L42131

; 5355 : 		pPlayer = (CBasePlayer *)pActivator;

	mov	eax, DWORD PTR _pActivator$[ebp]
	mov	DWORD PTR _pPlayer$[ebp], eax

; 5357 : 	else if ( !g_pGameRules->IsDeathmatch() )

	jmp	SHORT $L42134
$L42131:
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+28]
	test	eax, eax
	jne	SHORT $L42134

; 5359 : 		pPlayer = (CBasePlayer *)UTIL_PlayerByIndex( 1 );

	push	1
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pPlayer$[ebp], eax
$L42134:

; 5361 : 
; 5362 : 	if ( pPlayer )

	cmp	DWORD PTR _pPlayer$[ebp], 0
	je	SHORT $L42136

; 5363 : 		pPlayer->RemoveAllItems( FBitSet( pev->spawnflags, SF_REMOVE_SUIT ), FBitSet( pev->spawnflags, SF_REMOVE_CYCLER ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 2
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	and	edx, 1
	push	edx
	mov	ecx, DWORD PTR _pPlayer$[ebp]
	call	?RemoveAllItems@CBasePlayer@@QAEXHH@Z	; CBasePlayer::RemoveAllItems
$L42136:

; 5364 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CStripWeapons@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CStripWeapons::Use
_TEXT	ENDS
;	COMDAT _$E62
_TEXT	SEGMENT
_$E62	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E61
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E62	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCRevertSaved@@@@QAE@PBD@Z	; CEntityFactory<CRevertSaved>::CEntityFactory<CRevertSaved>
PUBLIC	??_C@_0BB@IBM@player_loadsaved?$AA@		; `string'
_BSS	SEGMENT
_player_loadsaved DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BB@IBM@player_loadsaved?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0BB@IBM@player_loadsaved?$AA@ DB 'player_loadsaved', 00H ; `string'
CONST	ENDS
;	COMDAT _$E61
_TEXT	SEGMENT
_$E61	PROC NEAR					; COMDAT

; 5393 : LINK_ENTITY_TO_CLASS( player_loadsaved, CRevertSaved );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BB@IBM@player_loadsaved?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_player_loadsaved
	call	??0?$CEntityFactory@VCRevertSaved@@@@QAE@PBD@Z ; CEntityFactory<CRevertSaved>::CEntityFactory<CRevertSaved>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E61	ENDP
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CRevertSaved@@UAEPAUdatamap_s@@XZ ; CRevertSaved::GetDataDescMap
;	COMDAT ?GetDataDescMap@CRevertSaved@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CRevertSaved@@UAEPAUdatamap_s@@XZ PROC NEAR ; CRevertSaved::GetDataDescMap, COMDAT

; 5395 : BEGIN_DATADESC( CRevertSaved )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CRevertSaved@@2Udatamap_s@@A ; CRevertSaved::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CRevertSaved@@UAEPAUdatamap_s@@XZ ENDP	; CRevertSaved::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CRevertSaved@@SAPAUdatamap_s@@XZ	; CRevertSaved::GetBaseMap
PUBLIC	?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
;	COMDAT ?GetBaseMap@CRevertSaved@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
_pResult$ = -4
?GetBaseMap@CRevertSaved@@SAPAUdatamap_s@@XZ PROC NEAR	; CRevertSaved::GetBaseMap, COMDAT

; 5395 : BEGIN_DATADESC( CRevertSaved )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	lea	eax, DWORD PTR _pResult$[ebp]
	push	eax
	push	0
	call	?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z ; DataMapAccess
	add	esp, 8
	mov	eax, DWORD PTR _pResult$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CRevertSaved@@SAPAUdatamap_s@@XZ ENDP	; CRevertSaved::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E65
_TEXT	SEGMENT
_$E65	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E64
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E65	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z ; DataMapInit
;	COMDAT _$E64
_TEXT	SEGMENT
_$E64	PROC NEAR					; COMDAT

; 5395 : BEGIN_DATADESC( CRevertSaved )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CRevertSaved_DataDescInit@@3PAUdatamap_s@@A, eax ; CRevertSaved_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E64	ENDP
_TEXT	ENDS
PUBLIC	?MessageThink@CRevertSaved@@QAEXXZ		; CRevertSaved::MessageThink
PUBLIC	?LoadThink@CRevertSaved@@QAEXXZ			; CRevertSaved::LoadThink
PUBLIC	??_C@_0N@PMMA@MessageThink?$AA@			; `string'
PUBLIC	??_C@_09FGAG@LoadThink?$AA@			; `string'
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0N@PMMA@MessageThink?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0N@PMMA@MessageThink?$AA@ DB 'MessageThink', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09FGAG@LoadThink?$AA@
CONST	SEGMENT
??_C@_09FGAG@LoadThink?$AA@ DB 'LoadThink', 00H		; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z PROC NEAR ; DataMapInit, COMDAT

; 5395 : BEGIN_DATADESC( CRevertSaved )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L42274
	mov	cl, BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0N@PJHA@CRevertSaved?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E68
	call	_atexit
	add	esp, 4
$L42274:
	call	?GetBaseMap@CRevertSaved@@SAPAUdatamap_s@@XZ ; CRevertSaved::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CRevertSaved@@2Udatamap_s@@A+12, eax

; 5396 : 	DEFINE_FIELD( m_messageTime, FIELD_FLOAT ),	// These are not actual times, but durations, so save as floats
; 5397 : 	DEFINE_FIELD( m_loadTime, FIELD_FLOAT ),
; 5398 : 	DEFINE_FUNCTION( MessageThink ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L42284
	mov	al, BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S67@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0N@PMMA@MessageThink?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+76, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+80, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+84, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+86, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+88, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+92, OFFSET FLAT:?MessageThink@CRevertSaved@@QAEXXZ ; CRevertSaved::MessageThink

; 5399 : 	DEFINE_FUNCTION( LoadThink ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+96, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_09FGAG@LoadThink?$AA@	; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+100, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+104, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+108, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+110, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+112, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+116, OFFSET FLAT:?LoadThink@CRevertSaved@@QAEXXZ ; CRevertSaved::LoadThink
$L42284:

; 5400 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L42291
	mov	DWORD PTR ?m_DataMap@CRevertSaved@@2Udatamap_s@@A+4, 4
	mov	DWORD PTR ?m_DataMap@CRevertSaved@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L42292
$L42291:
	mov	DWORD PTR ?m_DataMap@CRevertSaved@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CRevertSaved@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4PAUtypedescription_s@@A
$L42292:
	mov	eax, OFFSET FLAT:?m_DataMap@CRevertSaved@@2Udatamap_s@@A ; CRevertSaved::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z ENDP	; DataMapInit
_TEXT	ENDS
;	COMDAT _$E68
_TEXT	SEGMENT
_$E68	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCRevertSaved@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E68	ENDP
_TEXT	ENDS
PUBLIC	?KeyValue@CRevertSaved@@UAEXPAUKeyValueData_s@@@Z ; CRevertSaved::KeyValue
PUBLIC	?SetDuration@CRevertSaved@@QAEXM@Z		; CRevertSaved::SetDuration
PUBLIC	?SetHoldTime@CRevertSaved@@QAEXM@Z		; CRevertSaved::SetHoldTime
PUBLIC	?SetMessageTime@CRevertSaved@@QAEXM@Z		; CRevertSaved::SetMessageTime
PUBLIC	?SetLoadTime@CRevertSaved@@QAEXM@Z		; CRevertSaved::SetLoadTime
PUBLIC	??_C@_08OIHC@duration?$AA@			; `string'
PUBLIC	??_C@_08GFEH@holdtime?$AA@			; `string'
PUBLIC	??_C@_0M@LJDP@messagetime?$AA@			; `string'
PUBLIC	??_C@_08CLNM@loadtime?$AA@			; `string'
PUBLIC	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
EXTRN	_atof:NEAR
;	COMDAT ??_C@_08OIHC@duration?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_08OIHC@duration?$AA@ DB 'duration', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GFEH@holdtime?$AA@
CONST	SEGMENT
??_C@_08GFEH@holdtime?$AA@ DB 'holdtime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJDP@messagetime?$AA@
CONST	SEGMENT
??_C@_0M@LJDP@messagetime?$AA@ DB 'messagetime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLNM@loadtime?$AA@
CONST	SEGMENT
??_C@_08CLNM@loadtime?$AA@ DB 'loadtime', 00H		; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CRevertSaved@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_pkvd$ = 8
_this$ = -4
?KeyValue@CRevertSaved@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CRevertSaved::KeyValue, COMDAT

; 5403 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5404 : 	if (FStrEq(pkvd->szKeyName, "duration"))

	push	OFFSET FLAT:??_C@_08OIHC@duration?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L42298

; 5406 : 		SetDuration( atof(pkvd->szValue) );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atof
	add	esp, 4
	fst	DWORD PTR -8+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetDuration@CRevertSaved@@QAEXM@Z	; CRevertSaved::SetDuration

; 5407 : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 5409 : 	else if (FStrEq(pkvd->szKeyName, "holdtime"))

	jmp	$L42309
$L42298:
	push	OFFSET FLAT:??_C@_08GFEH@holdtime?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L42301

; 5411 : 		SetHoldTime( atof(pkvd->szValue) );

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_atof
	add	esp, 4
	fst	DWORD PTR -12+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetHoldTime@CRevertSaved@@QAEXM@Z	; CRevertSaved::SetHoldTime

; 5412 : 		pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 5414 : 	else if (FStrEq(pkvd->szKeyName, "messagetime"))

	jmp	$L42309
$L42301:
	push	OFFSET FLAT:??_C@_0M@LJDP@messagetime?$AA@ ; `string'
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L42304

; 5416 : 		SetMessageTime( atof(pkvd->szValue) );

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_atof
	add	esp, 4
	fst	DWORD PTR -16+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetMessageTime@CRevertSaved@@QAEXM@Z	; CRevertSaved::SetMessageTime

; 5417 : 		pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 5419 : 	else if (FStrEq(pkvd->szKeyName, "loadtime"))

	jmp	SHORT $L42309
$L42304:
	push	OFFSET FLAT:??_C@_08CLNM@loadtime?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L42307

; 5421 : 		SetLoadTime( atof(pkvd->szValue) );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atof
	add	esp, 4
	fst	DWORD PTR -20+[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLoadTime@CRevertSaved@@QAEXM@Z	; CRevertSaved::SetLoadTime

; 5422 : 		pkvd->fHandled = TRUE;

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 5424 : 	else

	jmp	SHORT $L42309
$L42307:

; 5425 : 		CPointEntity::KeyValue( pkvd );

	mov	edx, DWORD PTR _pkvd$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ; CBaseEntity::KeyValue
$L42309:

; 5426 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CRevertSaved@@UAEXPAUKeyValueData_s@@@Z ENDP	; CRevertSaved::KeyValue
_TEXT	ENDS
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_08IDGH@movewith?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	??_C@_05JCDO@style?$AA@				; `string'
PUBLIC	??_C@_0L@MCHI@reflection?$AA@			; `string'
PUBLIC	??_C@_0N@DCCA@vlight_cache?$AA@			; `string'
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
;	COMDAT ??_C@_06FOPF@parent?$AA@
; File z:\xashxtsrc\server\cbase.h
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT
??_C@_08IDGH@movewith?$AA@ DB 'movewith', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT
??_C@_05JCDO@style?$AA@ DB 'style', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT
??_C@_0L@MCHI@reflection?$AA@ DB 'reflection', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT
??_C@_0N@DCCA@vlight_cache?$AA@ DB 'vlight_cache', 00H	; `string'
CONST	ENDS
;	COMDAT ?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pkvd$ = 8
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z PROC NEAR ; CBaseEntity::KeyValue, COMDAT

; 328  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 		// get support for spirit field too
; 330  : 		if( FStrEq( pkvd->szKeyName, "parent" ) || FStrEq( pkvd->szKeyName, "movewith" ))

	push	OFFSET FLAT:??_C@_06FOPF@parent?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	jne	SHORT $L34875
	push	OFFSET FLAT:??_C@_08IDGH@movewith?$AA@	; `string'
	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34874
$L34875:

; 332  : 			m_iParent = ALLOC_STRING(pkvd->szValue);

	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+172], eax

; 333  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 335  : 		else if( FStrEq( pkvd->szKeyName, "parentflags" ))

	jmp	$L34896
$L34874:
	push	OFFSET FLAT:??_C@_0M@FCIN@parentflags?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34879

; 337  : 			m_iParentFlags = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+176], eax

; 338  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 340  : 		else if( FStrEq( pkvd->szKeyName, "style" ))

	jmp	$L34896
$L34879:
	push	OFFSET FLAT:??_C@_05JCDO@style?$AA@	; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34882

; 342  : 			m_iStyle = Q_atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 343  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 345  : 		else if( FStrEq( pkvd->szKeyName, "reflection" ))

	jmp	$L34896
$L34882:
	push	OFFSET FLAT:??_C@_0L@MCHI@reflection?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34885

; 348  : 			{

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR -8+[ebp], eax
	cmp	DWORD PTR -8+[ebp], 1
	je	SHORT $L34891
	cmp	DWORD PTR -8+[ebp], 2
	je	SHORT $L34892
	jmp	SHORT $L34888
$L34891:

; 349  : 			case 1: pev->effects |= EF_NOREFLECT; break;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+280]
	or	eax, 16777216				; 01000000H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+280], eax
	jmp	SHORT $L34888
$L34892:

; 350  : 			case 2: pev->effects |= EF_REFLECTONLY; break;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L34888:

; 352  : 			pkvd->fHandled = TRUE;

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [edx+12], 1

; 354  : 		else if( FStrEq(pkvd->szKeyName, "vlight_cache"))

	jmp	SHORT $L34896
$L34885:
	push	OFFSET FLAT:??_C@_0N@DCCA@vlight_cache?$AA@ ; `string'
	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	test	eax, eax
	je	SHORT $L34894

; 356  : 			pev->iuser3 = atoi( pkvd->szValue );

	mov	edx, DWORD PTR _pkvd$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+588], eax

; 357  : 			pkvd->fHandled = TRUE;

	mov	eax, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [eax+12], 1

; 359  : 		else pkvd->fHandled = FALSE;

	jmp	SHORT $L34896
$L34894:
	mov	ecx, DWORD PTR _pkvd$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L34896:

; 360  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z ENDP	; CBaseEntity::KeyValue
_TEXT	ENDS
;	COMDAT ?SetDuration@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT
_duration$ = 8
_this$ = -4
?SetDuration@CRevertSaved@@QAEXM@Z PROC NEAR		; CRevertSaved::SetDuration, COMDAT

; 5383 : 	inline	void	SetDuration( float duration ) { pev->dmg_take = duration; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _duration$[ebp]
	mov	DWORD PTR [ecx+472], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetDuration@CRevertSaved@@QAEXM@Z ENDP			; CRevertSaved::SetDuration
_TEXT	ENDS
;	COMDAT ?SetHoldTime@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT
_hold$ = 8
_this$ = -4
?SetHoldTime@CRevertSaved@@QAEXM@Z PROC NEAR		; CRevertSaved::SetHoldTime, COMDAT

; 5384 : 	inline	void	SetHoldTime( float hold ) { pev->dmg_save = hold; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _hold$[ebp]
	mov	DWORD PTR [ecx+476], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetHoldTime@CRevertSaved@@QAEXM@Z ENDP			; CRevertSaved::SetHoldTime
_TEXT	ENDS
;	COMDAT ?SetMessageTime@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT
_time$ = 8
_this$ = -4
?SetMessageTime@CRevertSaved@@QAEXM@Z PROC NEAR		; CRevertSaved::SetMessageTime, COMDAT

; 5385 : 	inline	void	SetMessageTime( float time ) { m_messageTime = time; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+1764], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetMessageTime@CRevertSaved@@QAEXM@Z ENDP		; CRevertSaved::SetMessageTime
_TEXT	ENDS
;	COMDAT ?SetLoadTime@CRevertSaved@@QAEXM@Z
_TEXT	SEGMENT
_time$ = 8
_this$ = -4
?SetLoadTime@CRevertSaved@@QAEXM@Z PROC NEAR		; CRevertSaved::SetLoadTime, COMDAT

; 5386 : 	inline	void	SetLoadTime( float time ) { m_loadTime = time; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _time$[ebp]
	mov	DWORD PTR [eax+1768], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLoadTime@CRevertSaved@@QAEXM@Z ENDP			; CRevertSaved::SetLoadTime
_TEXT	ENDS
PUBLIC	?Use@CRevertSaved@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CRevertSaved::Use
PUBLIC	?Duration@CRevertSaved@@QAEMXZ			; CRevertSaved::Duration
PUBLIC	?HoldTime@CRevertSaved@@QAEMXZ			; CRevertSaved::HoldTime
PUBLIC	?MessageTime@CRevertSaved@@QAEMXZ		; CRevertSaved::MessageTime
EXTRN	?UTIL_ScreenFadeAll@@YAXABVVector@@MMHH@Z:NEAR	; UTIL_ScreenFadeAll
;	COMDAT ?Use@CRevertSaved@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
?Use@CRevertSaved@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CRevertSaved::Use, COMDAT

; 5429 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5430 : 	UTIL_ScreenFadeAll( pev->rendercolor, Duration(), HoldTime(), pev->renderamt, FFADE_OUT );

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+332]
	call	__ftol
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HoldTime@CRevertSaved@@QAEMXZ		; CRevertSaved::HoldTime
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Duration@CRevertSaved@@QAEMXZ		; CRevertSaved::Duration
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 336				; 00000150H
	push	eax
	call	?UTIL_ScreenFadeAll@@YAXABVVector@@MMHH@Z ; UTIL_ScreenFadeAll
	add	esp, 20					; 00000014H

; 5431 : 	pev->nextthink = gpGlobals->time + MessageTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MessageTime@CRevertSaved@@QAEMXZ	; CRevertSaved::MessageTime
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]

; 5432 : 	SetThink( MessageThink );

	push	OFFSET FLAT:??_C@_0N@PMMA@MessageThink?$AA@ ; `string'
	push	OFFSET FLAT:?MessageThink@CRevertSaved@@QAEXXZ ; CRevertSaved::MessageThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 5433 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CRevertSaved@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CRevertSaved::Use
_TEXT	ENDS
;	COMDAT ?Duration@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?Duration@CRevertSaved@@QAEMXZ PROC NEAR		; CRevertSaved::Duration, COMDAT

; 5378 : 	inline	float	Duration( void ) { return pev->dmg_take; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+472]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Duration@CRevertSaved@@QAEMXZ ENDP			; CRevertSaved::Duration
_TEXT	ENDS
;	COMDAT ?HoldTime@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?HoldTime@CRevertSaved@@QAEMXZ PROC NEAR		; CRevertSaved::HoldTime, COMDAT

; 5379 : 	inline	float	HoldTime( void ) { return pev->dmg_save; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+476]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HoldTime@CRevertSaved@@QAEMXZ ENDP			; CRevertSaved::HoldTime
_TEXT	ENDS
;	COMDAT ?MessageTime@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?MessageTime@CRevertSaved@@QAEMXZ PROC NEAR		; CRevertSaved::MessageTime, COMDAT

; 5380 : 	inline	float	MessageTime( void ) { return m_messageTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MessageTime@CRevertSaved@@QAEMXZ ENDP			; CRevertSaved::MessageTime
_TEXT	ENDS
PUBLIC	?LoadTime@CRevertSaved@@QAEMXZ			; CRevertSaved::LoadTime
EXTRN	?UTIL_ShowMessageAll@@YAXPBD@Z:NEAR		; UTIL_ShowMessageAll
;	COMDAT ?MessageThink@CRevertSaved@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_nextThink$ = -8
?MessageThink@CRevertSaved@@QAEXXZ PROC NEAR		; CRevertSaved::MessageThink, COMDAT

; 5437 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5438 : 	UTIL_ShowMessageAll( STRING(pev->message) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+468]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?UTIL_ShowMessageAll@@YAXPBD@Z		; UTIL_ShowMessageAll
	add	esp, 4

; 5439 : 	float nextThink = LoadTime() - MessageTime();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadTime@CRevertSaved@@QAEMXZ		; CRevertSaved::LoadTime
	fstp	DWORD PTR -12+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MessageTime@CRevertSaved@@QAEMXZ	; CRevertSaved::MessageTime
	fsubr	DWORD PTR -12+[ebp]
	fstp	DWORD PTR _nextThink$[ebp]

; 5440 : 	if ( nextThink > 0 )

	fld	DWORD PTR _nextThink$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L42324

; 5442 : 		pev->nextthink = gpGlobals->time + nextThink;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _nextThink$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 5443 : 		SetThink( LoadThink );

	push	OFFSET FLAT:??_C@_09FGAG@LoadThink?$AA@	; `string'
	push	OFFSET FLAT:?LoadThink@CRevertSaved@@QAEXXZ ; CRevertSaved::LoadThink
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z ; CBaseEntity::ThinkSet

; 5445 : 	else

	jmp	SHORT $L42327
$L42324:

; 5446 : 		LoadThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadThink@CRevertSaved@@QAEXXZ		; CRevertSaved::LoadThink
$L42327:

; 5447 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MessageThink@CRevertSaved@@QAEXXZ ENDP			; CRevertSaved::MessageThink
_TEXT	ENDS
;	COMDAT ?LoadTime@CRevertSaved@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4
?LoadTime@CRevertSaved@@QAEMXZ PROC NEAR		; CRevertSaved::LoadTime, COMDAT

; 5381 : 	inline	float	LoadTime( void ) { return m_loadTime; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1768]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadTime@CRevertSaved@@QAEMXZ ENDP			; CRevertSaved::LoadTime
_TEXT	ENDS
PUBLIC	??_C@_07MPIK@reload?6?$AA@			; `string'
;	COMDAT ??_C@_07MPIK@reload?6?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_07MPIK@reload?6?$AA@ DB 'reload', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ?LoadThink@CRevertSaved@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?LoadThink@CRevertSaved@@QAEXXZ PROC NEAR		; CRevertSaved::LoadThink, COMDAT

; 5451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5452 : 	if ( !gpGlobals->deathmatch )

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+20]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L42332

; 5454 : 		SERVER_COMMAND("reload\n");

	push	OFFSET FLAT:??_C@_07MPIK@reload?6?$AA@	; `string'
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+156
	add	esp, 4
$L42332:

; 5456 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadThink@CRevertSaved@@QAEXXZ ENDP			; CRevertSaved::LoadThink
_TEXT	ENDS
PUBLIC	?Spawn@CInfoIntermission@@UAEXXZ		; CInfoIntermission::Spawn
;	COMDAT ?Spawn@CInfoIntermission@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CInfoIntermission@@UAEXXZ PROC NEAR		; CInfoIntermission::Spawn, COMDAT

; 5471 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5472 : 	pev->solid = SOLID_NOT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+268], 0

; 5473 : 	pev->effects = EF_NODRAW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+280], 128		; 00000080H

; 5474 : 	pev->v_angle = g_vecZero;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax

; 5475 : 
; 5476 : 	pev->nextthink = gpGlobals->time + 2;// let targets spawn!

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR __real@4@40008000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+260]

; 5477 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CInfoIntermission@@UAEXXZ ENDP			; CInfoIntermission::Spawn
_TEXT	ENDS
PUBLIC	?Think@CInfoIntermission@@UAEXXZ		; CInfoIntermission::Think
;	COMDAT ?Think@CInfoIntermission@@UAEXXZ
_TEXT	SEGMENT
$T44349 = -20
$T44350 = -32
$T44351 = -44
_this$ = -4
_pTarget$ = -8
?Think@CInfoIntermission@@UAEXXZ PROC NEAR		; CInfoIntermission::Think, COMDAT

; 5480 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5481 : 	CBaseEntity *pTarget;
; 5482 : 
; 5483 : 	// find my target
; 5484 : 	pTarget = UTIL_FindEntityByTargetname( NULL, STRING(pev->target) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 5485 : 
; 5486 : 	if ( !FNullEnt(pTarget) )

	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?FNullEnt@@YAHPAVCBaseEntity@@@Z	; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L42363

; 5488 : 		pev->v_angle = UTIL_VecToAngles( (pTarget->GetAbsOrigin() - GetAbsOrigin()).Normalize() );

	lea	ecx, DWORD PTR $T44350[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T44349[ebp]
	push	edx
	mov	ecx, DWORD PTR _pTarget$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	lea	eax, DWORD PTR $T44351[ebp]
	push	eax
	call	?UTIL_VecToAngles@@YA?AVVector@@ABV1@@Z	; UTIL_VecToAngles
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 116				; 00000074H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L42363:

; 5490 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CInfoIntermission@@UAEXXZ ENDP			; CInfoIntermission::Think
_TEXT	ENDS
;	COMDAT _$E70
_TEXT	SEGMENT
_$E70	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E69
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E70	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCInfoIntermission@@@@QAE@PBD@Z ; CEntityFactory<CInfoIntermission>::CEntityFactory<CInfoIntermission>
_BSS	SEGMENT
	ALIGN	4

_info_intermission DD 01H DUP (?)
_BSS	ENDS
;	COMDAT _$E69
_TEXT	SEGMENT
_$E69	PROC NEAR					; COMDAT

; 5492 : LINK_ENTITY_TO_CLASS( info_intermission, CInfoIntermission );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0BC@FEBM@info_intermission?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_info_intermission
	call	??0?$CEntityFactory@VCInfoIntermission@@@@QAE@PBD@Z ; CEntityFactory<CInfoIntermission>::CEntityFactory<CInfoIntermission>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E69	ENDP
_TEXT	ENDS
;	COMDAT _$E73
_TEXT	SEGMENT
_$E73	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E72
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E73	ENDP
_TEXT	ENDS
PUBLIC	??0?$CEntityFactory@VCHudSprite@@@@QAE@PBD@Z	; CEntityFactory<CHudSprite>::CEntityFactory<CHudSprite>
PUBLIC	??_C@_0L@PGFC@hud_sprite?$AA@			; `string'
_BSS	SEGMENT
_hud_sprite DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@PGFC@hud_sprite?$AA@
; File z:\xashxtsrc\server\player.cpp
CONST	SEGMENT
??_C@_0L@PGFC@hud_sprite?$AA@ DB 'hud_sprite', 00H	; `string'
CONST	ENDS
;	COMDAT _$E72
_TEXT	SEGMENT
_$E72	PROC NEAR					; COMDAT

; 5506 : LINK_ENTITY_TO_CLASS( hud_sprite, CHudSprite );

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:??_C@_0L@PGFC@hud_sprite?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_hud_sprite
	call	??0?$CEntityFactory@VCHudSprite@@@@QAE@PBD@Z ; CEntityFactory<CHudSprite>::CEntityFactory<CHudSprite>
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E72	ENDP
_TEXT	ENDS
PUBLIC	?Spawn@CHudSprite@@UAEXXZ			; CHudSprite::Spawn
;	COMDAT ?Spawn@CHudSprite@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CHudSprite@@UAEXXZ PROC NEAR			; CHudSprite::Spawn, COMDAT

; 5509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5510 : 	if( g_pGameRules->IsMultiplayer( ))

	mov	eax, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?g_pGameRules@@3PAVCGameRules@@A ; g_pGameRules
	call	DWORD PTR [edx+24]
	test	eax, eax
	je	SHORT $L42450

; 5512 : 		REMOVE_ENTITY( edict() );	// only in single

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+88
	add	esp, 4

; 5513 : 		return;

	jmp	SHORT $L42449
$L42450:

; 5515 : 
; 5516 : 	if( FStringNull( pev->targetname ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L42451

; 5518 : 		SetBits( pev->spawnflags, SF_HUDSPR_ACTIVE );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	or	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx
$L42451:
$L42449:

; 5520 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CHudSprite@@UAEXXZ ENDP				; CHudSprite::Spawn
_TEXT	ENDS
PUBLIC	?StartMessage@CHudSprite@@UAEXPAVCBasePlayer@@@Z ; CHudSprite::StartMessage
;	COMDAT ?StartMessage@CHudSprite@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_pPlayer$ = 8
_this$ = -4
?StartMessage@CHudSprite@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CHudSprite::StartMessage, COMDAT

; 5523 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5524 : 	if( GetState() == STATE_OFF ) return; // inactive

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	test	eax, eax
	jne	SHORT $L42456
	jmp	$L42455
$L42456:

; 5525 : 
; 5526 : 	MESSAGE_BEGIN( MSG_ONE, gmsgStatusIcon, NULL, pPlayer->pev );

	mov	eax, DWORD PTR _pPlayer$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR ?gmsgStatusIcon@@3HA	; gmsgStatusIcon
	push	edx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 5527 : 		WRITE_BYTE( GetState() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5528 : 		WRITE_STRING( STRING( pev->model ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 5529 : 		WRITE_BYTE( pev->rendercolor.x );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+336]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5530 : 		WRITE_BYTE( pev->rendercolor.y );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+340]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5531 : 		WRITE_BYTE( pev->rendercolor.z );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+344]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5532 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L42455:

; 5533 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CHudSprite@@UAEXPAVCBasePlayer@@@Z ENDP	; CHudSprite::StartMessage
_TEXT	ENDS
PUBLIC	?Use@CHudSprite@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; CHudSprite::Use
EXTRN	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z:NEAR ; CBaseEntity::ShouldToggle
;	COMDAT ?Use@CHudSprite@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 16
_this$ = -4
?Use@CHudSprite@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z PROC NEAR ; CHudSprite::Use, COMDAT

; 5536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 5537 : 	if( !pActivator || !pActivator->IsPlayer( ))

	cmp	DWORD PTR _pActivator$[ebp], 0
	je	SHORT $L42465
	mov	eax, DWORD PTR _pActivator$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pActivator$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	jne	SHORT $L42464
$L42465:

; 5539 : 		pActivator = UTIL_PlayerByIndex( 1 );

	push	1
	call	?UTIL_PlayerByIndex@@YAPAVCBaseEntity@@H@Z ; UTIL_PlayerByIndex
	add	esp, 4
	mov	DWORD PTR _pActivator$[ebp], eax
$L42464:

; 5541 : 
; 5542 : 	if( ShouldToggle( useType ))

	mov	eax, DWORD PTR _useType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ; CBaseEntity::ShouldToggle
	test	eax, eax
	je	SHORT $L42468

; 5544 : 		if( FBitSet( pev->spawnflags, SF_HUDSPR_ACTIVE ))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	eax, 1
	test	eax, eax
	je	SHORT $L42467

; 5545 : 			ClearBits( pev->spawnflags, SF_HUDSPR_ACTIVE );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+416]
	and	al, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+416], eax

; 5546 : 		else SetBits( pev->spawnflags, SF_HUDSPR_ACTIVE );

	jmp	SHORT $L42468
$L42467:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+416]
	or	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+416], edx
$L42468:

; 5548 : 
; 5549 : 	MESSAGE_BEGIN( MSG_ONE, gmsgStatusIcon, NULL, pActivator->pev );

	mov	edx, DWORD PTR _pActivator$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR ?gmsgStatusIcon@@3HA	; gmsgStatusIcon
	push	ecx
	push	1
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUentvars_s@@@Z ; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 5550 : 		WRITE_BYTE( GetState() );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+88]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5551 : 		WRITE_STRING( STRING( pev->model ));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+184]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+216
	add	esp, 4

; 5552 : 		WRITE_BYTE( pev->rendercolor.x );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+336]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5553 : 		WRITE_BYTE( pev->rendercolor.y );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+340]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5554 : 		WRITE_BYTE( pev->rendercolor.z );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+344]
	call	__ftol
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+192
	add	esp, 4

; 5555 : 	MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 5556 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CHudSprite@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z ENDP ; CHudSprite::Use
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCBasePlayer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CBasePlayer>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCBasePlayer@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CBasePlayer>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCBasePlayer@@@@UAEIXZ ; CEntityFactory<CBasePlayer>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCBasePlayer@@@@6B@	; CEntityFactory<CBasePlayer>::`vftable'
PUBLIC	??0IEntityFactory@@QAE@XZ			; IEntityFactory::IEntityFactory
EXTRN	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ:NEAR ; EntityFactoryDictionary
;	COMDAT ??_7?$CEntityFactory@VCBasePlayer@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCBasePlayer@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCBasePlayer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CBasePlayer>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCBasePlayer@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCBasePlayer@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCBasePlayer@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCBasePlayer@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CBasePlayer>::CEntityFactory<CBasePlayer>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCBasePlayer@@@@6B@ ; CEntityFactory<CBasePlayer>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCBasePlayer@@@@QAE@PBD@Z ENDP	; CEntityFactory<CBasePlayer>::CEntityFactory<CBasePlayer>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCBasePlayer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCBasePlayer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CBasePlayer>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCBasePlayer@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CBasePlayer>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCBasePlayer@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCBasePlayer@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CBasePlayer>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCBasePlayer@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CBasePlayer>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCBasePlayer@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCBasePlayer@@@@UAEIXZ PROC NEAR ; CEntityFactory<CBasePlayer>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 4224				; 00001080H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCBasePlayer@@@@UAEIXZ ENDP ; CEntityFactory<CBasePlayer>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCDeadHEV@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CDeadHEV>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCDeadHEV@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CDeadHEV>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCDeadHEV@@@@UAEIXZ ; CEntityFactory<CDeadHEV>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCDeadHEV@@@@6B@		; CEntityFactory<CDeadHEV>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCDeadHEV@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCDeadHEV@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCDeadHEV@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CDeadHEV>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCDeadHEV@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCDeadHEV@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCDeadHEV@@@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4
_pClassName$ = 8
??0?$CEntityFactory@VCDeadHEV@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CDeadHEV>::CEntityFactory<CDeadHEV>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCDeadHEV@@@@6B@ ; CEntityFactory<CDeadHEV>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCDeadHEV@@@@QAE@PBD@Z ENDP		; CEntityFactory<CDeadHEV>::CEntityFactory<CDeadHEV>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z		; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCDeadHEV@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEnt$ = -8
_pClassName$ = 8
_pev$ = 12
?Create@?$CEntityFactory@VCDeadHEV@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CDeadHEV>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z	; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCDeadHEV@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CDeadHEV>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCDeadHEV@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = 8
?Destroy@?$CEntityFactory@VCDeadHEV@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CDeadHEV>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCDeadHEV@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CDeadHEV>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCDeadHEV@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCDeadHEV@@@@UAEIXZ PROC NEAR ; CEntityFactory<CDeadHEV>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 2400				; 00000960H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCDeadHEV@@@@UAEIXZ ENDP ; CEntityFactory<CDeadHEV>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CPlayerKeyCatcher>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CPlayerKeyCatcher>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEIXZ ; CEntityFactory<CPlayerKeyCatcher>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCPlayerKeyCatcher@@@@6B@	; CEntityFactory<CPlayerKeyCatcher>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCPlayerKeyCatcher@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCPlayerKeyCatcher@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CPlayerKeyCatcher>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCPlayerKeyCatcher@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCPlayerKeyCatcher@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CPlayerKeyCatcher>::CEntityFactory<CPlayerKeyCatcher>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCPlayerKeyCatcher@@@@6B@ ; CEntityFactory<CPlayerKeyCatcher>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCPlayerKeyCatcher@@@@QAE@PBD@Z ENDP ; CEntityFactory<CPlayerKeyCatcher>::CEntityFactory<CPlayerKeyCatcher>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z ; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CPlayerKeyCatcher>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CPlayerKeyCatcher>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CPlayerKeyCatcher>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CPlayerKeyCatcher>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEIXZ PROC NEAR ; CEntityFactory<CPlayerKeyCatcher>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1804				; 0000070cH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCPlayerKeyCatcher@@@@UAEIXZ ENDP ; CEntityFactory<CPlayerKeyCatcher>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCStripWeapons@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CStripWeapons>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCStripWeapons@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CStripWeapons>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCStripWeapons@@@@UAEIXZ ; CEntityFactory<CStripWeapons>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCStripWeapons@@@@6B@	; CEntityFactory<CStripWeapons>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCStripWeapons@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCStripWeapons@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCStripWeapons@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CStripWeapons>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCStripWeapons@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCStripWeapons@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCStripWeapons@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCStripWeapons@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CStripWeapons>::CEntityFactory<CStripWeapons>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCStripWeapons@@@@6B@ ; CEntityFactory<CStripWeapons>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCStripWeapons@@@@QAE@PBD@Z ENDP	; CEntityFactory<CStripWeapons>::CEntityFactory<CStripWeapons>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCStripWeapons@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCStripWeapons@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CStripWeapons>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCStripWeapons@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CStripWeapons>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCStripWeapons@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCStripWeapons@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CStripWeapons>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCStripWeapons@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CStripWeapons>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCStripWeapons@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCStripWeapons@@@@UAEIXZ PROC NEAR ; CEntityFactory<CStripWeapons>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCStripWeapons@@@@UAEIXZ ENDP ; CEntityFactory<CStripWeapons>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCRevertSaved@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CRevertSaved>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCRevertSaved@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CRevertSaved>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCRevertSaved@@@@UAEIXZ ; CEntityFactory<CRevertSaved>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCRevertSaved@@@@6B@	; CEntityFactory<CRevertSaved>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCRevertSaved@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCRevertSaved@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCRevertSaved@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CRevertSaved>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCRevertSaved@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCRevertSaved@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCRevertSaved@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCRevertSaved@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CRevertSaved>::CEntityFactory<CRevertSaved>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCRevertSaved@@@@6B@ ; CEntityFactory<CRevertSaved>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCRevertSaved@@@@QAE@PBD@Z ENDP	; CEntityFactory<CRevertSaved>::CEntityFactory<CRevertSaved>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCRevertSaved@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCRevertSaved@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CRevertSaved>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCRevertSaved@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CRevertSaved>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCRevertSaved@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCRevertSaved@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CRevertSaved>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCRevertSaved@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CRevertSaved>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCRevertSaved@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCRevertSaved@@@@UAEIXZ PROC NEAR ; CEntityFactory<CRevertSaved>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1772				; 000006ecH

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCRevertSaved@@@@UAEIXZ ENDP ; CEntityFactory<CRevertSaved>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCInfoIntermission@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CInfoIntermission>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCInfoIntermission@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CInfoIntermission>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCInfoIntermission@@@@UAEIXZ ; CEntityFactory<CInfoIntermission>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCInfoIntermission@@@@6B@	; CEntityFactory<CInfoIntermission>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCInfoIntermission@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCInfoIntermission@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCInfoIntermission@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CInfoIntermission>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCInfoIntermission@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCInfoIntermission@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCInfoIntermission@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCInfoIntermission@@@@QAE@PBD@Z PROC NEAR ; CEntityFactory<CInfoIntermission>::CEntityFactory<CInfoIntermission>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCInfoIntermission@@@@6B@ ; CEntityFactory<CInfoIntermission>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCInfoIntermission@@@@QAE@PBD@Z ENDP ; CEntityFactory<CInfoIntermission>::CEntityFactory<CInfoIntermission>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z ; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCInfoIntermission@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCInfoIntermission@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CInfoIntermission>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCInfoIntermission@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CInfoIntermission>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCInfoIntermission@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCInfoIntermission@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CInfoIntermission>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCInfoIntermission@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CInfoIntermission>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCInfoIntermission@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCInfoIntermission@@@@UAEIXZ PROC NEAR ; CEntityFactory<CInfoIntermission>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCInfoIntermission@@@@UAEIXZ ENDP ; CEntityFactory<CInfoIntermission>::GetEntitySize
_TEXT	ENDS
PUBLIC	?Create@?$CEntityFactory@VCHudSprite@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CHudSprite>::Create
PUBLIC	?Destroy@?$CEntityFactory@VCHudSprite@@@@UAEXPAVCBaseEntity@@@Z ; CEntityFactory<CHudSprite>::Destroy
PUBLIC	?GetEntitySize@?$CEntityFactory@VCHudSprite@@@@UAEIXZ ; CEntityFactory<CHudSprite>::GetEntitySize
PUBLIC	??_7?$CEntityFactory@VCHudSprite@@@@6B@		; CEntityFactory<CHudSprite>::`vftable'
;	COMDAT ??_7?$CEntityFactory@VCHudSprite@@@@6B@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_7?$CEntityFactory@VCHudSprite@@@@6B@ DD FLAT:?Create@?$CEntityFactory@VCHudSprite@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CEntityFactory<CHudSprite>::`vftable'
	DD	FLAT:?Destroy@?$CEntityFactory@VCHudSprite@@@@UAEXPAVCBaseEntity@@@Z
	DD	FLAT:?GetEntitySize@?$CEntityFactory@VCHudSprite@@@@UAEIXZ
CONST	ENDS
;	COMDAT ??0?$CEntityFactory@VCHudSprite@@@@QAE@PBD@Z
_TEXT	SEGMENT
_pClassName$ = 8
_this$ = -4
??0?$CEntityFactory@VCHudSprite@@@@QAE@PBD@Z PROC NEAR	; CEntityFactory<CHudSprite>::CEntityFactory<CHudSprite>, COMDAT

; 86   : 	CEntityFactory( const char *pClassName )

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IEntityFactory@@QAE@XZ		; IEntityFactory::IEntityFactory
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CEntityFactory@VCHudSprite@@@@6B@ ; CEntityFactory<CHudSprite>::`vftable'

; 87   : 	{
; 88   : 		EntityFactoryDictionary()->InstallFactory( this, pClassName );

	mov	ecx, DWORD PTR _pClassName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?EntityFactoryDictionary@@YAPAVIEntityFactoryDictionary@@XZ ; EntityFactoryDictionary
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx]

; 89   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CEntityFactory@VCHudSprite@@@@QAE@PBD@Z ENDP	; CEntityFactory<CHudSprite>::CEntityFactory<CHudSprite>
_TEXT	ENDS
PUBLIC	?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z	; GetClassPtr
;	COMDAT ?Create@?$CEntityFactory@VCHudSprite@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z
_TEXT	SEGMENT
_pClassName$ = 8
_pev$ = 12
_this$ = -4
_pEnt$ = -8
?Create@?$CEntityFactory@VCHudSprite@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z PROC NEAR ; CEntityFactory<CHudSprite>::Create, COMDAT

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		T* pEnt = GetClassPtr((T*)pev, pClassName);

	mov	eax, DWORD PTR _pClassName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z ; GetClassPtr
	add	esp, 8
	mov	DWORD PTR _pEnt$[ebp], eax

; 94   : 		return pEnt;

	mov	eax, DWORD PTR _pEnt$[ebp]

; 95   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Create@?$CEntityFactory@VCHudSprite@@@@UAEPAVCBaseEntity@@PBDPAUentvars_s@@@Z ENDP ; CEntityFactory<CHudSprite>::Create
_TEXT	ENDS
;	COMDAT ?Destroy@?$CEntityFactory@VCHudSprite@@@@UAEXPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
?Destroy@?$CEntityFactory@VCHudSprite@@@@UAEXPAVCBaseEntity@@@Z PROC NEAR ; CEntityFactory<CHudSprite>::Destroy, COMDAT

; 98   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 		UTIL_Remove( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 100  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Destroy@?$CEntityFactory@VCHudSprite@@@@UAEXPAVCBaseEntity@@@Z ENDP ; CEntityFactory<CHudSprite>::Destroy
_TEXT	ENDS
;	COMDAT ?GetEntitySize@?$CEntityFactory@VCHudSprite@@@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4
?GetEntitySize@?$CEntityFactory@VCHudSprite@@@@UAEIXZ PROC NEAR ; CEntityFactory<CHudSprite>::GetEntitySize, COMDAT

; 103  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		return sizeof(T);

	mov	eax, 1764				; 000006e4H

; 105  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetEntitySize@?$CEntityFactory@VCHudSprite@@@@UAEIXZ ENDP ; CEntityFactory<CHudSprite>::GetEntitySize
_TEXT	ENDS
PUBLIC	??_7IEntityFactory@@6B@				; IEntityFactory::`vftable'
EXTRN	__purecall:NEAR
;	COMDAT ??_7IEntityFactory@@6B@
CONST	SEGMENT
??_7IEntityFactory@@6B@ DD FLAT:__purecall		; IEntityFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??0IEntityFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0IEntityFactory@@QAE@XZ PROC NEAR			; IEntityFactory::IEntityFactory, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7IEntityFactory@@6B@ ; IEntityFactory::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0IEntityFactory@@QAE@XZ ENDP				; IEntityFactory::IEntityFactory
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L44448
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L44448
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L44448
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44448:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseMonster@@2Udatamap_s@@A:BYTE	; CBaseMonster::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseMonster@@2Udatamap_s@@A ; CBaseMonster::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseMonster@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	??0CSprayCan@@QAE@XZ				; CSprayCan::CSprayCan
PUBLIC	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z		; CBaseEntity::operator new
PUBLIC	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z		; CBaseEntity::operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z
_TEXT	SEGMENT
_a$ = 8
$T44453 = -20
$T44454 = -24
__$EHRec$ = -12
_pev$ = -16
?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z PROC NEAR		; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42609

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42609:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L42611

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44454[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44454[ebp], 0
	je	SHORT $L44455
	mov	ecx, DWORD PTR $T44454[ebp]
	call	??0CSprayCan@@QAE@XZ			; CSprayCan::CSprayCan
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44456
$L44455:
	mov	DWORD PTR -28+[ebp], 0
$L44456:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44453[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44453[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42611:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44454[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCSprayCan@@PAV1@@Z ENDP		; GetClassPtr
;	COMDAT ??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z
_TEXT	SEGMENT
_stAllocateBlock$ = 8
_pev$ = 12
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator new, COMDAT

; 489  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 490  : 		return (void *)ALLOC_PRIVATE(ENT(pev), stAllocateBlock);

	mov	eax, DWORD PTR _stAllocateBlock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+252
	add	esp, 8

; 491  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z ENDP		; CBaseEntity::operator new
_TEXT	ENDS
;	COMDAT ??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 12
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z PROC NEAR	; CBaseEntity::operator delete, COMDAT

; 496  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 497  : 		pev->flags |= FL_KILLME;

	mov	eax, DWORD PTR _pev$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+420], ecx

; 498  : 	};

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z ENDP		; CBaseEntity::operator delete
_TEXT	ENDS
PUBLIC	??0CBloodSplat@@QAE@XZ				; CBloodSplat::CBloodSplat
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z
_TEXT	SEGMENT
$T44470 = -20
$T44471 = -24
__$EHRec$ = -12
_a$ = 8
_pev$ = -16
?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z PROC NEAR	; GetClassPtr, COMDAT

; 1073 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1074 : 	entvars_t *pev = (entvars_t *)a;

	mov	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1075 : 
; 1076 : 	// allocate entity if necessary
; 1077 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42620

; 1078 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42620:

; 1079 : 
; 1080 : 	// get the private data
; 1081 : 	a = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _a$[ebp], eax

; 1082 : 
; 1083 : 	if (a == NULL) 

	cmp	DWORD PTR _a$[ebp], 0
	jne	SHORT $L42622

; 1085 : 		// allocate private data 
; 1086 : 		a = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44471[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44471[ebp], 0
	je	SHORT $L44472
	mov	ecx, DWORD PTR $T44471[ebp]
	call	??0CBloodSplat@@QAE@XZ			; CBloodSplat::CBloodSplat
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44473
$L44472:
	mov	DWORD PTR -28+[ebp], 0
$L44473:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44470[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44470[ebp]
	mov	DWORD PTR _a$[ebp], ecx

; 1087 : 		a->pev = pev;

	mov	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42622:

; 1089 : 	return a;

	mov	eax, DWORD PTR _a$[ebp]

; 1090 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44471[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCBloodSplat@@PAV1@@Z ENDP		; GetClassPtr
EXTRN	?m_DataMap@CBaseDelay@@2Udatamap_s@@A:BYTE	; CBaseDelay::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseDelay@@2Udatamap_s@@A ; CBaseDelay::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCBaseDelay@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
EXTRN	?m_DataMap@CBaseEntity@@2Udatamap_s@@A:BYTE	; CBaseEntity::m_DataMap
;	COMDAT ?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z
_TEXT	SEGMENT
_p$ = 12
?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z PROC NEAR ; DataMapAccess, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 183  : 	*p = &T::m_DataMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap

; 184  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapAccess@@YAXPAVCPointEntity@@PAPAUdatamap_s@@@Z ENDP ; DataMapAccess
_TEXT	ENDS
PUBLIC	?SetClassname@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetClassname
PUBLIC	??0CBasePlayer@@QAE@XZ				; CBasePlayer::CBasePlayer
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z
_TEXT	SEGMENT
$T44487 = -20
$T44488 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
_pev$ = -16
?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42633

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42633:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L42635

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	4224					; 00001080H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44488[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44488[ebp], 0
	je	SHORT $L44489
	mov	ecx, DWORD PTR $T44488[ebp]
	call	??0CBasePlayer@@QAE@XZ			; CBasePlayer::CBasePlayer
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44490
$L44489:
	mov	DWORD PTR -28+[ebp], 0
$L44490:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44487[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44487[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42635:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44488[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCBasePlayer@@PAV1@PBD@Z ENDP		; GetClassPtr
;	COMDAT ?SetClassname@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4
_pszClassName$ = 8
?SetClassname@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetClassname, COMDAT

; 302  : 	void		SetClassname( const char *pszClassName ) { pev->classname = MAKE_STRING( pszClassName ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pszClassName$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetClassname@CBaseEntity@@QAEXPBD@Z ENDP		; CBaseEntity::SetClassname
_TEXT	ENDS
PUBLIC	??0CDeadHEV@@QAE@XZ				; CDeadHEV::CDeadHEV
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z
_TEXT	SEGMENT
$T44502 = -20
$T44503 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
_pev$ = -16
?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42644

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42644:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L42646

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	2400					; 00000960H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44503[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44503[ebp], 0
	je	SHORT $L44504
	mov	ecx, DWORD PTR $T44503[ebp]
	call	??0CDeadHEV@@QAE@XZ			; CDeadHEV::CDeadHEV
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44505
$L44504:
	mov	DWORD PTR -28+[ebp], 0
$L44505:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44502[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44502[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42646:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44503[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCDeadHEV@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	??0CPlayerKeyCatcher@@QAE@XZ			; CPlayerKeyCatcher::CPlayerKeyCatcher
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z
_TEXT	SEGMENT
$T44515 = -20
$T44516 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
_pev$ = -16
?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42655

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42655:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L42657

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1804					; 0000070cH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44516[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44516[ebp], 0
	je	SHORT $L44517
	mov	ecx, DWORD PTR $T44516[ebp]
	call	??0CPlayerKeyCatcher@@QAE@XZ		; CPlayerKeyCatcher::CPlayerKeyCatcher
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44518
$L44517:
	mov	DWORD PTR -28+[ebp], 0
$L44518:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44515[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44515[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42657:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44516[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCPlayerKeyCatcher@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CStripWeapons@@QAE@XZ			; CStripWeapons::CStripWeapons
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z
_TEXT	SEGMENT
$T44528 = -20
$T44529 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
_pev$ = -16
?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42666

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42666:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L42668

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44529[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44529[ebp], 0
	je	SHORT $L44530
	mov	ecx, DWORD PTR $T44529[ebp]
	call	??0CStripWeapons@@QAE@XZ		; CStripWeapons::CStripWeapons
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44531
$L44530:
	mov	DWORD PTR -28+[ebp], 0
$L44531:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44528[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44528[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42668:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44529[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCStripWeapons@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CRevertSaved@@QAE@XZ				; CRevertSaved::CRevertSaved
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z
_TEXT	SEGMENT
$T44541 = -20
$T44542 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
_pev$ = -16
?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42677

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42677:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L42679

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1772					; 000006ecH
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44542[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44542[ebp], 0
	je	SHORT $L44543
	mov	ecx, DWORD PTR $T44542[ebp]
	call	??0CRevertSaved@@QAE@XZ			; CRevertSaved::CRevertSaved
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44544
$L44543:
	mov	DWORD PTR -28+[ebp], 0
$L44544:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44541[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44541[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42679:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44542[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCRevertSaved@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CInfoIntermission@@QAE@XZ			; CInfoIntermission::CInfoIntermission
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z
_TEXT	SEGMENT
$T44554 = -20
$T44555 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
_pev$ = -16
?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z PROC NEAR ; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42688

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42688:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L42690

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44555[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44555[ebp], 0
	je	SHORT $L44556
	mov	ecx, DWORD PTR $T44555[ebp]
	call	??0CInfoIntermission@@QAE@XZ		; CInfoIntermission::CInfoIntermission
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44557
$L44556:
	mov	DWORD PTR -28+[ebp], 0
$L44557:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44554[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44554[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42690:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44555[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCInfoIntermission@@PAV1@PBD@Z ENDP	; GetClassPtr
PUBLIC	??0CHudSprite@@QAE@XZ				; CHudSprite::CHudSprite
;	COMDAT xdata$x
; File z:\xashxtsrc\server\cbase.h
xdata$x	SEGMENT
__ehfuncinfo$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z$0
xdata$x	ENDS
;	COMDAT ?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z
_TEXT	SEGMENT
$T44567 = -20
$T44568 = -24
__$EHRec$ = -12
_newEnt$ = 8
_className$ = 12
_pev$ = -16
?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z PROC NEAR	; GetClassPtr, COMDAT

; 1093 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 1094 : 	entvars_t *pev = (entvars_t *)newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]
	mov	DWORD PTR _pev$[ebp], eax

; 1095 : 
; 1096 : 	// allocate entity if necessary
; 1097 : 	if (pev == NULL)

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L42699

; 1098 : 		pev = VARS(CREATE_ENTITY());

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+84
	push	eax
	call	?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z	; VARS
	add	esp, 4
	mov	DWORD PTR _pev$[ebp], eax
$L42699:

; 1099 : 
; 1100 : 	// get the private data
; 1101 : 	newEnt = (T *)GET_PRIVATE(ENT(pev));

	mov	ecx, DWORD PTR _pev$[ebp]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _newEnt$[ebp], eax

; 1102 : 
; 1103 : 	if (newEnt == NULL) 

	cmp	DWORD PTR _newEnt$[ebp], 0
	jne	SHORT $L42701

; 1105 : 		// allocate private data 
; 1106 : 		newEnt = new(pev) T;

	mov	edx, DWORD PTR _pev$[ebp]
	push	edx
	push	1764					; 000006e4H
	call	??2CBaseEntity@@SAPAXIPAUentvars_s@@@Z	; CBaseEntity::operator new
	add	esp, 8
	mov	DWORD PTR $T44568[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T44568[ebp], 0
	je	SHORT $L44569
	mov	ecx, DWORD PTR $T44568[ebp]
	call	??0CHudSprite@@QAE@XZ			; CHudSprite::CHudSprite
	mov	DWORD PTR -28+[ebp], eax
	jmp	SHORT $L44570
$L44569:
	mov	DWORD PTR -28+[ebp], 0
$L44570:
	mov	eax, DWORD PTR -28+[ebp]
	mov	DWORD PTR $T44567[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T44567[ebp]
	mov	DWORD PTR _newEnt$[ebp], ecx

; 1107 : 		newEnt->pev = pev;

	mov	edx, DWORD PTR _newEnt$[ebp]
	mov	eax, DWORD PTR _pev$[ebp]
	mov	DWORD PTR [edx+4], eax
$L42701:

; 1109 : 	newEnt->SetClassname( className );

	mov	ecx, DWORD PTR _className$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _newEnt$[ebp]
	call	?SetClassname@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetClassname

; 1110 : 
; 1111 : 	return newEnt;

	mov	eax, DWORD PTR _newEnt$[ebp]

; 1112 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z$0:
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T44568[ebp]
	push	ecx
	call	??3CBaseEntity@@SAXPAXPAUentvars_s@@@Z	; CBaseEntity::operator delete
	add	esp, 8
	ret	0
__ehhandler$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?GetClassPtr@@YAPAVCHudSprite@@PAV1@PBD@Z ENDP		; GetClassPtr
PUBLIC	?EarPosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EarPosition
PUBLIC	?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z	; CBaseEntity::BodyTarget
PUBLIC	?IsPointSized@CBaseEntity@@UBEHXZ		; CBaseEntity::IsPointSized
PUBLIC	??0CBaseEntity@@QAE@XZ				; CBaseEntity::CBaseEntity
PUBLIC	?ObjectCaps@CSprayCan@@UAEHXZ			; CSprayCan::ObjectCaps
PUBLIC	??_7CSprayCan@@6B@				; CSprayCan::`vftable'
PUBLIC	?Spawn@CBaseEntity@@UAEXXZ			; CBaseEntity::Spawn
PUBLIC	?Precache@CBaseEntity@@UAEXXZ			; CBaseEntity::Precache
PUBLIC	?Activate@CBaseEntity@@UAEXXZ			; CBaseEntity::Activate
PUBLIC	?OnChangeLevel@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeLevel
PUBLIC	?OnTeleport@CBaseEntity@@UAEXXZ			; CBaseEntity::OnTeleport
PUBLIC	?PortalSleep@CBaseEntity@@UAEXM@Z		; CBaseEntity::PortalSleep
PUBLIC	?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ; CBaseEntity::StartMessage
PUBLIC	?GetPosition@CBaseEntity@@UAEMXZ		; CBaseEntity::GetPosition
PUBLIC	?OnChangeParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnChangeParent
PUBLIC	?OnClearParent@CBaseEntity@@UAEXXZ		; CBaseEntity::OnClearParent
PUBLIC	?OnRemove@CBaseEntity@@UAEXXZ			; CBaseEntity::OnRemove
PUBLIC	?Classify@CBaseEntity@@UAEHXZ			; CBaseEntity::Classify
PUBLIC	?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z	; CBaseEntity::DeathNotice
PUBLIC	?IsRigidBody@CBaseEntity@@UAEHXZ		; CBaseEntity::IsRigidBody
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@XZ		; CBaseEntity::GetState
PUBLIC	?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z	; CBaseEntity::GetState
PUBLIC	?BloodColor@CBaseEntity@@UAEHXZ			; CBaseEntity::BloodColor
PUBLIC	?IsTriggered@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::IsTriggered
PUBLIC	?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ; CBaseEntity::MyMonsterPointer
PUBLIC	?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ; CBaseEntity::MySquadMonsterPointer
PUBLIC	?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ	; CBaseEntity::GetVehicleDriver
PUBLIC	?GetToggleState@CBaseEntity@@UAEHXZ		; CBaseEntity::GetToggleState
PUBLIC	?AddPoints@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPoints
PUBLIC	?AddPointsToTeam@CBaseEntity@@UAEXHH@Z		; CBaseEntity::AddPointsToTeam
PUBLIC	?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::AddPlayerItem
PUBLIC	?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ; CBaseEntity::RemovePlayerItem
PUBLIC	?GiveAmmo@CBaseEntity@@UAEHHPADH@Z		; CBaseEntity::GiveAmmo
PUBLIC	?GetDelay@CBaseEntity@@UAEMXZ			; CBaseEntity::GetDelay
PUBLIC	?IsMoving@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMoving
PUBLIC	?OverrideReset@CBaseEntity@@UAEXXZ		; CBaseEntity::OverrideReset
PUBLIC	?TransferReset@CBaseEntity@@UAEXXZ		; CBaseEntity::TransferReset
PUBLIC	?SetToggleState@CBaseEntity@@UAEXH@Z		; CBaseEntity::SetToggleState
PUBLIC	?StartSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StartSneaking
PUBLIC	?StopSneaking@CBaseEntity@@UAEXXZ		; CBaseEntity::StopSneaking
PUBLIC	?OnControls@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::OnControls
PUBLIC	?IsSneaking@CBaseEntity@@UAEHXZ			; CBaseEntity::IsSneaking
PUBLIC	?IsAlive@CBaseEntity@@UAEHXZ			; CBaseEntity::IsAlive
PUBLIC	?IsBSPModel@CBaseEntity@@UAEHXZ			; CBaseEntity::IsBSPModel
PUBLIC	?IsCustomModel@CBaseEntity@@UAEHXZ		; CBaseEntity::IsCustomModel
PUBLIC	?ReflectGauss@CBaseEntity@@UAEHXZ		; CBaseEntity::ReflectGauss
PUBLIC	?HasTarget@CBaseEntity@@UAEHH@Z			; CBaseEntity::HasTarget
PUBLIC	?IsPlayer@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPlayer
PUBLIC	?IsNetClient@CBaseEntity@@UAEHXZ		; CBaseEntity::IsNetClient
PUBLIC	?IsMonster@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMonster
PUBLIC	?IsPushable@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPushable
PUBLIC	?IsProjectile@CBaseEntity@@UAEHXZ		; CBaseEntity::IsProjectile
PUBLIC	?IsFuncScreen@CBaseEntity@@UAEHXZ		; CBaseEntity::IsFuncScreen
PUBLIC	?IsPortal@CBaseEntity@@UAEHXZ			; CBaseEntity::IsPortal
PUBLIC	?IsTank@CBaseEntity@@UAEHXZ			; CBaseEntity::IsTank
PUBLIC	?IsMover@CBaseEntity@@UAEHXZ			; CBaseEntity::IsMover
PUBLIC	?IsBreakable@CBaseEntity@@UAEHXZ		; CBaseEntity::IsBreakable
PUBLIC	?TeamID@CBaseEntity@@UAEPBDXZ			; CBaseEntity::TeamID
PUBLIC	?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z	; CBaseEntity::Use
PUBLIC	?Touch@CBaseEntity@@UAEXPAV1@@Z			; CBaseEntity::Touch
PUBLIC	?Blocked@CBaseEntity@@UAEXPAV1@@Z		; CBaseEntity::Blocked
PUBLIC	?MoveDone@CBaseEntity@@UAEXXZ			; CBaseEntity::MoveDone
PUBLIC	?Respawn@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::Respawn
PUBLIC	?UpdateOwner@CBaseEntity@@UAEXXZ		; CBaseEntity::UpdateOwner
PUBLIC	?FBecomeProne@CBaseEntity@@UAEHXZ		; CBaseEntity::FBecomeProne
PUBLIC	?Center@CBaseEntity@@UAE?AVVector@@XZ		; CBaseEntity::Center
PUBLIC	?EyePosition@CBaseEntity@@UAE?AVVector@@XZ	; CBaseEntity::EyePosition
EXTRN	?FVisible@CBaseEntity@@UAEHPAV1@@Z:NEAR		; CBaseEntity::FVisible
EXTRN	?FVisible@CBaseEntity@@UAEHABVVector@@@Z:NEAR	; CBaseEntity::FVisible
EXTRN	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z:NEAR	; CBaseEntity::ShouldCollide
EXTRN	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseEntity::GetDataDescMap
EXTRN	?Save@CBaseEntity@@UAEHAAVCSave@@@Z:NEAR	; CBaseEntity::Save
EXTRN	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ:NEAR	; CBaseEntity::SetObjectCollisionBox
EXTRN	?SetNextThink@CBaseEntity@@UAEXM@Z:NEAR		; CBaseEntity::SetNextThink
EXTRN	?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceAttack
EXTRN	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z:NEAR ; CBaseEntity::TakeDamage
EXTRN	?TakeHealth@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeHealth
EXTRN	?TakeArmor@CBaseEntity@@UAEHMH@Z:NEAR		; CBaseEntity::TakeArmor
EXTRN	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z:NEAR	; CBaseEntity::Killed
EXTRN	?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseEntity::TraceBleed
EXTRN	?DamageDecal@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::DamageDecal
EXTRN	?IsInWorld@CBaseEntity@@UAEHH@Z:NEAR		; CBaseEntity::IsInWorld
EXTRN	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ:NEAR	; CBaseEntity::GetNextTarget
;	COMDAT ??_7CSprayCan@@6B@
CONST	SEGMENT
??_7CSprayCan@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CSprayCan::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CSprayCan@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CSprayCan@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CSprayCan@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CSprayCan@@QAE@XZ PROC NEAR				; CSprayCan::CSprayCan, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CSprayCan@@6B@ ; CSprayCan::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CSprayCan@@QAE@XZ ENDP				; CSprayCan::CSprayCan
_TEXT	ENDS
;	COMDAT ?Spawn@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Spawn@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Spawn, COMDAT

; 325  : 	virtual void	Spawn( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Spawn@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Spawn
_TEXT	ENDS
;	COMDAT ?Precache@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Precache@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Precache, COMDAT

; 326  : 	virtual void	Precache( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Precache@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Precache
_TEXT	ENDS
;	COMDAT ?Activate@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Activate@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Activate, COMDAT

; 365  : 	virtual void	Activate( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Activate@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::Activate
_TEXT	ENDS
;	COMDAT ?OnChangeLevel@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeLevel@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeLevel, COMDAT

; 366  : 	virtual void	OnChangeLevel( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeLevel@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnChangeLevel
_TEXT	ENDS
;	COMDAT ?OnTeleport@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnTeleport@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnTeleport, COMDAT

; 367  : 	virtual void	OnTeleport( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnTeleport@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnTeleport
_TEXT	ENDS
;	COMDAT ?PortalSleep@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_this$ = -4
?PortalSleep@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::PortalSleep, COMDAT

; 368  : 	virtual void	PortalSleep( float seconds ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?PortalSleep@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::PortalSleep
_TEXT	ENDS
;	COMDAT ?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
_TEXT	SEGMENT
_this$ = -4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z PROC NEAR ; CBaseEntity::StartMessage, COMDAT

; 369  :           virtual void	StartMessage( CBasePlayer *pPlayer ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z ENDP	; CBaseEntity::StartMessage
_TEXT	ENDS
;	COMDAT ?GetPosition@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetPosition@CBaseEntity@@UAEMXZ PROC NEAR		; CBaseEntity::GetPosition, COMDAT

; 370  : 	virtual float	GetPosition( void ) { return 0.0f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetPosition@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetPosition
_TEXT	ENDS
;	COMDAT ?OnChangeParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnChangeParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnChangeParent, COMDAT

; 371  : 	virtual void	OnChangeParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnChangeParent@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::OnChangeParent
_TEXT	ENDS
;	COMDAT ?OnClearParent@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnClearParent@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OnClearParent, COMDAT

; 372  : 	virtual void	OnClearParent( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnClearParent@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnClearParent
_TEXT	ENDS
;	COMDAT ?OnRemove@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OnRemove@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::OnRemove, COMDAT

; 373  : 	virtual void	OnRemove( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OnRemove@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OnRemove
_TEXT	ENDS
;	COMDAT ?Classify@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::Classify, COMDAT

; 385  : 	virtual int Classify ( void ) { return CLASS_NONE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::Classify
_TEXT	ENDS
;	COMDAT ?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
_TEXT	SEGMENT
_this$ = -4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z PROC NEAR ; CBaseEntity::DeathNotice, COMDAT

; 386  : 	virtual void DeathNotice ( entvars_t *pevChild ) { } // monster maker children use this to tell the monster maker that they have died.

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z ENDP	; CBaseEntity::DeathNotice
_TEXT	ENDS
;	COMDAT ?IsRigidBody@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsRigidBody@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsRigidBody, COMDAT

; 387  : 	virtual BOOL IsRigidBody( void ) { return (m_iActorType == ACTOR_DYNAMIC); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	mov	eax, ecx
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsRigidBody@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsRigidBody
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseEntity::GetState, COMDAT

; 398  : 	virtual STATE GetState ( void ) { return STATE_OFF; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseEntity@@UAE?AW4STATE@@XZ ENDP		; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z PROC NEAR	; CBaseEntity::GetState, COMDAT

; 401  : 	virtual STATE GetState ( CBaseEntity* pEnt ) { return GetState(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z ENDP	; CBaseEntity::GetState
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::BloodColor, COMDAT

; 408  : 	virtual int	BloodColor( void ) { return DONT_BLEED; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::BloodColor
_TEXT	ENDS
;	COMDAT ?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::IsTriggered, COMDAT

; 410  : 	virtual BOOL	IsTriggered( CBaseEntity *pActivator ) {return TRUE;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsTriggered@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::IsTriggered
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ PROC NEAR ; CBaseEntity::MyMonsterPointer, COMDAT

; 411  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ ENDP ; CBaseEntity::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
_TEXT	SEGMENT
_this$ = -4
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ PROC NEAR ; CBaseEntity::MySquadMonsterPointer, COMDAT

; 412  : 	virtual CSquadMonster *MySquadMonsterPointer( void ) { return NULL;}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ ENDP ; CBaseEntity::MySquadMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetVehicleDriver, COMDAT

; 413  : 	virtual CBaseEntity *GetVehicleDriver( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetVehicleDriver
_TEXT	ENDS
;	COMDAT ?GetToggleState@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::GetToggleState, COMDAT

; 414  : 	virtual int	GetToggleState( void ) { return TS_AT_TOP; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseEntity@@UAEHXZ ENDP		; CBaseEntity::GetToggleState
_TEXT	ENDS
;	COMDAT ?AddPoints@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPoints@CBaseEntity@@UAEXHH@Z PROC NEAR		; CBaseEntity::AddPoints, COMDAT

; 415  : 	virtual void	AddPoints( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPoints@CBaseEntity@@UAEXHH@Z ENDP			; CBaseEntity::AddPoints
_TEXT	ENDS
;	COMDAT ?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z PROC NEAR	; CBaseEntity::AddPointsToTeam, COMDAT

; 416  : 	virtual void	AddPointsToTeam( int score, BOOL bAllowNegativeScore ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?AddPointsToTeam@CBaseEntity@@UAEXHH@Z ENDP		; CBaseEntity::AddPointsToTeam
_TEXT	ENDS
;	COMDAT ?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::AddPlayerItem, COMDAT

; 417  : 	virtual BOOL	AddPlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::AddPlayerItem
_TEXT	ENDS
;	COMDAT ?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
_TEXT	SEGMENT
_this$ = -4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z PROC NEAR ; CBaseEntity::RemovePlayerItem, COMDAT

; 418  : 	virtual BOOL	RemovePlayerItem( CBasePlayerItem *pItem ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z ENDP ; CBaseEntity::RemovePlayerItem
_TEXT	ENDS
;	COMDAT ?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
_TEXT	SEGMENT
_this$ = -4
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z PROC NEAR		; CBaseEntity::GiveAmmo, COMDAT

; 419  : 	virtual int 	GiveAmmo( int iAmount, char *szName, int iMax ) { return -1; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	or	eax, -1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GiveAmmo@CBaseEntity@@UAEHHPADH@Z ENDP			; CBaseEntity::GiveAmmo
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseEntity@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseEntity@@UAEMXZ PROC NEAR			; CBaseEntity::GetDelay, COMDAT

; 420  : 	virtual float	GetDelay( void ) { return 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@00000000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseEntity@@UAEMXZ ENDP			; CBaseEntity::GetDelay
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
;	COMDAT ?IsMoving@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMoving, COMDAT

; 421  : 	virtual int	IsMoving( void ) { return GetAbsVelocity() != g_vecZero; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMoving
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
;	COMDAT ?OverrideReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?OverrideReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::OverrideReset, COMDAT

; 422  : 	virtual void	OverrideReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OverrideReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::OverrideReset
_TEXT	ENDS
;	COMDAT ?TransferReset@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?TransferReset@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::TransferReset, COMDAT

; 423  : 	virtual void	TransferReset( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TransferReset@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::TransferReset
_TEXT	ENDS
;	COMDAT ?SetToggleState@CBaseEntity@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?SetToggleState@CBaseEntity@@UAEXH@Z PROC NEAR		; CBaseEntity::SetToggleState, COMDAT

; 426  : 	virtual void	SetToggleState( int state ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetToggleState@CBaseEntity@@UAEXH@Z ENDP		; CBaseEntity::SetToggleState
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StartSneaking, COMDAT

; 427  : 	virtual void	StartSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::StopSneaking, COMDAT

; 428  : 	virtual void	StopSneaking( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::StopSneaking
_TEXT	ENDS
;	COMDAT ?OnControls@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
?OnControls@CBaseEntity@@UAEHPAV1@@Z PROC NEAR		; CBaseEntity::OnControls, COMDAT

; 429  : 	virtual BOOL	OnControls( CBaseEntity *pTest ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?OnControls@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::OnControls
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsSneaking, COMDAT

; 430  : 	virtual BOOL	IsSneaking( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsAlive, COMDAT

; 431  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L44657
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L44657
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L44658
$L44657:
	mov	DWORD PTR -8+[ebp], 0
$L44658:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsAlive
_TEXT	ENDS
;	COMDAT ?IsBSPModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBSPModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBSPModel, COMDAT

; 432  : 	virtual BOOL	IsBSPModel( void ) { return UTIL_GetModelType( pev->modelindex ) == mod_brush; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBSPModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBSPModel
_TEXT	ENDS
;	COMDAT ?IsCustomModel@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsCustomModel@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsCustomModel, COMDAT

; 433  : 	virtual BOOL	IsCustomModel( void ) { return pev->solid == SOLID_CUSTOM; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+268], 5
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsCustomModel@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsCustomModel
_TEXT	ENDS
;	COMDAT ?ReflectGauss@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ReflectGauss@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ReflectGauss, COMDAT

; 434  : 	virtual BOOL	ReflectGauss( void ) { return (( IsBSPModel() || IsCustomModel()) && !pev->takedamage ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+204]
	test	eax, eax
	jne	SHORT $L44665
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+208]
	test	eax, eax
	je	SHORT $L44666
$L44665:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L44666
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L44667
$L44666:
	mov	DWORD PTR -8+[ebp], 0
$L44667:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReflectGauss@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ReflectGauss
_TEXT	ENDS
;	COMDAT ?HasTarget@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
_targetname$ = 8
?HasTarget@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::HasTarget, COMDAT

; 435  : 	virtual BOOL	HasTarget( string_t targetname ) { return FStrEq(STRING(targetname), STRING(pev->targetname) ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _targetname$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	call	?FStrEq@@YAHPBD0@Z			; FStrEq
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HasTarget@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::HasTarget
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPlayer, COMDAT

; 437  : 	virtual BOOL	IsPlayer( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsNetClient, COMDAT

; 438  : 	virtual BOOL	IsNetClient( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsNetClient
_TEXT	ENDS
;	COMDAT ?IsMonster@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMonster@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsMonster, COMDAT

; 439  : 	virtual BOOL	IsMonster( void ) { return (pev->flags & FL_MONSTER ? TRUE : FALSE); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, 32					; 00000020H
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMonster@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMonster
_TEXT	ENDS
;	COMDAT ?IsPushable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPushable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsPushable, COMDAT

; 440  : 	virtual BOOL	IsPushable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPushable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPushable
_TEXT	ENDS
;	COMDAT ?IsProjectile@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsProjectile@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsProjectile, COMDAT

; 441  : 	virtual BOOL	IsProjectile( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsProjectile@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsProjectile
_TEXT	ENDS
;	COMDAT ?IsFuncScreen@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsFuncScreen@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsFuncScreen, COMDAT

; 442  : 	virtual BOOL	IsFuncScreen( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsFuncScreen@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsFuncScreen
_TEXT	ENDS
;	COMDAT ?IsPortal@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPortal@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsPortal, COMDAT

; 443  : 	virtual BOOL	IsPortal( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPortal@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsPortal
_TEXT	ENDS
;	COMDAT ?IsTank@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsTank@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsTank, COMDAT

; 444  : 	virtual BOOL	IsTank( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsTank@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsTank
_TEXT	ENDS
;	COMDAT ?IsMover@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMover@CBaseEntity@@UAEHXZ PROC NEAR			; CBaseEntity::IsMover, COMDAT

; 445  : 	virtual BOOL	IsMover( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMover@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsMover
_TEXT	ENDS
;	COMDAT ?IsBreakable@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsBreakable@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::IsBreakable, COMDAT

; 446  : 	virtual BOOL	IsBreakable( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsBreakable@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::IsBreakable
_TEXT	ENDS
;	COMDAT ?TeamID@CBaseEntity@@UAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?TeamID@CBaseEntity@@UAEPBDXZ PROC NEAR			; CBaseEntity::TeamID, COMDAT

; 447  : 	virtual const char	*TeamID( void ) { return ""; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:??_C@_00A@?$AA@	; `string'
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?TeamID@CBaseEntity@@UAEPBDXZ ENDP			; CBaseEntity::TeamID
_TEXT	ENDS
;	COMDAT ?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
_TEXT	SEGMENT
_this$ = -4
_pActivator$ = 8
_pCaller$ = 12
_useType$ = 16
_value$ = 20
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z PROC NEAR	; CBaseEntity::Use, COMDAT

; 461  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 462  : 		if (m_pfnUse) (this->*m_pfnUse)( pActivator, pCaller, useType, value );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1752], 0
	je	SHORT $L35009
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCaller$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1752]
$L35009:

; 463  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z ENDP	; CBaseEntity::Use
_TEXT	ENDS
;	COMDAT ?Touch@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Touch@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Touch, COMDAT

; 466  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		if( m_pfnTouch )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1748], 0
	je	SHORT $L35012

; 468  : 			(this->*m_pfnTouch)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1748]
$L35012:

; 469  : 
; 470  : 		// forward the blocked event to our parent, if any.
; 471  : 		if( m_hParent != NULL && !m_isChaining )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35013
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1628]
	test	ecx, ecx
	jne	SHORT $L35013

; 472  : 			m_hParent->Touch( pOther );

	mov	edx, DWORD PTR _pOther$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	eax, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+280]
$L35013:

; 473  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Touch@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Touch
_TEXT	ENDS
;	COMDAT ?Blocked@CBaseEntity@@UAEXPAV1@@Z
_TEXT	SEGMENT
_this$ = -4
_pOther$ = 8
?Blocked@CBaseEntity@@UAEXPAV1@@Z PROC NEAR		; CBaseEntity::Blocked, COMDAT

; 476  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 477  : 		if( m_pfnBlocked )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1756], 0
	je	SHORT $L35016

; 478  : 			(this->*m_pfnBlocked)( pOther );

	mov	ecx, DWORD PTR _pOther$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1756]
$L35016:

; 479  : 
; 480  : 		// forward the blocked event to our parent, if any.
; 481  : 		if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L35017

; 482  : 			m_hParent->Blocked( pOther );

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -8+[ebp], eax
	mov	ecx, DWORD PTR -8+[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR -8+[ebp]
	call	DWORD PTR [edx+284]
$L35017:

; 483  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Blocked@CBaseEntity@@UAEXPAV1@@Z ENDP			; CBaseEntity::Blocked
_TEXT	ENDS
;	COMDAT ?MoveDone@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MoveDone@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::MoveDone, COMDAT

; 485  : 	virtual void MoveDone( void ) { if( m_pfnMoveDone )(this->*m_pfnMoveDone)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1760], 0
	je	SHORT $L35020
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1760]
$L35020:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MoveDone@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::MoveDone
_TEXT	ENDS
;	COMDAT ?Respawn@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?Respawn@CBaseEntity@@UAEPAV1@XZ PROC NEAR		; CBaseEntity::Respawn, COMDAT

; 513  : 	virtual CBaseEntity *Respawn( void ) { return NULL; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Respawn@CBaseEntity@@UAEPAV1@XZ ENDP			; CBaseEntity::Respawn
_TEXT	ENDS
;	COMDAT ?UpdateOwner@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?UpdateOwner@CBaseEntity@@UAEXXZ PROC NEAR		; CBaseEntity::UpdateOwner, COMDAT

; 705  : 	virtual	void UpdateOwner( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOwner@CBaseEntity@@UAEXXZ ENDP			; CBaseEntity::UpdateOwner
_TEXT	ENDS
;	COMDAT ?FBecomeProne@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?FBecomeProne@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::FBecomeProne, COMDAT

; 709  : 	virtual BOOL FBecomeProne( void ) {return FALSE;};

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FBecomeProne@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::FBecomeProne
_TEXT	ENDS
;	COMDAT ?Center@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T44708 = -16
$T44709 = -28
?Center@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR		; CBaseEntity::Center, COMDAT

; 714  : 	virtual Vector Center( ) { return (pev->absmax + pev->absmin) * 0.5; }; // center point of entity

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1056964608				; 3f000000H
	lea	eax, DWORD PTR $T44709[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	push	edx
	lea	eax, DWORD PTR $T44708[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 208				; 000000d0H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Center@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::Center
_TEXT	ENDS
;	COMDAT ?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T44712 = -16
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EyePosition, COMDAT

; 715  : 	virtual Vector EyePosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of eyes

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T44712[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EyePosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EyePosition
_TEXT	ENDS
;	COMDAT ?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T44715 = -16
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ PROC NEAR	; CBaseEntity::EarPosition, COMDAT

; 716  : 	virtual Vector EarPosition( ) { return GetAbsOrigin() + pev->view_ofs; };			// position of ears

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 372				; 00000174H
	push	ecx
	lea	edx, DWORD PTR $T44715[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?EarPosition@CBaseEntity@@UAE?AVVector@@XZ ENDP		; CBaseEntity::EarPosition
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T44718 = -16
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseEntity::BodyTarget, COMDAT

; 717  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T44718[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseEntity::BodyTarget
_TEXT	ENDS
;	COMDAT ?IsPointSized@CBaseEntity@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPointSized@CBaseEntity@@UBEHXZ PROC NEAR		; CBaseEntity::IsPointSized, COMDAT

; 718  : 	virtual BOOL IsPointSized() const { return (pev->size == g_vecZero) ? true : false; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 244				; 000000f4H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	setne	al
	and	eax, 255				; 000000ffH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPointSized@CBaseEntity@@UBEHXZ ENDP			; CBaseEntity::IsPointSized
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CSprayCan@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CSprayCan@@UAEHXZ PROC NEAR			; CSprayCan::ObjectCaps, COMDAT

; 3523 : 	virtual int ObjectCaps( void ) { return FCAP_DONT_SAVE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, -2147483648			; 80000000H
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CSprayCan@@UAEHXZ ENDP			; CSprayCan::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CBloodSplat@@6B@				; CBloodSplat::`vftable'
PUBLIC	?ObjectCaps@CBaseEntity@@UAEHXZ			; CBaseEntity::ObjectCaps
PUBLIC	?Think@CBaseEntity@@UAEXXZ			; CBaseEntity::Think
;	COMDAT ??_7CBloodSplat@@6B@
CONST	SEGMENT
??_7CBloodSplat@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBloodSplat::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBloodSplat@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBloodSplat@@QAE@XZ PROC NEAR			; CBloodSplat::CBloodSplat, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBloodSplat@@6B@ ; CBloodSplat::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBloodSplat@@QAE@XZ ENDP				; CBloodSplat::CBloodSplat
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBaseEntity@@UAEHXZ PROC NEAR		; CBaseEntity::ObjectCaps, COMDAT

; 364  : 	virtual int	ObjectCaps( void ) { return FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 2
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBaseEntity@@UAEHXZ ENDP			; CBaseEntity::ObjectCaps
_TEXT	ENDS
;	COMDAT ?Think@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Think@CBaseEntity@@UAEXXZ PROC NEAR			; CBaseEntity::Think, COMDAT

; 458  : 	virtual void Think( void ) { if (m_pfnThink) (this->*m_pfnThink)(); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1744], 0
	je	SHORT $L35006
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+1744]
$L35006:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Think@CBaseEntity@@UAEXXZ ENDP				; CBaseEntity::Think
_TEXT	ENDS
PUBLIC	?SetYawSpeed@CBaseMonster@@UAEXXZ		; CBaseMonster::SetYawSpeed
PUBLIC	?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z	; CBaseMonster::FValidateCover
PUBLIC	?CoverRadius@CBaseMonster@@UAEMXZ		; CBaseMonster::CoverRadius
PUBLIC	?CheckAmmo@CBaseMonster@@UAEXXZ			; CBaseMonster::CheckAmmo
PUBLIC	?HearingSensitivity@CBaseMonster@@UAEMXZ	; CBaseMonster::HearingSensitivity
PUBLIC	?PrescheduleThink@CBaseMonster@@UAEXXZ		; CBaseMonster::PrescheduleThink
PUBLIC	?IsMoving@CBaseMonster@@UAEHXZ			; CBaseMonster::IsMoving
PUBLIC	?AlertSound@CBaseMonster@@UAEXXZ		; CBaseMonster::AlertSound
PUBLIC	?IdleSound@CBaseMonster@@UAEXXZ			; CBaseMonster::IdleSound
PUBLIC	?PainSound@CBaseMonster@@UAEXXZ			; CBaseMonster::PainSound
PUBLIC	?StopFollowing@CBaseMonster@@UAEXH@Z		; CBaseMonster::StopFollowing
PUBLIC	??0CBaseMonster@@QAE@XZ				; CBaseMonster::CBaseMonster
PUBLIC	??1CBaseMonster@@QAE@XZ				; CBaseMonster::~CBaseMonster
PUBLIC	?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z	; CBasePlayer::BodyTarget
PUBLIC	?StartSneaking@CBasePlayer@@UAEXXZ		; CBasePlayer::StartSneaking
PUBLIC	?StopSneaking@CBasePlayer@@UAEXXZ		; CBasePlayer::StopSneaking
PUBLIC	?IsSneaking@CBasePlayer@@UAEHXZ			; CBasePlayer::IsSneaking
PUBLIC	?IsAlive@CBasePlayer@@UAEHXZ			; CBasePlayer::IsAlive
PUBLIC	?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ		; CBasePlayer::ShouldFadeOnDeath
PUBLIC	?IsPlayer@CBasePlayer@@UAEHXZ			; CBasePlayer::IsPlayer
PUBLIC	?IsNetClient@CBasePlayer@@UAEHXZ		; CBasePlayer::IsNetClient
PUBLIC	?GetToggleState@CBaseToggle@@UAEHXZ		; CBaseToggle::GetToggleState
PUBLIC	?GetDelay@CBaseToggle@@UAEMXZ			; CBaseToggle::GetDelay
PUBLIC	?ObjectCaps@CBasePlayer@@UAEHXZ			; CBasePlayer::ObjectCaps
PUBLIC	??_7CBasePlayer@@6B@				; CBasePlayer::`vftable'
PUBLIC	?BloodColor@CBaseMonster@@UAEHXZ		; CBaseMonster::BloodColor
PUBLIC	?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ	; CBaseMonster::MyMonsterPointer
PUBLIC	?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ; CBaseMonster::GetStoppedActivity
PUBLIC	?Stop@CBaseMonster@@UAEXXZ			; CBaseMonster::Stop
PUBLIC	?ScheduleChange@CBaseMonster@@UAEXXZ		; CBaseMonster::ScheduleChange
PUBLIC	?CanPlaySentence@CBaseMonster@@UAEHH@Z		; CBaseMonster::CanPlaySentence
EXTRN	?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::BuildNearestRoute
EXTRN	?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z:NEAR ; CBaseMonster::FindCover
EXTRN	?FCanCheckAttacks@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanCheckAttacks
EXTRN	?IgnoreConditions@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::IgnoreConditions
EXTRN	?FValidateHintType@CBaseMonster@@UAEHF@Z:NEAR	; CBaseMonster::FValidateHintType
EXTRN	?FCanActiveIdle@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::FCanActiveIdle
EXTRN	?ISoundMask@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::ISoundMask
EXTRN	?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestSound
EXTRN	?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ:NEAR	; CBaseMonster::PBestScent
EXTRN	?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ:NEAR ; CBaseMonster::GetDeathActivity
EXTRN	?GibMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::GibMonster
EXTRN	?DamageDecal@CBaseMonster@@UAEHH@Z:NEAR		; CBaseMonster::DamageDecal
EXTRN	?HasHumanGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasHumanGibs
EXTRN	?HasAlienGibs@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::HasAlienGibs
EXTRN	?FadeMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::FadeMonster
EXTRN	?StepSound@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StepSound
EXTRN	?GetState@CBaseToggle@@UAE?AW4STATE@@XZ:NEAR	; CBaseToggle::GetState
EXTRN	?MoveDone@CBaseToggle@@UAEXXZ:NEAR		; CBaseToggle::MoveDone
EXTRN	?Look@CBaseMonster@@UAEXH@Z:NEAR		; CBaseMonster::Look
EXTRN	?RunAI@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::RunAI
EXTRN	?ChangeYaw@CBaseMonster@@UAEMH@Z:NEAR		; CBaseMonster::ChangeYaw
EXTRN	?MonsterThink@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterThink
EXTRN	?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::IRelationship
EXTRN	?MonsterInit@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::MonsterInit
EXTRN	?MonsterInitDead@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::MonsterInitDead
EXTRN	?BecomeDead@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::BecomeDead
EXTRN	?StartMonster@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::StartMonster
EXTRN	?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ:NEAR ; CBaseMonster::BestVisibleEnemy
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z:NEAR ; CBaseMonster::FInViewCone
EXTRN	?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z:NEAR ; CBaseMonster::HandleAnimEvent
EXTRN	?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z:NEAR ; CBaseMonster::CheckLocalMove
EXTRN	?Move@CBaseMonster@@UAEXM@Z:NEAR		; CBaseMonster::Move
EXTRN	?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z:NEAR ; CBaseMonster::MoveExecute
EXTRN	?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z:NEAR	; CBaseMonster::ShouldAdvanceRoute
EXTRN	?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack1
EXTRN	?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckRangeAttack2
EXTRN	?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack1
EXTRN	?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z:NEAR	; CBaseMonster::CheckMeleeAttack2
EXTRN	?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z:NEAR ; CBaseMonster::ScheduleFromName
EXTRN	?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::StartTask
EXTRN	?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z:NEAR	; CBaseMonster::RunTask
EXTRN	?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z:NEAR ; CBaseMonster::GetScheduleOfType
EXTRN	?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ:NEAR ; CBaseMonster::GetSchedule
EXTRN	?CanPlaySequence@CBaseMonster@@UAEHHH@Z:NEAR	; CBaseMonster::CanPlaySequence
EXTRN	?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z:NEAR	; CBaseMonster::PlaySentence
EXTRN	?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::PlayScriptedSentence
EXTRN	?SentenceStop@CBaseMonster@@UAEXXZ:NEAR		; CBaseMonster::SentenceStop
EXTRN	?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ:NEAR ; CBaseMonster::GetIdealState
EXTRN	?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z:NEAR ; CBaseMonster::SetActivity
EXTRN	?ReportAIState@CBaseMonster@@UAEXXZ:NEAR	; CBaseMonster::ReportAIState
EXTRN	?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z:NEAR ; CBaseMonster::CheckEnemy
EXTRN	?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z:NEAR ; CBaseMonster::FTriangulate
;	COMDAT ??_7CBasePlayer@@6B@
CONST	SEGMENT
??_7CBasePlayer@@6B@ DD FLAT:?GetDataDescMap@CBasePlayer@@UAEPAUdatamap_s@@XZ ; CBasePlayer::`vftable'
	DD	FLAT:?Spawn@CBasePlayer@@UAEXXZ
	DD	FLAT:?Precache@CBasePlayer@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBasePlayer@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBasePlayer@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBasePlayer@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBasePlayer@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBasePlayer@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBasePlayer@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBasePlayer@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBasePlayer@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBasePlayer@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBasePlayer@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBasePlayer@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBasePlayer@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBasePlayer@@UAEXXZ
	DD	FLAT:?StopSneaking@CBasePlayer@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsAlive@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsNetClient@CBasePlayer@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBasePlayer@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBasePlayer@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBasePlayer@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBasePlayer@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBasePlayer@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBasePlayer@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBasePlayer@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
	DD	FLAT:?Jump@CBasePlayer@@UAEXXZ
	DD	FLAT:?Duck@CBasePlayer@@UAEXXZ
	DD	FLAT:?PreThink@CBasePlayer@@UAEXXZ
	DD	FLAT:?PostThink@CBasePlayer@@UAEXXZ
	DD	FLAT:?UpdateClientData@CBasePlayer@@UAEXXZ
	DD	FLAT:?ImpulseCommands@CBasePlayer@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBasePlayer@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBasePlayer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBasePlayer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBasePlayer@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBasePlayer@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0CBasePlayer@@QAE@XZ PROC NEAR			; CBasePlayer::CBasePlayer, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBasePlayer@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3764				; 00000eb4H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4148				; 00001034H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBasePlayer@@6B@ ; CBasePlayer::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBasePlayer@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseMonster@@QAE@XZ			; CBaseMonster::~CBaseMonster
	ret	0
__ehhandler$??0CBasePlayer@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBasePlayer@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBasePlayer@@QAE@XZ ENDP				; CBasePlayer::CBasePlayer
;	COMDAT ?GetToggleState@CBaseToggle@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?GetToggleState@CBaseToggle@@UAEHXZ PROC NEAR		; CBaseToggle::GetToggleState, COMDAT

; 978  : 	virtual int GetToggleState( void ) { return m_toggle_state; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1816]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetToggleState@CBaseToggle@@UAEHXZ ENDP		; CBaseToggle::GetToggleState
_TEXT	ENDS
;	COMDAT ?GetDelay@CBaseToggle@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?GetDelay@CBaseToggle@@UAEMXZ PROC NEAR			; CBaseToggle::GetDelay, COMDAT

; 979  : 	virtual float GetDelay( void ) { return m_flWait; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+1764]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDelay@CBaseToggle@@UAEMXZ ENDP			; CBaseToggle::GetDelay
_TEXT	ENDS
;	COMDAT ?BloodColor@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?BloodColor@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::BloodColor, COMDAT

; 132  : 	virtual int	 BloodColor( void ) { return m_bloodColor; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2328]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BloodColor@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::BloodColor
_TEXT	ENDS
;	COMDAT ?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ PROC NEAR	; CBaseMonster::MyMonsterPointer, COMDAT

; 134  : 	virtual CBaseMonster *MyMonsterPointer( void ) { return this; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ ENDP		; CBaseMonster::MyMonsterPointer
_TEXT	ENDS
;	COMDAT ?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ PROC NEAR ; CBaseMonster::GetStoppedActivity, COMDAT

; 175  : 		virtual Activity GetStoppedActivity( void ) { return ACT_IDLE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ ENDP ; CBaseMonster::GetStoppedActivity
_TEXT	ENDS
;	COMDAT ?Stop@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Stop@CBaseMonster@@UAEXXZ PROC NEAR			; CBaseMonster::Stop, COMDAT

; 176  : 		virtual void Stop( void ) { m_IdealActivity = GetStoppedActivity(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+412]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2072], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Stop@CBaseMonster@@UAEXXZ ENDP				; CBaseMonster::Stop
_TEXT	ENDS
;	COMDAT ?ScheduleChange@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ScheduleChange@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::ScheduleChange, COMDAT

; 203  : 		virtual void ScheduleChange( void ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ScheduleChange@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::ScheduleChange
_TEXT	ENDS
;	COMDAT ?CanPlaySentence@CBaseMonster@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
?CanPlaySentence@CBaseMonster@@UAEHH@Z PROC NEAR	; CBaseMonster::CanPlaySentence, COMDAT

; 206  : 		virtual int CanPlaySentence( BOOL fDisregardState ) { return IsAlive(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+200]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?CanPlaySentence@CBaseMonster@@UAEHH@Z ENDP		; CBaseMonster::CanPlaySentence
_TEXT	ENDS
;	COMDAT ?SetYawSpeed@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SetYawSpeed@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::SetYawSpeed, COMDAT

; 241  : 		virtual void SetYawSpeed ( void ) { return; };// allows different yaw_speeds for each activity

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetYawSpeed@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::SetYawSpeed
_TEXT	ENDS
;	COMDAT ?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
_TEXT	SEGMENT
_this$ = -4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z PROC NEAR ; CBaseMonster::FValidateCover, COMDAT

; 249  : 		virtual BOOL FValidateCover ( const Vector &vecCoverLocation ) { return TRUE; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z ENDP	; CBaseMonster::FValidateCover
_TEXT	ENDS
PUBLIC	__real@4@4008c400000000000000
;	COMDAT __real@4@4008c400000000000000
; File z:\xashxtsrc\server\monsters\basemonster.h
CONST	SEGMENT
__real@4@4008c400000000000000 DD 044440000r	; 784
CONST	ENDS
;	COMDAT ?CoverRadius@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?CoverRadius@CBaseMonster@@UAEMXZ PROC NEAR		; CBaseMonster::CoverRadius, COMDAT

; 250  : 		virtual float CoverRadius( void ) { return 784; } // Default cover radius

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@4008c400000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CoverRadius@CBaseMonster@@UAEMXZ ENDP			; CBaseMonster::CoverRadius
_TEXT	ENDS
;	COMDAT ?CheckAmmo@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckAmmo@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::CheckAmmo, COMDAT

; 253  : 		virtual void CheckAmmo( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAmmo@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::CheckAmmo
_TEXT	ENDS
;	COMDAT ?HearingSensitivity@CBaseMonster@@UAEMXZ
_TEXT	SEGMENT
_this$ = -4
?HearingSensitivity@CBaseMonster@@UAEMXZ PROC NEAR	; CBaseMonster::HearingSensitivity, COMDAT

; 278  : 		virtual float HearingSensitivity( void ) { return 1.0; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	fld	DWORD PTR __real@4@3fff8000000000000000
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HearingSensitivity@CBaseMonster@@UAEMXZ ENDP		; CBaseMonster::HearingSensitivity
_TEXT	ENDS
;	COMDAT ?PrescheduleThink@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PrescheduleThink@CBaseMonster@@UAEXXZ PROC NEAR	; CBaseMonster::PrescheduleThink, COMDAT

; 298  : 		virtual void PrescheduleThink( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrescheduleThink@CBaseMonster@@UAEXXZ ENDP		; CBaseMonster::PrescheduleThink
_TEXT	ENDS
;	COMDAT ?IsMoving@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsMoving@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::IsMoving, COMDAT

; 329  : 	virtual int		IsMoving( void ) { return m_movementGoal != MOVEGOAL_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+2228], 0
	setne	cl
	mov	eax, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsMoving@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsMoving
_TEXT	ENDS
;	COMDAT ?AlertSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?AlertSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::AlertSound, COMDAT

; 335  : 	virtual void AlertSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?AlertSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::AlertSound
_TEXT	ENDS
;	COMDAT ?IdleSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?IdleSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::IdleSound, COMDAT

; 336  : 	virtual void IdleSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IdleSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::IdleSound
_TEXT	ENDS
;	COMDAT ?PainSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?PainSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::PainSound, COMDAT

; 337  : 	virtual void PainSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PainSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::PainSound
_TEXT	ENDS
;	COMDAT ?StopFollowing@CBaseMonster@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4
?StopFollowing@CBaseMonster@@UAEXH@Z PROC NEAR		; CBaseMonster::StopFollowing, COMDAT

; 340  : 	virtual void StopFollowing( BOOL clearSchedule ) {}

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?StopFollowing@CBaseMonster@@UAEXH@Z ENDP		; CBaseMonster::StopFollowing
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
$T44781 = -16
$T44782 = -28
$T44783 = -40
___$ReturnUdt$ = 8
_this$ = -4
?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBasePlayer::BodyTarget, COMDAT

; 242  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ) + pev->view_ofs * RANDOM_FLOAT( 0.5, 1.1 ); };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1066192077				; 3f8ccccdH
	push	1056964608				; 3f000000H
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+364
	add	esp, 4
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T44782[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 372				; 00000174H
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T44783[ebp]
	push	edx
	lea	eax, DWORD PTR $T44781[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBasePlayer@@UAE?AVVector@@ABV2@@Z ENDP	; CBasePlayer::BodyTarget
_TEXT	ENDS
;	COMDAT ?StartSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StartSneaking@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::StartSneaking, COMDAT

; 243  : 	virtual void StartSneaking( void ) { m_tSneaking = gpGlobals->time - 1; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2912]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StartSneaking@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::StartSneaking
_TEXT	ENDS
;	COMDAT ?StopSneaking@CBasePlayer@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?StopSneaking@CBasePlayer@@UAEXXZ PROC NEAR		; CBasePlayer::StopSneaking, COMDAT

; 244  : 	virtual void StopSneaking( void ) { m_tSneaking = gpGlobals->time + 30; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax]
	fadd	DWORD PTR __real@4@4003f000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+2912]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?StopSneaking@CBasePlayer@@UAEXXZ ENDP			; CBasePlayer::StopSneaking
_TEXT	ENDS
;	COMDAT ?IsSneaking@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsSneaking@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::IsSneaking, COMDAT

; 245  : 	virtual BOOL IsSneaking( void ) { return m_tSneaking <= gpGlobals->time; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR [eax+2912]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L44790
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L44791
$L44790:
	mov	DWORD PTR -8+[ebp], 0
$L44791:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsSneaking@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsSneaking
_TEXT	ENDS
;	COMDAT ?IsAlive@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBasePlayer@@UAEHXZ PROC NEAR			; CBasePlayer::IsAlive, COMDAT

; 246  : 	virtual BOOL IsAlive( void ) { return (pev->deadflag == DEAD_NO) && pev->health > 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+368], 0
	jne	SHORT $L44794
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L44794
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L44795
$L44794:
	mov	DWORD PTR -8+[ebp], 0
$L44795:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsAlive
_TEXT	ENDS
;	COMDAT ?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ PROC NEAR	; CBasePlayer::ShouldFadeOnDeath, COMDAT

; 247  : 	virtual BOOL ShouldFadeOnDeath( void ) { return FALSE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ShouldFadeOnDeath@CBasePlayer@@UAEHXZ ENDP		; CBasePlayer::ShouldFadeOnDeath
_TEXT	ENDS
;	COMDAT ?IsPlayer@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsPlayer@CBasePlayer@@UAEHXZ PROC NEAR			; CBasePlayer::IsPlayer, COMDAT

; 248  : 	virtual BOOL IsPlayer( void ) { return TRUE; }		// Spectators should return FALSE for this, they aren't "players" as far as game logic is concerned

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsPlayer@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsPlayer
_TEXT	ENDS
;	COMDAT ?IsNetClient@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsNetClient@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::IsNetClient, COMDAT

; 250  : 	virtual BOOL IsNetClient( void ) { return TRUE; }		// Bots should return FALSE for this, they can't receive NET messages

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 1
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsNetClient@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::IsNetClient
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBasePlayer@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CBasePlayer@@UAEHXZ PROC NEAR		; CBasePlayer::ObjectCaps, COMDAT

; 267  : 	virtual int	ObjectCaps( void ) { return CBaseMonster :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CBasePlayer@@UAEHXZ ENDP			; CBasePlayer::ObjectCaps
_TEXT	ENDS
PUBLIC	?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z	; CBaseMonster::BodyTarget
PUBLIC	?DeathSound@CBaseMonster@@UAEXXZ		; CBaseMonster::DeathSound
PUBLIC	?IsAlive@CBaseMonster@@UAEHXZ			; CBaseMonster::IsAlive
PUBLIC	?Classify@CDeadHEV@@UAEHXZ			; CDeadHEV::Classify
PUBLIC	??_7CDeadHEV@@6B@				; CDeadHEV::`vftable'
EXTRN	?FBecomeProne@CBaseMonster@@UAEHXZ:NEAR		; CBaseMonster::FBecomeProne
EXTRN	?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z:NEAR ; CBaseMonster::BarnacleVictimBitten
EXTRN	?BarnacleVictimReleased@CBaseMonster@@UAEXXZ:NEAR ; CBaseMonster::BarnacleVictimReleased
EXTRN	?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z:NEAR ; CBaseMonster::TraceAttack
EXTRN	?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z:NEAR ; CBaseMonster::Killed
EXTRN	?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ:NEAR ; CBaseMonster::GetGunPosition
EXTRN	?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseMonster::GetDataDescMap
EXTRN	?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ:NEAR	; CBaseMonster::ShouldFadeOnDeath
;	COMDAT ??_7CDeadHEV@@6B@
CONST	SEGMENT
??_7CDeadHEV@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CDeadHEV::`vftable'
	DD	FLAT:?Spawn@CDeadHEV@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CDeadHEV@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CDeadHEV@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT ??0CDeadHEV@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CDeadHEV@@QAE@XZ PROC NEAR				; CDeadHEV::CDeadHEV, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseMonster@@QAE@XZ			; CBaseMonster::CBaseMonster
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CDeadHEV@@6B@ ; CDeadHEV::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CDeadHEV@@QAE@XZ ENDP				; CDeadHEV::CDeadHEV
_TEXT	ENDS
;	COMDAT ?IsAlive@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsAlive@CBaseMonster@@UAEHXZ PROC NEAR			; CBaseMonster::IsAlive, COMDAT

; 139  : 	virtual BOOL	IsAlive( void ) { return (pev->deadflag != DEAD_DEAD); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	DWORD PTR [ecx+368], 2
	setne	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsAlive@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::IsAlive
_TEXT	ENDS
;	COMDAT ?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T44811 = -16
$T44812 = -28
$T44813 = -40
$T44814 = -52
$T44815 = -64
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z PROC NEAR ; CBaseMonster::BodyTarget, COMDAT

; 318  : 	virtual Vector BodyTarget( const Vector &posSrc ) { return Center( ) * 0.75 + EyePosition() * 0.25; };		// position to shoot at

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1048576000				; 3e800000H
	lea	eax, DWORD PTR $T44814[ebp]
	push	eax
	lea	ecx, DWORD PTR $T44813[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+308]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T44815[ebp]
	push	ecx
	push	1061158912				; 3f400000H
	lea	edx, DWORD PTR $T44812[ebp]
	push	edx
	lea	eax, DWORD PTR $T44811[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+304]
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z ENDP	; CBaseMonster::BodyTarget
_TEXT	ENDS
;	COMDAT ?DeathSound@CBaseMonster@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DeathSound@CBaseMonster@@UAEXXZ PROC NEAR		; CBaseMonster::DeathSound, COMDAT

; 334  : 	virtual void DeathSound ( void ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DeathSound@CBaseMonster@@UAEXXZ ENDP			; CBaseMonster::DeathSound
_TEXT	ENDS
;	COMDAT ?Classify@CDeadHEV@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CDeadHEV@@UAEHXZ PROC NEAR			; CDeadHEV::Classify, COMDAT

; 5181 : 	int Classify ( void ) { return	CLASS_HUMAN_MILITARY; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CDeadHEV@@UAEHXZ ENDP				; CDeadHEV::Classify
_TEXT	ENDS
PUBLIC	?GetState@CBaseDelay@@UAE?AW4STATE@@XZ		; CBaseDelay::GetState
PUBLIC	?ObjectCaps@CPlayerKeyCatcher@@UAEHXZ		; CPlayerKeyCatcher::ObjectCaps
PUBLIC	??0CBaseDelay@@QAE@XZ				; CBaseDelay::CBaseDelay
PUBLIC	??_7CPlayerKeyCatcher@@6B@			; CPlayerKeyCatcher::`vftable'
;	COMDAT ??_7CPlayerKeyCatcher@@6B@
CONST	SEGMENT
??_7CPlayerKeyCatcher@@6B@ DD FLAT:?GetDataDescMap@CPlayerKeyCatcher@@UAEPAUdatamap_s@@XZ ; CPlayerKeyCatcher::`vftable'
	DD	FLAT:?Spawn@CPlayerKeyCatcher@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CPlayerKeyCatcher@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CPlayerKeyCatcher@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPlayerKeyCatcher@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CPlayerKeyCatcher@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPlayerKeyCatcher@@QAE@XZ PROC NEAR			; CPlayerKeyCatcher::CPlayerKeyCatcher, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPlayerKeyCatcher@@6B@ ; CPlayerKeyCatcher::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CPlayerKeyCatcher@@QAE@XZ ENDP			; CPlayerKeyCatcher::CPlayerKeyCatcher
_TEXT	ENDS
;	COMDAT ?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ PROC NEAR	; CBaseDelay::GetState, COMDAT

; 881  : 	virtual STATE GetState( void ) { return m_iState; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1788]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CBaseDelay@@UAE?AW4STATE@@XZ ENDP		; CBaseDelay::GetState
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPlayerKeyCatcher@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CPlayerKeyCatcher@@UAEHXZ PROC NEAR		; CPlayerKeyCatcher::ObjectCaps, COMDAT

; 112  : 	int	ObjectCaps( void ) { return BaseClass::ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CPlayerKeyCatcher@@UAEHXZ ENDP		; CPlayerKeyCatcher::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CStripWeapons@@6B@				; CStripWeapons::`vftable'
PUBLIC	?ObjectCaps@CPointEntity@@UAEHXZ		; CPointEntity::ObjectCaps
PUBLIC	??0CPointEntity@@QAE@XZ				; CPointEntity::CPointEntity
EXTRN	?Spawn@CPointEntity@@UAEXXZ:NEAR		; CPointEntity::Spawn
;	COMDAT ??_7CStripWeapons@@6B@
CONST	SEGMENT
??_7CStripWeapons@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CStripWeapons::`vftable'
	DD	FLAT:?Spawn@CPointEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPointEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CStripWeapons@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CStripWeapons@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CStripWeapons@@QAE@XZ PROC NEAR			; CStripWeapons::CStripWeapons, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CPointEntity@@QAE@XZ			; CPointEntity::CPointEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CStripWeapons@@6B@ ; CStripWeapons::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CStripWeapons@@QAE@XZ ENDP				; CStripWeapons::CStripWeapons
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?ObjectCaps@CPointEntity@@UAEHXZ PROC NEAR		; CPointEntity::ObjectCaps, COMDAT

; 837  : 	virtual int ObjectCaps( void ) { return CBaseEntity :: ObjectCaps() & ~FCAP_ACROSS_TRANSITION; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ObjectCaps@CBaseEntity@@UAEHXZ		; CBaseEntity::ObjectCaps
	and	al, -3					; fffffffdH
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ObjectCaps@CPointEntity@@UAEHXZ ENDP			; CPointEntity::ObjectCaps
_TEXT	ENDS
PUBLIC	??_7CRevertSaved@@6B@				; CRevertSaved::`vftable'
;	COMDAT ??_7CRevertSaved@@6B@
CONST	SEGMENT
??_7CRevertSaved@@6B@ DD FLAT:?GetDataDescMap@CRevertSaved@@UAEPAUdatamap_s@@XZ ; CRevertSaved::`vftable'
	DD	FLAT:?Spawn@CPointEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CRevertSaved@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPointEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CRevertSaved@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CRevertSaved@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CRevertSaved@@QAE@XZ PROC NEAR			; CRevertSaved::CRevertSaved, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CPointEntity@@QAE@XZ			; CPointEntity::CPointEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CRevertSaved@@6B@ ; CRevertSaved::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CRevertSaved@@QAE@XZ ENDP				; CRevertSaved::CRevertSaved
_TEXT	ENDS
PUBLIC	??_7CInfoIntermission@@6B@			; CInfoIntermission::`vftable'
;	COMDAT ??_7CInfoIntermission@@6B@
CONST	SEGMENT
??_7CInfoIntermission@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CInfoIntermission::`vftable'
	DD	FLAT:?Spawn@CInfoIntermission@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPointEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CInfoIntermission@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CInfoIntermission@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CInfoIntermission@@QAE@XZ PROC NEAR			; CInfoIntermission::CInfoIntermission, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CPointEntity@@QAE@XZ			; CPointEntity::CPointEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CInfoIntermission@@6B@ ; CInfoIntermission::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CInfoIntermission@@QAE@XZ ENDP			; CInfoIntermission::CInfoIntermission
_TEXT	ENDS
PUBLIC	?GetState@CHudSprite@@UAE?AW4STATE@@XZ		; CHudSprite::GetState
PUBLIC	??_7CHudSprite@@6B@				; CHudSprite::`vftable'
;	COMDAT ??_7CHudSprite@@6B@
CONST	SEGMENT
??_7CHudSprite@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CHudSprite::`vftable'
	DD	FLAT:?Spawn@CHudSprite@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CHudSprite@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CHudSprite@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CHudSprite@@UAEXPAVCBaseEntity@@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CHudSprite@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CHudSprite@@QAE@XZ PROC NEAR				; CHudSprite::CHudSprite, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CHudSprite@@6B@ ; CHudSprite::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CHudSprite@@QAE@XZ ENDP				; CHudSprite::CHudSprite
_TEXT	ENDS
;	COMDAT ?GetState@CHudSprite@@UAE?AW4STATE@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetState@CHudSprite@@UAE?AW4STATE@@XZ PROC NEAR	; CHudSprite::GetState, COMDAT

; 5502 : 	STATE GetState( void ) { return FBitSet( pev->spawnflags, SF_HUDSPR_ACTIVE ) ? STATE_ON : STATE_OFF; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+416]
	and	eax, 1
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetState@CHudSprite@@UAE?AW4STATE@@XZ ENDP		; CHudSprite::GetState
_TEXT	ENDS
PUBLIC	??_7CBaseEntity@@6B@				; CBaseEntity::`vftable'
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	??0CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::CMeshDesc
EXTRN	??1CMeshDesc@@QAE@XZ:NEAR			; CMeshDesc::~CMeshDesc
;	COMDAT ??_7CBaseEntity@@6B@
CONST	SEGMENT
??_7CBaseEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseEntity@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseEntity@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseEntity@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseEntity@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseEntity@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 76					; 0000004cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??0CMeshDesc@@QAE@XZ			; CMeshDesc::CMeshDesc
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1632				; 00000660H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseEntity@@6B@ ; CBaseEntity::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseEntity@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	ret	0
__ehhandler$??0CBaseEntity@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseEntity@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::CBaseEntity
PUBLIC	??0WayPoint_t@@QAE@XZ				; WayPoint_t::WayPoint_t
PUBLIC	??_7CBaseMonster@@6B@				; CBaseMonster::`vftable'
PUBLIC	??0CBaseToggle@@QAE@XZ				; CBaseToggle::CBaseToggle
PUBLIC	??1CBaseToggle@@QAE@XZ				; CBaseToggle::~CBaseToggle
PUBLIC	?Classify@CBaseMonster@@UAEHXZ			; CBaseMonster::Classify
;	COMDAT ??_7CBaseMonster@@6B@
CONST	SEGMENT
??_7CBaseMonster@@6B@ DD FLAT:?GetDataDescMap@CBaseMonster@@UAEPAUdatamap_s@@XZ ; CBaseMonster::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseMonster@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseMonster@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseMonster@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseMonster@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseMonster@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseMonster@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseMonster@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseMonster@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseMonster@@UAEPAV1@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseMonster@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseMonster@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseMonster@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseMonster@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseMonster@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseMonster@@UAEXPAUMonsterEvent_t@@@Z
	DD	FLAT:?Look@CBaseMonster@@UAEXH@Z
	DD	FLAT:?RunAI@CBaseMonster@@UAEXXZ
	DD	FLAT:?ShouldFadeOnDeath@CBaseMonster@@UAEHXZ
	DD	FLAT:?ChangeYaw@CBaseMonster@@UAEMH@Z
	DD	FLAT:?MonsterThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?IRelationship@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?MonsterInit@CBaseMonster@@UAEXXZ
	DD	FLAT:?MonsterInitDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?BecomeDead@CBaseMonster@@UAEXXZ
	DD	FLAT:?StartMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?BestVisibleEnemy@CBaseMonster@@UAEPAVCBaseEntity@@XZ
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVVector@@@Z
	DD	FLAT:?FInViewCone@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?CheckLocalMove@CBaseMonster@@UAEHABVVector@@0PAVCBaseEntity@@PAM@Z
	DD	FLAT:?Move@CBaseMonster@@UAEXM@Z
	DD	FLAT:?MoveExecute@CBaseMonster@@UAEXPAVCBaseEntity@@ABVVector@@M@Z
	DD	FLAT:?ShouldAdvanceRoute@CBaseMonster@@UAEHM@Z
	DD	FLAT:?GetStoppedActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?Stop@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckRangeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckRangeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack1@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?CheckMeleeAttack2@CBaseMonster@@UAEHMM@Z
	DD	FLAT:?ScheduleFromName@CBaseMonster@@UAEPAUSchedule_t@@PBD@Z
	DD	FLAT:?StartTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?RunTask@CBaseMonster@@UAEXPAUTask_t@@@Z
	DD	FLAT:?GetScheduleOfType@CBaseMonster@@UAEPAUSchedule_t@@H@Z
	DD	FLAT:?GetSchedule@CBaseMonster@@UAEPAUSchedule_t@@XZ
	DD	FLAT:?ScheduleChange@CBaseMonster@@UAEXXZ
	DD	FLAT:?CanPlaySequence@CBaseMonster@@UAEHHH@Z
	DD	FLAT:?CanPlaySentence@CBaseMonster@@UAEHH@Z
	DD	FLAT:?PlaySentence@CBaseMonster@@UAEXPBDMMM@Z
	DD	FLAT:?PlayScriptedSentence@CBaseMonster@@UAEXPBDMMMHPAVCBaseEntity@@@Z
	DD	FLAT:?SentenceStop@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetIdealState@CBaseMonster@@UAE?AW4MONSTERSTATE@@XZ
	DD	FLAT:?SetActivity@CBaseMonster@@UAEXW4Activity@@@Z
	DD	FLAT:?ReportAIState@CBaseMonster@@UAEXXZ
	DD	FLAT:?CheckEnemy@CBaseMonster@@UAEHPAVCBaseEntity@@@Z
	DD	FLAT:?FTriangulate@CBaseMonster@@UAEHABVVector@@0MPAVCBaseEntity@@PAV2@@Z
	DD	FLAT:?SetYawSpeed@CBaseMonster@@UAEXXZ
	DD	FLAT:?BuildNearestRoute@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FindCover@CBaseMonster@@UAEHVVector@@0MM@Z
	DD	FLAT:?FValidateCover@CBaseMonster@@UAEHABVVector@@@Z
	DD	FLAT:?CoverRadius@CBaseMonster@@UAEMXZ
	DD	FLAT:?FCanCheckAttacks@CBaseMonster@@UAEHXZ
	DD	FLAT:?CheckAmmo@CBaseMonster@@UAEXXZ
	DD	FLAT:?IgnoreConditions@CBaseMonster@@UAEHXZ
	DD	FLAT:?FValidateHintType@CBaseMonster@@UAEHF@Z
	DD	FLAT:?FCanActiveIdle@CBaseMonster@@UAEHXZ
	DD	FLAT:?ISoundMask@CBaseMonster@@UAEHXZ
	DD	FLAT:?PBestSound@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?PBestScent@CBaseMonster@@UAEPAVCSound@@XZ
	DD	FLAT:?HearingSensitivity@CBaseMonster@@UAEMXZ
	DD	FLAT:?BarnacleVictimBitten@CBaseMonster@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?BarnacleVictimReleased@CBaseMonster@@UAEXXZ
	DD	FLAT:?PrescheduleThink@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetDeathActivity@CBaseMonster@@UAE?AW4Activity@@XZ
	DD	FLAT:?GibMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?HasHumanGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?HasAlienGibs@CBaseMonster@@UAEHXZ
	DD	FLAT:?FadeMonster@CBaseMonster@@UAEXXZ
	DD	FLAT:?GetGunPosition@CBaseMonster@@UAE?AVVector@@XZ
	DD	FLAT:?DeathSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?AlertSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?IdleSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?PainSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StepSound@CBaseMonster@@UAEXXZ
	DD	FLAT:?StopFollowing@CBaseMonster@@UAEXH@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseMonster@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseMonster@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseMonster@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseMonster@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseMonster@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseToggle@@QAE@XZ			; CBaseToggle::CBaseToggle
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	OFFSET FLAT:??0Vector@@QAE@XZ		; Vector::Vector
	push	4
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2008				; 000007d8H
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	push	OFFSET FLAT:??0WayPoint_t@@QAE@XZ	; WayPoint_t::WayPoint_t
	push	8
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2100				; 00000834H
	push	ecx
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2264				; 000008d8H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2364				; 0000093cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET FLAT:??_7CBaseMonster@@6B@ ; CBaseMonster::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseMonster@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	ret	0
__ehhandler$??0CBaseMonster@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseMonster@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::CBaseMonster
;	COMDAT ?Classify@CBaseMonster@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4
?Classify@CBaseMonster@@UAEHXZ PROC NEAR		; CBaseMonster::Classify, COMDAT

; 130  : 	virtual int	Classify( void ) { return m_iClass ? m_iClass : CLASS_NONE; }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2388], 0
	je	SHORT $L44863
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2388]
	mov	DWORD PTR -8+[ebp], edx
	jmp	SHORT $L44864
$L44863:
	mov	DWORD PTR -8+[ebp], 0
$L44864:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Classify@CBaseMonster@@UAEHXZ ENDP			; CBaseMonster::Classify
_TEXT	ENDS
;	COMDAT ??1CBaseMonster@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseMonster@@QAE@XZ PROC NEAR			; CBaseMonster::~CBaseMonster, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseToggle@@QAE@XZ			; CBaseToggle::~CBaseToggle
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseMonster@@QAE@XZ ENDP				; CBaseMonster::~CBaseMonster
_TEXT	ENDS
PUBLIC	??_7CBaseDelay@@6B@				; CBaseDelay::`vftable'
EXTRN	?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseDelay::GetDataDescMap
;	COMDAT ??_7CBaseDelay@@6B@
CONST	SEGMENT
??_7CBaseDelay@@6B@ DD FLAT:?GetDataDescMap@CBaseDelay@@UAEPAUdatamap_s@@XZ ; CBaseDelay::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseDelay@@6B@ ; CBaseDelay::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::CBaseDelay
_TEXT	ENDS
PUBLIC	??_7CPointEntity@@6B@				; CPointEntity::`vftable'
;	COMDAT ??_7CPointEntity@@6B@
CONST	SEGMENT
??_7CPointEntity@@6B@ DD FLAT:?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CPointEntity::`vftable'
	DD	FLAT:?Spawn@CPointEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseEntity@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CPointEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
CONST	ENDS
;	COMDAT ??0CPointEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CPointEntity@@QAE@XZ PROC NEAR			; CPointEntity::CPointEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseEntity@@QAE@XZ			; CBaseEntity::CBaseEntity
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CPointEntity@@6B@ ; CPointEntity::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CPointEntity@@QAE@XZ ENDP				; CPointEntity::CPointEntity
_TEXT	ENDS
PUBLIC	?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ; CBaseAnimating::HandleAnimEvent
PUBLIC	??0CBaseAnimating@@QAE@XZ			; CBaseAnimating::CBaseAnimating
PUBLIC	??1CBaseAnimating@@QAE@XZ			; CBaseAnimating::~CBaseAnimating
PUBLIC	??_7CBaseToggle@@6B@				; CBaseToggle::`vftable'
EXTRN	?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z:NEAR ; CBaseToggle::KeyValue
EXTRN	?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z:NEAR	; CBaseToggle::Restore
EXTRN	?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseToggle::GetDataDescMap
;	COMDAT ??_7CBaseToggle@@6B@
CONST	SEGMENT
??_7CBaseToggle@@6B@ DD FLAT:?GetDataDescMap@CBaseToggle@@UAEPAUdatamap_s@@XZ ; CBaseToggle::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseToggle@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseToggle@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseToggle@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseToggle@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseToggle@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseToggle@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CBaseToggle@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0CBaseToggle@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0CBaseToggle@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CBaseToggle@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??0CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16
__$EHRec$ = -12
??0CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CBaseToggle@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseAnimating@@QAE@XZ		; CBaseAnimating::CBaseAnimating
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1840				; 00000730H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1852				; 0000073cH
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1864				; 00000748H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1876				; 00000754H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1888				; 00000760H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1912				; 00000778H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1924				; 00000784H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1936				; 00000790H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseToggle@@6B@ ; CBaseToggle::`vftable'
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CBaseToggle@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	ret	0
__ehhandler$??0CBaseToggle@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0CBaseToggle@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??0CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::CBaseToggle
;	COMDAT ?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
_TEXT	SEGMENT
_this$ = -4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z PROC NEAR ; CBaseAnimating::HandleAnimEvent, COMDAT

; 909  : 	virtual void HandleAnimEvent( MonsterEvent_t *pEvent ) { return; };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z ENDP ; CBaseAnimating::HandleAnimEvent
_TEXT	ENDS
;	COMDAT ??1CBaseToggle@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseToggle@@QAE@XZ PROC NEAR			; CBaseToggle::~CBaseToggle, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseAnimating@@QAE@XZ		; CBaseAnimating::~CBaseAnimating
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseToggle@@QAE@XZ ENDP				; CBaseToggle::~CBaseToggle
_TEXT	ENDS
;	COMDAT ??0WayPoint_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0WayPoint_t@@QAE@XZ PROC NEAR				; WayPoint_t::WayPoint_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0WayPoint_t@@QAE@XZ ENDP				; WayPoint_t::WayPoint_t
_TEXT	ENDS
PUBLIC	??_7CBaseAnimating@@6B@				; CBaseAnimating::`vftable'
EXTRN	?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ:NEAR ; CBaseAnimating::GetDataDescMap
;	COMDAT ??_7CBaseAnimating@@6B@
CONST	SEGMENT
??_7CBaseAnimating@@6B@ DD FLAT:?GetDataDescMap@CBaseAnimating@@UAEPAUdatamap_s@@XZ ; CBaseAnimating::`vftable'
	DD	FLAT:?Spawn@CBaseEntity@@UAEXXZ
	DD	FLAT:?Precache@CBaseEntity@@UAEXXZ
	DD	FLAT:?KeyValue@CBaseDelay@@UAEXPAUKeyValueData_s@@@Z
	DD	FLAT:?Save@CBaseEntity@@UAEHAAVCSave@@@Z
	DD	FLAT:?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
	DD	FLAT:?ObjectCaps@CBaseEntity@@UAEHXZ
	DD	FLAT:?Activate@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnChangeLevel@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnTeleport@CBaseEntity@@UAEXXZ
	DD	FLAT:?PortalSleep@CBaseEntity@@UAEXM@Z
	DD	FLAT:?StartMessage@CBaseEntity@@UAEXPAVCBasePlayer@@@Z
	DD	FLAT:?GetPosition@CBaseEntity@@UAEMXZ
	DD	FLAT:?OnChangeParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnClearParent@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnRemove@CBaseEntity@@UAEXXZ
	DD	FLAT:?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
	DD	FLAT:?Classify@CBaseEntity@@UAEHXZ
	DD	FLAT:?DeathNotice@CBaseEntity@@UAEXPAUentvars_s@@@Z
	DD	FLAT:?IsRigidBody@CBaseEntity@@UAEHXZ
	DD	FLAT:?SetNextThink@CBaseEntity@@UAEXM@Z
	DD	FLAT:?GetState@CBaseEntity@@UAE?AW4STATE@@PAV1@@Z
	DD	FLAT:?GetState@CBaseDelay@@UAE?AW4STATE@@XZ
	DD	FLAT:?TraceAttack@CBaseEntity@@UAEXPAUentvars_s@@MVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
	DD	FLAT:?TakeHealth@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?TakeArmor@CBaseEntity@@UAEHMH@Z
	DD	FLAT:?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
	DD	FLAT:?BloodColor@CBaseEntity@@UAEHXZ
	DD	FLAT:?TraceBleed@CBaseEntity@@UAEXMVVector@@PAUgametrace_s@@H@Z
	DD	FLAT:?IsTriggered@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?MyMonsterPointer@CBaseEntity@@UAEPAVCBaseMonster@@XZ
	DD	FLAT:?MySquadMonsterPointer@CBaseEntity@@UAEPAVCSquadMonster@@XZ
	DD	FLAT:?GetVehicleDriver@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?GetToggleState@CBaseEntity@@UAEHXZ
	DD	FLAT:?AddPoints@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPointsToTeam@CBaseEntity@@UAEXHH@Z
	DD	FLAT:?AddPlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?RemovePlayerItem@CBaseEntity@@UAEHPAVCBasePlayerItem@@@Z
	DD	FLAT:?GiveAmmo@CBaseEntity@@UAEHHPADH@Z
	DD	FLAT:?GetDelay@CBaseEntity@@UAEMXZ
	DD	FLAT:?IsMoving@CBaseEntity@@UAEHXZ
	DD	FLAT:?OverrideReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?TransferReset@CBaseEntity@@UAEXXZ
	DD	FLAT:?DamageDecal@CBaseEntity@@UAEHH@Z
	DD	FLAT:?SetToggleState@CBaseEntity@@UAEXH@Z
	DD	FLAT:?StartSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?StopSneaking@CBaseEntity@@UAEXXZ
	DD	FLAT:?OnControls@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?IsSneaking@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsAlive@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBSPModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsCustomModel@CBaseEntity@@UAEHXZ
	DD	FLAT:?ReflectGauss@CBaseEntity@@UAEHXZ
	DD	FLAT:?HasTarget@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsInWorld@CBaseEntity@@UAEHH@Z
	DD	FLAT:?IsPlayer@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsNetClient@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMonster@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPushable@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsProjectile@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsFuncScreen@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsPortal@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsTank@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsMover@CBaseEntity@@UAEHXZ
	DD	FLAT:?IsBreakable@CBaseEntity@@UAEHXZ
	DD	FLAT:?TeamID@CBaseEntity@@UAEPBDXZ
	DD	FLAT:?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?Think@CBaseEntity@@UAEXXZ
	DD	FLAT:?Use@CBaseEntity@@UAEXPAV1@0W4USE_TYPE@@M@Z
	DD	FLAT:?Touch@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?Blocked@CBaseEntity@@UAEXPAV1@@Z
	DD	FLAT:?MoveDone@CBaseEntity@@UAEXXZ
	DD	FLAT:?Respawn@CBaseEntity@@UAEPAV1@XZ
	DD	FLAT:?UpdateOwner@CBaseEntity@@UAEXXZ
	DD	FLAT:?FBecomeProne@CBaseEntity@@UAEHXZ
	DD	FLAT:?Center@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EyePosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?EarPosition@CBaseEntity@@UAE?AVVector@@XZ
	DD	FLAT:?BodyTarget@CBaseEntity@@UAE?AVVector@@ABV2@@Z
	DD	FLAT:?IsPointSized@CBaseEntity@@UBEHXZ
	DD	FLAT:?Illumination@CBaseEntity@@UAEHXZ
	DD	FLAT:?FVisible@CBaseEntity@@UAEHABVVector@@@Z
	DD	FLAT:?FVisible@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
	DD	FLAT:?HandleAnimEvent@CBaseAnimating@@UAEXPAUMonsterEvent_t@@@Z
CONST	ENDS
;	COMDAT ??0CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CBaseDelay@@QAE@XZ			; CBaseDelay::CBaseDelay
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBaseAnimating@@6B@ ; CBaseAnimating::`vftable'
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::CBaseAnimating
_TEXT	ENDS
PUBLIC	??1CBaseDelay@@QAE@XZ				; CBaseDelay::~CBaseDelay
;	COMDAT ??1CBaseAnimating@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseAnimating@@QAE@XZ PROC NEAR			; CBaseAnimating::~CBaseAnimating, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseDelay@@QAE@XZ			; CBaseDelay::~CBaseDelay
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseAnimating@@QAE@XZ ENDP				; CBaseAnimating::~CBaseAnimating
_TEXT	ENDS
PUBLIC	??1CBaseEntity@@QAE@XZ				; CBaseEntity::~CBaseEntity
;	COMDAT ??1CBaseDelay@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseDelay@@QAE@XZ PROC NEAR				; CBaseDelay::~CBaseDelay, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBaseEntity@@QAE@XZ			; CBaseEntity::~CBaseEntity
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseDelay@@QAE@XZ ENDP				; CBaseDelay::~CBaseDelay
_TEXT	ENDS
;	COMDAT ??1CBaseEntity@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1CBaseEntity@@QAE@XZ PROC NEAR			; CBaseEntity::~CBaseEntity, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 248				; 000000f8H
	call	??1CMeshDesc@@QAE@XZ			; CMeshDesc::~CMeshDesc
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBaseEntity@@QAE@XZ ENDP				; CBaseEntity::~CBaseEntity
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L44908
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L44908
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L44908
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44908:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L44909
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44909
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44909:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L44914
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44914:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L42781

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L42781:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44919
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44919:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44920
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44920:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L44923
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44923:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L44930
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L44930
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L44931
$L44930:
	mov	DWORD PTR -8+[ebp], 0
$L44931:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L42814:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L42815

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L42814
$L42815:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L42824

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L42824:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L44938
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L44938
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L44938
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44938:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L42833
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L42833

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L42833:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T44941 = -4
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T44941[ebp], eax
	cmp	DWORD PTR $T44941[ebp], 0
	je	SHORT $L44942
	mov	ecx, DWORD PTR $T44941[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T44941[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L44943
$L44942:
	mov	DWORD PTR -8+[ebp], 0
$L44943:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L44948
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L44948
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L44949
$L44948:
	mov	DWORD PTR -8+[ebp], 0
$L44949:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L42847

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L42848

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L42848:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L42847:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L44958
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44958:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L42862

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L44959
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44959:

; 567  : 		return;

	jmp	$L42859
$L42862:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L42881

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L42873
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L42873

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L42881
$L42873:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L42877

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L44960
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44960:

; 589  : 				return;

	jmp	$L42859
$L42877:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L42881

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L42877
$L42881:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L42884

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L44961
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44961:

; 603  : 	else

	jmp	SHORT $L44962
$L42884:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L44962
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L44962:
$L42859:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
END
