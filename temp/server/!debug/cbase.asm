	TITLE	Z:\XashXTSRC\server\cbase.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JDJH@classname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06CCPD@target?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04GOCP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IDGH@movewith?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05JCDO@style?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@MCHI@reflection?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DCCA@vlight_cache?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00A@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@JICI@FUNCTION?5NOT?5IN?5TABLE?$CB?3?5?$CFs?3?$CFs?5?$CI?$CF@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KKBN@Bad?5Node?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OJHA@Bad?5link?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09OKKL@Half?9Life?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGEN@AnimateUntilDead?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@FEH@Entity?5?$CFs?5?$FL?$CFi?$FN?5with?5model?5?$CFs?5mis@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@JJED@bad?5entity?5in?5trigger?5list?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@MFG@UnlinkChild?3?5couldn?8t?5find?5the?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CO@PAHO@SetParent?3?5static?5actor?5?$CFs?5can?8t@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@PEOO@Not?5found?5parent?5for?5?$CFs?5with?5nam@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CDHA@Not?5found?5parent?5for?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@FNM@?$CFs?5with?5name?5?$CFs?5has?5illegal?5pare@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@KPHE@?$CFs?5has?5illegal?5parent?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@CCMB@class?5?$CFs?$FL?$CFi?$FN?5serial?5?$CFi?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@HJGB@?0?5globalname?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@OPFJ@?0?5targetname?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@HJEL@?0?5target?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IBOL@?0?5model?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HCEK@?0?5state?5?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08IAOK@Parent?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GDEB@add?5to?5teleport?5list?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@GABH@z?3?2xashxtsrc?2server?2cbase?4cpp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@EODA@g_TeleportStack?$FLindex?$FN?5?$DN?$DN?5this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??Teleport@CBaseEntity@@QAEXPBVVector@@00@Z@4FA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GOBJ@CBaseEntity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@GODC@m_pGoalEnt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09PFMD@m_iParent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09NLFG@m_hParent?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FCCJ@m_hChild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GKIK@m_hNextChild?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@IPLA@m_iParentFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@IJOC@m_vecEndPos?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@EBOB@m_vecOrigin?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@JDMF@m_vecAngles?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MJNK@m_vecVelocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KNMC@m_vecAvelocity?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BDKN@m_local?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08JAPK@m_iFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@OKPK@m_iOldSolid?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@BNBC@m_iOldMoveType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@EFNL@m_flMoveDoneTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09GCMG@m_fPicked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08KENI@m_iStyle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@LBND@m_flGaitYaw?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IGKD@m_pfnThink?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@IDHF@m_pfnTouch?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08PBLD@m_pfnUse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@IDE@m_pfnBlocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@EJGJ@m_pfnMoveDone?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGKC@m_flShowHostile?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@NMGB@m_isChaining?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHBB@m_flPoseParameter?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KJEE@SUB_DoNothing?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GAKJ@SUB_FadeOut?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GHMF@m_iActorType?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@OEID@m_iActorFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@DBPD@m_iBodyFlags?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@KEGA@m_usActorGroup?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@PBGE@m_flBodyMass?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KDGN@m_fFreezed?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BFFD@ENTVARS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DLND@NULL?5Ent?5in?5Create?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector2D@@QAE@MM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector2D@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector2D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Vector4D@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Vector4D@@QBE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Radian@@QAE@MMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BRadian@@QBEPBMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Radian@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@MMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x3@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x3@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x3@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x3@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@MMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix3x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix3x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix3x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix3x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@MMMMMMMMMMMMMMMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Amatrix4x4@@QBEPBMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8matrix4x4@@QBEHABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetForward@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRight@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetUp@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetOrigin@matrix4x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SimpleSpline@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLessThan@@YA_NABQBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VARS@@YAPAUentvars_s@@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FStrEq@@YAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteAll@CSave@@QAEHPBXPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReadAll@CRestore@@QAEHPAXPAUdatamap_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsGlobalMode@CRestore@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGlobalname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTarget@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CBaseEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SUB_CallUseToggle@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUentvars_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FunctionCheck@CBaseEntity@@QAEXPAXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThinkSet@CBaseEntity@@QAEP81@AEXXZP81@AEXXZPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearGroundEntity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeNonMoving@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RestoreMoveType@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStudioModel@CBaseEntity@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CollisionToWorldSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WorldToCollisionSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTime@CBaseEntity@@QBEMXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectCaps@CPointEntity@@UAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetConditions@CBaseMonster@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasConditions@CBaseMonster@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Node@CGraph@@QAEAAVCNode@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Link@CGraph@@QAEAAVCLink@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NodeLink@CGraph@@QAEAAVCLink@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E31
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DontThink@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetNextThink@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAbsAvelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckAngles@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetAbsAvelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcAbsolutePosition@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcAbsoluteVelocity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcAbsoluteAvelocity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyLocalVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetVectors@CBaseEntity@@QBEXPAVVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClipLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetModel@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnlinkFromParent@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnlinkChild@CBaseEntity@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LinkChild@CBaseEntity@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnlinkAllChildren@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRootParent@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HasAttachment@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParent@CBaseEntity@@QAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetParent@CBaseEntity@@QAEXPAV1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateOnRemove@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SUB_UseTargets@CBaseEntity@@QAEXPAV1@W4USE_TYPE@@MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeHealth@CBaseEntity@@UAEHMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeArmor@CBaseEntity@@UAEHMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReportInfo@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildTeleportList_r@@YAXPAVCBaseEntity@@AAV?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TeleportListEntry_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseMap@CBaseEntity@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Save@CBaseEntity@@UAEHAAVCSave@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EntityAABBToWorldAABB@CBaseEntity@@QBEXABVVector@@0AAV2@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CalcNearestPoint@CBaseEntity@@QBEXABVVector@@PAV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Intersects@CBaseEntity@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AreaIntersect@CBaseEntity@@QAEHVVector@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TriggerIntersects@CBaseEntity@@QAEHPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsWater@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeDormant@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDormant@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsInWorld@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DamageDecal@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHABQAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Find@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHABQAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FastRemove@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHABUTeleportListEntry_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEABQAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHHABQAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAVCBaseEntity@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHHABUTeleportListEntry_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@UTeleportListEntry_t@@H@@QAEAAUTeleportListEntry_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEPAUTeleportListEntry_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UTeleportListEntry_t@@H@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PAVCBaseEntity@@H@@QBEABQAVCBaseEntity@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPAVCBaseEntity@@ABQAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GrowVector@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Purge@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0TeleportListEntry_t@@QAE@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUTeleportListEntry_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_06FOPF@parent?$AA@			; `string'
PUBLIC	??_C@_0M@FCIN@parentflags?$AA@			; `string'
PUBLIC	?m_DataMap@CBaseEntity@@2Udatamap_s@@A		; CBaseEntity::m_DataMap
PUBLIC	??_C@_0M@GOBJ@CBaseEntity?$AA@			; `string'
PUBLIC	?g_DataMapHolder@CBaseEntity_DataDescInit@@3PAUdatamap_s@@A ; CBaseEntity_DataDescInit::g_DataMapHolder
PUBLIC	??_C@_0L@GODC@m_pGoalEnt?$AA@			; `string'
PUBLIC	??_C@_09PFMD@m_iParent?$AA@			; `string'
PUBLIC	??_C@_09NLFG@m_hParent?$AA@			; `string'
PUBLIC	??_C@_08FCCJ@m_hChild?$AA@			; `string'
PUBLIC	??_C@_0N@GKIK@m_hNextChild?$AA@			; `string'
PUBLIC	??_C@_0P@IPLA@m_iParentFlags?$AA@		; `string'
PUBLIC	??_C@_0M@IJOC@m_vecEndPos?$AA@			; `string'
PUBLIC	??_C@_0M@EBOB@m_vecOrigin?$AA@			; `string'
PUBLIC	??_C@_0M@JDMF@m_vecAngles?$AA@			; `string'
PUBLIC	??_C@_0O@MJNK@m_vecVelocity?$AA@		; `string'
PUBLIC	??_C@_0P@KNMC@m_vecAvelocity?$AA@		; `string'
PUBLIC	??_C@_07BDKN@m_local?$AA@			; `string'
PUBLIC	??_C@_08JAPK@m_iFlags?$AA@			; `string'
PUBLIC	??_C@_0M@OKPK@m_iOldSolid?$AA@			; `string'
PUBLIC	??_C@_0P@BNBC@m_iOldMoveType?$AA@		; `string'
PUBLIC	??_C@_0BB@EFNL@m_flMoveDoneTime?$AA@		; `string'
PUBLIC	??_C@_09GCMG@m_fPicked?$AA@			; `string'
PUBLIC	??_C@_08KENI@m_iStyle?$AA@			; `string'
PUBLIC	??_C@_0M@LBND@m_flGaitYaw?$AA@			; `string'
PUBLIC	??_C@_0L@IGKD@m_pfnThink?$AA@			; `string'
PUBLIC	??_C@_0L@IDHF@m_pfnTouch?$AA@			; `string'
PUBLIC	??_C@_08PBLD@m_pfnUse?$AA@			; `string'
PUBLIC	??_C@_0N@IDE@m_pfnBlocked?$AA@			; `string'
PUBLIC	??_C@_0O@EJGJ@m_pfnMoveDone?$AA@		; `string'
PUBLIC	??_C@_0BA@JGKC@m_flShowHostile?$AA@		; `string'
PUBLIC	??_C@_0N@NMGB@m_isChaining?$AA@			; `string'
PUBLIC	??_C@_0BC@NHBB@m_flPoseParameter?$AA@		; `string'
_BSS	SEGMENT
?g_DataMapHolder@CBaseEntity_DataDescInit@@3PAUdatamap_s@@A DD 01H DUP (?) ; CBaseEntity_DataDescInit::g_DataMapHolder
_BSS	ENDS
CRT$XCU	SEGMENT
_$S34	DD	FLAT:_$E33
CRT$XCU	ENDS
_DATA	SEGMENT
?m_DataMap@CBaseEntity@@2Udatamap_s@@A DD 00H		; CBaseEntity::m_DataMap
	DD	00H
	DD	FLAT:??_C@_0M@GOBJ@CBaseEntity?$AA@
	DD	00H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S37	DD	FLAT:_$E36
CRT$XCU	ENDS
_DATA	SEGMENT
_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A DD 012H
	DD	00H
	DD	00H
	DW	00H
	DW	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:??_C@_0L@GODC@m_pGoalEnt?$AA@
	DD	08H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:??_C@_09PFMD@m_iParent?$AA@
	DD	0acH
	DW	01H
	DW	06H
	DD	FLAT:??_C@_06FOPF@parent?$AA@
	DD	00H
	DD	04H
	DD	FLAT:??_C@_09NLFG@m_hParent?$AA@
	DD	094H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_08FCCJ@m_hChild?$AA@
	DD	09cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:??_C@_0N@GKIK@m_hNextChild?$AA@
	DD	0a4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@IPLA@m_iParentFlags?$AA@
	DD	0b0H
	DW	01H
	DW	06H
	DD	FLAT:??_C@_0M@FCIN@parentflags?$AA@
	DD	00H
	DD	08H
	DD	FLAT:??_C@_0M@IJOC@m_vecEndPos?$AA@
	DD	058H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0M@EBOB@m_vecOrigin?$AA@
	DD	064H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0M@JDMF@m_vecAngles?$AA@
	DD	070H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0O@MJNK@m_vecVelocity?$AA@
	DD	07cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:??_C@_0P@KNMC@m_vecAvelocity?$AA@
	DD	088H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_07BDKN@m_local?$AA@
	DD	0b4H
	DW	010H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08JAPK@m_iFlags?$AA@
	DD	018H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0M@OKPK@m_iOldSolid?$AA@
	DD	010H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_0P@BNBC@m_iOldMoveType?$AA@
	DD	014H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BB@EFNL@m_flMoveDoneTime?$AA@
	DD	02cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_09GCMG@m_fPicked?$AA@
	DD	044H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0aH
	DD	FLAT:??_C@_08KENI@m_iStyle?$AA@
	DD	040H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0M@LBND@m_flGaitYaw?$AA@
	DD	030H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0bH
	DD	FLAT:??_C@_0L@IGKD@m_pfnThink?$AA@
	DD	06d0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0bH
	DD	FLAT:??_C@_0L@IDHF@m_pfnTouch?$AA@
	DD	06d4H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0bH
	DD	FLAT:??_C@_08PBLD@m_pfnUse?$AA@
	DD	06d8H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0bH
	DD	FLAT:??_C@_0N@IDE@m_pfnBlocked?$AA@
	DD	06dcH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0bH
	DD	FLAT:??_C@_0O@EJGJ@m_pfnMoveDone?$AA@
	DD	06e0H
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0fH
	DD	FLAT:??_C@_0BA@JGKC@m_flShowHostile?$AA@
	DD	066cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:??_C@_0N@NMGB@m_isChaining?$AA@
	DD	065cH
	DW	01H
	DW	02H
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:??_C@_0BC@NHBB@m_flPoseParameter?$AA@
	DD	0670H
	DW	018H
	DW	02H
	DD	00H
	DD	00H
	DD	012H
	ORG $+260
_DATA	ENDS
;	COMDAT ??_C@_06FOPF@parent?$AA@
CONST	SEGMENT
??_C@_06FOPF@parent?$AA@ DB 'parent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FCIN@parentflags?$AA@
CONST	SEGMENT
??_C@_0M@FCIN@parentflags?$AA@ DB 'parentflags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GOBJ@CBaseEntity?$AA@
CONST	SEGMENT
??_C@_0M@GOBJ@CBaseEntity?$AA@ DB 'CBaseEntity', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GODC@m_pGoalEnt?$AA@
CONST	SEGMENT
??_C@_0L@GODC@m_pGoalEnt?$AA@ DB 'm_pGoalEnt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFMD@m_iParent?$AA@
CONST	SEGMENT
??_C@_09PFMD@m_iParent?$AA@ DB 'm_iParent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NLFG@m_hParent?$AA@
CONST	SEGMENT
??_C@_09NLFG@m_hParent?$AA@ DB 'm_hParent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FCCJ@m_hChild?$AA@
CONST	SEGMENT
??_C@_08FCCJ@m_hChild?$AA@ DB 'm_hChild', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKIK@m_hNextChild?$AA@
CONST	SEGMENT
??_C@_0N@GKIK@m_hNextChild?$AA@ DB 'm_hNextChild', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IPLA@m_iParentFlags?$AA@
CONST	SEGMENT
??_C@_0P@IPLA@m_iParentFlags?$AA@ DB 'm_iParentFlags', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJOC@m_vecEndPos?$AA@
CONST	SEGMENT
??_C@_0M@IJOC@m_vecEndPos?$AA@ DB 'm_vecEndPos', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EBOB@m_vecOrigin?$AA@
CONST	SEGMENT
??_C@_0M@EBOB@m_vecOrigin?$AA@ DB 'm_vecOrigin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JDMF@m_vecAngles?$AA@
CONST	SEGMENT
??_C@_0M@JDMF@m_vecAngles?$AA@ DB 'm_vecAngles', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJNK@m_vecVelocity?$AA@
CONST	SEGMENT
??_C@_0O@MJNK@m_vecVelocity?$AA@ DB 'm_vecVelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KNMC@m_vecAvelocity?$AA@
CONST	SEGMENT
??_C@_0P@KNMC@m_vecAvelocity?$AA@ DB 'm_vecAvelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BDKN@m_local?$AA@
CONST	SEGMENT
??_C@_07BDKN@m_local?$AA@ DB 'm_local', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAPK@m_iFlags?$AA@
CONST	SEGMENT
??_C@_08JAPK@m_iFlags?$AA@ DB 'm_iFlags', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKPK@m_iOldSolid?$AA@
CONST	SEGMENT
??_C@_0M@OKPK@m_iOldSolid?$AA@ DB 'm_iOldSolid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BNBC@m_iOldMoveType?$AA@
CONST	SEGMENT
??_C@_0P@BNBC@m_iOldMoveType?$AA@ DB 'm_iOldMoveType', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EFNL@m_flMoveDoneTime?$AA@
CONST	SEGMENT
??_C@_0BB@EFNL@m_flMoveDoneTime?$AA@ DB 'm_flMoveDoneTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09GCMG@m_fPicked?$AA@
CONST	SEGMENT
??_C@_09GCMG@m_fPicked?$AA@ DB 'm_fPicked', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KENI@m_iStyle?$AA@
CONST	SEGMENT
??_C@_08KENI@m_iStyle?$AA@ DB 'm_iStyle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LBND@m_flGaitYaw?$AA@
CONST	SEGMENT
??_C@_0M@LBND@m_flGaitYaw?$AA@ DB 'm_flGaitYaw', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGKD@m_pfnThink?$AA@
CONST	SEGMENT
??_C@_0L@IGKD@m_pfnThink?$AA@ DB 'm_pfnThink', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IDHF@m_pfnTouch?$AA@
CONST	SEGMENT
??_C@_0L@IDHF@m_pfnTouch?$AA@ DB 'm_pfnTouch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PBLD@m_pfnUse?$AA@
CONST	SEGMENT
??_C@_08PBLD@m_pfnUse?$AA@ DB 'm_pfnUse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IDE@m_pfnBlocked?$AA@
CONST	SEGMENT
??_C@_0N@IDE@m_pfnBlocked?$AA@ DB 'm_pfnBlocked', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJGJ@m_pfnMoveDone?$AA@
CONST	SEGMENT
??_C@_0O@EJGJ@m_pfnMoveDone?$AA@ DB 'm_pfnMoveDone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JGKC@m_flShowHostile?$AA@
CONST	SEGMENT
??_C@_0BA@JGKC@m_flShowHostile?$AA@ DB 'm_flShowHostile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NMGB@m_isChaining?$AA@
CONST	SEGMENT
??_C@_0N@NMGB@m_isChaining?$AA@ DB 'm_isChaining', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NHBB@m_flPoseParameter?$AA@
CONST	SEGMENT
??_C@_0BC@NHBB@m_flPoseParameter?$AA@ DB 'm_flPoseParameter', 00H ; `string'
CONST	ENDS
PUBLIC	??_H@YGXPAXIHP6EX0@Z@Z				; `vector constructor iterator'
;	COMDAT ??_H@YGXPAXIHP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8
___s$ = 12
___n$ = 16
___f$ = 20
??_H@YGXPAXIHP6EX0@Z@Z PROC NEAR			; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
$L25385:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	cmp	DWORD PTR ___n$[ebp], 0
	jl	SHORT $L25386
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	ecx, DWORD PTR ___t$[ebp]
	add	ecx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], ecx
	jmp	SHORT $L25385
$L25386:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT
_$E33	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E30
	call	_$E32
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E33	ENDP
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
_BSS	SEGMENT
_g_TeleportStack DB 014H DUP (?)
_BSS	ENDS
;	COMDAT _$E30
_TEXT	SEGMENT
_$E30	PROC NEAR					; COMDAT

; 34   : static CUtlArray<CBaseEntity *>	g_TeleportStack;

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	push	0
	mov	ecx, OFFSET FLAT:_g_TeleportStack
	call	??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E30	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
;	COMDAT _$E32
_TEXT	SEGMENT
_$E32	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	OFFSET FLAT:_$E31
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E32	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
;	COMDAT _$E31
_TEXT	SEGMENT
_$E31	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_g_TeleportStack
	call	??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E31	ENDP
_TEXT	ENDS
PUBLIC	?DontThink@CBaseEntity@@QAEXXZ			; CBaseEntity::DontThink
EXTRN	__fltused:NEAR
;	COMDAT ?DontThink@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?DontThink@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::DontThink, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 	pev->nextthink = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+260], 0

; 39   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DontThink@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::DontThink
_TEXT	ENDS
PUBLIC	?SetNextThink@CBaseEntity@@UAEXM@Z		; CBaseEntity::SetNextThink
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
;	COMDAT ?SetNextThink@CBaseEntity@@UAEXM@Z
_TEXT	SEGMENT
_delay$ = 8
_this$ = -4
?SetNextThink@CBaseEntity@@UAEXM@Z PROC NEAR		; CBaseEntity::SetNextThink, COMDAT

; 42   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 	pev->nextthink = gpGlobals->time + delay;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fld	DWORD PTR _delay$[ebp]
	fadd	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+260]

; 44   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetNextThink@CBaseEntity@@UAEXM@Z ENDP			; CBaseEntity::SetNextThink
_TEXT	ENDS
PUBLIC	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetLocalOrigin
;	COMDAT ?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ PROC NEAR	; CBaseEntity::GetLocalOrigin, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 	return m_vecOrigin;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H

; 52   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetLocalOrigin
_TEXT	ENDS
PUBLIC	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetLocalAngles
;	COMDAT ?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ PROC NEAR	; CBaseEntity::GetLocalAngles, COMDAT

; 55   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 	return m_vecAngles;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H

; 57   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetLocalAngles
_TEXT	ENDS
PUBLIC	?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetLocalVelocity
;	COMDAT ?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ PROC NEAR ; CBaseEntity::GetLocalVelocity, COMDAT

; 60   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 	return m_vecVelocity;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH

; 62   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalVelocity@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetLocalVelocity
_TEXT	ENDS
PUBLIC	?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAvelocity
;	COMDAT ?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ PROC NEAR ; CBaseEntity::GetLocalAvelocity, COMDAT

; 65   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	return m_vecAvelocity;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 136				; 00000088H

; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetLocalAvelocity@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetLocalAvelocity
_TEXT	ENDS
PUBLIC	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetAbsOrigin
PUBLIC	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ	; CBaseEntity::CalcAbsolutePosition
;	COMDAT ?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ PROC NEAR	; CBaseEntity::GetAbsOrigin, COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 	if( pev->flags & FL_ABSTRANSFORM )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L38702

; 76   : 		const_cast<CBaseEntity*>(this)->CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition
$L38702:

; 78   : 
; 79   : 	return pev->origin;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, 8

; 80   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetAbsOrigin
_TEXT	ENDS
PUBLIC	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetAbsAngles
;	COMDAT ?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ PROC NEAR	; CBaseEntity::GetAbsAngles, COMDAT

; 83   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 	if( pev->flags & FL_ABSTRANSFORM )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 131072				; 00020000H
	test	edx, edx
	je	SHORT $L38708

; 86   : 		const_cast<CBaseEntity*>(this)->CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition
$L38708:

; 88   : 
; 89   : 	return pev->angles;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, 80					; 00000050H

; 90   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetAbsAngles
_TEXT	ENDS
PUBLIC	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetAbsVelocity
PUBLIC	?CalcAbsoluteVelocity@CBaseEntity@@QAEXXZ	; CBaseEntity::CalcAbsoluteVelocity
;	COMDAT ?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ PROC NEAR	; CBaseEntity::GetAbsVelocity, COMDAT

; 93   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 	if( pev->flags & FL_ABSVELOCITY )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 262144				; 00040000H
	test	edx, edx
	je	SHORT $L38714

; 96   : 		const_cast<CBaseEntity*>(this)->CalcAbsoluteVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsoluteVelocity@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsoluteVelocity
$L38714:

; 98   : 
; 99   : 	return pev->velocity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, 32					; 00000020H

; 100  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetAbsVelocity
_TEXT	ENDS
PUBLIC	?GetAbsAvelocity@CBaseEntity@@QBEABVVector@@XZ	; CBaseEntity::GetAbsAvelocity
PUBLIC	?CalcAbsoluteAvelocity@CBaseEntity@@QAEXXZ	; CBaseEntity::CalcAbsoluteAvelocity
;	COMDAT ?GetAbsAvelocity@CBaseEntity@@QBEABVVector@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetAbsAvelocity@CBaseEntity@@QBEABVVector@@XZ PROC NEAR ; CBaseEntity::GetAbsAvelocity, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 	if( pev->flags & FL_ABSAVELOCITY )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 524288				; 00080000H
	test	edx, edx
	je	SHORT $L38720

; 106  : 		const_cast<CBaseEntity*>(this)->CalcAbsoluteAvelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsoluteAvelocity@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsoluteAvelocity
$L38720:

; 108  : 
; 109  : 	return pev->avelocity;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, 92					; 0000005cH

; 110  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetAbsAvelocity@CBaseEntity@@QBEABVVector@@XZ ENDP	; CBaseEntity::GetAbsAvelocity
_TEXT	ENDS
PUBLIC	??8Vector@@QBEHABV0@@Z				; Vector::operator==
PUBLIC	?CheckAngles@CBaseEntity@@QAEXXZ		; CBaseEntity::CheckAngles
PUBLIC	?GetClassname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetClassname
PUBLIC	?GetModel@CBaseEntity@@QAEPBDXZ			; CBaseEntity::GetModel
PUBLIC	??_C@_0EG@FEH@Entity?5?$CFs?5?$FL?$CFi?$FN?5with?5model?5?$CFs?5mis@ ; `string'
PUBLIC	?entindex@CBaseEntity@@QAEHXZ			; CBaseEntity::entindex
EXTRN	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z:NEAR	; UTIL_CanRotate
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?g_vecZero@@3VVector@@B:BYTE			; g_vecZero
;	COMDAT ??_C@_0EG@FEH@Entity?5?$CFs?5?$FL?$CFi?$FN?5with?5model?5?$CFs?5mis@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_0EG@FEH@Entity?5?$CFs?5?$FL?$CFi?$FN?5with?5model?5?$CFs?5mis@ DB 'E'
	DB	'ntity %s [%i] with model %s missed ''origin'' brush. Rotation'
	DB	' ignored', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?CheckAngles@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?CheckAngles@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::CheckAngles, COMDAT

; 113  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 	if( pev->angles == g_vecZero || UTIL_CanRotate( this ))

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 80					; 00000050H
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	jne	SHORT $L38727
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z	; UTIL_CanRotate
	add	esp, 4
	test	eax, eax
	je	SHORT $L38726
$L38727:

; 115  : 		return;

	jmp	SHORT $L38725
$L38726:

; 116  : 
; 117  : 	if( pev->movetype == MOVETYPE_PUSH )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 7
	jne	SHORT $L38728

; 118  : 		ALERT( at_error, "Entity %s [%i] with model %s missed 'origin' brush. Rotation ignored\n", GetClassname(), entindex(), GetModel());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0EG@FEH@Entity?5?$CFs?5?$FL?$CFi?$FN?5with?5model?5?$CFs?5mis@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 20					; 00000014H
$L38728:

; 119  : 
; 120  : 	pev->angles = g_vecZero;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 80					; 00000050H
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?g_vecZero@@3VVector@@B+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?g_vecZero@@3VVector@@B+8
	mov	DWORD PTR [edx+8], eax
$L38725:

; 121  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckAngles@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::CheckAngles
_TEXT	ENDS
;	COMDAT ??8Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??8Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator==, COMDAT

; 147  : 	inline int operator==(const Vector& v) const	{ return x==v.x && y==v.y && z==v.z;	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR [ecx]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40758
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fcomp	DWORD PTR [eax+4]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40758
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	DWORD PTR [edx+8]
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L40758
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L40759
$L40758:
	mov	DWORD PTR -8+[ebp], 0
$L40759:
	mov	eax, DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector@@QBEHABV0@@Z ENDP				; Vector::operator==
_TEXT	ENDS
;	COMDAT ?GetClassname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetClassname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetClassname, COMDAT

; 282  : 	const char*	GetClassname() { return STRING( pev->classname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetClassname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetClassname
_TEXT	ENDS
;	COMDAT ?GetModel@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetModel@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetModel, COMDAT

; 288  : 	const char*	GetModel() { return STRING( pev->model ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+184]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModel@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetModel
_TEXT	ENDS
PUBLIC	?ENTINDEX@@YAHPAUedict_s@@@Z			; ENTINDEX
PUBLIC	?edict@CBaseEntity@@QAEPAUedict_s@@XZ		; CBaseEntity::edict
;	COMDAT ?entindex@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?entindex@CBaseEntity@@QAEHXZ PROC NEAR			; CBaseEntity::entindex, COMDAT

; 712  : 	int entindex( ) { return ENTINDEX( edict() ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?entindex@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::entindex
_TEXT	ENDS
;	COMDAT ?ENTINDEX@@YAHPAUedict_s@@@Z
_TEXT	SEGMENT
_pEdict$ = 8
?ENTINDEX@@YAHPAUedict_s@@@Z PROC NEAR			; ENTINDEX, COMDAT

; 186  : inline int	  ENTINDEX(edict_t *pEdict)			{ return (*g_engfuncs.pfnIndexOfEdict)(pEdict); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pEdict$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+284
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENTINDEX@@YAHPAUedict_s@@@Z ENDP			; ENTINDEX
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z		; ENT
;	COMDAT ?edict@CBaseEntity@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?edict@CBaseEntity@@QAEPAUedict_s@@XZ PROC NEAR		; CBaseEntity::edict, COMDAT

; 710  : 	edict_t *edict() { return ENT( pev ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?edict@CBaseEntity@@QAEPAUedict_s@@XZ ENDP		; CBaseEntity::edict
_TEXT	ENDS
EXTRN	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z:NEAR ; DBG_EntOfVars
;	COMDAT ?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z PROC NEAR		; ENT, COMDAT

; 151  : 	inline edict_t *ENT(const entvars_t *pev)	{ return DBG_EntOfVars(pev); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?DBG_EntOfVars@@YAPAUedict_s@@PBUentvars_s@@@Z ; DBG_EntOfVars
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z ENDP		; ENT
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@XZ				; Vector::Vector
PUBLIC	?SetOrigin@matrix4x4@@QAEXABVVector@@@Z		; matrix4x4::SetOrigin
PUBLIC	??0matrix4x4@@QAE@ABV0@@Z			; matrix4x4::matrix4x4
PUBLIC	??BEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator CBaseEntity *
PUBLIC	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetAbsOrigin
PUBLIC	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
PUBLIC	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z	; CBaseEntity::InvalidatePhysicsState
EXTRN	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorITransform
;	COMDAT ?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
$T40774 = -148
$T40775 = -160
_absOrigin$ = 8
_this$ = -4
_pParent$ = -8
_vecNewOrigin$ = -20
_parentSpace$38738 = -84
?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR	; CBaseEntity::SetAbsOrigin, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 	// this is necessary to get the other fields of m_local
; 129  : 	CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition

; 130  : 
; 131  : 	// all children are invalid, but we are not
; 132  : 	InvalidatePhysicsState( FL_ABSTRANSFORM );

	push	0
	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 133  : 	ClearBits( pev->flags, FL_ABSTRANSFORM );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 134  : 
; 135  : 	pev->origin = pev->oldorigin = absOrigin;

	mov	edx, DWORD PTR _absOrigin$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 20					; 00000014H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 136  : 	m_local.SetOrigin( absOrigin );

	mov	edx, DWORD PTR _absOrigin$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	?SetOrigin@matrix4x4@@QAEXABVVector@@@Z	; matrix4x4::SetOrigin

; 137  : 
; 138  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 139  : 	Vector vecNewOrigin;

	lea	ecx, DWORD PTR _vecNewOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 140  : 
; 141  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38736

; 143  : 		vecNewOrigin = absOrigin;

	mov	eax, DWORD PTR _absOrigin$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecNewOrigin$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecNewOrigin$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecNewOrigin$[ebp+8], eax

; 145  : 	else

	jmp	SHORT $L38737
$L38736:

; 147  : 		matrix4x4 parentSpace = GetParentToWorldTransform();

	lea	ecx, DWORD PTR $T40774[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _parentSpace$38738[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 148  : 
; 149  : 		// moveparent case: transform the abs position into local space
; 150  : 		vecNewOrigin = parentSpace.VectorITransform( absOrigin );

	mov	edx, DWORD PTR _absOrigin$[ebp]
	push	edx
	lea	eax, DWORD PTR $T40775[ebp]
	push	eax
	lea	ecx, DWORD PTR _parentSpace$38738[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecNewOrigin$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecNewOrigin$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecNewOrigin$[ebp+8], eax
$L38737:

; 152  : 
; 153  : 	m_vecOrigin = vecNewOrigin;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _vecNewOrigin$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _vecNewOrigin$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _vecNewOrigin$[ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 154  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetAbsOrigin
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector@@QAE@XZ PROC NEAR				; Vector::Vector, COMDAT

; 134  : 	inline Vector(void)				{ }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector@@QAE@XZ ENDP					; Vector::Vector
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@MMMM@Z				; Vector4D::Vector4D
;	COMDAT ?SetOrigin@matrix4x4@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vOrigin$ = 8
_this$ = -4
$T40780 = -20
?SetOrigin@matrix4x4@@QAEXABVVector@@@Z PROC NEAR	; matrix4x4::SetOrigin, COMDAT

; 989  : 	void	SetOrigin( const Vector &vOrigin ) { mat[3] = Vector4D( vOrigin.x, vOrigin.y, vOrigin.z, 1.0f ); };

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _vOrigin$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _vOrigin$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _vOrigin$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR $T40780[ebp]
	call	??0Vector4D@@QAE@MMMM@Z			; Vector4D::Vector4D
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetOrigin@matrix4x4@@QAEXABVVector@@@Z ENDP		; matrix4x4::SetOrigin
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@MMMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_W$ = 20
_this$ = -4
??0Vector4D@@QAE@MMMM@Z PROC NEAR			; Vector4D::Vector4D, COMDAT

; 312  : 	inline Vector4D( float X, float Y, float Z, float W ) { x = X; y = Y; z = Z; w = W; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _W$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0Vector4D@@QAE@MMMM@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	??0Vector4D@@QAE@ABV0@@Z			; Vector4D::Vector4D
;	COMDAT ??0matrix4x4@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
_$S7$ = -8
_$S8$ = -12
_$S9$ = -16
??0matrix4x4@@QAE@ABV0@@Z PROC NEAR			; matrix4x4::matrix4x4, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S7$[ebp], 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	DWORD PTR _$S9$[ebp], ecx
$L26032:
	mov	edx, DWORD PTR _$S9$[ebp]
	push	edx
	mov	ecx, DWORD PTR _$S8$[ebp]
	call	??0Vector4D@@QAE@ABV0@@Z		; Vector4D::Vector4D
	mov	eax, DWORD PTR _$S8$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _$S8$[ebp], eax
	mov	ecx, DWORD PTR _$S9$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _$S9$[ebp], ecx
	mov	edx, DWORD PTR _$S7$[ebp]
	sub	edx, 1
	mov	DWORD PTR _$S7$[ebp], edx
	cmp	DWORD PTR _$S7$[ebp], 0
	ja	SHORT $L26032
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0matrix4x4@@QAE@ABV0@@Z ENDP				; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector4D@@QAE@ABV0@@Z PROC NEAR			; Vector4D::Vector4D, COMDAT

; 313  : 	inline Vector4D( const Vector4D& v ) { x = v.x; y = v.y; z = v.z, w = v.w; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector4D@@QAE@ABV0@@Z ENDP				; Vector4D::Vector4D
_TEXT	ENDS
PUBLIC	?Get@EHANDLE@@QAEPAUedict_s@@XZ			; EHANDLE::Get
PUBLIC	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z		; GET_PRIVATE
;	COMDAT ??BEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator CBaseEntity *, COMDAT

; 64   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 66   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator CBaseEntity *
_TEXT	ENDS
;	COMDAT ?GET_PRIVATE@@YAPAXPAUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z PROC NEAR		; GET_PRIVATE, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 102  : 	if ( pent )

	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L28281

; 103  : 		return pent->pvPrivateData;

	mov	eax, DWORD PTR _pent$[ebp]
	mov	eax, DWORD PTR [eax+124]
	jmp	SHORT $L28280
$L28281:

; 104  : 	return NULL;

	xor	eax, eax
$L28280:

; 105  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GET_PRIVATE@@YAPAXPAUedict_s@@@Z ENDP			; GET_PRIVATE
_TEXT	ENDS
;	COMDAT ?Get@EHANDLE@@QAEPAUedict_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?Get@EHANDLE@@QAEPAUedict_s@@XZ PROC NEAR		; EHANDLE::Get, COMDAT

; 40   : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 41   : 	if( m_pent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L34265

; 43   : #if 0
; 44   : 		// keep client entity always in actual state
; 45   : 		if( ENTINDEX( m_pent ) == 1 )
; 46   : 			m_serialnumber = m_pent->serialnumber;
; 47   : #endif
; 48   : 		if( m_pent->serialnumber == m_serialnumber ) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L34265

; 49   : 			return m_pent; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L34263
$L34265:

; 51   : 
; 52   : 	return NULL; 

	xor	eax, eax
$L34263:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Get@EHANDLE@@QAEPAUedict_s@@XZ ENDP			; EHANDLE::Get
_TEXT	ENDS
PUBLIC	??0matrix4x4@@QAE@ABVVector@@0M@Z		; matrix4x4::matrix4x4
PUBLIC	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z		; matrix4x4::GetAngles
PUBLIC	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetAbsAngles
PUBLIC	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
EXTRN	??4matrix4x4@@QAEAAV0@ABV0@@Z:NEAR		; matrix4x4::operator=
EXTRN	?Invert@matrix4x4@@QBE?AV1@XZ:NEAR		; matrix4x4::Invert
EXTRN	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z:NEAR	; matrix4x4::ConcatTransforms
;	COMDAT ?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_absAngles$ = 8
_this$ = -4
_pParent$ = -8
$T40795 = -212
_vecNewAngles$ = -20
$T40796 = -276
$T40798 = -344
_iparentSpace$38750 = -84
_local$38752 = -148
?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR	; CBaseEntity::SetAbsAngles, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 	// this is necessary to get the other fields of m_local
; 159  : 	CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition

; 160  : 
; 161  : 	// all children are invalid, but we are not
; 162  : 	// this will cause the velocities of all children to need recomputation
; 163  : 	InvalidatePhysicsState( FL_ABSTRANSFORM, FL_ABSVELOCITY|FL_ABSAVELOCITY );

	push	786432					; 000c0000H
	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 164  : 	ClearBits( pev->flags, FL_ABSTRANSFORM );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 165  : 
; 166  : 	pev->angles = absAngles;

	mov	edx, DWORD PTR _absAngles$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 80					; 00000050H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 167  : 
; 168  : 	CheckAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckAngles@CBaseEntity@@QAEXXZ	; CBaseEntity::CheckAngles

; 169  : 
; 170  : 	m_local = matrix4x4( pev->origin, pev->angles, 1.0f );

	push	1065353216				; 3f800000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR $T40795[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 171  : 
; 172  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 173  : 	Vector vecNewAngles;

	lea	ecx, DWORD PTR _vecNewAngles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 174  : 
; 175  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38748

; 177  : 		vecNewAngles = absAngles;

	mov	ecx, DWORD PTR _absAngles$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vecNewAngles$[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _vecNewAngles$[ebp+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _vecNewAngles$[ebp+8], ecx

; 179  : 	else

	jmp	SHORT $L38749
$L38748:

; 181  : 		// moveparent case: transform the abs transform into local space
; 182  : 		matrix4x4 iparentSpace = pParent->EntityToWorldTransform().Invert();

	lea	edx, DWORD PTR $T40796[ebp]
	push	edx
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?Invert@matrix4x4@@QBE?AV1@XZ		; matrix4x4::Invert
	push	eax
	lea	ecx, DWORD PTR _iparentSpace$38750[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 183  : 		matrix4x4 local = iparentSpace.ConcatTransforms( m_local );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	push	eax
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR $T40798[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iparentSpace$38750[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _local$38752[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 184  : 		local.GetAngles( vecNewAngles );

	lea	edx, DWORD PTR _vecNewAngles$[ebp]
	push	edx
	lea	ecx, DWORD PTR _local$38752[ebp]
	call	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetAngles
$L38749:

; 186  : 
; 187  : 	m_vecAngles = vecNewAngles;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	mov	ecx, DWORD PTR _vecNewAngles$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vecNewAngles$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vecNewAngles$[ebp+8]
	mov	DWORD PTR [eax+8], ecx

; 188  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetAbsAngles
_TEXT	ENDS
PUBLIC	??BVector@@QBEPBMXZ				; Vector::operator float const *
PUBLIC	??0Vector4D@@QAE@XZ				; Vector4D::Vector4D
PUBLIC	??BVector4D@@QAEPAMXZ				; Vector4D::operator float *
PUBLIC	__real@4@00000000000000000000
PUBLIC	__real@8@3ff98efa351294e9c800
PUBLIC	?SinCos@@YAXMPAM0@Z				; SinCos
;	COMDAT __real@4@00000000000000000000
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@4@00000000000000000000 DD 000000000r	; 0
CONST	ENDS
;	COMDAT __real@8@3ff98efa351294e9c800
CONST	SEGMENT
__real@8@3ff98efa351294e9c800 DQ 03f91df46a2529d39r ; 0.0174533
CONST	ENDS
;	COMDAT ??0matrix4x4@@QAE@ABVVector@@0M@Z
_TEXT	SEGMENT
_origin$ = 8
_angles$ = 12
_scale$ = 16
_this$ = -4
_angle$ = -8
_sr$ = -12
_sp$ = -16
_sy$ = -20
_cr$ = -24
_cp$ = -28
_cy$ = -32
??0matrix4x4@@QAE@ABVVector@@0M@Z PROC NEAR		; matrix4x4::matrix4x4, COMDAT

; 701  : 	_forceinline matrix4x4( const Vector &origin, const Vector &angles, float scale = 1.0f )

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET FLAT:??0Vector4D@@QAE@XZ		; Vector4D::Vector4D
	push	4
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_H@YGXPAXIHP6EX0@Z@Z			; `vector constructor iterator'

; 702  : 	{
; 703  : 		float	angle, sr, sp, sy, cr, cp, cy;
; 704  : 
; 705  : 		if( angles[ROLL] )

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25873

; 707  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 708  : 			SinCos( angle, &sy, &cy );

	lea	ecx, DWORD PTR _cy$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sy$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 709  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 710  : 			SinCos( angle, &sp, &cp );

	lea	ecx, DWORD PTR _cp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sp$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 711  : 			angle = angles[ROLL] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 712  : 			SinCos( angle, &sr, &cr );

	lea	ecx, DWORD PTR _cr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sr$[ebp]
	push	edx
	mov	eax, DWORD PTR _angle$[ebp]
	push	eax
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 713  : 
; 714  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -36+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -36+[ebp]
	mov	DWORD PTR [eax], ecx

; 715  : 			mat[1][0] = (sr*sp*cy+cr*-sy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _cr$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -40+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax], edx

; 716  : 			mat[2][0] = (cr*sp*cy+-sr*-sy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fld	DWORD PTR _sy$[ebp]
	fchs
	fmulp	ST(1), ST(0)
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -44+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -44+[ebp]
	mov	DWORD PTR [eax], ecx

; 717  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 718  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -48+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+4], edx

; 719  : 			mat[1][1] = (sr*sp*sy+cr*cy) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -52+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -52+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 720  : 			mat[2][1] = (cr*sp*sy+-sr*cy) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fld	DWORD PTR _sr$[ebp]
	fchs
	fmul	DWORD PTR _cy$[ebp]
	faddp	ST(1), ST(0)
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -56+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax+4], edx

; 721  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 722  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -60+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -60+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 723  : 			mat[1][2] = (sr*cp) * scale;

	fld	DWORD PTR _sr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -64+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+8], edx

; 724  : 			mat[2][2] = (cr*cp) * scale;

	fld	DWORD PTR _cr$[ebp]
	fmul	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -68+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -68+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 725  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 726  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 727  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 728  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 729  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 731  : 		else if( angles[PITCH] )

	jmp	$L25878
$L25873:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25875

; 733  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 734  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 735  : 			angle = angles[PITCH] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 736  : 			SinCos( angle, &sp, &cp );

	lea	edx, DWORD PTR _cp$[ebp]
	push	edx
	lea	eax, DWORD PTR _sp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 737  : 
; 738  : 			mat[0][0] = (cp*cy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -72+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -72+[ebp]
	mov	DWORD PTR [eax], edx

; 739  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -76+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -76+[ebp]
	mov	DWORD PTR [eax], ecx

; 740  : 			mat[2][0] = (sp*cy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -80+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -80+[ebp]
	mov	DWORD PTR [eax], edx

; 741  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 742  : 			mat[0][1] = (cp*sy) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -84+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -84+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 743  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -88+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -88+[ebp]
	mov	DWORD PTR [eax+4], edx

; 744  : 			mat[2][1] = (sp*sy) * scale;

	fld	DWORD PTR _sp$[ebp]
	fmul	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -92+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -92+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 745  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 746  : 			mat[0][2] = (-sp) * scale;

	fld	DWORD PTR _sp$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -96+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -96+[ebp]
	mov	DWORD PTR [eax+8], edx

; 747  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 748  : 			mat[2][2] = (cp) * scale;

	fld	DWORD PTR _cp$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -100+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -100+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 749  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 750  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 751  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 752  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 753  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 755  : 		else if( angles[YAW] )

	jmp	$L25878
$L25875:
	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	$L25877

; 757  : 			angle = angles[YAW] * (M_PI*2 / 360);

	mov	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@8@3ff98efa351294e9c800
	fstp	DWORD PTR _angle$[ebp]

; 758  : 			SinCos( angle, &sy, &cy );

	lea	edx, DWORD PTR _cy$[ebp]
	push	edx
	lea	eax, DWORD PTR _sy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _angle$[ebp]
	push	ecx
	call	?SinCos@@YAXMPAM0@Z			; SinCos
	add	esp, 12					; 0000000cH

; 759  : 
; 760  : 			mat[0][0] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -104+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -104+[ebp]
	mov	DWORD PTR [eax], edx

; 761  : 			mat[1][0] = (-sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fchs
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -108+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -108+[ebp]
	mov	DWORD PTR [eax], ecx

; 762  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 763  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 764  : 			mat[0][1] = (sy) * scale;

	fld	DWORD PTR _sy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -112+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR -112+[ebp]
	mov	DWORD PTR [eax+4], edx

; 765  : 			mat[1][1] = (cy) * scale;

	fld	DWORD PTR _cy$[ebp]
	fmul	DWORD PTR _scale$[ebp]
	fstp	DWORD PTR -116+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR -116+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 766  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 767  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx

; 768  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 769  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 770  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], edx

; 771  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx

; 772  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 773  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 774  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 775  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H

; 777  : 		else

	jmp	$L25878
$L25877:

; 779  : 			mat[0][0] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax], ecx

; 780  : 			mat[1][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 781  : 			mat[2][0] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax], 0

; 782  : 			mat[3][0] = origin.x;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 783  : 			mat[0][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 784  : 			mat[1][1] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+4], edx

; 785  : 			mat[2][1] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+4], 0

; 786  : 			mat[3][1] = origin.y;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _origin$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 787  : 			mat[0][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 788  : 			mat[1][2] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+8], 0

; 789  : 			mat[2][2] = scale;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	ecx, DWORD PTR _scale$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 790  : 			mat[3][2] = origin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	edx, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx

; 791  : 			mat[0][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 792  : 			mat[1][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 793  : 			mat[2][3] = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 0

; 794  : 			mat[3][3] = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	DWORD PTR [eax+12], 1065353216		; 3f800000H
$L25878:

; 796  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0matrix4x4@@QAE@ABVVector@@0M@Z ENDP			; matrix4x4::matrix4x4
_TEXT	ENDS
;	COMDAT ?SinCos@@YAXMPAM0@Z
_TEXT	SEGMENT
_angle$ = 8
_sine$ = 12
_cosine$ = 16
?SinCos@@YAXMPAM0@Z PROC NEAR				; SinCos, COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 37   : 	__asm
; 38   : 	{
; 39   : 		push	ecx

	push	ecx

; 40   : 		fld	dword ptr angle

	fld	DWORD PTR _angle$[ebp]

; 41   : 		fsincos

	fsincos

; 42   : 		mov	ecx, dword ptr[cosine]

	mov	ecx, DWORD PTR _cosine$[ebp]

; 43   : 		fstp      dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 44   : 		mov 	ecx, dword ptr[sine]

	mov	ecx, DWORD PTR _sine$[ebp]

; 45   : 		fstp	dword ptr [ecx]

	fstp	DWORD PTR [ecx]

; 46   : 		pop	ecx

	pop	ecx

; 47   : 	}
; 48   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SinCos@@YAXMPAM0@Z ENDP				; SinCos
_TEXT	ENDS
;	COMDAT ??BVector@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QBEPBMXZ PROC NEAR				; Vector::operator float const *, COMDAT

; 229  : 	operator const float *() const		{ return &x; } 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QBEPBMXZ ENDP				; Vector::operator float const *
_TEXT	ENDS
;	COMDAT ??0Vector4D@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0Vector4D@@QAE@XZ PROC NEAR				; Vector4D::Vector4D, COMDAT

; 311  : 	inline Vector4D( void ) { }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4D@@QAE@XZ ENDP				; Vector4D::Vector4D
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector4D@@QAEPAMXZ PROC NEAR				; Vector4D::operator float *, COMDAT

; 325  : 	operator float *()					{ return &x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector4D@@QAEPAMXZ ENDP				; Vector4D::operator float *
_TEXT	ENDS
PUBLIC	?GetAngles@matrix4x4@@QAE?AVVector@@XZ		; matrix4x4::GetAngles
;	COMDAT ?GetAngles@matrix4x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT
_angles$ = 8
_this$ = -4
$T40815 = -16
?GetAngles@matrix4x4@@QAEXAAVVector@@@Z PROC NEAR	; matrix4x4::GetAngles, COMDAT

; 1014 : 	void	GetAngles( Vector &angles ) { angles = GetAngles(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40815[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAngles@matrix4x4@@QAE?AVVector@@XZ	; matrix4x4::GetAngles
	mov	ecx, DWORD PTR _angles$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix4x4@@QAEXAAVVector@@@Z ENDP		; matrix4x4::GetAngles
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@ABV0@@Z				; Vector::Vector
PUBLIC	??BVector@@QAEPAMXZ				; Vector::operator float *
PUBLIC	__real@4@3ff583126f0000000000
PUBLIC	__real@4@4004e52ee10000000000
EXTRN	_atan2:NEAR
EXTRN	_sqrt:NEAR
;	COMDAT __real@4@3ff583126f0000000000
; File z:\xashxtsrc\game_shared\matrix.h
CONST	SEGMENT
__real@4@3ff583126f0000000000 DD 03a83126fr	; 0.001
CONST	ENDS
;	COMDAT __real@4@4004e52ee10000000000
CONST	SEGMENT
__real@4@4004e52ee10000000000 DD 042652ee1r	; 57.2958
CONST	ENDS
;	COMDAT ?GetAngles@matrix4x4@@QAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_xyDist$ = -8
_angles$ = -20
?GetAngles@matrix4x4@@QAE?AVVector@@XZ PROC NEAR	; matrix4x4::GetAngles, COMDAT

; 993  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 994  : 		float xyDist = sqrt( mat[0][0] * mat[0][0] + mat[0][1] * mat[0][1] );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR -24+[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [esi+4]
	fmul	DWORD PTR [eax+4]
	fadd	DWORD PTR -24+[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR _xyDist$[ebp]

; 995  : 		Vector angles;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 996  : 
; 997  : 		// enough here to get angles?
; 998  : 		if( xyDist > 0.001f )

	fld	DWORD PTR _xyDist$[ebp]
	fcomp	DWORD PTR __real@4@3ff583126f0000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$L25975

; 1000 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -28+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -32+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -32+[ebp]
	mov	DWORD PTR [eax], ecx

; 1001 : 			angles[1] = RAD2DEG( atan2( mat[0][1], mat[0][0] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -36+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -40+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -40+[ebp]
	mov	DWORD PTR [eax+4], edx

; 1002 : 			angles[2] = RAD2DEG( atan2( mat[1][2], mat[2][2] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -44+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -48+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -48+[ebp]
	mov	DWORD PTR [eax+8], ecx

; 1004 : 		else	// forward is mostly Z, gimbal lock

	jmp	$L25982
$L25975:

; 1006 : 			angles[0] = RAD2DEG( atan2( -mat[0][2], xyDist ) );

	fld	DWORD PTR _xyDist$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+8]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -52+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -56+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	edx, DWORD PTR -56+[ebp]
	mov	DWORD PTR [eax], edx

; 1007 : 			angles[1] = RAD2DEG( atan2( -mat[1][0], mat[1][1] ) );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax+4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QAEPAMXZ			; Vector4D::operator float *
	fld	DWORD PTR [eax]
	fchs
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_atan2
	add	esp, 16					; 00000010H
	fst	DWORD PTR -60+[ebp]
	fmul	DWORD PTR __real@4@4004e52ee10000000000
	fstp	DWORD PTR -64+[ebp]
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	ecx, DWORD PTR -64+[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1008 : 			angles[2] = 0;

	lea	ecx, DWORD PTR _angles$[ebp]
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	mov	DWORD PTR [eax+8], 0
$L25982:

; 1010 : 
; 1011 : 		return angles;

	lea	edx, DWORD PTR _angles$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1012 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetAngles@matrix4x4@@QAE?AVVector@@XZ ENDP		; matrix4x4::GetAngles
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??0Vector@@QAE@ABV0@@Z PROC NEAR			; Vector::Vector, COMDAT

; 136  : 	inline Vector(const Vector& v)		{ x = v.x; y = v.y; z = v.z;		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector@@QAE@ABV0@@Z ENDP				; Vector::Vector
_TEXT	ENDS
;	COMDAT ??BVector@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4
??BVector@@QAEPAMXZ PROC NEAR				; Vector::operator float *, COMDAT

; 228  : 	operator float *()				{ return &x; } // Vectors will now automatically convert to float * when needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector@@QAEPAMXZ ENDP				; Vector::operator float *
_TEXT	ENDS
PUBLIC	??0Vector@@QAE@MMM@Z				; Vector::Vector
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ
_TEXT	SEGMENT
_this$ = -4
$T40828 = -68
$T40829 = -80
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ PROC NEAR ; CBaseEntity::EntityToWorldTransform, COMDAT

; 732  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 733  : 	if( IsPlayer( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L35136

; 735  : 		m_local = matrix4x4( pev->origin, Vector( 0.0f, pev->angles.y, 0.0f ));

	push	1065353216				; 3f800000H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	push	0
	lea	ecx, DWORD PTR $T40829[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	lea	ecx, DWORD PTR $T40828[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 737  : 	else if( pev->flags & FL_ABSTRANSFORM )

	jmp	SHORT $L35140
$L35136:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L35140

; 739  : 		CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition
$L35140:

; 741  : 	return m_local; 

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H

; 742  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ENDP ; CBaseEntity::EntityToWorldTransform
_TEXT	ENDS
;	COMDAT ??0Vector@@QAE@MMM@Z
_TEXT	SEGMENT
_X$ = 8
_Y$ = 12
_Z$ = 16
_this$ = -4
??0Vector@@QAE@MMM@Z PROC NEAR				; Vector::Vector, COMDAT

; 135  : 	inline Vector(float X, float Y, float Z)	{ x = X; y = Y; z = Z;                     }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _Y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _Z$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector@@QAE@MMM@Z ENDP				; Vector::Vector
_TEXT	ENDS
PUBLIC	??GVector@@QBE?AV0@ABV0@@Z			; Vector::operator-
PUBLIC	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetAbsVelocity
EXTRN	?VectorIRotate@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorIRotate
;	COMDAT ?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vecAbsVelocity$ = 8
_this$ = -4
_pParent$ = -8
_relVelocity$ = -20
$T40834 = -32
$T40835 = -44
?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetAbsVelocity, COMDAT

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 192  : 	// the abs velocity won't be dirty since we're setting it here
; 193  : 	// all children are invalid, but we are not
; 194  : 	InvalidatePhysicsState( FL_ABSVELOCITY );

	push	0
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 195  : 	ClearBits( pev->flags, FL_ABSVELOCITY );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -262145				; fffbffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 196  : 
; 197  : 	pev->velocity = vecAbsVelocity;

	mov	edx, DWORD PTR _vecAbsVelocity$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 32					; 00000020H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 198  : 
; 199  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 200  : 
; 201  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38760

; 203  : 		m_vecVelocity = vecAbsVelocity;

	mov	eax, DWORD PTR _vecAbsVelocity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 204  : 		return;

	jmp	SHORT $L38758
$L38760:

; 206  : 
; 207  : 	// first subtract out the parent's abs velocity to get a relative
; 208  : 	// velocity measured in world space
; 209  : 	Vector relVelocity = vecAbsVelocity - pParent->GetAbsVelocity();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR $T40834[ebp]
	push	ecx
	mov	ecx, DWORD PTR _vecAbsVelocity$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _relVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 210  : 
; 211  : 	// transform relative velocity into parent space
; 212  : 	m_vecVelocity = pParent->EntityToWorldTransform().VectorIRotate( relVelocity );

	lea	edx, DWORD PTR _relVelocity$[ebp]
	push	edx
	lea	eax, DWORD PTR $T40835[ebp]
	push	eax
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?VectorIRotate@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorIRotate
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L38758:

; 213  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetAbsVelocity
_TEXT	ENDS
;	COMDAT ??GVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40838 = -16
??GVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator-, COMDAT

; 150  : 	inline Vector operator-(const Vector& v) const	{ return Vector(x-v.x, y-v.y, z-v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fsub	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fsub	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fsub	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40838[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??GVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator-
_TEXT	ENDS
PUBLIC	?SetAbsAvelocity@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetAbsAvelocity
;	COMDAT ?SetAbsAvelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vecAbsAvelocity$ = 8
_this$ = -4
_pParent$ = -8
?SetAbsAvelocity@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetAbsAvelocity, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 217  : 	// the abs velocity won't be dirty since we're setting it here
; 218  : 	// all children are invalid, but we are not
; 219  : 	InvalidatePhysicsState( FL_ABSAVELOCITY );

	push	0
	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 220  : 	ClearBits( pev->flags, FL_ABSAVELOCITY );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -524289				; fff7ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 221  : 
; 222  : 	pev->avelocity = vecAbsAvelocity;

	mov	edx, DWORD PTR _vecAbsAvelocity$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 92					; 0000005cH
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 223  : 
; 224  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 225  : 
; 226  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38769

; 228  : 		m_vecAvelocity = vecAbsAvelocity;

	mov	eax, DWORD PTR _vecAbsAvelocity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L38769:

; 231  : 
; 232  : 	// DAMN! we can't transform avelocity because it's not angle and not vector!!!
; 233  : 	// i've just leave unchanged
; 234  : #if 0
; 235  : 	// this transforms the local ang velocity into world space
; 236  : 	matrix4x4	avel = matrix4x4( g_vecZero, vecAbsAvelocity );
; 237  : 	matrix4x4 iparentSpace = pParent->GetParentToWorldTransform().Invert();
; 238  : 	matrix4x4 worldAvel = iparentSpace.ConcatTransforms( avel );
; 239  : 	worldAvel.GetAngles( pev->avelocity );	// but.. this is no more avelocity? this is some angles
; 240  : 
; 241  : 	// g-cont. trying to get avelocity length, normalize, rotate by parent space and apply length again?
; 242  : #endif
; 243  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetAbsAvelocity@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetAbsAvelocity
_TEXT	ENDS
;	COMDAT ?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z
_TEXT	SEGMENT
_flags$ = 8
_childflags$ = 12
_this$ = -4
_pChild$ = -8
?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z PROC NEAR	; CBaseEntity::InvalidatePhysicsState, COMDAT

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 	pev->flags |= flags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, DWORD PTR _flags$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 251  : 	flags |= childflags;

	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, DWORD PTR _childflags$[ebp]
	mov	DWORD PTR _flags$[ebp], edx

; 252  : 
; 253  : 	for( CBaseEntity *pChild = m_hChild; pChild != NULL; pChild = pChild->m_hNextChild )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pChild$[ebp], eax
	jmp	SHORT $L38776
$L38777:
	mov	ecx, DWORD PTR _pChild$[ebp]
	add	ecx, 164				; 000000a4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pChild$[ebp], eax
$L38776:
	cmp	DWORD PTR _pChild$[ebp], 0
	je	SHORT $L38778

; 255  : 		pChild->InvalidatePhysicsState( flags );

	push	0
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChild$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 256  : 	}

	jmp	SHORT $L38777
$L38778:

; 257  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ENDP	; CBaseEntity::InvalidatePhysicsState
_TEXT	ENDS
PUBLIC	??HVector@@QBE?AV0@ABV0@@Z			; Vector::operator+
PUBLIC	??DVector@@QBE?AV0@M@Z				; Vector::operator*
PUBLIC	?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z		; matrix4x4::GetOrigin
PUBLIC	?Normalize@Vector@@QBE?AV1@XZ			; Vector::Normalize
EXTRN	??0matrix4x4@@QAE@XZ:NEAR			; matrix4x4::matrix4x4
EXTRN	?Identity@matrix4x4@@QAEXXZ:NEAR		; matrix4x4::Identity
EXTRN	?GetAbsStartPos@CBeam@@QBEABVVector@@XZ:NEAR	; CBeam::GetAbsStartPos
EXTRN	?GetAbsEndPos@CBeam@@QBEABVVector@@XZ:NEAR	; CBeam::GetAbsEndPos
;	COMDAT ?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_pParent$ = -8
_temp$ = -72
_pBeam$38788 = -76
_beamDir$38790 = -88
$T40845 = -188
_m$38797 = -152
$T40846 = -200
_vecAngles$38798 = -164
$T40847 = -264
_vecOrigin$38799 = -176
$T40848 = -276
$T40849 = -288
$T40850 = -352
?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ PROC NEAR ; CBaseEntity::GetParentToWorldTransform, COMDAT

; 263  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 416				; 000001a0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 265  : 
; 266  : 	matrix4x4	temp;

	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0matrix4x4@@QAE@XZ			; matrix4x4::matrix4x4

; 267  : 
; 268  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38786

; 270  : 		temp.Identity();

	lea	ecx, DWORD PTR _temp$[ebp]
	call	?Identity@matrix4x4@@QAEXXZ		; matrix4x4::Identity

; 271  : 		return temp;

	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$L38783
$L38786:

; 273  : 
; 274  : #if 0	// UNDONE
; 275  : 	if( m_iParentAttachment != 0 )
; 276  : 	{
; 277  : 		Vector vOrigin, vAngles;
; 278  : 
; 279  : 		CBaseAnimating *pAnimating = pParent->GetBaseAnimating();
; 280  : 		if( pAnimating && pAnimating->GetAttachment( m_iParentAttachment, vOrigin, vAngles ))
; 281  : 		{
; 282  : 			// NOTE: we need to set sv_allow_studio_attachment_angles to 1
; 283  : 			// if we want give valid attachment angles here
; 284  : 			temp = matrix4x4( vOrigin, vAngles );
; 285  : 			return temp;
; 286  : 		}
; 287  : 	}
; 288  : #endif	
; 289  : 	// allow to attach at end of the laser beam
; 290  : 	if( pParent->pev->flags & FL_CUSTOMENTITY )

	mov	ecx, DWORD PTR _pParent$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 536870912				; 20000000H
	test	eax, eax
	je	$L38787

; 292  : 		CBeam *pBeam = (CBeam *)pParent;

	mov	ecx, DWORD PTR _pParent$[ebp]
	mov	DWORD PTR _pBeam$38788[ebp], ecx

; 293  : 		Vector beamDir = (pBeam->GetAbsEndPos() - pBeam->GetAbsStartPos()).Normalize();

	lea	edx, DWORD PTR $T40846[ebp]
	push	edx
	mov	ecx, DWORD PTR _pBeam$38788[ebp]
	call	?GetAbsStartPos@CBeam@@QBEABVVector@@XZ	; CBeam::GetAbsStartPos
	push	eax
	lea	eax, DWORD PTR $T40845[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBeam$38788[ebp]
	call	?GetAbsEndPos@CBeam@@QBEABVVector@@XZ	; CBeam::GetAbsEndPos
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, eax
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	push	eax
	lea	ecx, DWORD PTR _beamDir$38790[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 294  : 		return matrix4x4( pBeam->GetAbsEndPos() + beamDir * -8.0f, g_vecZero );

	push	1065353216				; 3f800000H
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	push	-1056964608				; c1000000H
	lea	ecx, DWORD PTR $T40848[ebp]
	push	ecx
	lea	ecx, DWORD PTR _beamDir$38790[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	edx, DWORD PTR $T40849[ebp]
	push	edx
	mov	ecx, DWORD PTR _pBeam$38788[ebp]
	call	?GetAbsEndPos@CBeam@@QBEABVVector@@XZ	; CBeam::GetAbsEndPos
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR $T40847[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$L38783
$L38787:

; 296  : 
; 297  : 	// TODO: do revision, some cases may be wrong
; 298  : 	if( m_iParentFlags != 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+176], 0
	je	$L38796

; 300  : 		matrix4x4	m = pParent->EntityToWorldTransform();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _m$38797[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 301  : 
; 302  : 		// this an incredible stupid way but...
; 303  : 		Vector vecAngles, vecOrigin;

	lea	ecx, DWORD PTR _vecAngles$38798[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _vecOrigin$38799[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 304  : 
; 305  : 		m.GetOrigin( vecOrigin );

	lea	ecx, DWORD PTR _vecOrigin$38799[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m$38797[ebp]
	call	?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetOrigin

; 306  : 		m.GetAngles( vecAngles );

	lea	edx, DWORD PTR _vecAngles$38798[ebp]
	push	edx
	lea	ecx, DWORD PTR _m$38797[ebp]
	call	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetAngles

; 307  : 
; 308  : 		if( m_iParentFlags & PARENT_FROZEN_POS_X )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 2
	test	ecx, ecx
	je	SHORT $L38800

; 309  : 			vecOrigin.x = m_vecOrigin.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	DWORD PTR _vecOrigin$38799[ebp], eax
$L38800:

; 310  : 
; 311  : 		if( m_iParentFlags & PARENT_FROZEN_POS_Y )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	and	edx, 4
	test	edx, edx
	je	SHORT $L38801

; 312  : 			vecOrigin.y = m_vecOrigin.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	DWORD PTR _vecOrigin$38799[ebp+4], ecx
$L38801:

; 313  : 
; 314  : 		if( m_iParentFlags & PARENT_FROZEN_POS_Z )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+176]
	and	eax, 8
	test	eax, eax
	je	SHORT $L38802

; 315  : 			vecOrigin.z = m_vecOrigin.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR _vecOrigin$38799[ebp+8], edx
$L38802:

; 316  : 
; 317  : 		if( m_iParentFlags & PARENT_FROZEN_ROT_X )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	and	ecx, 16					; 00000010H
	test	ecx, ecx
	je	SHORT $L38803

; 318  : 			vecAngles.x = m_vecAngles.x;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	DWORD PTR _vecAngles$38798[ebp], eax
$L38803:

; 319  : 
; 320  : 		if( m_iParentFlags & PARENT_FROZEN_ROT_Y )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+176]
	and	edx, 32					; 00000020H
	test	edx, edx
	je	SHORT $L38804

; 321  : 			vecAngles.y = m_vecAngles.y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	mov	DWORD PTR _vecAngles$38798[ebp+4], ecx
$L38804:

; 322  : 
; 323  : 		if( m_iParentFlags & PARENT_FROZEN_ROT_Z )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+176]
	and	eax, 64					; 00000040H
	test	eax, eax
	je	SHORT $L38805

; 324  : 			vecAngles.z = m_vecAngles.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	DWORD PTR _vecAngles$38798[ebp+8], edx
$L38805:

; 325  : 
; 326  : 		return matrix4x4( vecOrigin, vecAngles, 1.0f );

	push	1065353216				; 3f800000H
	lea	eax, DWORD PTR _vecAngles$38798[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$38799[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T40850[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L38783
$L38796:

; 328  : 
; 329  : 	// If we fall through to here, then just use the move parent's abs origin and angles.
; 330  : 	return pParent->EntityToWorldTransform();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L38783:

; 331  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ENDP ; CBaseEntity::GetParentToWorldTransform
_TEXT	ENDS
;	COMDAT ??HVector@@QBE?AV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40853 = -16
??HVector@@QBE?AV0@ABV0@@Z PROC NEAR			; Vector::operator+, COMDAT

; 149  : 	inline Vector operator+(const Vector& v) const	{ return Vector(x+v.x, y+v.y, z+v.z);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+4]
	fadd	DWORD PTR [eax+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fadd	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40853[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??HVector@@QBE?AV0@ABV0@@Z ENDP				; Vector::operator+
_TEXT	ENDS
;	COMDAT ??DVector@@QBE?AV0@M@Z
_TEXT	SEGMENT
_fl$ = 12
___$ReturnUdt$ = 8
_this$ = -4
$T40856 = -16
??DVector@@QBE?AV0@M@Z PROC NEAR			; Vector::operator*, COMDAT

; 153  : 	inline Vector operator*(float fl) const		{ return Vector(x*fl, y*fl, z*fl);	   }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fl$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40856[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??DVector@@QBE?AV0@M@Z ENDP				; Vector::operator*
_TEXT	ENDS
PUBLIC	?Length@Vector@@QBEMXZ				; Vector::Length
PUBLIC	__real@4@3fff8000000000000000
;	COMDAT __real@4@3fff8000000000000000
; File z:\xashxtsrc\game_shared\vector.h
CONST	SEGMENT
__real@4@3fff8000000000000000 DD 03f800000r	; 1
CONST	ENDS
;	COMDAT ?Normalize@Vector@@QBE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
_flLen$ = -8
$T40859 = -20
?Normalize@Vector@@QBE?AV1@XZ PROC NEAR			; Vector::Normalize, COMDAT

; 232  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		float flLen = Length();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Length@Vector@@QBEMXZ			; Vector::Length
	fstp	DWORD PTR _flLen$[ebp]

; 234  : 
; 235  : 		if( flLen )

	fld	DWORD PTR _flLen$[ebp]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	jne	SHORT $L24894

; 237  : 			flLen = 1.0f / flLen;

	fld	DWORD PTR __real@4@3fff8000000000000000
	fdiv	DWORD PTR _flLen$[ebp]
	fstp	DWORD PTR _flLen$[ebp]

; 238  : 			return Vector( x * flLen, y * flLen, z * flLen );

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [eax+8]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [ecx+4]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _flLen$[ebp]
	fmul	DWORD PTR [edx]
	push	ecx
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T40859[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L24892
$L24894:

; 240  : 
; 241  : 		return *this; // can't normalize

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L24892:

; 242  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Normalize@Vector@@QBE?AV1@XZ ENDP			; Vector::Normalize
_TEXT	ENDS
;	COMDAT ?Length@Vector@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4
?Length@Vector@@QBEMXZ PROC NEAR			; Vector::Length, COMDAT

; 226  : 	inline float Length(void) const		{ return sqrt( x*x + y*y + z*z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fst	DWORD PTR -8+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@Vector@@QBEMXZ ENDP				; Vector::Length
_TEXT	ENDS
PUBLIC	??BVector4D@@QAE?AVVector@@XZ			; Vector4D::operator Vector
;	COMDAT ?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z
_TEXT	SEGMENT
_vOrigin$ = 8
_this$ = -4
$T40866 = -16
$T40867 = -28
?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z PROC NEAR	; matrix4x4::GetOrigin, COMDAT

; 990  : 	void	GetOrigin( Vector &vOrigin ) { vOrigin = mat[3]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40867[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??BVector4D@@QAE?AVVector@@XZ		; Vector4D::operator Vector
	push	eax
	lea	ecx, DWORD PTR $T40866[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR _vOrigin$[ebp]
	mov	edx, DWORD PTR $T40866[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T40866[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T40866[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z ENDP		; matrix4x4::GetOrigin
_TEXT	ENDS
;	COMDAT ??BVector4D@@QAE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40870 = -16
??BVector4D@@QAE?AVVector@@XZ PROC NEAR			; Vector4D::operator Vector, COMDAT

; 329  : 	operator Vector()					{ return Vector( x, y, z ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR $T40870[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??BVector4D@@QAE?AVVector@@XZ ENDP			; Vector4D::operator Vector
_TEXT	ENDS
PUBLIC	??9Vector@@QBEHABV0@@Z				; Vector::operator!=
;	COMDAT ?CalcAbsolutePosition@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pParent$ = -8
_parentSpace$ = -72
$T40873 = -136
$T40874 = -200
$T40876 = -268
$T40877 = -280
?CalcAbsolutePosition@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::CalcAbsolutePosition, COMDAT

; 338  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 	if( !FBitSet( pev->flags, FL_ABSTRANSFORM ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 131072				; 00020000H
	test	edx, edx
	jne	SHORT $L38811

; 340  : 		return;

	jmp	$L38810
$L38811:

; 341  : 
; 342  : 	ClearBits( pev->flags, FL_ABSTRANSFORM ); // waiting for next invalidate

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 343  : 
; 344  : 	// plop the entity->parent matrix into m_local
; 345  : 	m_local = matrix4x4( m_vecOrigin, m_vecAngles, 1.0f );

	push	1065353216				; 3f800000H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	lea	ecx, DWORD PTR $T40873[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 346  : 
; 347  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 348  : 
; 349  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38814

; 351  : 		// no move parent, so just copy existing values
; 352  : 		pev->origin = pev->oldorigin = m_vecOrigin;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 20					; 00000014H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 8
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 353  : 		pev->angles = m_vecAngles;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 80					; 00000050H
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx

; 354  : 
; 355  : 		CheckAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckAngles@CBaseEntity@@QAEXXZ	; CBaseEntity::CheckAngles

; 356  : 		return;

	jmp	$L38810
$L38814:

; 358  : 
; 359  : 	// concatenate with our parent's transform
; 360  : 	matrix4x4	parentSpace = GetParentToWorldTransform();

	lea	edx, DWORD PTR $T40874[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetParentToWorldTransform@CBaseEntity@@QAE?AVmatrix4x4@@XZ ; CBaseEntity::GetParentToWorldTransform
	push	eax
	lea	ecx, DWORD PTR _parentSpace$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 361  : 
; 362  : 	// g-cont. probably our local matrix is now contain world orientation
; 363  : 	// and keep this state until next call of SetLocalAngles or SetLocalOrigin
; 364  : 	m_local = parentSpace.ConcatTransforms( m_local );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H
	sub	esp, 64					; 00000040H
	mov	ecx, esp
	push	eax
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR $T40876[ebp]
	push	ecx
	lea	ecx, DWORD PTR _parentSpace$[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 365  : 
; 366  : 	// pull our absolute position out of the matrix
; 367  : 	m_local.GetOrigin( pev->origin );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetOrigin

; 368  : 
; 369  : 	// if we have any angles, we have to extract our absolute angles from our matrix
; 370  : 	if( m_vecAngles != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38819

; 371  : 		m_local.GetAngles( pev->angles );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 80					; 00000050H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetAngles

; 372  : 	else if( pParent->IsPlayer() )

	jmp	SHORT $L38823
$L38819:
	mov	eax, DWORD PTR _pParent$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L38821

; 373  : 		pev->angles = Vector( 0.0f, pParent->pev->angles.y, 0.0f );

	push	0
	mov	eax, DWORD PTR _pParent$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	push	0
	lea	ecx, DWORD PTR $T40877[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 80					; 00000050H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 374  : 	else // just copy our parent's absolute angles

	jmp	SHORT $L38823
$L38821:

; 375  : 		pev->angles = pParent->GetAbsAngles();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 80					; 00000050H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L38823:

; 376  : 
; 377  : 	CheckAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckAngles@CBaseEntity@@QAEXXZ	; CBaseEntity::CheckAngles
$L38810:

; 378  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::CalcAbsolutePosition
_TEXT	ENDS
;	COMDAT ??9Vector@@QBEHABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??9Vector@@QBEHABV0@@Z PROC NEAR			; Vector::operator!=, COMDAT

; 148  : 	inline int operator!=(const Vector& v) const	{ return !(*this==v);		   }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector@@QBEHABV0@@Z ENDP				; Vector::operator!=
_TEXT	ENDS
PUBLIC	??YVector@@QAEAAV0@ABV0@@Z			; Vector::operator+=
EXTRN	?VectorRotate@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorRotate
;	COMDAT ?CalcAbsoluteVelocity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pParent$ = -8
$T40882 = -20
?CalcAbsoluteVelocity@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::CalcAbsoluteVelocity, COMDAT

; 381  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 382  : 	if( !FBitSet( pev->flags, FL_ABSVELOCITY ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 262144				; 00040000H
	test	edx, edx
	jne	SHORT $L38828

; 383  : 		return;

	jmp	$L38827
$L38828:

; 384  : 
; 385  : 	ClearBits( pev->flags, FL_ABSVELOCITY ); // waiting for next invalidate

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -262145				; fffbffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 386  : 
; 387  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 388  : 
; 389  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38830

; 391  : 		pev->velocity = m_vecVelocity;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 124				; 0000007cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 32					; 00000020H
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx

; 392  : 		return;

	jmp	SHORT $L38827
$L38830:

; 394  : 
; 395  : 	// this transforms the local velocity into world space
; 396  : 	pev->velocity = pParent->EntityToWorldTransform().VectorRotate( m_vecVelocity );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 124				; 0000007cH
	push	eax
	lea	ecx, DWORD PTR $T40882[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?VectorRotate@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorRotate
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 397  : 
; 398  : 	// now add in the parent abs velocity
; 399  : 	pev->velocity += pParent->GetAbsVelocity();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 32					; 00000020H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$L38827:

; 400  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcAbsoluteVelocity@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::CalcAbsoluteVelocity
_TEXT	ENDS
;	COMDAT ??YVector@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_v$ = 8
_this$ = -4
??YVector@@QAEAAV0@ABV0@@Z PROC NEAR			; Vector::operator+=, COMDAT

; 159  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		x+=v.x; y+=v.y; z += v.z;	

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+8]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 161  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 162  : 	}			

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??YVector@@QAEAAV0@ABV0@@Z ENDP				; Vector::operator+=
_TEXT	ENDS
;	COMDAT ?CalcAbsoluteAvelocity@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pParent$ = -8
?CalcAbsoluteAvelocity@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::CalcAbsoluteAvelocity, COMDAT

; 405  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 406  : 	if( !FBitSet( pev->flags, FL_ABSAVELOCITY ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 524288				; 00080000H
	test	edx, edx
	jne	SHORT $L38836

; 407  : 		return;

	jmp	SHORT $L38835
$L38836:

; 408  : 
; 409  : 	ClearBits( pev->flags, FL_ABSAVELOCITY ); // waiting for next invalidate

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, -524289				; fff7ffffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 410  : 
; 411  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 412  : 
; 413  : 	if( !pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L38838

; 415  : 		pev->avelocity = m_vecAvelocity;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 92					; 0000005cH
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], edx
$L38838:
$L38835:

; 418  : 
; 419  : 	// DAMN! we can't transform avelocity because it's not angle and not vector!!!
; 420  : 	// i've just leave unchanged
; 421  : #if 0
; 422  : 	// this transforms the local ang velocity into world space
; 423  : 	matrix4x4	avel = matrix4x4( g_vecZero, m_vecAvelocity );
; 424  : 	matrix4x4 parentSpace = pParent->GetParentToWorldTransform();
; 425  : 	matrix4x4 worldAvel = parentSpace.ConcatTransforms( avel );
; 426  : 	worldAvel.GetAngles( pev->avelocity );	// but.. this is no more avelocity? this is some angles
; 427  : 
; 428  : 	// g-cont. trying to get avelocity length, normalize, rotate by parent space and apply length again?
; 429  : #endif
; 430  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CalcAbsoluteAvelocity@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::CalcAbsoluteAvelocity
_TEXT	ENDS
PUBLIC	?ApplyLocalVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::ApplyLocalVelocityImpulse
;	COMDAT ?ApplyLocalVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vecImpulse$ = 8
_this$ = -4
?ApplyLocalVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::ApplyLocalVelocityImpulse, COMDAT

; 433  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 434  : 	// NOTE: Don't have to use GetVelocity here because local values
; 435  : 	// are always guaranteed to be correct, unlike abs values which may 
; 436  : 	// require recomputation
; 437  : 	if( vecImpulse != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _vecImpulse$[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38843

; 439  : 		InvalidatePhysicsState( FL_ABSVELOCITY );

	push	0
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 440  : 		m_vecVelocity += vecImpulse;

	mov	eax, DWORD PTR _vecImpulse$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$L38843:

; 442  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ApplyLocalVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ENDP ; CBaseEntity::ApplyLocalVelocityImpulse
_TEXT	ENDS
PUBLIC	?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::ApplyAbsVelocityImpulse
;	COMDAT ?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
$T40891 = -28
_vecImpulse$ = 8
_this$ = -4
_vecResult$38849 = -16
?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::ApplyAbsVelocityImpulse, COMDAT

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 446  : 	// NOTE: Have to use GetAbsVelocity here to ensure it's the correct value
; 447  : 	if( vecImpulse != g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _vecImpulse$[ebp]
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38848

; 449  : 		Vector vecResult = GetAbsVelocity() + vecImpulse;

	mov	eax, DWORD PTR _vecImpulse$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T40891[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	lea	ecx, DWORD PTR _vecResult$38849[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 450  : 		SetAbsVelocity( vecResult );

	lea	edx, DWORD PTR _vecResult$38849[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L38848:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ApplyAbsVelocityImpulse@CBaseEntity@@QAEXABVVector@@@Z ENDP ; CBaseEntity::ApplyAbsVelocityImpulse
_TEXT	ENDS
PUBLIC	?GetForward@matrix4x4@@QBE?AVVector@@XZ		; matrix4x4::GetForward
PUBLIC	?GetRight@matrix4x4@@QBE?AVVector@@XZ		; matrix4x4::GetRight
PUBLIC	?GetUp@matrix4x4@@QBE?AVVector@@XZ		; matrix4x4::GetUp
PUBLIC	?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
PUBLIC	?GetVectors@CBaseEntity@@QBEXPAVVector@@00@Z	; CBaseEntity::GetVectors
;	COMDAT ?GetVectors@CBaseEntity@@QBEXPAVVector@@00@Z
_TEXT	SEGMENT
$T40894 = -20
$T40895 = -32
$T40896 = -44
_pForward$ = 8
_pRight$ = 12
_pUp$ = 16
_this$ = -4
_entityToWorld$ = -8
?GetVectors@CBaseEntity@@QBEXPAVVector@@00@Z PROC NEAR	; CBaseEntity::GetVectors, COMDAT

; 455  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 456  : 	// this call is necessary to cause m_rgflCoordinateFrame to be recomputed
; 457  : 	const matrix4x4 &entityToWorld = EntityToWorldTransform();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	DWORD PTR _entityToWorld$[ebp], eax

; 458  : 
; 459  : 	if( pForward != NULL )

	cmp	DWORD PTR _pForward$[ebp], 0
	je	SHORT $L38858

; 461  : 		*pForward = entityToWorld.GetForward();

	lea	eax, DWORD PTR $T40894[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityToWorld$[ebp]
	call	?GetForward@matrix4x4@@QBE?AVVector@@XZ	; matrix4x4::GetForward
	mov	ecx, DWORD PTR _pForward$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L38858:

; 463  : 
; 464  : 	if( pRight != NULL )

	cmp	DWORD PTR _pRight$[ebp], 0
	je	SHORT $L38860

; 466  : 		*pRight = entityToWorld.GetRight();

	lea	ecx, DWORD PTR $T40895[ebp]
	push	ecx
	mov	ecx, DWORD PTR _entityToWorld$[ebp]
	call	?GetRight@matrix4x4@@QBE?AVVector@@XZ	; matrix4x4::GetRight
	mov	edx, DWORD PTR _pRight$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L38860:

; 468  : 
; 469  : 	if( pUp != NULL )

	cmp	DWORD PTR _pUp$[ebp], 0
	je	SHORT $L38862

; 471  : 		*pUp = entityToWorld.GetUp();

	lea	ecx, DWORD PTR $T40896[ebp]
	push	ecx
	mov	ecx, DWORD PTR _entityToWorld$[ebp]
	call	?GetUp@matrix4x4@@QBE?AVVector@@XZ	; matrix4x4::GetUp
	mov	edx, DWORD PTR _pUp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L38862:

; 473  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetVectors@CBaseEntity@@QBEXPAVVector@@00@Z ENDP	; CBaseEntity::GetVectors
_TEXT	ENDS
PUBLIC	??BVector4D@@QBE?BVVector@@XZ			; Vector4D::operator Vector const 
;	COMDAT ?GetForward@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40899 = -16
$T40900 = -28
?GetForward@matrix4x4@@QBE?AVVector@@XZ PROC NEAR	; matrix4x4::GetForward, COMDAT

; 976  : 	Vector	GetForward() const { return mat[0]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40900[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??BVector4D@@QBE?BVVector@@XZ		; Vector4D::operator Vector const 
	push	eax
	lea	ecx, DWORD PTR $T40899[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR $T40899[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetForward@matrix4x4@@QBE?AVVector@@XZ ENDP		; matrix4x4::GetForward
_TEXT	ENDS
;	COMDAT ??BVector4D@@QBE?BVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40903 = -16
??BVector4D@@QBE?BVVector@@XZ PROC NEAR			; Vector4D::operator Vector const , COMDAT

; 330  : 	operator const Vector() const				{ return Vector( x, y, z ); } 

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR $T40903[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??BVector4D@@QBE?BVVector@@XZ ENDP			; Vector4D::operator Vector const 
_TEXT	ENDS
;	COMDAT ?GetRight@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40906 = -16
$T40907 = -28
?GetRight@matrix4x4@@QBE?AVVector@@XZ PROC NEAR		; matrix4x4::GetRight, COMDAT

; 977  : 	Vector	GetRight() const { return mat[1]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40907[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??BVector4D@@QBE?BVVector@@XZ		; Vector4D::operator Vector const 
	push	eax
	lea	ecx, DWORD PTR $T40906[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR $T40906[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetRight@matrix4x4@@QBE?AVVector@@XZ ENDP		; matrix4x4::GetRight
_TEXT	ENDS
;	COMDAT ?GetUp@matrix4x4@@QBE?AVVector@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8
_this$ = -4
$T40910 = -16
$T40911 = -28
?GetUp@matrix4x4@@QBE?AVVector@@XZ PROC NEAR		; matrix4x4::GetUp, COMDAT

; 978  : 	Vector	GetUp() const { return mat[2]; };

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR $T40911[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??BVector4D@@QBE?BVVector@@XZ		; Vector4D::operator Vector const 
	push	eax
	lea	ecx, DWORD PTR $T40910[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	lea	ecx, DWORD PTR $T40910[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GetUp@matrix4x4@@QBE?AVVector@@XZ ENDP			; matrix4x4::GetUp
_TEXT	ENDS
;	COMDAT ?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ
_TEXT	SEGMENT
_this$ = -4
$T40914 = -68
$T40915 = -80
?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ PROC NEAR ; CBaseEntity::EntityToWorldTransform, COMDAT

; 745  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 746  : 	if( const_cast<CBaseEntity*>(this)->IsPlayer( ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L35146

; 748  : 		const_cast<CBaseEntity*>(this)->m_local = matrix4x4( pev->origin, Vector( 0.0f, pev->angles.y, 0.0f ));

	push	1065353216				; 3f800000H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	push	0
	lea	ecx, DWORD PTR $T40915[ebp]
	call	??0Vector@@QAE@MMM@Z			; Vector::Vector
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	lea	ecx, DWORD PTR $T40914[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 750  : 	else if( pev->flags & FL_ABSTRANSFORM )

	jmp	SHORT $L35151
$L35146:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+420]
	and	ecx, 131072				; 00020000H
	test	ecx, ecx
	je	SHORT $L35151

; 752  : 		const_cast<CBaseEntity*>(this)->CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition
$L35151:

; 754  : 	return m_local; 

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 180				; 000000b4H

; 755  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ ENDP ; CBaseEntity::EntityToWorldTransform
_TEXT	ENDS
PUBLIC	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetLocalOrigin
;	COMDAT ?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_origin$ = 8
_this$ = -4
?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetLocalOrigin, COMDAT

; 479  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 480  : //	if( m_vecOrigin == origin ) return;
; 481  : 
; 482  : 	InvalidatePhysicsState( FL_ABSTRANSFORM );

	push	0
	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 483  : 	m_vecOrigin = origin;

	mov	eax, DWORD PTR _origin$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 484  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetLocalOrigin
_TEXT	ENDS
PUBLIC	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z	; CBaseEntity::SetLocalAngles
;	COMDAT ?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_angles$ = 8
_this$ = -4
?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetLocalAngles, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : //	if( m_vecAngles == angles ) return;
; 489  : 
; 490  : 	// This will cause the velocities of all children to need recomputation
; 491  : 	InvalidatePhysicsState( FL_ABSTRANSFORM, FL_ABSVELOCITY|FL_ABSAVELOCITY );

	push	786432					; 000c0000H
	push	131072					; 00020000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 492  : 	m_vecAngles = angles;

	mov	eax, DWORD PTR _angles$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 493  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetLocalAngles
_TEXT	ENDS
PUBLIC	?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalVelocity
;	COMDAT ?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vecVelocity$ = 8
_this$ = -4
?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetLocalVelocity, COMDAT

; 496  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 497  : //	if( m_vecVelocity == vecVelocity ) return;
; 498  : 
; 499  : 	InvalidatePhysicsState( FL_ABSVELOCITY );

	push	0
	push	262144					; 00040000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 500  : 	m_vecVelocity = vecVelocity;

	mov	eax, DWORD PTR _vecVelocity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 501  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLocalVelocity@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetLocalVelocity
_TEXT	ENDS
PUBLIC	?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAvelocity
;	COMDAT ?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z
_TEXT	SEGMENT
_vecAvelocity$ = 8
_this$ = -4
?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z PROC NEAR ; CBaseEntity::SetLocalAvelocity, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : //	if( m_vecAvelocity == vecAvelocity ) return;
; 506  : 
; 507  : 	InvalidatePhysicsState( FL_ABSAVELOCITY );

	push	0
	push	524288					; 00080000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InvalidatePhysicsState@CBaseEntity@@QAEXHH@Z ; CBaseEntity::InvalidatePhysicsState

; 508  : 	m_vecAvelocity = vecAvelocity;

	mov	eax, DWORD PTR _vecAvelocity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 509  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLocalAvelocity@CBaseEntity@@QAEXABVVector@@@Z ENDP	; CBaseEntity::SetLocalAvelocity
_TEXT	ENDS
PUBLIC	??0gametrace_s@@QAE@XZ				; gametrace_s::gametrace_s
PUBLIC	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z	; CBaseEntity::Instance
PUBLIC	?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z ; CBaseEntity::TouchLinks
PUBLIC	??_C@_0BN@JJED@bad?5entity?5in?5trigger?5list?$CB?6?$AA@ ; `string'
EXTRN	?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z:NEAR ; UTIL_TraceModel
EXTRN	?DispatchTouch@@YAXPAUedict_s@@0@Z:NEAR		; DispatchTouch
EXTRN	?g_groupop@@3HA:DWORD				; g_groupop
EXTRN	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z:NEAR	; UTIL_GetModelType
EXTRN	?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z:NEAR ; UTIL_HullPointContents
EXTRN	?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z:NEAR ; UTIL_HullForBsp
EXTRN	?BoundsIntersect@@YA_NABVVector@@000@Z:NEAR	; BoundsIntersect
EXTRN	?g_physfuncs@@3Userver_physics_api_s@@A:BYTE	; g_physfuncs
;	COMDAT ??_C@_0BN@JJED@bad?5entity?5in?5trigger?5list?$CB?6?$AA@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_0BN@JJED@bad?5entity?5in?5trigger?5list?$CB?6?$AA@ DB 'bad entity i'
	DB	'n trigger list!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z
_TEXT	SEGMENT
_tr$38914 = -104
_hull$38917 = -108
_matrix$38919 = -172
$T40926 = -184
$T40927 = -196
_ent$ = 8
_entmins$ = 12
_entmaxs$ = 16
_pPrevOrigin$ = 20
_node$ = 24
_this$ = -4
_touch$ = -8
_l$ = -12
_next$ = -16
_pTouch$ = -20
_pEnt$ = -24
_test$ = -36
_offset$ = -48
?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z PROC NEAR ; CBaseEntity::TouchLinks, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	edict_t *touch;
; 519  : 	link_t *l, *next;
; 520  : 	CBaseEntity *pTouch, *pEnt;
; 521  : 	Vector test, offset;

	lea	ecx, DWORD PTR _test$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 522  : 
; 523  : 	pEnt = CBaseEntity::Instance( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 524  : 
; 525  : 	// touch linked edicts
; 526  : 	for( l = node->trigger_edicts.next; l != &node->trigger_edicts; l = next )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _l$[ebp], edx
	jmp	SHORT $L38895
$L38896:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$L38895:
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 16					; 00000010H
	cmp	DWORD PTR _l$[ebp], ecx
	je	$L38897

; 528  : 		next = l->next;

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _next$[ebp], eax

; 529  : 		touch = EDICT_FROM_AREA( l );

	mov	ecx, DWORD PTR _l$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _touch$[ebp], ecx

; 530  : 		pTouch = CBaseEntity::Instance( touch );

	mov	edx, DWORD PTR _touch$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pTouch$[ebp], eax

; 531  : 
; 532  : 		if( !pTouch )

	cmp	DWORD PTR _pTouch$[ebp], 0
	jne	SHORT $L38902

; 534  : 			if( !touch->free )

	mov	eax, DWORD PTR _touch$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L38903

; 536  : 				ALERT( at_error, "bad entity in trigger list!\n" );

	push	OFFSET FLAT:??_C@_0BN@JJED@bad?5entity?5in?5trigger?5list?$CB?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 537  : 				SetBits( touch->v.flags, FL_KILLME ); // let the engine kill invalid entity

	mov	ecx, DWORD PTR _touch$[ebp]
	mov	edx, DWORD PTR [ecx+548]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _touch$[ebp]
	mov	DWORD PTR [eax+548], edx
$L38903:

; 539  : 			break;

	jmp	$L38897
$L38902:

; 541  : 
; 542  : 		if( pTouch == pEnt || pTouch->pev->solid != SOLID_TRIGGER ) // disabled ?

	mov	ecx, DWORD PTR _pTouch$[ebp]
	cmp	ecx, DWORD PTR _pEnt$[ebp]
	je	SHORT $L38906
	mov	edx, DWORD PTR _pTouch$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+268], 1
	je	SHORT $L38905
$L38906:

; 543  : 			continue;

	jmp	$L38896
$L38905:

; 544  : 
; 545  : 		if( pTouch->pev->groupinfo && pEnt->pev->groupinfo )

	mov	ecx, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+576], 0
	je	SHORT $L38908
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+576], 0
	je	SHORT $L38908

; 548  : 			(g_groupop == 1 && (pTouch->pev->groupinfo & pEnt->pev->groupinfo)))

	cmp	DWORD PTR ?g_groupop@@3HA, 0		; g_groupop
	jne	SHORT $L38910
	mov	edx, DWORD PTR _pTouch$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+576]
	and	eax, DWORD PTR [edx+576]
	test	eax, eax
	je	SHORT $L38909
$L38910:
	cmp	DWORD PTR ?g_groupop@@3HA, 1		; g_groupop
	jne	SHORT $L38908
	mov	ecx, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+576]
	and	edx, DWORD PTR [ecx+576]
	test	edx, edx
	je	SHORT $L38908
$L38909:

; 549  : 				continue;

	jmp	$L38896
$L38908:

; 551  : 
; 552  : 		if( !BoundsIntersect( entmins, entmaxs, touch->v.absmin, touch->v.absmax ))

	mov	eax, DWORD PTR _touch$[ebp]
	add	eax, 336				; 00000150H
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 324				; 00000144H
	push	ecx
	mov	edx, DWORD PTR _entmaxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _entmins$[ebp]
	push	eax
	call	?BoundsIntersect@@YA_NABVVector@@000@Z	; BoundsIntersect
	add	esp, 16					; 00000010H
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38911

; 553  : 			continue;

	jmp	$L38896
$L38911:

; 554  : 
; 555  : 		// check brush triggers accuracy
; 556  : 		if( UTIL_GetModelType( pTouch->pev->modelindex ) == mod_brush )

	mov	ecx, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	jne	$L38923

; 558  : 			if( pPrevOrigin && pTouch->IsPortal( ))

	cmp	DWORD PTR _pPrevOrigin$[ebp], 0
	je	SHORT $L38913
	mov	ecx, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	DWORD PTR [edx+248]
	test	eax, eax
	je	SHORT $L38913

; 560  : 				TraceResult tr;

	lea	ecx, DWORD PTR _tr$38914[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 561  : 
; 562  : 				// BUGBUG: this is valid only for zero-sized objects
; 563  : 				// This code helps the fast moving objects a moving through thin triggers (e.g. portals)
; 564  : 				UTIL_TraceModel( *pPrevOrigin, pEnt->GetAbsOrigin(), point_hull, touch, &tr );

	lea	eax, DWORD PTR _tr$38914[ebp]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	edx, DWORD PTR _pPrevOrigin$[ebp]
	push	edx
	call	?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceModel
	add	esp, 20					; 00000014H

; 565  : 				if( tr.flFraction == 1.0f )

	cmp	DWORD PTR _tr$38914[ebp+16], 1065353216	; 3f800000H
	jne	SHORT $L38915

; 566  : 					continue;

	jmp	$L38896
$L38915:

; 568  : 			else

	jmp	$L38923
$L38913:

; 570  : 				// force to select bsp-hull
; 571  : 				hull_t *hull = UTIL_HullForBsp( pTouch, pEnt->pev->mins, pEnt->pev->maxs, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 220				; 000000dcH
	push	ecx
	mov	edx, DWORD PTR _pTouch$[ebp]
	push	edx
	call	?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z ; UTIL_HullForBsp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$38917[ebp], eax

; 572  : 
; 573  : 				// support for rotational triggers
; 574  : 				if( UTIL_CanRotate( pTouch ) && pTouch->GetAbsAngles() != g_vecZero )

	mov	eax, DWORD PTR _pTouch$[ebp]
	push	eax
	call	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z	; UTIL_CanRotate
	add	esp, 4
	test	eax, eax
	je	SHORT $L38918
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38918

; 576  : 					matrix4x4	matrix( offset, pTouch->GetAbsAngles() );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _matrix$38919[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 577  : 					test = matrix.VectorITransform( pEnt->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T40926[ebp]
	push	edx
	lea	ecx, DWORD PTR _matrix$38919[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax

; 579  : 				else

	jmp	SHORT $L38921
$L38918:

; 581  : 					// offset the test point appropriately for this hull.
; 582  : 					test = pEnt->GetAbsOrigin() - offset;

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40927[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax
$L38921:

; 584  : 
; 585  : 				// test hull for intersection with this model
; 586  : 				if( UTIL_HullPointContents( hull, hull->firstclipnode, test ) != CONTENTS_SOLID )

	lea	ecx, DWORD PTR _test$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$38917[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _hull$38917[ebp]
	push	ecx
	call	?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z ; UTIL_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	je	SHORT $L38923

; 587  : 					continue;

	jmp	$L38896
$L38923:

; 590  : 
; 591  :       		gpGlobals->time = PHYSICS_TIME();

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+4
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [edx]

; 592  : 		DispatchTouch( touch, ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	push	ecx
	call	?DispatchTouch@@YAXPAUedict_s@@0@Z	; DispatchTouch
	add	esp, 8

; 593  : 	}

	jmp	$L38896
$L38897:

; 594  : 	
; 595  : 	// recurse down both sides
; 596  : 	if( node->axis == -1 ) return;

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $L38924
	jmp	SHORT $L38887
$L38924:

; 597  : 	
; 598  : 	if( entmaxs[node->axis] > node->dist )

	mov	ecx, DWORD PTR _entmaxs$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38925

; 599  : 		TouchLinks( ent, entmins, entmaxs, pPrevOrigin, node->children[0] );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pPrevOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entmaxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _entmins$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z ; CBaseEntity::TouchLinks
$L38925:

; 600  : 	if( entmins[node->axis] < node->dist )

	mov	ecx, DWORD PTR _entmins$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	edx, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+ecx*4]
	fcomp	DWORD PTR [edx+4]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38926

; 601  : 		TouchLinks( ent, entmins, entmaxs, pPrevOrigin, node->children[1] );

	mov	eax, DWORD PTR _node$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _pPrevOrigin$[ebp]
	push	edx
	mov	eax, DWORD PTR _entmaxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entmins$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z ; CBaseEntity::TouchLinks
$L38926:
$L38887:

; 602  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z ENDP ; CBaseEntity::TouchLinks
_TEXT	ENDS
PUBLIC	?ENT@@YAPAUedict_s@@H@Z				; ENT
;	COMDAT ?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z
_TEXT	SEGMENT
_pEnt$ = -4
_pent$ = 8
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z PROC NEAR	; CBaseEntity::Instance, COMDAT

; 526  : 	{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 527  : 		if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L35031

; 528  : 			pent = ENT(0);

	push	0
	call	?ENT@@YAPAUedict_s@@H@Z			; ENT
	add	esp, 4
	mov	DWORD PTR _pent$[ebp], eax
$L35031:

; 529  : 		CBaseEntity *pEnt = (CBaseEntity *)GET_PRIVATE(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 530  : 		return pEnt; 

	mov	eax, DWORD PTR _pEnt$[ebp]

; 531  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ENDP	; CBaseEntity::Instance
_TEXT	ENDS
;	COMDAT ?ENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_eoffset$ = 8
?ENT@@YAPAUedict_s@@H@Z PROC NEAR			; ENT, COMDAT

; 157  : inline edict_t *ENT(EOFFSET eoffset)			{ return (*g_engfuncs.pfnPEntityOfEntOffset)(eoffset); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _eoffset$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+276
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ENT@@YAPAUedict_s@@H@Z ENDP				; ENT
_TEXT	ENDS
;	COMDAT ??0gametrace_s@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0gametrace_s@@QAE@XZ PROC NEAR			; gametrace_s::gametrace_s, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0gametrace_s@@QAE@XZ ENDP				; gametrace_s::gametrace_s
_TEXT	ENDS
PUBLIC	?ClipLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ; CBaseEntity::ClipLinks
;	COMDAT ?ClipLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z
_TEXT	SEGMENT
_ent$ = 8
_entmins$ = 12
_entmaxs$ = 16
_node$ = 20
_this$ = -4
_clip$ = -8
_l$ = -12
_next$ = -16
_pClip$ = -20
_pEnt$ = -24
_test$ = -36
_offset$ = -48
_hull$38958 = -52
_matrix$38960 = -116
$T40936 = -128
$T40937 = -140
?ClipLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z PROC NEAR ; CBaseEntity::ClipLinks, COMDAT

; 612  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 	edict_t *clip;
; 614  : 	link_t *l, *next;
; 615  : 	CBaseEntity *pClip, *pEnt;
; 616  : 	Vector test, offset;

	lea	ecx, DWORD PTR _test$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 617  : 
; 618  : 	pEnt = CBaseEntity::Instance( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 619  : 
; 620  : 	// touch linked edicts
; 621  : 	for( l = node->solid_edicts.next; l != &node->solid_edicts; l = next )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR _l$[ebp], edx
	jmp	SHORT $L38943
$L38944:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$L38943:
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 24					; 00000018H
	cmp	DWORD PTR _l$[ebp], ecx
	je	$L38945

; 623  : 		next = l->next;

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _next$[ebp], eax

; 624  : 		clip = EDICT_FROM_AREA( l );

	mov	ecx, DWORD PTR _l$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _clip$[ebp], ecx

; 625  : 		pClip = CBaseEntity::Instance( clip );

	mov	edx, DWORD PTR _clip$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pClip$[ebp], eax

; 626  : 
; 627  : 		if( pClip == pEnt || pClip->pev->solid == SOLID_NOT ) // disabled ?

	mov	eax, DWORD PTR _pClip$[ebp]
	cmp	eax, DWORD PTR _pEnt$[ebp]
	je	SHORT $L38951
	mov	ecx, DWORD PTR _pClip$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+268], 0
	jne	SHORT $L38950
$L38951:

; 628  : 			continue;

	jmp	SHORT $L38944
$L38950:

; 629  : 
; 630  : 		if( pClip->pev->groupinfo && pEnt->pev->groupinfo )

	mov	eax, DWORD PTR _pClip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+576], 0
	je	SHORT $L38953
	mov	edx, DWORD PTR _pEnt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+576], 0
	je	SHORT $L38953

; 633  : 			(g_groupop == 1 && (pClip->pev->groupinfo & pEnt->pev->groupinfo)))

	cmp	DWORD PTR ?g_groupop@@3HA, 0		; g_groupop
	jne	SHORT $L38955
	mov	ecx, DWORD PTR _pClip$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx+576]
	and	edx, DWORD PTR [ecx+576]
	test	edx, edx
	je	SHORT $L38954
$L38955:
	cmp	DWORD PTR ?g_groupop@@3HA, 1		; g_groupop
	jne	SHORT $L38953
	mov	eax, DWORD PTR _pClip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pEnt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ecx+576]
	and	ecx, DWORD PTR [eax+576]
	test	ecx, ecx
	je	SHORT $L38953
$L38954:

; 634  : 				continue;

	jmp	$L38944
$L38953:

; 636  : 
; 637  : 		if( !BoundsIntersect( entmins, entmaxs, clip->v.absmin, clip->v.absmax ))

	mov	edx, DWORD PTR _clip$[ebp]
	add	edx, 336				; 00000150H
	push	edx
	mov	eax, DWORD PTR _clip$[ebp]
	add	eax, 324				; 00000144H
	push	eax
	mov	ecx, DWORD PTR _entmaxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entmins$[ebp]
	push	edx
	call	?BoundsIntersect@@YA_NABVVector@@000@Z	; BoundsIntersect
	add	esp, 16					; 00000010H
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38956

; 638  : 			continue;

	jmp	$L38944
$L38956:

; 639  : 
; 640  : 		// check brush triggers accuracy
; 641  : 		if( UTIL_GetModelType( pClip->pev->modelindex ) == mod_brush )

	mov	eax, DWORD PTR _pClip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	jne	$L38964

; 643  : 			// force to select bsp-hull
; 644  : 			hull_t *hull = UTIL_HullForBsp( pClip, pEnt->pev->mins, pEnt->pev->maxs, offset );

	lea	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	mov	eax, DWORD PTR _pEnt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 220				; 000000dcH
	push	ecx
	mov	edx, DWORD PTR _pClip$[ebp]
	push	edx
	call	?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z ; UTIL_HullForBsp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$38958[ebp], eax

; 645  : 
; 646  : 			// support for rotational triggers
; 647  : 			if( UTIL_CanRotate( pClip ) && pClip->GetAbsAngles() != g_vecZero )

	mov	eax, DWORD PTR _pClip$[ebp]
	push	eax
	call	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z	; UTIL_CanRotate
	add	esp, 4
	test	eax, eax
	je	SHORT $L38959
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pClip$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38959

; 649  : 				matrix4x4	matrix( offset, pClip->GetAbsAngles() );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pClip$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _matrix$38960[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 650  : 				test = matrix.VectorITransform( pEnt->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	edx, DWORD PTR $T40936[ebp]
	push	edx
	lea	ecx, DWORD PTR _matrix$38960[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax

; 652  : 			else

	jmp	SHORT $L38962
$L38959:

; 654  : 				// offset the test point appropriately for this hull.
; 655  : 				test = pEnt->GetAbsOrigin() - offset;

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40937[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax
$L38962:

; 657  : 
; 658  : 			// test hull for intersection with this model
; 659  : 			if( UTIL_HullPointContents( hull, hull->firstclipnode, test ) != CONTENTS_SOLID )

	lea	ecx, DWORD PTR _test$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$38958[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _hull$38958[ebp]
	push	ecx
	call	?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z ; UTIL_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	je	SHORT $L38964

; 660  : 				continue;

	jmp	$L38944
$L38964:

; 662  : 
; 663  :       		gpGlobals->time = PHYSICS_TIME();

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+4
	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	fstp	DWORD PTR [edx]

; 664  : 		DispatchTouch( ent, clip );

	mov	eax, DWORD PTR _clip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ent$[ebp]
	push	ecx
	call	?DispatchTouch@@YAXPAUedict_s@@0@Z	; DispatchTouch
	add	esp, 8

; 665  : 	}

	jmp	$L38944
$L38945:

; 666  : 	
; 667  : 	// recurse down both sides
; 668  : 	if( node->axis == -1 ) return;

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $L38965
	jmp	SHORT $L38935
$L38965:

; 669  : 	
; 670  : 	if( entmaxs[node->axis] > node->dist )

	mov	ecx, DWORD PTR _entmaxs$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L38966

; 671  : 		ClipLinks( ent, entmins, entmaxs, node->children[0] );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _entmaxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entmins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ; CBaseEntity::ClipLinks
$L38966:

; 672  : 	if( entmins[node->axis] < node->dist )

	mov	ecx, DWORD PTR _entmins$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L38967

; 673  : 		ClipLinks( ent, entmins, entmaxs, node->children[1] );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _entmaxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entmins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClipLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ; CBaseEntity::ClipLinks
$L38967:
$L38935:

; 674  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?ClipLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ENDP ; CBaseEntity::ClipLinks
_TEXT	ENDS
PUBLIC	?INDEXENT@@YAPAUedict_s@@H@Z			; INDEXENT
PUBLIC	?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ; CBaseEntity::SleepPortals
;	COMDAT ?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z
_TEXT	SEGMENT
_ent$ = 8
_entmins$ = 12
_entmaxs$ = 16
_node$ = 20
_this$ = -4
_touch$ = -8
_l$ = -12
_next$ = -16
_pTouch$ = -20
_pEnt$ = -24
_test$ = -36
_offset$ = -48
_hull$38992 = -52
_matrix$38994 = -116
_pPortalCamera$39000 = -120
$T40940 = -132
$T40941 = -144
?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z PROC NEAR ; CBaseEntity::SleepPortals, COMDAT

; 684  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 685  : 	edict_t *touch;
; 686  : 	link_t *l, *next;
; 687  : 	CBaseEntity *pTouch, *pEnt;
; 688  : 	Vector test, offset;

	lea	ecx, DWORD PTR _test$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _offset$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 689  : 
; 690  : 	pEnt = CBaseEntity::Instance( ent );

	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pEnt$[ebp], eax

; 691  : 
; 692  : 	// touch linked edicts
; 693  : 	for( l = node->trigger_edicts.next; l != &node->trigger_edicts; l = next )

	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _l$[ebp], edx
	jmp	SHORT $L38982
$L38983:
	mov	eax, DWORD PTR _next$[ebp]
	mov	DWORD PTR _l$[ebp], eax
$L38982:
	mov	ecx, DWORD PTR _node$[ebp]
	add	ecx, 16					; 00000010H
	cmp	DWORD PTR _l$[ebp], ecx
	je	$L38984

; 695  : 		next = l->next;

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _next$[ebp], eax

; 696  : 		touch = EDICT_FROM_AREA( l );

	mov	ecx, DWORD PTR _l$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _touch$[ebp], ecx

; 697  : 		pTouch = CBaseEntity::Instance( touch );

	mov	edx, DWORD PTR _touch$[ebp]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pTouch$[ebp], eax

; 698  : 
; 699  : 		if( !pTouch->IsPortal( ))

	mov	eax, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	DWORD PTR [edx+248]
	test	eax, eax
	jne	SHORT $L38989

; 700  : 			continue;

	jmp	SHORT $L38983
$L38989:

; 701  : 
; 702  : 		if( !BoundsIntersect( entmins, entmaxs, touch->v.absmin, touch->v.absmax ))

	mov	eax, DWORD PTR _touch$[ebp]
	add	eax, 336				; 00000150H
	push	eax
	mov	ecx, DWORD PTR _touch$[ebp]
	add	ecx, 324				; 00000144H
	push	ecx
	mov	edx, DWORD PTR _entmaxs$[ebp]
	push	edx
	mov	eax, DWORD PTR _entmins$[ebp]
	push	eax
	call	?BoundsIntersect@@YA_NABVVector@@000@Z	; BoundsIntersect
	add	esp, 16					; 00000010H
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L38990

; 703  : 			continue;

	jmp	SHORT $L38983
$L38990:

; 704  : 
; 705  : 		// check brush triggers accuracy
; 706  : 		if( UTIL_GetModelType( pTouch->pev->modelindex ) == mod_brush )

	mov	ecx, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+180]
	push	eax
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	jne	$L38998

; 708  : 			// force to select bsp-hull
; 709  : 			hull_t *hull = UTIL_HullForBsp( pTouch, pEnt->pev->mins, pEnt->pev->maxs, offset );

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pEnt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 232				; 000000e8H
	push	eax
	mov	ecx, DWORD PTR _pEnt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	push	edx
	mov	eax, DWORD PTR _pTouch$[ebp]
	push	eax
	call	?UTIL_HullForBsp@@YAPAUhull_s@@PAVCBaseEntity@@ABVVector@@1AAV3@@Z ; UTIL_HullForBsp
	add	esp, 16					; 00000010H
	mov	DWORD PTR _hull$38992[ebp], eax

; 710  : 
; 711  : 			// support for rotational triggers
; 712  : 			if( UTIL_CanRotate( pTouch ) && pTouch->GetAbsAngles() != g_vecZero )

	mov	ecx, DWORD PTR _pTouch$[ebp]
	push	ecx
	call	?UTIL_CanRotate@@YAHPAVCBaseEntity@@@Z	; UTIL_CanRotate
	add	esp, 4
	test	eax, eax
	je	SHORT $L38993
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L38993

; 714  : 				matrix4x4	matrix( offset, pTouch->GetAbsAngles() );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	edx, DWORD PTR _offset$[ebp]
	push	edx
	lea	ecx, DWORD PTR _matrix$38994[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 715  : 				test = matrix.VectorITransform( pEnt->GetAbsOrigin() );

	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T40940[ebp]
	push	eax
	lea	ecx, DWORD PTR _matrix$38994[ebp]
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax

; 717  : 			else

	jmp	SHORT $L38996
$L38993:

; 719  : 				// offset the test point appropriately for this hull.
; 720  : 				test = pEnt->GetAbsOrigin() - offset;

	lea	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T40941[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEnt$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _test$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _test$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _test$[ebp+8], eax
$L38996:

; 722  : 
; 723  : 			// test hull for intersection with this model
; 724  : 			if( UTIL_HullPointContents( hull, hull->firstclipnode, test ) != CONTENTS_SOLID )

	lea	ecx, DWORD PTR _test$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hull$38992[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _hull$38992[ebp]
	push	ecx
	call	?UTIL_HullPointContents@@YAHPAUhull_s@@HABVVector@@@Z ; UTIL_HullPointContents
	add	esp, 12					; 0000000cH
	cmp	eax, -2					; fffffffeH
	je	SHORT $L38998

; 725  : 				continue;

	jmp	$L38983
$L38998:

; 727  : 
; 728  : 		// complex two-side portals may activate twice
; 729  : 		// so we need put to sleep them to avoid back teleportation
; 730  : 		pTouch->PortalSleep( 0.2f );

	push	1045220557				; 3e4ccccdH
	mov	edx, DWORD PTR _pTouch$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pTouch$[ebp]
	call	DWORD PTR [eax+40]

; 731  : 
; 732  : 		// make backside portal is active now
; 733  : 		if( pTouch->pev->sequence > 0 )

	mov	ecx, DWORD PTR _pTouch$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+296], 0
	jle	SHORT $L39001

; 735  : 			CBaseEntity *pPortalCamera = CBaseEntity::Instance( INDEXENT( pTouch->pev->sequence ));

	mov	eax, DWORD PTR _pTouch$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+296]
	push	edx
	call	?INDEXENT@@YAPAUedict_s@@H@Z		; INDEXENT
	add	esp, 4
	push	eax
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	mov	DWORD PTR _pPortalCamera$39000[ebp], eax

; 736  : 			if( pPortalCamera ) SetBits( pPortalCamera->pev->effects, EF_MERGE_VISIBILITY ); // visible now

	cmp	DWORD PTR _pPortalCamera$39000[ebp], 0
	je	SHORT $L39001
	mov	eax, DWORD PTR _pPortalCamera$39000[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	edx, 536870912				; 20000000H
	mov	eax, DWORD PTR _pPortalCamera$39000[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx
$L39001:

; 738  : 	}

	jmp	$L38983
$L38984:

; 739  : 	
; 740  : 	// recurse down both sides
; 741  : 	if( node->axis == -1 ) return;

	mov	edx, DWORD PTR _node$[ebp]
	cmp	DWORD PTR [edx], -1
	jne	SHORT $L39002
	jmp	SHORT $L38974
$L39002:

; 742  : 	
; 743  : 	if( entmaxs[node->axis] > node->dist )

	mov	ecx, DWORD PTR _entmaxs$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39003

; 744  : 		SleepPortals( ent, entmins, entmaxs, node->children[0] );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _entmaxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entmins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ; CBaseEntity::SleepPortals
$L39003:

; 745  : 	if( entmins[node->axis] < node->dist )

	mov	ecx, DWORD PTR _entmins$[ebp]
	call	??BVector@@QBEPBMXZ			; Vector::operator float const *
	mov	ecx, DWORD PTR _node$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _node$[ebp]
	fld	DWORD PTR [eax+edx*4]
	fcomp	DWORD PTR [ecx+4]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39004

; 746  : 		SleepPortals( ent, entmins, entmaxs, node->children[1] );

	mov	edx, DWORD PTR _node$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _entmaxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entmins$[ebp]
	push	edx
	mov	eax, DWORD PTR _ent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ; CBaseEntity::SleepPortals
$L39004:
$L38974:

; 747  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ENDP ; CBaseEntity::SleepPortals
_TEXT	ENDS
;	COMDAT ?INDEXENT@@YAPAUedict_s@@H@Z
_TEXT	SEGMENT
_iEdictNum$ = 8
?INDEXENT@@YAPAUedict_s@@H@Z PROC NEAR			; INDEXENT, COMDAT

; 187  : inline edict_t* INDEXENT( int iEdictNum )		{ return (*g_engfuncs.pfnPEntityOfEntIndex)(iEdictNum); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR _iEdictNum$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+288
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?INDEXENT@@YAPAUedict_s@@H@Z ENDP			; INDEXENT
_TEXT	ENDS
PUBLIC	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z	; CBaseEntity::RelinkEntity
EXTRN	?g_fPhysicInitialized@@3HA:DWORD		; g_fPhysicInitialized
EXTRN	?g_fTouchLinkSemaphore@@3HA:DWORD		; g_fTouchLinkSemaphore
EXTRN	?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z:NEAR ; UTIL_MoveBounds
;	COMDAT ?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z
_TEXT	SEGMENT
_touch_triggers$ = 8
_pPrevOrigin$ = 12
_sleep_portals$ = 16
_this$ = -4
_entmins$39013 = -16
_entmaxs$39014 = -28
?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z PROC NEAR ; CBaseEntity::RelinkEntity, COMDAT

; 750  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 751  : 	if( !g_fPhysicInitialized )

	cmp	DWORD PTR ?g_fPhysicInitialized@@3HA, 0	; g_fPhysicInitialized
	jne	SHORT $L39011

; 753  : 		SET_ORIGIN( edict(), pev->origin );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	call	??BVector@@QAEPAMXZ			; Vector::operator float *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+112
	add	esp, 8

; 754  : 		return;

	jmp	$L39010
$L39011:

; 756  : 
; 757  : #ifdef USE_ENGINE_TOUCH_TRIGGERS
; 758  : 	LINK_ENTITY( edict(), TRUE );
; 759  : #else
; 760  : 	LINK_ENTITY( edict(), FALSE );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A
	add	esp, 8

; 761  : 
; 762  : 	// custom trigger handler used an accurate collision on fast moving objects with triggers
; 763  : 	if( touch_triggers )

	cmp	DWORD PTR _touch_triggers$[ebp], 0
	je	$L39019

; 765  : 		Vector entmins, entmaxs;

	lea	ecx, DWORD PTR _entmins$39013[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _entmaxs$39014[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 766  : 
; 767  : 		// only point entities needs to check with special case:
; 768  : 		// fast moving point entity moving through portal
; 769  : 		if( !IsPointSized( )) pPrevOrigin = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+320]
	test	eax, eax
	jne	SHORT $L39015
	mov	DWORD PTR _pPrevOrigin$[ebp], 0
$L39015:

; 770  : 
; 771  : 		if( pPrevOrigin != NULL )

	cmp	DWORD PTR _pPrevOrigin$[ebp], 0
	je	SHORT $L39016

; 772  : 			UTIL_MoveBounds( *pPrevOrigin, pev->mins, pev->maxs, GetAbsOrigin(), entmins, entmaxs );

	lea	eax, DWORD PTR _entmaxs$39014[ebp]
	push	eax
	lea	ecx, DWORD PTR _entmins$39013[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 232				; 000000e8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	push	edx
	mov	eax, DWORD PTR _pPrevOrigin$[ebp]
	push	eax
	call	?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z ; UTIL_MoveBounds
	add	esp, 24					; 00000018H

; 773  : 		else UTIL_MoveBounds( GetAbsOrigin(), pev->mins, pev->maxs, GetAbsOrigin(), entmins, entmaxs );

	jmp	SHORT $L39017
$L39016:
	lea	ecx, DWORD PTR _entmaxs$39014[ebp]
	push	ecx
	lea	edx, DWORD PTR _entmins$39013[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 232				; 000000e8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 220				; 000000dcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_MoveBounds@@YAXABVVector@@000AAV1@1@Z ; UTIL_MoveBounds
	add	esp, 24					; 00000018H
$L39017:

; 774  : 
; 775  : 		if( sleep_portals )

	cmp	DWORD PTR _sleep_portals$[ebp], 0
	je	SHORT $L39018

; 776  : 			SleepPortals( edict(), entmins, entmaxs, GET_AREANODE() );

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+16
	push	eax
	lea	ecx, DWORD PTR _entmaxs$39014[ebp]
	push	ecx
	lea	edx, DWORD PTR _entmins$39013[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SleepPortals@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PAUareanode_s@@@Z ; CBaseEntity::SleepPortals
$L39018:

; 777  : 
; 778  : 		if( !g_fTouchLinkSemaphore )

	cmp	DWORD PTR ?g_fTouchLinkSemaphore@@3HA, 0 ; g_fTouchLinkSemaphore
	jne	SHORT $L39019

; 780  : 			g_fTouchLinkSemaphore = TRUE;

	mov	DWORD PTR ?g_fTouchLinkSemaphore@@3HA, 1 ; g_fTouchLinkSemaphore

; 781  :  
; 782  : 			// moving triggers retouches objects
; 783  : #if 0			// g-cont. disabled until is done
; 784  : 			if( pev->solid == SOLID_TRIGGER )
; 785  : 				ClipLinks( edict(), entmins, entmaxs, GET_AREANODE() );
; 786  : 			else
; 787  : #endif
; 788  : 				TouchLinks( edict(), entmins, entmaxs, pPrevOrigin, GET_AREANODE() );

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+16
	push	eax
	mov	eax, DWORD PTR _pPrevOrigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _entmaxs$39014[ebp]
	push	ecx
	lea	edx, DWORD PTR _entmins$39013[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?TouchLinks@CBaseEntity@@QAEXPAUedict_s@@ABVVector@@1PBV3@PAUareanode_s@@@Z ; CBaseEntity::TouchLinks

; 789  : 			g_fTouchLinkSemaphore = FALSE;

	mov	DWORD PTR ?g_fTouchLinkSemaphore@@3HA, 0 ; g_fTouchLinkSemaphore
$L39019:
$L39010:

; 792  : #endif
; 793  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ENDP	; CBaseEntity::RelinkEntity
_TEXT	ENDS
PUBLIC	?SetModel@CBaseEntity@@QAEXPBD@Z		; CBaseEntity::SetModel
EXTRN	?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z:NEAR	; UTIL_GetModelBounds
EXTRN	?UTIL_SetSize@@YAXPAVCBaseEntity@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
EXTRN	?ResetPoseParameters@CBaseEntity@@QAEXXZ:NEAR	; CBaseEntity::ResetPoseParameters
;	COMDAT ?SetModel@CBaseEntity@@QAEXPBD@Z
_TEXT	SEGMENT
_model$ = 8
_this$ = -4
_modelIndex$ = -8
_mod_type$ = -12
_mins$ = -24
_maxs$ = -36
?SetModel@CBaseEntity@@QAEXPBD@Z PROC NEAR		; CBaseEntity::SetModel, COMDAT

; 796  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 797  : 	int modelIndex = MODEL_INDEX( model );

	mov	eax, DWORD PTR _model$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+12
	add	esp, 4
	mov	DWORD PTR _modelIndex$[ebp], eax

; 798  : 	if( modelIndex == 0 ) return;

	cmp	DWORD PTR _modelIndex$[ebp], 0
	jne	SHORT $L39025
	jmp	$L39023
$L39025:

; 799  : 
; 800  : 	pev->model = MAKE_STRING( model );

	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+268
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+184], eax

; 801  : 	pev->modelindex = modelIndex;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _modelIndex$[ebp]
	mov	DWORD PTR [eax+180], ecx

; 802  : 
; 803  : 	modtype_t mod_type = UTIL_GetModelType( modelIndex );

	mov	edx, DWORD PTR _modelIndex$[ebp]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	mov	DWORD PTR _mod_type$[ebp], eax

; 804  : 
; 805  : 	Vector mins = g_vecZero;

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _mins$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 806  : 	Vector maxs = g_vecZero;

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	lea	ecx, DWORD PTR _maxs$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 810  : 	{

	mov	eax, DWORD PTR _mod_type$[ebp]
	mov	DWORD PTR -40+[ebp], eax
	cmp	DWORD PTR -40+[ebp], 0
	je	SHORT $L39033
	cmp	DWORD PTR -40+[ebp], 1
	je	SHORT $L39035
	cmp	DWORD PTR -40+[ebp], 3
	je	SHORT $L39034
	jmp	SHORT $L39036
$L39033:

; 811  : 	case mod_brush:
; 812  : 		UTIL_GetModelBounds( modelIndex, mins, maxs );

	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z ; UTIL_GetModelBounds
	add	esp, 12					; 0000000cH

; 813  : 		break;

	jmp	SHORT $L39030
$L39034:

; 814  : 	case mod_studio:
; 815  : 		ResetPoseParameters();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetPoseParameters@CBaseEntity@@QAEXXZ ; CBaseEntity::ResetPoseParameters

; 816  : 		break;

	jmp	SHORT $L39030
$L39035:

; 817  : 	case mod_sprite:
; 818  : 		UTIL_GetModelBounds( modelIndex, mins, maxs );

	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _modelIndex$[ebp]
	push	eax
	call	?UTIL_GetModelBounds@@YAXHAAVVector@@0@Z ; UTIL_GetModelBounds
	add	esp, 12					; 0000000cH
$L39036:
$L39030:

; 823  : 
; 824  : 	UTIL_SetSize( this, mins, maxs );

	lea	ecx, DWORD PTR _maxs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _mins$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_SetSize@@YAXPAVCBaseEntity@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH
$L39023:

; 825  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetModel@CBaseEntity@@QAEXPBD@Z ENDP			; CBaseEntity::SetModel
_TEXT	ENDS
PUBLIC	??BEHANDLE@@QAEHXZ				; EHANDLE::operator int
PUBLIC	??CEHANDLE@@QAEPAVCBaseEntity@@XZ		; EHANDLE::operator->
PUBLIC	?UnlinkFromParent@CBaseEntity@@QAEXXZ		; CBaseEntity::UnlinkFromParent
PUBLIC	?UnlinkChild@CBaseEntity@@QAEXPAV1@@Z		; CBaseEntity::UnlinkChild
PUBLIC	?RestoreMoveType@CBaseEntity@@QAEXXZ		; CBaseEntity::RestoreMoveType
;	COMDAT ?UnlinkFromParent@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_vecOrigin$ = -16
_angAngles$ = -28
_vecVelocity$ = -40
?UnlinkFromParent@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::UnlinkFromParent, COMDAT

; 828  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 829  : 	if( m_hParent == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L39041

; 830  : 		return;

	jmp	$L39040
$L39041:

; 831  : 
; 832  : 	if( m_hParent->IsPlayer( ))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	DWORD PTR -44+[ebp], eax
	mov	eax, DWORD PTR -44+[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR -44+[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39042

; 834  : 		RestoreMoveType();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RestoreMoveType@CBaseEntity@@QAEXXZ	; CBaseEntity::RestoreMoveType
$L39042:

; 836  : 
; 837  : 	// parent is loosed
; 838  : 	OnClearParent ();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+56]

; 839  : 
; 840  : 	// NOTE: Have to do this before the unlink to ensure local coords are valid
; 841  : 	Vector vecOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _vecOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 842  : 	Vector angAngles = GetAbsAngles();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _angAngles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 843  : 	Vector vecVelocity = GetAbsVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _vecVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 844  : //	Vector vecAvelocity = GetAbsAvelocity();
; 845  : 
; 846  : 	UnlinkChild( m_hParent );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlinkChild@CBaseEntity@@QAEXPAV1@@Z	; CBaseEntity::UnlinkChild

; 847  : 
; 848  : 	SetAbsOrigin( vecOrigin );

	lea	eax, DWORD PTR _vecOrigin$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 849  : 	SetAbsAngles( angAngles );

	lea	ecx, DWORD PTR _angAngles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 850  : 	SetAbsVelocity( vecVelocity);

	lea	edx, DWORD PTR _vecVelocity$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39040:

; 851  : //	SetAbsAvelocity( vecAbsAvelocity );
; 852  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnlinkFromParent@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::UnlinkFromParent
_TEXT	ENDS
;	COMDAT ??BEHANDLE@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
??BEHANDLE@@QAEHXZ PROC NEAR				; EHANDLE::operator int, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 	return Get() != NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	neg	eax
	sbb	eax, eax
	neg	eax

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??BEHANDLE@@QAEHXZ ENDP					; EHANDLE::operator int
_TEXT	ENDS
;	COMDAT ??CEHANDLE@@QAEPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
??CEHANDLE@@QAEPAVCBaseEntity@@XZ PROC NEAR		; EHANDLE::operator->, COMDAT

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 	return (CBaseEntity *)GET_PRIVATE( Get( ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Get@EHANDLE@@QAEPAUedict_s@@XZ		; EHANDLE::Get
	push	eax
	call	?GET_PRIVATE@@YAPAXPAUedict_s@@@Z	; GET_PRIVATE
	add	esp, 4

; 92   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??CEHANDLE@@QAEPAVCBaseEntity@@XZ ENDP			; EHANDLE::operator->
_TEXT	ENDS
;	COMDAT ?RestoreMoveType@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?RestoreMoveType@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::RestoreMoveType, COMDAT

; 666  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 667  : 		if( m_iOldMoveType != MOVETYPE_NONE && pev->movetype == MOVETYPE_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $L35089
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 0
	jne	SHORT $L35089

; 669  : 			pev->movetype = m_iOldMoveType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+264], eax

; 670  : 			m_iOldMoveType = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
$L35089:

; 672  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RestoreMoveType@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::RestoreMoveType
_TEXT	ENDS
PUBLIC	??_C@_0CI@MFG@UnlinkChild?3?5couldn?8t?5find?5the?5p@ ; `string'
PUBLIC	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z		; EHANDLE::operator=
;	COMDAT ??_C@_0CI@MFG@UnlinkChild?3?5couldn?8t?5find?5the?5p@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_0CI@MFG@UnlinkChild?3?5couldn?8t?5find?5the?5p@ DB 'UnlinkChild: co'
	DB	'uldn''t find the parent!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ?UnlinkChild@CBaseEntity@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pParent$ = 8
_this$ = -4
_pList$ = -8
_pPrev$ = -12
_pNext$39056 = -16
?UnlinkChild@CBaseEntity@@QAEXPAV1@@Z PROC NEAR		; CBaseEntity::UnlinkChild, COMDAT

; 855  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 856  : 	CBaseEntity *pList;
; 857  : 	EHANDLE *pPrev;
; 858  : 
; 859  : 	if( pParent == NULL )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L39052

; 860  : 		return;

	jmp	$L39049
$L39052:

; 861  : 
; 862  : 	pList = pParent->m_hChild;

	mov	ecx, DWORD PTR _pParent$[ebp]
	add	ecx, 156				; 0000009cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pList$[ebp], eax

; 863  : 	pPrev = &pParent->m_hChild;

	mov	eax, DWORD PTR _pParent$[ebp]
	add	eax, 156				; 0000009cH
	mov	DWORD PTR _pPrev$[ebp], eax
$L39054:

; 864  : 
; 865  : 	while( pList )

	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $L39055

; 867  : 		CBaseEntity *pNext = pList->m_hNextChild;

	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, 164				; 000000a4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pNext$39056[ebp], eax

; 868  : 
; 869  : 		if( pList == this )

	mov	ecx, DWORD PTR _pList$[ebp]
	cmp	ecx, DWORD PTR _this$[ebp]
	jne	SHORT $L39057

; 871  : 			// patch up the list
; 872  : 			*pPrev = pNext;

	mov	edx, DWORD PTR _pNext$39056[ebp]
	push	edx
	mov	ecx, DWORD PTR _pPrev$[ebp]
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 873  : 
; 874  : 			// clear hierarchy bits for this guy
; 875  : 			pList->m_hParent = NULL;

	push	0
	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, 148				; 00000094H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 876  : 			pList->m_hNextChild = NULL;

	push	0
	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, 164				; 000000a4H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 877  : 			return;

	jmp	SHORT $L39049
$L39057:

; 881  : 			pPrev = &pList->m_hNextChild;

	mov	eax, DWORD PTR _pList$[ebp]
	add	eax, 164				; 000000a4H
	mov	DWORD PTR _pPrev$[ebp], eax

; 882  : 			pList = pNext;

	mov	ecx, DWORD PTR _pNext$39056[ebp]
	mov	DWORD PTR _pList$[ebp], ecx

; 884  : 	}

	jmp	SHORT $L39054
$L39055:

; 885  : 
; 886  : 	// this only happens if the child wasn't found in the parent's child list
; 887  : 	ALERT( at_warning, "UnlinkChild: couldn't find the parent!\n" );

	push	OFFSET FLAT:??_C@_0CI@MFG@UnlinkChild?3?5couldn?8t?5find?5the?5p@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L39049:

; 888  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?UnlinkChild@CBaseEntity@@QAEXPAV1@@Z ENDP		; CBaseEntity::UnlinkChild
_TEXT	ENDS
EXTRN	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z:NEAR	; ENT
;	COMDAT ??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z
_TEXT	SEGMENT
_pEntity$ = 8
_this$ = -4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z PROC NEAR	; EHANDLE::operator=, COMDAT

; 69   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 	if (pEntity)

	cmp	DWORD PTR _pEntity$[ebp], 0
	je	SHORT $L34280

; 72   : 		m_pent = ENT( pEntity );

	mov	eax, DWORD PTR _pEntity$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PAVCBaseEntity@@@Z	; ENT
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 73   : 		if (m_pent)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L34281

; 74   : 			m_serialnumber = m_pent->serialnumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$L34281:

; 76   : 	else

	jmp	SHORT $L34282
$L34280:

; 78   : 		m_pent = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 79   : 		m_serialnumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L34282:

; 81   : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 82   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z ENDP		; EHANDLE::operator=
_TEXT	ENDS
PUBLIC	?LinkChild@CBaseEntity@@QAEXPAV1@@Z		; CBaseEntity::LinkChild
;	COMDAT ?LinkChild@CBaseEntity@@QAEXPAV1@@Z
_TEXT	SEGMENT
_pParent$ = 8
_this$ = -4
?LinkChild@CBaseEntity@@QAEXPAV1@@Z PROC NEAR		; CBaseEntity::LinkChild, COMDAT

; 891  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 892  : 	if( pParent == NULL )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L39064

; 893  : 		return;

	jmp	SHORT $L39063
$L39064:

; 894  : 
; 895  : 	m_hParent = pParent;

	mov	eax, DWORD PTR _pParent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=

; 896  : 	m_hNextChild = m_hParent->m_hChild;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR [eax+160]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], ecx
	mov	DWORD PTR [eax+168], edx

; 897  : 	m_hParent->m_hChild = this;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	add	ecx, 156				; 0000009cH
	call	??4EHANDLE@@QAEPAVCBaseEntity@@PAV1@@Z	; EHANDLE::operator=
$L39063:

; 898  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?LinkChild@CBaseEntity@@QAEXPAV1@@Z ENDP		; CBaseEntity::LinkChild
_TEXT	ENDS
PUBLIC	?UnlinkAllChildren@CBaseEntity@@QAEXXZ		; CBaseEntity::UnlinkAllChildren
;	COMDAT ?UnlinkAllChildren@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_pChild$ = -8
_pNext$39073 = -12
?UnlinkAllChildren@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::UnlinkAllChildren, COMDAT

; 901  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 902  : 	CBaseEntity *pChild = m_hChild;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 156				; 0000009cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pChild$[ebp], eax
$L39071:

; 903  : 
; 904  : 	while( pChild )

	cmp	DWORD PTR _pChild$[ebp], 0
	je	SHORT $L39072

; 906  : 		CBaseEntity *pNext = pChild->m_hNextChild;

	mov	ecx, DWORD PTR _pChild$[ebp]
	add	ecx, 164				; 000000a4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pNext$39073[ebp], eax

; 907  : 		pChild->UnlinkFromParent();

	mov	ecx, DWORD PTR _pChild$[ebp]
	call	?UnlinkFromParent@CBaseEntity@@QAEXXZ	; CBaseEntity::UnlinkFromParent

; 908  : 		pChild = pNext;

	mov	eax, DWORD PTR _pNext$39073[ebp]
	mov	DWORD PTR _pChild$[ebp], eax

; 909  : 	}

	jmp	SHORT $L39071
$L39072:

; 910  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UnlinkAllChildren@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::UnlinkAllChildren
_TEXT	ENDS
PUBLIC	?GetRootParent@CBaseEntity@@QAEPAV1@XZ		; CBaseEntity::GetRootParent
;	COMDAT ?GetRootParent@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
_pEntity$ = -8
_pParent$ = -12
?GetRootParent@CBaseEntity@@QAEPAV1@XZ PROC NEAR	; CBaseEntity::GetRootParent, COMDAT

; 913  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 914  : 	CBaseEntity *pEntity = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pEntity$[ebp], eax

; 915  : 	CBaseEntity *pParent = m_hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax
$L39081:

; 916  : 
; 917  : 	while( pParent )

	cmp	DWORD PTR _pParent$[ebp], 0
	je	SHORT $L39082

; 919  : 		pEntity = pParent;

	mov	ecx, DWORD PTR _pParent$[ebp]
	mov	DWORD PTR _pEntity$[ebp], ecx

; 920  : 		pParent = pEntity->m_hParent;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pParent$[ebp], eax

; 921  : 	}

	jmp	SHORT $L39081
$L39082:

; 922  : 
; 923  : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]

; 924  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetRootParent@CBaseEntity@@QAEPAV1@XZ ENDP		; CBaseEntity::GetRootParent
_TEXT	ENDS
PUBLIC	?HasAttachment@CBaseEntity@@QAEHXZ		; CBaseEntity::HasAttachment
EXTRN	?Q_strchr@@YAPADPBDD@Z:NEAR			; Q_strchr
;	COMDAT ?HasAttachment@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
_pname$ = -8
?HasAttachment@CBaseEntity@@QAEHXZ PROC NEAR		; CBaseEntity::HasAttachment, COMDAT

; 927  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 928  : 	// try to extract aiment from name
; 929  : 	char *pname = (char *)STRING( m_iParent );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	mov	DWORD PTR _pname$[ebp], eax

; 930  : 
; 931  : 	return (Q_strchr( pname, '.' ) != NULL);

	push	46					; 0000002eH
	mov	edx, DWORD PTR _pname$[ebp]
	push	edx
	call	?Q_strchr@@YAPADPBDD@Z			; Q_strchr
	add	esp, 8
	neg	eax
	sbb	eax, eax
	neg	eax

; 932  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?HasAttachment@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::HasAttachment
_TEXT	ENDS
PUBLIC	?SetParent@CBaseEntity@@QAEXHH@Z		; CBaseEntity::SetParent
PUBLIC	?SetParent@CBaseEntity@@QAEXPAV1@H@Z		; CBaseEntity::SetParent
EXTRN	?Q_strncpy@@YAIPADPBDI@Z:NEAR			; Q_strncpy
EXTRN	?Q_atoi@@YAHPBD@Z:NEAR				; Q_atoi
EXTRN	?CheckForMultipleParents@@YAXPAVCBaseEntity@@0@Z:NEAR ; CheckForMultipleParents
EXTRN	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z:NEAR ; UTIL_FindEntityByTargetname
;	COMDAT ?SetParent@CBaseEntity@@QAEXHH@Z
_TEXT	SEGMENT
_m_iNewParent$ = 8
_m_iAttachment$ = 12
_this$ = -4
_pParent$ = -8
_name$39097 = -264
_pname$39098 = -268
_pstart$39100 = -272
?SetParent@CBaseEntity@@QAEXHH@Z PROC NEAR		; CBaseEntity::SetParent, COMDAT

; 938  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 939  : 	if( !m_iNewParent )

	cmp	DWORD PTR _m_iNewParent$[ebp], 0
	jne	SHORT $L39094

; 941  : 		// unlink entity from chain
; 942  : 		UnlinkFromParent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlinkFromParent@CBaseEntity@@QAEXXZ	; CBaseEntity::UnlinkFromParent

; 943  : 		return;

	jmp	$L39093
$L39094:

; 947  : 
; 948  : 	if( !m_iAttachment )

	cmp	DWORD PTR _m_iAttachment$[ebp], 0
	jne	$L39101

; 950  : 		char	name[256];
; 951  : 
; 952  : 		// don't modify string from table, make a local copy!
; 953  : 		Q_strncpy( name, STRING( m_iNewParent ), sizeof( name ));

	push	256					; 00000100H
	mov	eax, DWORD PTR _m_iNewParent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR _name$39097[ebp]
	push	ecx
	call	?Q_strncpy@@YAIPADPBDI@Z		; Q_strncpy
	add	esp, 12					; 0000000cH

; 954  : 
; 955  : 		// try to extract aiment from name
; 956  : 		char *pname = (char *)name;

	lea	edx, DWORD PTR _name$39097[ebp]
	mov	DWORD PTR _pname$39098[ebp], edx

; 957  : 		char *pstart  = Q_strchr( pname, '.' );

	push	46					; 0000002eH
	mov	eax, DWORD PTR _pname$39098[ebp]
	push	eax
	call	?Q_strchr@@YAPADPBDD@Z			; Q_strchr
	add	esp, 8
	mov	DWORD PTR _pstart$39100[ebp], eax

; 958  : 
; 959  : 		if( pstart )

	cmp	DWORD PTR _pstart$39100[ebp], 0
	je	SHORT $L39101

; 961  : 			m_iAttachment = Q_atoi( pstart + 1 );	

	mov	ecx, DWORD PTR _pstart$39100[ebp]
	add	ecx, 1
	push	ecx
	call	?Q_atoi@@YAHPBD@Z			; Q_atoi
	add	esp, 4
	mov	DWORD PTR _m_iAttachment$[ebp], eax

; 962  : 			pname[pstart-pname] = '\0';

	mov	edx, DWORD PTR _pstart$39100[ebp]
	sub	edx, DWORD PTR _pname$39098[ebp]
	mov	eax, DWORD PTR _pname$39098[ebp]
	mov	BYTE PTR [eax+edx], 0

; 963  : 			pParent = UTIL_FindEntityByTargetname( NULL, pname );

	mov	ecx, DWORD PTR _pname$39098[ebp]
	push	ecx
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pParent$[ebp], eax

; 964  : 			SetParent( pParent, m_iAttachment );

	mov	edx, DWORD PTR _m_iAttachment$[ebp]
	push	edx
	mov	eax, DWORD PTR _pParent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent

; 965  : 			return;

	jmp	SHORT $L39093
$L39101:

; 968  : 
; 969  : 	pParent = UTIL_FindEntityByTargetname( NULL, STRING( m_iNewParent ));	

	mov	ecx, DWORD PTR _m_iNewParent$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?UTIL_FindEntityByTargetname@@YAPAVCBaseEntity@@PAV1@PBD@Z ; UTIL_FindEntityByTargetname
	add	esp, 8
	mov	DWORD PTR _pParent$[ebp], eax

; 970  : 	SetParent( pParent, m_iAttachment );

	mov	edx, DWORD PTR _m_iAttachment$[ebp]
	push	edx
	mov	eax, DWORD PTR _pParent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetParent@CBaseEntity@@QAEXPAV1@H@Z	; CBaseEntity::SetParent

; 971  : 
; 972  : 	CheckForMultipleParents( this, pParent );

	mov	ecx, DWORD PTR _pParent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?CheckForMultipleParents@@YAXPAVCBaseEntity@@0@Z ; CheckForMultipleParents
	add	esp, 8
$L39093:

; 973  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetParent@CBaseEntity@@QAEXHH@Z ENDP			; CBaseEntity::SetParent
_TEXT	ENDS
PUBLIC	??_C@_0CO@PAHO@SetParent?3?5static?5actor?5?$CFs?5can?8t@ ; `string'
PUBLIC	??_C@_0CG@PEOO@Not?5found?5parent?5for?5?$CFs?5with?5nam@ ; `string'
PUBLIC	??_C@_0BJ@CDHA@Not?5found?5parent?5for?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@FNM@?$CFs?5with?5name?5?$CFs?5has?5illegal?5pare@ ; `string'
PUBLIC	??_C@_0BH@KPHE@?$CFs?5has?5illegal?5parent?6?$AA@ ; `string'
PUBLIC	?MakeNonMoving@CBaseEntity@@QAEXXZ		; CBaseEntity::MakeNonMoving
PUBLIC	?IsStudioModel@CBaseEntity@@QAE_NXZ		; CBaseEntity::IsStudioModel
EXTRN	?g_pWorld@@3PAVCBaseEntity@@A:DWORD		; g_pWorld
;	COMDAT ??_C@_0CO@PAHO@SetParent?3?5static?5actor?5?$CFs?5can?8t@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_0CO@PAHO@SetParent?3?5static?5actor?5?$CFs?5can?8t@ DB 'SetParent: '
	DB	'static actor %s can''t have parent', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PEOO@Not?5found?5parent?5for?5?$CFs?5with?5nam@
CONST	SEGMENT
??_C@_0CG@PEOO@Not?5found?5parent?5for?5?$CFs?5with?5nam@ DB 'Not found p'
	DB	'arent for %s with name %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CDHA@Not?5found?5parent?5for?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CDHA@Not?5found?5parent?5for?5?$CFs?6?$AA@ DB 'Not found parent'
	DB	' for %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FNM@?$CFs?5with?5name?5?$CFs?5has?5illegal?5pare@
CONST	SEGMENT
??_C@_0CE@FNM@?$CFs?5with?5name?5?$CFs?5has?5illegal?5pare@ DB '%s with n'
	DB	'ame %s has illegal parent', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KPHE@?$CFs?5has?5illegal?5parent?6?$AA@
CONST	SEGMENT
??_C@_0BH@KPHE@?$CFs?5has?5illegal?5parent?6?$AA@ DB '%s has illegal pare'
	DB	'nt', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?SetParent@CBaseEntity@@QAEXPAV1@H@Z
_TEXT	SEGMENT
$T40972 = -296
$T40974 = -364
_pParent$ = 8
_m_iAttachment$ = 12
_this$ = -4
_angles$ = -16
_parent$ = -80
_child$ = -144
_tmp$ = -208
_localOrigin$ = -220
_localAngles$ = -232
?SetParent@CBaseEntity@@QAEXPAV1@H@Z PROC NEAR		; CBaseEntity::SetParent, COMDAT

; 979  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 428				; 000001acH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 980  : 	if( pParent != NULL && ( pParent == m_hParent ) || m_fPicked )

	cmp	DWORD PTR _pParent$[ebp], 0
	je	SHORT $L39109
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	cmp	DWORD PTR _pParent$[ebp], eax
	je	SHORT $L39108
$L39109:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $L39107
$L39108:

; 981  : 		return; // new parent is already set or object is picked

	jmp	$L39106
$L39107:

; 982  : 
; 983  : 	if( pParent == g_pWorld )

	mov	ecx, DWORD PTR _pParent$[ebp]
	cmp	ecx, DWORD PTR ?g_pWorld@@3PAVCBaseEntity@@A ; g_pWorld
	jne	SHORT $L39110

; 984  : 		return; // newer use world as parent

	jmp	$L39106
$L39110:

; 985  : 
; 986  : 	if( m_iActorType == ACTOR_STATIC )

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	mov	al, BYTE PTR [edx+1604]
	cmp	eax, 4
	jne	SHORT $L39111

; 988  : 		ALERT( at_error, "SetParent: static actor %s can't have parent\n", GetClassname( ));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0CO@PAHO@SetParent?3?5static?5actor?5?$CFs?5can?8t@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH

; 989  : 		return;

	jmp	$L39106
$L39111:

; 991  : 
; 992  : 	UnlinkFromParent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlinkFromParent@CBaseEntity@@QAEXXZ	; CBaseEntity::UnlinkFromParent

; 993  : 
; 994  : 	if( pParent == NULL )

	cmp	DWORD PTR _pParent$[ebp], 0
	jne	SHORT $L39113

; 996  : 		if( pev->targetname )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+460], 0
	je	SHORT $L39114

; 997  : 			ALERT( at_warning, "Not found parent for %s with name %s\n", STRING( pev->classname ), STRING( pev->targetname ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CG@PEOO@Not?5found?5parent?5for?5?$CFs?5with?5nam@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 998  : 		else ALERT( at_warning, "Not found parent for %s\n", STRING( pev->classname ));

	jmp	SHORT $L39116
$L39114:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BJ@CDHA@Not?5found?5parent?5for?5?$CFs?6?$AA@ ; `string'
	push	3
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L39116:

; 999  : 		return;

	jmp	$L39106
$L39113:

; 1001 : 
; 1002 : 	// check for himself parent
; 1003 : 	if( pParent == this ) 

	mov	eax, DWORD PTR _pParent$[ebp]
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $L39118

; 1005 : 		if( pev->targetname )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+460], 0
	je	SHORT $L39119

; 1006 : 			ALERT( at_error, "%s with name %s has illegal parent\n", STRING( pev->classname ), STRING( pev->targetname ));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0CE@FNM@?$CFs?5with?5name?5?$CFs?5has?5illegal?5pare@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 16					; 00000010H

; 1007 : 		else ALERT( at_error, "%s has illegal parent\n", STRING( pev->classname ));

	jmp	SHORT $L39121
$L39119:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0BH@KPHE@?$CFs?5has?5illegal?5parent?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 12					; 0000000cH
$L39121:

; 1008 : 		return;

	jmp	$L39106
$L39118:

; 1010 : 
; 1011 : 	// make sure what child is the point entity and the parent have studiomodel
; 1012 :          	if( m_iAttachment && m_iFlags & MF_POINTENTITY && pParent->IsStudioModel( ))

	cmp	DWORD PTR _m_iAttachment$[ebp], 0
	je	SHORT $L39123
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 1
	test	ecx, ecx
	je	SHORT $L39123
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?IsStudioModel@CBaseEntity@@QAE_NXZ	; CBaseEntity::IsStudioModel
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L39123

; 1014 : 		pev->skin = ENTINDEX( pParent->edict( ));

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?ENTINDEX@@YAHPAUedict_s@@@Z		; ENTINDEX
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+272], eax

; 1015 : 		pev->body = m_iAttachment;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _m_iAttachment$[ebp]
	mov	DWORD PTR [eax+276], ecx

; 1016 : 		pev->aiment = pParent->edict();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+404], eax

; 1017 : 		pev->movetype = MOVETYPE_FOLLOW;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+264], 12			; 0000000cH

; 1018 : 		return;

	jmp	$L39106
$L39123:

; 1020 : 
; 1021 : 	if( pParent->IsPlayer( ))

	mov	ecx, DWORD PTR _pParent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39124

; 1023 : 		MakeNonMoving();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?MakeNonMoving@CBaseEntity@@QAEXXZ	; CBaseEntity::MakeNonMoving
$L39124:

; 1025 : 
; 1026 : 	LinkChild( pParent );

	mov	eax, DWORD PTR _pParent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LinkChild@CBaseEntity@@QAEXPAV1@@Z	; CBaseEntity::LinkChild

; 1027 : 
; 1028 : 	// I have the axes of local space in world space. (childMatrix)
; 1029 : 	// I want to compute those world space axes in the parent's local space
; 1030 : 	// and set that transform (as angles) on the child's object so the net
; 1031 : 	// result is that the child is now in parent space, but still oriented the same way
; 1032 : 	Vector angles = pParent->GetAbsAngles();

	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	push	eax
	lea	ecx, DWORD PTR _angles$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1033 : 
; 1034 : 	if( pParent->IsPlayer() )

	mov	ecx, DWORD PTR _pParent$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	DWORD PTR [edx+224]
	test	eax, eax
	je	SHORT $L39126

; 1035 : 		angles.x = angles.z = 0.0f; // only YAW will be affected

	mov	DWORD PTR _angles$[ebp+8], 0
	mov	eax, DWORD PTR _angles$[ebp+8]
	mov	DWORD PTR _angles$[ebp], eax
$L39126:

; 1036 : 
; 1037 : 	matrix4x4	parent( pParent->GetAbsOrigin(), angles, 1.0f );

	push	1065353216				; 3f800000H
	lea	ecx, DWORD PTR _angles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pParent$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _parent$[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 1038 : 	matrix4x4	child( GetLocalOrigin(), GetLocalAngles( ), 1.0f );

	push	1065353216				; 3f800000H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalAngles
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetLocalOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetLocalOrigin
	push	eax
	lea	ecx, DWORD PTR _child$[ebp]
	call	??0matrix4x4@@QAE@ABVVector@@0M@Z	; matrix4x4::matrix4x4

; 1039 : 
; 1040 : 	matrix4x4	tmp( parent.Invert( ));

	lea	edx, DWORD PTR $T40972[ebp]
	push	edx
	lea	ecx, DWORD PTR _parent$[ebp]
	call	?Invert@matrix4x4@@QBE?AV1@XZ		; matrix4x4::Invert
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4

; 1041 : 	tmp = tmp.ConcatTransforms( child );

	sub	esp, 64					; 00000040H
	mov	ecx, esp
	lea	eax, DWORD PTR _child$[ebp]
	push	eax
	call	??0matrix4x4@@QAE@ABV0@@Z		; matrix4x4::matrix4x4
	lea	ecx, DWORD PTR $T40974[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	?ConcatTransforms@matrix4x4@@QAE?AV1@V1@@Z ; matrix4x4::ConcatTransforms
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	??4matrix4x4@@QAEAAV0@ABV0@@Z		; matrix4x4::operator=

; 1042 : 
; 1043 : 	Vector localOrigin, localAngles;

	lea	ecx, DWORD PTR _localOrigin$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _localAngles$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1044 : 
; 1045 : 	tmp.GetAngles( localAngles );

	lea	edx, DWORD PTR _localAngles$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	?GetAngles@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetAngles

; 1046 : 	tmp.GetOrigin( localOrigin );

	lea	eax, DWORD PTR _localOrigin$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmp$[ebp]
	call	?GetOrigin@matrix4x4@@QAEXAAVVector@@@Z	; matrix4x4::GetOrigin

; 1047 : 
; 1048 : 	SetLocalAngles( localAngles );

	lea	ecx, DWORD PTR _localAngles$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalAngles

; 1049 : 	SetLocalOrigin( localOrigin );

	lea	edx, DWORD PTR _localOrigin$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLocalOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetLocalOrigin

; 1050 : 	RelinkEntity( FALSE );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 1051 : 
; 1052 : 	// NOTE: no need to call this event on initialization
; 1053 : 	// because entities linked *before* spawn not after
; 1054 : 	if( GET_SERVER_STATE() == SERVER_ACTIVE )

	call	DWORD PTR ?g_physfuncs@@3Userver_physics_api_s@@A+20
	cmp	eax, 2
	jne	SHORT $L39135

; 1056 : 		// parent is changed
; 1057 : 		OnChangeParent ();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+52]
$L39135:
$L39106:

; 1059 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?SetParent@CBaseEntity@@QAEXPAV1@H@Z ENDP		; CBaseEntity::SetParent
_TEXT	ENDS
;	COMDAT ?MakeNonMoving@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeNonMoving@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::MakeNonMoving, COMDAT

; 657  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 658  : 		if( m_iOldMoveType == MOVETYPE_NONE && pev->movetype != MOVETYPE_NONE )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $L35086
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 0
	je	SHORT $L35086

; 660  : 			m_iOldMoveType = pev->movetype;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+264]
	mov	DWORD PTR [edx+20], eax

; 661  : 			pev->movetype = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 0
$L35086:

; 663  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeNonMoving@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::MakeNonMoving
_TEXT	ENDS
PUBLIC	?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ	; CBaseEntity::GetModelType
;	COMDAT ?IsStudioModel@CBaseEntity@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsStudioModel@CBaseEntity@@QAE_NXZ PROC NEAR		; CBaseEntity::IsStudioModel, COMDAT

; 698  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 699  : 		return (GetModelType() == mod_studio) ? true : false;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ ; CBaseEntity::GetModelType
	cmp	eax, 3
	sete	al

; 700  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsStudioModel@CBaseEntity@@QAE_NXZ ENDP		; CBaseEntity::IsStudioModel
_TEXT	ENDS
;	COMDAT ?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ PROC NEAR ; CBaseEntity::GetModelType, COMDAT

; 693  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 694  : 		return UTIL_GetModelType( pev->modelindex );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4

; 695  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetModelType@CBaseEntity@@QAE?AW4modtype_t@@XZ ENDP	; CBaseEntity::GetModelType
_TEXT	ENDS
PUBLIC	?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z		; CBaseEntity::ShouldCollide
PUBLIC	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetGroundEntity
;	COMDAT ?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z PROC NEAR	; CBaseEntity::ShouldCollide, COMDAT

; 1062 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 	if( m_iParentFilter && m_pRootParent )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $L39142
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L39142

; 1065 : 		if( m_pRootParent == pOther->GetRootParent() )

	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetRootParent@CBaseEntity@@QAEPAV1@XZ	; CBaseEntity::GetRootParent
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], eax
	jne	SHORT $L39142

; 1067 : 			if( pOther->pev->movetype != MOVETYPE_PUSHSTEP )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 13			; 0000000dH
	je	SHORT $L39142

; 1068 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $L39139
$L39142:

; 1071 : 
; 1072 : 	if( m_iPushableFilter && pev->movetype == MOVETYPE_PUSHSTEP && pev->solid == SOLID_BSP )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $L39144
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+264], 13			; 0000000dH
	jne	SHORT $L39144
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+268], 4
	jne	SHORT $L39144

; 1074 : 		if( pOther->GetGroundEntity() == this )

	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ; CBaseEntity::GetGroundEntity
	cmp	eax, DWORD PTR _this$[ebp]
	jne	SHORT $L39144

; 1075 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L39139
$L39144:

; 1077 : 
; 1078 : 	return TRUE;

	mov	eax, 1
$L39139:

; 1079 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?ShouldCollide@CBaseEntity@@UAEHPAV1@@Z ENDP		; CBaseEntity::ShouldCollide
_TEXT	ENDS
;	COMDAT ?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ PROC NEAR	; CBaseEntity::GetGroundEntity, COMDAT

; 599  : 	CBaseEntity *GetGroundEntity( void ) { return Instance( pev->groundentity ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+412]
	push	edx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGroundEntity@CBaseEntity@@QAEPAV1@XZ ENDP		; CBaseEntity::GetGroundEntity
_TEXT	ENDS
PUBLIC	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z		; MESSAGE_BEGIN
PUBLIC	?UpdateOnRemove@CBaseEntity@@QAEXXZ		; CBaseEntity::UpdateOnRemove
EXTRN	?WorldPhysic@@3PAVIPhysicLayer@@A:DWORD		; WorldPhysic
EXTRN	?gmsgKillPart@@3HA:DWORD			; gmsgKillPart
EXTRN	?gmsgKillDecals@@3HA:DWORD			; gmsgKillDecals
EXTRN	?EntitySetState@CGlobalState@@QAEXHW4GLOBALESTATE@@@Z:NEAR ; CGlobalState::EntitySetState
EXTRN	?gGlobalState@@3VCGlobalState@@A:QWORD		; gGlobalState
EXTRN	?WorldGraph@@3VCGraph@@A:BYTE			; WorldGraph
;	COMDAT ?UpdateOnRemove@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$39150 = -8
?UpdateOnRemove@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::UpdateOnRemove, COMDAT

; 1083 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1084 : 	if ( FBitSet( pev->flags, FL_GRAPHED ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	and	edx, 65536				; 00010000H
	test	edx, edx
	je	SHORT $L39153

; 1086 : 		// this entity was a LinkEnt in the world node graph, so we must remove it from
; 1087 : 		// the graph since we are removing it from the world.
; 1088 : 		for ( int i = 0; i < WorldGraph.m_cLinks; i++ )

	mov	DWORD PTR _i$39150[ebp], 0
	jmp	SHORT $L39151
$L39152:
	mov	eax, DWORD PTR _i$39150[ebp]
	add	eax, 1
	mov	DWORD PTR _i$39150[ebp], eax
$L39151:
	mov	ecx, DWORD PTR _i$39150[ebp]
	cmp	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+28
	jge	SHORT $L39153

; 1090 : 			if ( WorldGraph.m_pLinkPool[i].m_pLinkEnt == pev )

	mov	edx, DWORD PTR _i$39150[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR ?WorldGraph@@3VCGraph@@A+16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+edx+8]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $L39154

; 1092 : 				// if this link has a link ent which is the same ent
; 1093 : 				// that is removing itself, remove it!
; 1094 : 				WorldGraph.m_pLinkPool[i].m_pLinkEnt = NULL;

	mov	eax, DWORD PTR _i$39150[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR ?WorldGraph@@3VCGraph@@A+16
	mov	DWORD PTR [ecx+eax+8], 0
$L39154:

; 1096 : 		}

	jmp	SHORT $L39152
$L39153:

; 1098 : 
; 1099 : 	UnlinkFromParent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlinkFromParent@CBaseEntity@@QAEXXZ	; CBaseEntity::UnlinkFromParent

; 1100 : 	UnlinkAllChildren();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnlinkAllChildren@CBaseEntity@@QAEXXZ	; CBaseEntity::UnlinkAllChildren

; 1101 : 
; 1102 : 	if ( pev->globalname )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L39155

; 1103 : 		gGlobalState.EntitySetState( pev->globalname, GLOBAL_DEAD );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, OFFSET FLAT:?gGlobalState@@3VCGlobalState@@A
	call	?EntitySetState@CGlobalState@@QAEXHW4GLOBALESTATE@@@Z ; CGlobalState::EntitySetState
$L39155:

; 1104 : 
; 1105 : 	// remove rigid body if present
; 1106 : 	WorldPhysic->RemoveBody( edict() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+24]

; 1107 : 
; 1108 : 	// call event "on remove"
; 1109 : 	OnRemove();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+60]

; 1110 : 
; 1111 : 	if( pev->modelindex )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+180], 0
	je	SHORT $L39156

; 1113 : 		// remove all the particle trails, attached to this entity
; 1114 : 		MESSAGE_BEGIN( MSG_ALL, gmsgKillPart );

	push	0
	push	0
	mov	edx, DWORD PTR ?gmsgKillPart@@3HA	; gmsgKillPart
	push	edx
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1115 : 			WRITE_ENTITY( entindex() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+220
	add	esp, 4

; 1116 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188

; 1117 : 
; 1118 : 		// remove all the studio decals, attached to this entity
; 1119 : 		MESSAGE_BEGIN( MSG_ALL, gmsgKillDecals );

	push	0
	push	0
	mov	eax, DWORD PTR ?gmsgKillDecals@@3HA	; gmsgKillDecals
	push	eax
	push	2
	call	?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z	; MESSAGE_BEGIN
	add	esp, 16					; 00000010H

; 1120 : 			WRITE_ENTITY( entindex() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+220
	add	esp, 4

; 1121 : 		MESSAGE_END();

	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+188
$L39156:

; 1123 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UpdateOnRemove@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::UpdateOnRemove
_TEXT	ENDS
;	COMDAT ?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z
_TEXT	SEGMENT
_msg_dest$ = 8
_msg_type$ = 12
_pOrigin$ = 16
_ed$ = 20
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z PROC NEAR	; MESSAGE_BEGIN, COMDAT

; 72   : inline void MESSAGE_BEGIN( int msg_dest, int msg_type, const float *pOrigin = NULL, edict_t *ed = NULL ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 73   : 	(*g_engfuncs.pfnMessageBegin)(msg_dest, msg_type, pOrigin, ed);

	mov	eax, DWORD PTR _ed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOrigin$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg_type$[ebp]
	push	edx
	mov	eax, DWORD PTR _msg_dest$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+184
	add	esp, 16					; 00000010H

; 74   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MESSAGE_BEGIN@@YAXHHPBMPAUedict_s@@@Z ENDP		; MESSAGE_BEGIN
_TEXT	ENDS
PUBLIC	?GetTarget@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTarget
PUBLIC	?FStringNull@@YAHH@Z				; FStringNull
PUBLIC	?SUB_UseTargets@CBaseEntity@@QAEXPAV1@W4USE_TYPE@@MH@Z ; CBaseEntity::SUB_UseTargets
EXTRN	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
EXTRN	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z:NEAR ; UTIL_FireTargets
;	COMDAT ?SUB_UseTargets@CBaseEntity@@QAEXPAV1@W4USE_TYPE@@MH@Z
_TEXT	SEGMENT
_pActivator$ = 8
_useType$ = 12
_value$ = 16
_m_iszAltTarget$ = 20
_this$ = -4
?SUB_UseTargets@CBaseEntity@@QAEXPAV1@W4USE_TYPE@@MH@Z PROC NEAR ; CBaseEntity::SUB_UseTargets, COMDAT

; 1141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1142 : 	//
; 1143 : 	// fire targets
; 1144 : 	//
; 1145 : 	if( !FStringNull( m_iszAltTarget ))

	mov	eax, DWORD PTR _m_iszAltTarget$[ebp]
	push	eax
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39164

; 1147 : 		UTIL_FireTargets( m_iszAltTarget, pActivator, this, useType, value );

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	edx, DWORD PTR _useType$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pActivator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _m_iszAltTarget$[ebp]
	push	edx
	call	?UTIL_FireTargets@@YAXHPAVCBaseEntity@@0W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H

; 1149 : 	else if( !FStringNull( pev->target ))

	jmp	SHORT $L39166
$L39164:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39166

; 1151 : 		UTIL_FireTargets( GetTarget(), pActivator, this, useType, value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _useType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _pActivator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	call	?UTIL_FireTargets@@YAXPBDPAVCBaseEntity@@1W4USE_TYPE@@M@Z ; UTIL_FireTargets
	add	esp, 20					; 00000014H
$L39166:

; 1153 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?SUB_UseTargets@CBaseEntity@@QAEXPAV1@W4USE_TYPE@@MH@Z ENDP ; CBaseEntity::SUB_UseTargets
_TEXT	ENDS
;	COMDAT ?FStringNull@@YAHH@Z
_TEXT	SEGMENT
_iString$ = 8
?FStringNull@@YAHH@Z PROC NEAR				; FStringNull, COMDAT

; 201  : inline BOOL FStringNull(int iString)			{ return iString == iStringNull; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _iString$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FStringNull@@YAHH@Z ENDP				; FStringNull
_TEXT	ENDS
;	COMDAT ?GetTarget@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetTarget@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetTarget, COMDAT

; 285  : 	const char*	GetTarget() { return STRING( pev->target ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTarget@CBaseEntity@@QAEPBDXZ ENDP			; CBaseEntity::GetTarget
_TEXT	ENDS
PUBLIC	?TakeHealth@CBaseEntity@@UAEHMH@Z		; CBaseEntity::TakeHealth
;	COMDAT ?TakeHealth@CBaseEntity@@UAEHMH@Z
_TEXT	SEGMENT
_flHealth$ = 8
_this$ = -4
?TakeHealth@CBaseEntity@@UAEHMH@Z PROC NEAR		; CBaseEntity::TakeHealth, COMDAT

; 1157 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1158 : 	if (!pev->takedamage)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39172

; 1159 : 		return 0;

	xor	eax, eax
	jmp	$L39171
$L39172:

; 1160 : 
; 1161 : 	if ( pev->health >= pev->max_health )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR [edx+432]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39173

; 1162 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L39171
$L39173:

; 1163 : 
; 1164 : 	pev->health += flHealth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR _flHealth$[ebp]
	fadd	DWORD PTR [ecx+352]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+352]

; 1165 : 
; 1166 : 	pev->health = Q_min(pev->health, pev->max_health);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+432]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L40997
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fstp	DWORD PTR -8+[ebp]
	jmp	SHORT $L40998
$L40997:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+432]
	fstp	DWORD PTR -8+[ebp]
$L40998:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [ecx+352], edx

; 1167 : 
; 1168 : 	return 1;

	mov	eax, 1
$L39171:

; 1169 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TakeHealth@CBaseEntity@@UAEHMH@Z ENDP			; CBaseEntity::TakeHealth
_TEXT	ENDS
PUBLIC	__real@4@4005c800000000000000
PUBLIC	?TakeArmor@CBaseEntity@@UAEHMH@Z		; CBaseEntity::TakeArmor
;	COMDAT __real@4@4005c800000000000000
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
__real@4@4005c800000000000000 DD 042c80000r	; 100
CONST	ENDS
;	COMDAT ?TakeArmor@CBaseEntity@@UAEHMH@Z
_TEXT	SEGMENT
_flArmor$ = 8
_this$ = -4
?TakeArmor@CBaseEntity@@UAEHMH@Z PROC NEAR		; CBaseEntity::TakeArmor, COMDAT

; 1173 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1174 : 	if (!pev->takedamage)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39179

; 1175 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L39178
$L39179:

; 1176 : 
; 1177 : 	if ( pev->armorvalue >= MAX_NORMAL_BATTERY )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+444]
	fcomp	DWORD PTR __real@4@4005c800000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39180

; 1178 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L39178
$L39180:

; 1179 : 
; 1180 : 	pev->armorvalue += flArmor;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR _flArmor$[ebp]
	fadd	DWORD PTR [edx+444]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+444]

; 1181 : 	pev->armorvalue = Q_min(pev->armorvalue, MAX_NORMAL_BATTERY);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+444]
	fcomp	DWORD PTR __real@4@4005c800000000000000
	fnstsw	ax
	test	ah, 1
	je	SHORT $L41001
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+444]
	fstp	DWORD PTR -8+[ebp]
	jmp	SHORT $L41002
$L41001:
	mov	DWORD PTR -8+[ebp], 1120403456		; 42c80000H
$L41002:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR -8+[ebp]
	mov	DWORD PTR [ecx+444], edx

; 1182 : 
; 1183 : 	return 1;

	mov	eax, 1
$L39178:

; 1184 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?TakeArmor@CBaseEntity@@UAEHMH@Z ENDP			; CBaseEntity::TakeArmor
_TEXT	ENDS
PUBLIC	__real@8@400f9000000000000000
PUBLIC	__real@8@4001a000000000000000
PUBLIC	__real@8@4008fa00000000000000
PUBLIC	?FNullEnt@@YAHPAUentvars_s@@@Z			; FNullEnt
PUBLIC	?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z ; CBaseEntity::TakeDamage
EXTRN	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z:NEAR ; VecBModelOrigin
EXTRN	?g_vecAttackDir@@3VVector@@A:BYTE		; g_vecAttackDir
;	COMDAT __real@8@400f9000000000000000
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
__real@8@400f9000000000000000 DQ 040f2000000000000r ; 73728
CONST	ENDS
;	COMDAT __real@8@4001a000000000000000
CONST	SEGMENT
__real@8@4001a000000000000000 DQ 04014000000000000r ; 5
CONST	ENDS
;	COMDAT __real@8@4008fa00000000000000
CONST	SEGMENT
__real@8@4008fa00000000000000 DQ 0408f400000000000r ; 1000
CONST	ENDS
;	COMDAT ?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z
_TEXT	SEGMENT
$T41007 = -44
$T41008 = -56
$T41009 = -68
$T41010 = -80
$T41011 = -92
$T41012 = -104
$T41013 = -116
$T41014 = -128
$T41015 = -140
$T41016 = -152
$T41017 = -164
_pevInflictor$ = 8
_pevAttacker$ = 12
_flDamage$ = 16
_this$ = -4
_vecTemp$ = -16
_vecDir$39199 = -28
_flForce$39204 = -32
?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z PROC NEAR ; CBaseEntity::TakeDamage, COMDAT

; 1189 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1190 : 	Vector	vecTemp;

	lea	ecx, DWORD PTR _vecTemp$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1191 : 
; 1192 : 	if (!pev->takedamage)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+364]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 64					; 00000040H
	je	SHORT $L39189

; 1193 : 		return 0;

	xor	eax, eax
	jmp	$L39187
$L39189:

; 1194 : 
; 1195 : 	// UNDONE: some entity types may be immune or resistant to some bitsDamageType
; 1196 : 	
; 1197 : 	// if Attacker == Inflictor, the attack was a melee or other instant-hit attack.
; 1198 : 	// (that is, no actual entity projectile was involved in the attack so use the shooter's origin). 
; 1199 : 	if ( pevAttacker == pevInflictor )	

	mov	edx, DWORD PTR _pevAttacker$[ebp]
	cmp	edx, DWORD PTR _pevInflictor$[ebp]
	jne	SHORT $L39190

; 1201 : 		vecTemp = pevInflictor->origin - ( VecBModelOrigin(pev) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T41007[ebp]
	push	edx
	call	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z ; VecBModelOrigin
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR $T41008[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	add	ecx, 8
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecTemp$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTemp$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTemp$[ebp+8], eax

; 1203 : 	else

	jmp	SHORT $L39193
$L39190:

; 1206 : 		vecTemp = pevInflictor->origin - ( VecBModelOrigin(pev) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR $T41009[ebp]
	push	eax
	call	?VecBModelOrigin@@YA?AVVector@@PAUentvars_s@@@Z ; VecBModelOrigin
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR $T41010[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	add	ecx, 8
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _vecTemp$[ebp], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecTemp$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _vecTemp$[ebp+8], edx
$L39193:

; 1208 : 
; 1209 : 	// this global is still used for glass and other non-monster killables, along with decals.
; 1210 : 	g_vecAttackDir = vecTemp.Normalize();

	lea	eax, DWORD PTR $T41011[ebp]
	push	eax
	lea	ecx, DWORD PTR _vecTemp$[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A+4, edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR ?g_vecAttackDir@@3VVector@@A+8, eax

; 1211 : 		
; 1212 : 	// save damage based on the target's armor level
; 1213 : 
; 1214 : 	// figure momentum add (don't let hurt brushes or other triggers move player)
; 1215 : 	if ((!FNullEnt(pevInflictor)) && (pev->movetype == MOVETYPE_WALK || pev->movetype == MOVETYPE_STEP) && (pevAttacker->solid != SOLID_TRIGGER) )

	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	push	ecx
	call	?FNullEnt@@YAHPAUentvars_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	$L39197
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+264], 3
	je	SHORT $L39198
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+264], 4
	jne	$L39197
$L39198:
	mov	eax, DWORD PTR _pevAttacker$[ebp]
	cmp	DWORD PTR [eax+268], 1
	je	$L39197

; 1217 : 		Vector vecDir = GetAbsOrigin() - (pevInflictor->absmin + pevInflictor->absmax) * 0.5;

	push	1056964608				; 3f000000H
	lea	ecx, DWORD PTR $T41013[ebp]
	push	ecx
	mov	edx, DWORD PTR _pevInflictor$[ebp]
	add	edx, 208				; 000000d0H
	push	edx
	lea	eax, DWORD PTR $T41012[ebp]
	push	eax
	mov	ecx, DWORD PTR _pevInflictor$[ebp]
	add	ecx, 196				; 000000c4H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, eax
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	ecx, DWORD PTR $T41014[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	push	eax
	lea	ecx, DWORD PTR _vecDir$39199[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1218 : 		vecDir = vecDir.Normalize();

	lea	edx, DWORD PTR $T41015[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDir$39199[ebp]
	call	?Normalize@Vector@@QBE?AV1@XZ		; Vector::Normalize
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vecDir$39199[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vecDir$39199[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _vecDir$39199[ebp+8], eax

; 1219 : 
; 1220 : 		float flForce = flDamage * ((32 * 32 * 72.0) / (pev->size.x * pev->size.y * pev->size.z)) * 5;

	fld	DWORD PTR _flDamage$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+244]
	fmul	DWORD PTR [ecx+248]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fmul	DWORD PTR [eax+252]
	fdivr	QWORD PTR __real@8@400f9000000000000000
	fmulp	ST(1), ST(0)
	fmul	QWORD PTR __real@8@4001a000000000000000
	fstp	DWORD PTR _flForce$39204[ebp]

; 1221 : 		
; 1222 : 		if (flForce > 1000.0) 

	fld	DWORD PTR _flForce$39204[ebp]
	fcomp	QWORD PTR __real@8@4008fa00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39205

; 1223 : 			flForce = 1000.0;

	mov	DWORD PTR _flForce$39204[ebp], 1148846080 ; 447a0000H
$L39205:

; 1224 : 		SetAbsVelocity( GetAbsVelocity() + vecDir * flForce );

	mov	ecx, DWORD PTR _flForce$39204[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41016[ebp]
	push	edx
	lea	ecx, DWORD PTR _vecDir$39199[ebp]
	call	??DVector@@QBE?AV0@M@Z			; Vector::operator*
	push	eax
	lea	eax, DWORD PTR $T41017[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetAbsVelocity@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsVelocity
$L39197:

; 1226 : 
; 1227 : 	// do the damage
; 1228 : 	pev->health -= flDamage;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+352]
	fsub	DWORD PTR _flDamage$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+352]

; 1229 : 	if (pev->health <= 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+352]
	fcomp	DWORD PTR __real@4@00000000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39208

; 1231 : 		Killed( pevAttacker, GIB_NORMAL );

	push	0
	mov	ecx, DWORD PTR _pevAttacker$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+108]

; 1232 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L39187
$L39208:

; 1234 : 
; 1235 : 	return 1;

	mov	eax, 1
$L39187:

; 1236 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?TakeDamage@CBaseEntity@@UAEHPAUentvars_s@@0MH@Z ENDP	; CBaseEntity::TakeDamage
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPAUentvars_s@@@Z			; OFFSET
PUBLIC	?FNullEnt@@YAHH@Z				; FNullEnt
;	COMDAT ?FNullEnt@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?FNullEnt@@YAHPAUentvars_s@@@Z PROC NEAR		; FNullEnt, COMDAT

; 196  : inline BOOL FNullEnt(entvars_t* pev)				{ return pev == NULL || FNullEnt(OFFSET(pev)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pev$[ebp], 0
	je	SHORT $L41026
	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?OFFSET@@YAHPAUentvars_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41026
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L41027
$L41026:
	mov	DWORD PTR -4+[ebp], 1
$L41027:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPAUentvars_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	?OFFSET@@YAHPBUedict_s@@@Z			; OFFSET
PUBLIC	??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad pev in OFFSET()', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPAUentvars_s@@@Z
_TEXT	SEGMENT
_pev$ = 8
?OFFSET@@YAHPAUentvars_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 168  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 169  : #if _DEBUG
; 170  : 	if ( !pev )

	cmp	DWORD PTR _pev$[ebp], 0
	jne	SHORT $L32439

; 171  : 		ALERT( at_error, "Bad pev in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@BH@Bad?5pev?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32439:

; 172  : #endif
; 173  : 	return OFFSET(ENT(pev)); 

	mov	eax, DWORD PTR _pev$[ebp]
	push	eax
	call	?ENT@@YAPAUedict_s@@PBUentvars_s@@@Z	; ENT
	add	esp, 4
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPAUentvars_s@@@Z ENDP			; OFFSET
_TEXT	ENDS
PUBLIC	??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
;	COMDAT ??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ DB 'Bad ent in OFFSET('
	DB	')', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ?OFFSET@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?OFFSET@@YAHPBUedict_s@@@Z PROC NEAR			; OFFSET, COMDAT

; 160  : { 

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 161  : #if _DEBUG
; 162  : 	if ( !pent )

	cmp	DWORD PTR _pent$[ebp], 0
	jne	SHORT $L32433

; 163  : 		ALERT( at_error, "Bad ent in OFFSET()\n" );

	push	OFFSET FLAT:??_C@_0BF@KILF@Bad?5ent?5in?5OFFSET?$CI?$CJ?6?$AA@ ; `string'
	push	4
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8
$L32433:

; 164  : #endif
; 165  : 	return (*g_engfuncs.pfnEntOffsetOfPEntity)(pent); 

	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+280
	add	esp, 4

; 166  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?OFFSET@@YAHPBUedict_s@@@Z ENDP				; OFFSET
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHH@Z
_TEXT	SEGMENT
_eoffset$ = 8
?FNullEnt@@YAHH@Z PROC NEAR				; FNullEnt, COMDAT

; 194  : inline BOOL FNullEnt(EOFFSET eoffset)			{ return eoffset == 0; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	cmp	DWORD PTR _eoffset$[ebp], 0
	sete	al
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHH@Z ENDP					; FNullEnt
_TEXT	ENDS
PUBLIC	?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z	; CBaseEntity::Killed
EXTRN	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z:NEAR	; UTIL_Remove
;	COMDAT ?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z
_TEXT	SEGMENT
_this$ = -4
?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z PROC NEAR	; CBaseEntity::Killed, COMDAT

; 1239 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1240 : 	pev->takedamage = DAMAGE_NO;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+364], 0

; 1241 : 	pev->deadflag = DEAD_DEAD;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+368], 2

; 1242 : 	UTIL_Remove( this );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?UTIL_Remove@@YAXPAVCBaseEntity@@@Z	; UTIL_Remove
	add	esp, 4

; 1243 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?Killed@CBaseEntity@@UAEXPAUentvars_s@@H@Z ENDP		; CBaseEntity::Killed
_TEXT	ENDS
PUBLIC	??_C@_0BH@CCMB@class?5?$CFs?$FL?$CFi?$FN?5serial?5?$CFi?$AA@ ; `string'
PUBLIC	??_C@_0BA@HJGB@?0?5globalname?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BA@OPFJ@?0?5targetname?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0M@HJEL@?0?5target?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0L@IBOL@?0?5model?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0L@HCEK@?0?5state?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_01BJG@?6?$AA@				; `string'
PUBLIC	??_C@_08IAOK@Parent?3?5?$AA@			; `string'
PUBLIC	?GetGlobalname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetGlobalname
PUBLIC	?GetTargetname@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetTargetname
PUBLIC	?ReportInfo@CBaseEntity@@QAEXXZ			; CBaseEntity::ReportInfo
EXTRN	?Msg@@YAXPBDZZ:NEAR				; Msg
EXTRN	?GetStringForState@@YAPBDW4STATE@@@Z:NEAR	; GetStringForState
;	COMDAT ??_C@_0BH@CCMB@class?5?$CFs?$FL?$CFi?$FN?5serial?5?$CFi?$AA@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_0BH@CCMB@class?5?$CFs?$FL?$CFi?$FN?5serial?5?$CFi?$AA@ DB 'class %s'
	DB	'[%i] serial %i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HJGB@?0?5globalname?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@HJGB@?0?5globalname?5?$CFs?$AA@ DB ', globalname %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OPFJ@?0?5targetname?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@OPFJ@?0?5targetname?5?$CFs?$AA@ DB ', targetname %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HJEL@?0?5target?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0M@HJEL@?0?5target?5?$CFs?$AA@ DB ', target %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IBOL@?0?5model?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@IBOL@?0?5model?5?$CFs?$AA@ DB ', model %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HCEK@?0?5state?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@HCEK@?0?5state?5?$CFs?$AA@ DB ', state %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJG@?6?$AA@
CONST	SEGMENT
??_C@_01BJG@?6?$AA@ DB 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAOK@Parent?3?5?$AA@
CONST	SEGMENT
??_C@_08IAOK@Parent?3?5?$AA@ DB 'Parent: ', 00H		; `string'
CONST	ENDS
;	COMDAT ?ReportInfo@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ReportInfo@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::ReportInfo, COMDAT

; 1246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1247 : 	Msg( "class %s[%i] serial %i", GetClassname(), entindex(), edict()->serialnumber );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?entindex@CBaseEntity@@QAEHXZ		; CBaseEntity::entindex
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetClassname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetClassname
	push	eax
	push	OFFSET FLAT:??_C@_0BH@CCMB@class?5?$CFs?$FL?$CFi?$FN?5serial?5?$CFi?$AA@ ; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 16					; 00000010H

; 1248 : 
; 1249 : 	if( pev->globalname != NULL_STRING )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L39219

; 1250 : 		Msg( ", globalname %s", GetGlobalname());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetGlobalname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetGlobalname
	push	eax
	push	OFFSET FLAT:??_C@_0BA@HJGB@?0?5globalname?5?$CFs?$AA@ ; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 8
$L39219:

; 1251 : 
; 1252 : 	if( pev->targetname != NULL_STRING )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+460], 0
	je	SHORT $L39221

; 1253 : 		Msg( ", targetname %s", GetTargetname());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTargetname@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTargetname
	push	eax
	push	OFFSET FLAT:??_C@_0BA@OPFJ@?0?5targetname?5?$CFs?$AA@ ; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 8
$L39221:

; 1254 : 
; 1255 : 	if( pev->target != NULL_STRING )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+456], 0
	je	SHORT $L39223

; 1256 : 		Msg( ", target %s", GetTarget());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTarget@CBaseEntity@@QAEPBDXZ	; CBaseEntity::GetTarget
	push	eax
	push	OFFSET FLAT:??_C@_0M@HJEL@?0?5target?5?$CFs?$AA@ ; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 8
$L39223:

; 1257 : 
; 1258 : 
; 1259 : 	if( pev->model != NULL_STRING )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+184], 0
	je	SHORT $L39225

; 1260 : 		Msg( ", model %s", GetModel());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	push	OFFSET FLAT:??_C@_0L@IBOL@?0?5model?5?$CFs?$AA@ ; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 8
$L39225:

; 1261 : 	
; 1262 : 	Msg( ", state %s", GetStringForState( GetState() )); //LRC

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	push	eax
	call	?GetStringForState@@YAPBDW4STATE@@@Z	; GetStringForState
	add	esp, 4
	push	eax
	push	OFFSET FLAT:??_C@_0L@HCEK@?0?5state?5?$CFs?$AA@ ; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 8

; 1263 : 
; 1264 : 	Msg( "\n" );

	push	OFFSET FLAT:??_C@_01BJG@?6?$AA@		; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 4

; 1265 : 
; 1266 : 	if( m_hParent != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	je	SHORT $L39229

; 1268 : 		Msg( "Parent: " );

	push	OFFSET FLAT:??_C@_08IAOK@Parent?3?5?$AA@ ; `string'
	call	?Msg@@YAXPBDZZ				; Msg
	add	esp, 4

; 1269 : 		m_hParent->ReportInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??CEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator->
	mov	ecx, eax
	call	?ReportInfo@CBaseEntity@@QAEXXZ		; CBaseEntity::ReportInfo
$L39229:

; 1271 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReportInfo@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::ReportInfo
_TEXT	ENDS
;	COMDAT ?GetGlobalname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetGlobalname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetGlobalname, COMDAT

; 283  : 	const char*	GetGlobalname() { return STRING( pev->globalname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetGlobalname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetGlobalname
_TEXT	ENDS
;	COMDAT ?GetTargetname@CBaseEntity@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4
?GetTargetname@CBaseEntity@@QAEPBDXZ PROC NEAR		; CBaseEntity::GetTargetname, COMDAT

; 284  : 	const char*	GetTargetname() { return STRING( pev->targetname ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+460]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetTargetname@CBaseEntity@@QAEPBDXZ ENDP		; CBaseEntity::GetTargetname
_TEXT	ENDS
PUBLIC	?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_TARGETNAME
PUBLIC	?FNullEnt@@YAHPBUedict_s@@@Z			; FNullEnt
PUBLIC	?GetNextTarget@CBaseEntity@@UAEPAV1@XZ		; CBaseEntity::GetNextTarget
;	COMDAT ?GetNextTarget@CBaseEntity@@UAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -4
_pTarget$ = -8
?GetNextTarget@CBaseEntity@@UAEPAV1@XZ PROC NEAR	; CBaseEntity::GetNextTarget, COMDAT

; 1274 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1275 : 	if ( FStringNull( pev->target ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	je	SHORT $L39235

; 1276 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L39234
$L39235:

; 1277 : 	edict_t *pTarget = FIND_ENTITY_BY_TARGETNAME ( NULL, STRING(pev->target) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+456]
	push	edx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+264
	add	esp, 4
	push	eax
	push	0
	call	?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z ; FIND_ENTITY_BY_TARGETNAME
	add	esp, 8
	mov	DWORD PTR _pTarget$[ebp], eax

; 1278 : 	if ( FNullEnt(pTarget) )

	mov	eax, DWORD PTR _pTarget$[ebp]
	push	eax
	call	?FNullEnt@@YAHPBUedict_s@@@Z		; FNullEnt
	add	esp, 4
	test	eax, eax
	je	SHORT $L39237

; 1279 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L39234
$L39237:

; 1280 : 
; 1281 : 	return Instance( pTarget );

	mov	ecx, DWORD PTR _pTarget$[ebp]
	push	ecx
	call	?Instance@CBaseEntity@@SAPAV1@PAUedict_s@@@Z ; CBaseEntity::Instance
	add	esp, 4
$L39234:

; 1282 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetNextTarget@CBaseEntity@@UAEPAV1@XZ ENDP		; CBaseEntity::GetNextTarget
_TEXT	ENDS
PUBLIC	??_C@_0L@PMO@targetname?$AA@			; `string'
;	COMDAT ??_C@_0L@PMO@targetname?$AA@
; File z:\xashxtsrc\server\util.h
CONST	SEGMENT
??_C@_0L@PMO@targetname?$AA@ DB 'targetname', 00H	; `string'
CONST	ENDS
;	COMDAT ?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z
_TEXT	SEGMENT
_entStart$ = 8
_pszName$ = 12
?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z PROC NEAR ; FIND_ENTITY_BY_TARGETNAME, COMDAT

; 114  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 115  : 	return FIND_ENTITY_BY_STRING(entStart, "targetname", pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0L@PMO@targetname?$AA@ ; `string'
	mov	ecx, DWORD PTR _entStart$[ebp]
	push	ecx
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+56
	add	esp, 12					; 0000000cH

; 116  : }	

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FIND_ENTITY_BY_TARGETNAME@@YAPAUedict_s@@PAU1@PBD@Z ENDP ; FIND_ENTITY_BY_TARGETNAME
_TEXT	ENDS
;	COMDAT ?FNullEnt@@YAHPBUedict_s@@@Z
_TEXT	SEGMENT
_pent$ = 8
?FNullEnt@@YAHPBUedict_s@@@Z PROC NEAR			; FNullEnt, COMDAT

; 195  : inline BOOL FNullEnt(const edict_t* pent)	{ return pent == NULL || FNullEnt(OFFSET(pent)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	cmp	DWORD PTR _pent$[ebp], 0
	je	SHORT $L41048
	mov	eax, DWORD PTR _pent$[ebp]
	push	eax
	call	?OFFSET@@YAHPBUedict_s@@@Z		; OFFSET
	add	esp, 4
	push	eax
	call	?FNullEnt@@YAHH@Z			; FNullEnt
	add	esp, 4
	test	eax, eax
	jne	SHORT $L41048
	mov	DWORD PTR -4+[ebp], 0
	jmp	SHORT $L41049
$L41048:
	mov	DWORD PTR -4+[ebp], 1
$L41049:
	mov	eax, DWORD PTR -4+[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?FNullEnt@@YAHPBUedict_s@@@Z ENDP			; FNullEnt
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >
PUBLIC	??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::~CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >
PUBLIC	??A?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Count
PUBLIC	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
PUBLIC	?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHABQAVCBaseEntity@@@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail
PUBLIC	??_C@_0BA@KOLE@func_tracktrain?$AA@		; `string'
PUBLIC	?__LINE__Var@?1??Teleport@CBaseEntity@@QAEXPBVVector@@00@Z@4FA ; `CBaseEntity::Teleport'::`2'::__LINE__Var
PUBLIC	??_C@_0BO@GABH@z?3?2xashxtsrc?2server?2cbase?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0BP@EODA@g_TeleportStack?$FLindex?$FN?5?$DN?$DN?5this?$AA@ ; `string'
PUBLIC	?Find@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHABQAVCBaseEntity@@@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Find
PUBLIC	?FastRemove@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::FastRemove
PUBLIC	?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z	; CBaseEntity::Teleport
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	?DBG_AssertFunction@@YAXHPBD0H0@Z:NEAR		; DBG_AssertFunction
EXTRN	?UTIL_Teleport@@YAXPAVCBaseEntity@@AAUTeleportListEntry_t@@PBVVector@@22@Z:NEAR ; UTIL_Teleport
EXTRN	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z:NEAR	; FClassnameIs
;	COMDAT ?__LINE__Var@?1??Teleport@CBaseEntity@@QAEXPBVVector@@00@Z@4FA
; File z:\xashxtsrc\server\cbase.cpp
_DATA	SEGMENT
?__LINE__Var@?1??Teleport@CBaseEntity@@QAEXPBVVector@@00@Z@4FA DW 0539H ; `CBaseEntity::Teleport'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0BA@KOLE@func_tracktrain?$AA@
CONST	SEGMENT
??_C@_0BA@KOLE@func_tracktrain?$AA@ DB 'func_tracktrain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GABH@z?3?2xashxtsrc?2server?2cbase?4cpp?$AA@
CONST	SEGMENT
??_C@_0BO@GABH@z?3?2xashxtsrc?2server?2cbase?4cpp?$AA@ DB 'z:\xashxtsrc\s'
	DB	'erver\cbase.cpp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EODA@g_TeleportStack?$FLindex?$FN?5?$DN?$DN?5this?$AA@
CONST	SEGMENT
??_C@_0BP@EODA@g_TeleportStack?$FLindex?$FN?5?$DN?$DN?5this?$AA@ DB 'g_Te'
	DB	'leportStack[index] == this', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z$0
xdata$x	ENDS
;	COMDAT ?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z
_TEXT	SEGMENT
$T41052 = -48
$T41053 = -52
__$EHRec$ = -12
_newPosition$ = 8
_newAngles$ = 12
_newVelocity$ = 16
_this$ = -16
_index$ = -20
_teleportList$ = -40
_i$ = -44
?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z PROC NEAR	; CBaseEntity::Teleport, COMDAT

; 1337 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1338 : 	if( g_TeleportStack.Find( this ) >= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T41052[ebp], eax
	lea	ecx, DWORD PTR $T41052[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:_g_TeleportStack
	call	?Find@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHABQAVCBaseEntity@@@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Find
	test	eax, eax
	jl	SHORT $L39510

; 1339 : 		return;

	jmp	$L39508
$L39510:

; 1340 : 
; 1341 : 	int index = g_TeleportStack.AddToTail( this );

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T41053[ebp], edx
	lea	eax, DWORD PTR $T41053[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:_g_TeleportStack
	call	?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHABQAVCBaseEntity@@@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail
	mov	DWORD PTR _index$[ebp], eax

; 1342 : 
; 1343 : 	CUtlArray<TeleportListEntry_t> teleportList;

	push	0
	push	0
	lea	ecx, DWORD PTR _teleportList$[ebp]
	call	??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1344 : 	BuildTeleportList_r( this, teleportList );

	lea	ecx, DWORD PTR _teleportList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?BuildTeleportList_r@@YAXPAVCBaseEntity@@AAV?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@@Z ; BuildTeleportList_r
	add	esp, 8

; 1345 : 
; 1346 : 	// also teleport all ents that stay on train
; 1347 : 	if( FClassnameIs( this, "func_tracktrain" ))

	push	OFFSET FLAT:??_C@_0BA@KOLE@func_tracktrain?$AA@ ; `string'
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?FClassnameIs@@YAHPAVCBaseEntity@@PBD@Z	; FClassnameIs
	add	esp, 8

; 1351 : 
; 1352 : 	for( int i = 0; i < teleportList.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39518
$L39519:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L39518:
	lea	ecx, DWORD PTR _teleportList$[ebp]
	call	?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L39520

; 1354 : 		UTIL_Teleport( this, teleportList[i], newPosition, newAngles, newVelocity );

	mov	edx, DWORD PTR _newVelocity$[ebp]
	push	edx
	mov	eax, DWORD PTR _newAngles$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	lea	ecx, DWORD PTR _teleportList$[ebp]
	call	??A?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::operator[]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_Teleport@@YAXPAVCBaseEntity@@AAUTeleportListEntry_t@@PBVVector@@22@Z ; UTIL_Teleport
	add	esp, 20					; 00000014H

; 1355 : 	}

	jmp	SHORT $L39519
$L39520:

; 1356 : 
; 1357 : 	ASSERT( g_TeleportStack[index] == this );

	push	0
	movsx	ecx, WORD PTR ?__LINE__Var@?1??Teleport@CBaseEntity@@QAEXPBVVector@@00@Z@4FA ; `CBaseEntity::Teleport'::`2'::__LINE__Var
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET FLAT:??_C@_0BO@GABH@z?3?2xashxtsrc?2server?2cbase?4cpp?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BP@EODA@g_TeleportStack?$FLindex?$FN?5?$DN?$DN?5this?$AA@ ; `string'
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:_g_TeleportStack
	call	??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
	mov	eax, DWORD PTR [eax]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _this$[ebp]
	sete	cl
	push	ecx
	call	?DBG_AssertFunction@@YAXHPBD0H0@Z	; DBG_AssertFunction
	add	esp, 20					; 00000014H

; 1358 : 	g_TeleportStack.FastRemove( index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:_g_TeleportStack
	call	?FastRemove@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::FastRemove

; 1359 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _teleportList$[ebp]
	call	??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::~CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >
$L39508:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z$0:
	lea	ecx, DWORD PTR _teleportList$[ebp]
	call	??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::~CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >
	ret	0
__ehhandler$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?Teleport@CBaseEntity@@QAEXPBVVector@@00@Z ENDP		; CBaseEntity::Teleport
PUBLIC	?AddToTail@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHABUTeleportListEntry_t@@@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::AddToTail
PUBLIC	??0TeleportListEntry_t@@QAE@XZ			; TeleportListEntry_t::TeleportListEntry_t
;	COMDAT ?BuildTeleportList_r@@YAXPAVCBaseEntity@@AAV?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@@Z
_TEXT	SEGMENT
_pTeleport$ = 8
_teleportList$ = 12
_entry$ = -28
_pList$ = -32
?BuildTeleportList_r@@YAXPAVCBaseEntity@@AAV?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@@Z PROC NEAR ; BuildTeleportList_r, COMDAT

; 1292 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi

; 1293 : 	TeleportListEntry_t entry;

	lea	ecx, DWORD PTR _entry$[ebp]
	call	??0TeleportListEntry_t@@QAE@XZ		; TeleportListEntry_t::TeleportListEntry_t

; 1294 : 	
; 1295 : 	entry.pEntity = pTeleport;

	mov	eax, DWORD PTR _pTeleport$[ebp]
	mov	DWORD PTR _entry$[ebp], eax

; 1296 : 	entry.prevAbsOrigin = pTeleport->GetAbsOrigin();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entry$[ebp+4], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _entry$[ebp+8], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _entry$[ebp+12], eax

; 1297 : 	entry.prevAbsAngles = pTeleport->GetAbsAngles();

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _entry$[ebp+16], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _entry$[ebp+20], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _entry$[ebp+24], eax

; 1298 : 
; 1299 : 	teleportList.AddToTail( entry );

	lea	ecx, DWORD PTR _entry$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _teleportList$[ebp]
	call	?AddToTail@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHABUTeleportListEntry_t@@@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::AddToTail

; 1300 : 
; 1301 : 	CBaseEntity *pList = pTeleport->m_hChild;

	mov	ecx, DWORD PTR _pTeleport$[ebp]
	add	ecx, 156				; 0000009cH
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pList$[ebp], eax
$L39481:

; 1302 : 
; 1303 : 	while( pList )

	cmp	DWORD PTR _pList$[ebp], 0
	je	SHORT $L39482

; 1305 : 		BuildTeleportList_r( pList, teleportList );

	mov	edx, DWORD PTR _teleportList$[ebp]
	push	edx
	mov	eax, DWORD PTR _pList$[ebp]
	push	eax
	call	?BuildTeleportList_r@@YAXPAVCBaseEntity@@AAV?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@@Z ; BuildTeleportList_r
	add	esp, 8

; 1306 : 		pList = pList->m_hNextChild;

	mov	ecx, DWORD PTR _pList$[ebp]
	add	ecx, 164				; 000000a4H
	call	??BEHANDLE@@QAEPAVCBaseEntity@@XZ	; EHANDLE::operator CBaseEntity *
	mov	DWORD PTR _pList$[ebp], eax

; 1307 : 	}

	jmp	SHORT $L39481
$L39482:

; 1308 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BuildTeleportList_r@@YAXPAVCBaseEntity@@AAV?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@@Z ENDP ; BuildTeleportList_r
_TEXT	ENDS
;	COMDAT ??0TeleportListEntry_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??0TeleportListEntry_t@@QAE@XZ PROC NEAR		; TeleportListEntry_t::TeleportListEntry_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0Vector@@QAE@XZ			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0TeleportListEntry_t@@QAE@XZ ENDP			; TeleportListEntry_t::TeleportListEntry_t
_TEXT	ENDS
PUBLIC	?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ; CBaseEntity::GetDataDescMap
;	COMDAT ?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ
_TEXT	SEGMENT
_this$ = -4
?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ PROC NEAR ; CBaseEntity::GetDataDescMap, COMDAT

; 1361 : BEGIN_DATADESC_NO_BASE( CBaseEntity )

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetDataDescMap@CBaseEntity@@UAEPAUdatamap_s@@XZ ENDP	; CBaseEntity::GetDataDescMap
_TEXT	ENDS
PUBLIC	?GetBaseMap@CBaseEntity@@SAPAUdatamap_s@@XZ	; CBaseEntity::GetBaseMap
;	COMDAT ?GetBaseMap@CBaseEntity@@SAPAUdatamap_s@@XZ
_TEXT	SEGMENT
?GetBaseMap@CBaseEntity@@SAPAUdatamap_s@@XZ PROC NEAR	; CBaseEntity::GetBaseMap, COMDAT

; 1361 : BEGIN_DATADESC_NO_BASE( CBaseEntity )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBaseMap@CBaseEntity@@SAPAUdatamap_s@@XZ ENDP	; CBaseEntity::GetBaseMap
_TEXT	ENDS
;	COMDAT _$E36
_TEXT	SEGMENT
_$E36	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	call	_$E35
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E36	ENDP
_TEXT	ENDS
PUBLIC	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z ; DataMapInit
;	COMDAT _$E35
_TEXT	SEGMENT
_$E35	PROC NEAR					; COMDAT

; 1361 : BEGIN_DATADESC_NO_BASE( CBaseEntity )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	0
	call	?DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z ; DataMapInit
	add	esp, 4
	mov	DWORD PTR ?g_DataMapHolder@CBaseEntity_DataDescInit@@3PAUdatamap_s@@A, eax ; CBaseEntity_DataDescInit::g_DataMapHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E35	ENDP
_TEXT	ENDS
PUBLIC	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
PUBLIC	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
PUBLIC	??_C@_0L@KHDH@SUB_Remove?$AA@			; `string'
PUBLIC	??_C@_0O@KJEE@SUB_DoNothing?$AA@		; `string'
PUBLIC	??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@		; `string'
PUBLIC	??_C@_0M@GAKJ@SUB_FadeOut?$AA@			; `string'
PUBLIC	??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@		; `string'
PUBLIC	??_C@_0N@GHMF@m_iActorType?$AA@			; `string'
PUBLIC	??_C@_0O@OEID@m_iActorFlags?$AA@		; `string'
PUBLIC	??_C@_0N@DBPD@m_iBodyFlags?$AA@			; `string'
PUBLIC	??_C@_0P@KEGA@m_usActorGroup?$AA@		; `string'
PUBLIC	??_C@_0N@PBGE@m_flBodyMass?$AA@			; `string'
PUBLIC	??_C@_0L@KDGN@m_fFreezed?$AA@			; `string'
PUBLIC	?SUB_CallUseToggle@CBaseEntity@@QAEXXZ		; CBaseEntity::SUB_CallUseToggle
EXTRN	?SUB_Remove@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_Remove
EXTRN	?SUB_DoNothing@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_DoNothing
EXTRN	?SUB_StartFadeOut@CBaseEntity@@QAEXXZ:NEAR	; CBaseEntity::SUB_StartFadeOut
EXTRN	?SUB_FadeOut@CBaseEntity@@QAEXXZ:NEAR		; CBaseEntity::SUB_FadeOut
_BSS	SEGMENT
_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A DB 01cH DUP (?)
_?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4EA DB 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@KHDH@SUB_Remove?$AA@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_0L@KHDH@SUB_Remove?$AA@ DB 'SUB_Remove', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KJEE@SUB_DoNothing?$AA@
CONST	SEGMENT
??_C@_0O@KJEE@SUB_DoNothing?$AA@ DB 'SUB_DoNothing', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@
CONST	SEGMENT
??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@ DB 'SUB_StartFadeOut', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GAKJ@SUB_FadeOut?$AA@
CONST	SEGMENT
??_C@_0M@GAKJ@SUB_FadeOut?$AA@ DB 'SUB_FadeOut', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@
CONST	SEGMENT
??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@ DB 'SUB_CallUseToggle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GHMF@m_iActorType?$AA@
CONST	SEGMENT
??_C@_0N@GHMF@m_iActorType?$AA@ DB 'm_iActorType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OEID@m_iActorFlags?$AA@
CONST	SEGMENT
??_C@_0O@OEID@m_iActorFlags?$AA@ DB 'm_iActorFlags', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DBPD@m_iBodyFlags?$AA@
CONST	SEGMENT
??_C@_0N@DBPD@m_iBodyFlags?$AA@ DB 'm_iBodyFlags', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KEGA@m_usActorGroup?$AA@
CONST	SEGMENT
??_C@_0P@KEGA@m_usActorGroup?$AA@ DB 'm_usActorGroup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PBGE@m_flBodyMass?$AA@
CONST	SEGMENT
??_C@_0N@PBGE@m_flBodyMass?$AA@ DB 'm_flBodyMass', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDGN@m_fFreezed?$AA@
CONST	SEGMENT
??_C@_0L@KDGN@m_fFreezed?$AA@ DB 'm_fFreezed', 00H	; `string'
CONST	ENDS
;	COMDAT ?DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z
_TEXT	SEGMENT
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z PROC NEAR ; DataMapInit, COMDAT

; 1361 : BEGIN_DATADESC_NO_BASE( CBaseEntity )

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	xor	eax, eax
	mov	al, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4EA
	and	eax, 1
	test	eax, eax
	jne	SHORT $L39555
	mov	cl, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4EA
	or	cl, 1
	mov	BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4EA, cl
	push	OFFSET FLAT:??_C@_0M@GOBJ@CBaseEntity?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
	push	OFFSET FLAT:_$E39
	call	_atexit
	add	esp, 4
$L39555:
	call	?GetBaseMap@CBaseEntity@@SAPAUdatamap_s@@XZ ; CBaseEntity::GetBaseMap
	mov	DWORD PTR ?m_DataMap@CBaseEntity@@2Udatamap_s@@A+12, eax

; 1362 : 	DEFINE_FIELD( m_pGoalEnt, FIELD_CLASSPTR ),
; 1363 : 
; 1364 : 	DEFINE_KEYFIELD( m_iParent, FIELD_STRING, "parent" ),
; 1365 : 	DEFINE_FIELD( m_hParent, FIELD_EHANDLE ),
; 1366 : 	DEFINE_FIELD( m_hChild, FIELD_EHANDLE ),	
; 1367 : 	DEFINE_FIELD( m_hNextChild, FIELD_EHANDLE ),
; 1368 : 	DEFINE_KEYFIELD( m_iParentFlags, FIELD_INTEGER, "parentflags" ),
; 1369 : 
; 1370 : 	DEFINE_FIELD( m_vecEndPos, FIELD_POSITION_VECTOR ),	// for beams 
; 1371 : 
; 1372 : 	DEFINE_FIELD( m_vecOrigin, FIELD_VECTOR ), 
; 1373 : 	DEFINE_FIELD( m_vecAngles, FIELD_VECTOR ),
; 1374 : 	DEFINE_FIELD( m_vecVelocity, FIELD_VECTOR ), 
; 1375 : 	DEFINE_FIELD( m_vecAvelocity, FIELD_VECTOR ),
; 1376 : 	DEFINE_AUTO_ARRAY( m_local, FIELD_FLOAT ),		// matrix4x4
; 1377 : 
; 1378 : 	DEFINE_FIELD( m_iFlags, FIELD_INTEGER ),
; 1379 : 	DEFINE_FIELD( m_iOldSolid, FIELD_INTEGER ),
; 1380 : 	DEFINE_FIELD( m_iOldMoveType, FIELD_INTEGER ),
; 1381 : 	DEFINE_FIELD( m_flMoveDoneTime, FIELD_FLOAT ),		// local time saved as float, not time!
; 1382 : 	DEFINE_FIELD( m_fPicked, FIELD_BOOLEAN ),
; 1383 : 	DEFINE_FIELD( m_iStyle, FIELD_INTEGER ),
; 1384 : 	DEFINE_FIELD( m_flGaitYaw, FIELD_FLOAT ),
; 1385 : 
; 1386 : 	DEFINE_FIELD( m_pfnThink, FIELD_FUNCTION ),		// UNDONE: Build table of these!!!
; 1387 : 	DEFINE_FIELD( m_pfnTouch, FIELD_FUNCTION ),
; 1388 : 	DEFINE_FIELD( m_pfnUse, FIELD_FUNCTION ),
; 1389 : 	DEFINE_FIELD( m_pfnBlocked, FIELD_FUNCTION ),
; 1390 : 	DEFINE_FIELD( m_pfnMoveDone, FIELD_FUNCTION ),
; 1391 : 
; 1392 : 	DEFINE_FIELD( m_flShowHostile, FIELD_TIME ),
; 1393 : 	DEFINE_FIELD( m_isChaining, FIELD_BOOLEAN ),		// door stuff but need to set everywhere
; 1394 : 
; 1395 : 	// studio pose parameters
; 1396 : 	DEFINE_AUTO_ARRAY( m_flPoseParameter, FIELD_FLOAT ),
; 1397 : 
; 1398 : 	// function pointers
; 1399 : 	DEFINE_FUNCTION( SUB_Remove ),

	xor	edx, edx
	mov	dl, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4EA
	and	edx, 2
	test	edx, edx
	jne	$L39644
	mov	al, BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4EA
	or	al, 2
	mov	BYTE PTR _?$S38@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4EA, al
	push	OFFSET FLAT:??_C@_0L@KHDH@SUB_Remove?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+676, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+680, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+684, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+686, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+688, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+692, OFFSET FLAT:?SUB_Remove@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_Remove

; 1400 : 	DEFINE_FUNCTION( SUB_DoNothing ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+696, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0O@KJEE@SUB_DoNothing?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+700, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+704, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+708, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+710, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+712, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+716, OFFSET FLAT:?SUB_DoNothing@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_DoNothing

; 1401 : 	DEFINE_FUNCTION( SUB_StartFadeOut ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+720, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0BB@BMDK@SUB_StartFadeOut?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+724, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+728, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+732, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+734, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+736, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+740, OFFSET FLAT:?SUB_StartFadeOut@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_StartFadeOut

; 1402 : 	DEFINE_FUNCTION( SUB_FadeOut ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+744, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0M@GAKJ@SUB_FadeOut?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+748, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+752, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+756, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+758, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+760, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+764, OFFSET FLAT:?SUB_FadeOut@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_FadeOut

; 1403 : 	DEFINE_FUNCTION( SUB_CallUseToggle ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+768, 18 ; 00000012H
	push	OFFSET FLAT:??_C@_0BC@FMAO@SUB_CallUseToggle?$AA@ ; `string'
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ; CDatadescGeneratedNameHolder::GenerateName
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+772, eax
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+776, 0
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+780, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+782, 8
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+784, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+788, OFFSET FLAT:?SUB_CallUseToggle@CBaseEntity@@QAEXXZ ; CBaseEntity::SUB_CallUseToggle

; 1404 : 
; 1405 : 	// PhysX description
; 1406 : 	DEFINE_FIELD( m_iActorType, FIELD_CHARACTER ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+792, 14 ; 0000000eH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+796, OFFSET FLAT:??_C@_0N@GHMF@m_iActorType?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+800, 1604 ; 00000644H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+804, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+806, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+808, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+812, 0

; 1407 : 	DEFINE_FIELD( m_iActorFlags, FIELD_INTEGER ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+816, 10 ; 0000000aH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+820, OFFSET FLAT:??_C@_0O@OEID@m_iActorFlags?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+824, 1608 ; 00000648H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+828, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+830, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+832, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+836, 0

; 1408 : 	DEFINE_FIELD( m_iBodyFlags, FIELD_INTEGER ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+840, 10 ; 0000000aH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+844, OFFSET FLAT:??_C@_0N@DBPD@m_iBodyFlags?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+848, 1612 ; 0000064cH
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+852, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+854, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+856, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+860, 0

; 1409 : 	DEFINE_FIELD( m_usActorGroup, FIELD_SHORT ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+864, 13 ; 0000000dH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+868, OFFSET FLAT:??_C@_0P@KEGA@m_usActorGroup?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+872, 1616 ; 00000650H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+876, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+878, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+880, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+884, 0

; 1410 : 	DEFINE_FIELD( m_flBodyMass, FIELD_FLOAT ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+888, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+892, OFFSET FLAT:??_C@_0N@PBGE@m_flBodyMass?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+896, 1620 ; 00000654H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+900, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+902, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+904, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+908, 0

; 1411 : 	DEFINE_FIELD( m_fFreezed, FIELD_BOOLEAN ),

	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+912, 12 ; 0000000cH
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+916, OFFSET FLAT:??_C@_0L@KDGN@m_fFreezed?$AA@ ; `string'
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+920, 1624 ; 00000658H
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+924, 1
	mov	WORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+926, 2
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+928, 0
	mov	DWORD PTR _?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+932, 0
$L39644:

; 1412 : END_DATADESC()

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L39677
	mov	DWORD PTR ?m_DataMap@CBaseEntity@@2Udatamap_s@@A+4, 38 ; 00000026H
	mov	DWORD PTR ?m_DataMap@CBaseEntity@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A+24
	jmp	SHORT $L39678
$L39677:
	mov	DWORD PTR ?m_DataMap@CBaseEntity@@2Udatamap_s@@A+4, 1
	mov	DWORD PTR ?m_DataMap@CBaseEntity@@2Udatamap_s@@A, OFFSET FLAT:_?dataDesc@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4PAUtypedescription_s@@A
$L39678:
	mov	eax, OFFSET FLAT:?m_DataMap@CBaseEntity@@2Udatamap_s@@A ; CBaseEntity::m_DataMap
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z ENDP	; DataMapInit
_TEXT	ENDS
PUBLIC	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
EXTRN	_strlen:NEAR
;	COMDAT ??0CDatadescGeneratedNameHolder@@QAE@PBD@Z
_TEXT	SEGMENT
_pszBase$ = 8
_this$ = -4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z PROC NEAR	; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder, COMDAT

; 192  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszBase$[ebp]
	mov	DWORD PTR [eax], ecx
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >

; 193  : 		m_nLenBase = strlen( m_pszBase ) + 2;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 194  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0CDatadescGeneratedNameHolder@@QAE@PBD@Z ENDP		; CDatadescGeneratedNameHolder::CDatadescGeneratedNameHolder
_TEXT	ENDS
PUBLIC	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
PUBLIC	??_C@_04NHIK@?$CFs?3?3?$AA@			; `string'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	_strcat:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_04NHIK@?$CFs?3?3?$AA@
; File z:\xashxtsrc\common\datamap.h
CONST	SEGMENT
??_C@_04NHIK@?$CFs?3?3?$AA@ DB '%s::', 00H		; `string'
CONST	ENDS
;	COMDAT ?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z
_TEXT	SEGMENT
$T41084 = -12
_pszIdentifier$ = 8
_this$ = -4
_pBuf$ = -8
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z PROC NEAR ; CDatadescGeneratedNameHolder::GenerateName, COMDAT

; 205  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  : 		char *pBuf = new char[m_nLenBase + strlen(pszIdentifier) + 1];

	mov	eax, DWORD PTR _pszIdentifier$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [edx+eax+1]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T41084[ebp], eax
	mov	ecx, DWORD PTR $T41084[ebp]
	mov	DWORD PTR _pBuf$[ebp], ecx

; 207  : 		sprintf( pBuf, "%s::", m_pszBase );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET FLAT:??_C@_04NHIK@?$CFs?3?3?$AA@	; `string'
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 208  : 		strcat( pBuf, pszIdentifier );

	mov	edx, DWORD PTR _pszIdentifier$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 209  : 		m_Names.AddToTail( pBuf );

	lea	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail

; 210  : 		return pBuf;

	mov	eax, DWORD PTR _pBuf$[ebp]

; 211  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateName@CDatadescGeneratedNameHolder@@QAEPBDPBD@Z ENDP ; CDatadescGeneratedNameHolder::GenerateName
_TEXT	ENDS
;	COMDAT ?SUB_CallUseToggle@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?SUB_CallUseToggle@CBaseEntity@@QAEXXZ PROC NEAR	; CBaseEntity::SUB_CallUseToggle, COMDAT

; 507  : 	void SUB_CallUseToggle( void ) { this->Use( this, this, USE_TOGGLE, 0 ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	push	3
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+276]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SUB_CallUseToggle@CBaseEntity@@QAEXXZ ENDP		; CBaseEntity::SUB_CallUseToggle
_TEXT	ENDS
PUBLIC	??1CDatadescGeneratedNameHolder@@QAE@XZ		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	ecx, OFFSET FLAT:_?nameHolder@?1??DataMapInit@@YAPAUdatamap_s@@PAVCBaseEntity@@@Z@4VCDatadescGeneratedNameHolder@@A
	call	??1CDatadescGeneratedNameHolder@@QAE@XZ	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_$E39	ENDP
_TEXT	ENDS
PUBLIC	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
PUBLIC	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT xdata$x
; File z:\xashxtsrc\common\datamap.h
xdata$x	SEGMENT
__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1CDatadescGeneratedNameHolder@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1CDatadescGeneratedNameHolder@@QAE@XZ
_TEXT	SEGMENT
$T41091 = -24
__$EHRec$ = -12
_this$ = -16
_i$ = -20
??1CDatadescGeneratedNameHolder@@QAE@XZ PROC NEAR	; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder, COMDAT

; 197  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 198  : 		for( int i = 0; i < m_Names.Count(); i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L30214
$L30215:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L30214:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L30216

; 200  : 			delete m_Names[i];

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T41091[ebp], edx
	mov	eax, DWORD PTR $T41091[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 201  : 		}

	jmp	SHORT $L30215
$L30216:

; 202  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDatadescGeneratedNameHolder@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
	ret	0
__ehhandler$??1CDatadescGeneratedNameHolder@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1CDatadescGeneratedNameHolder@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1CDatadescGeneratedNameHolder@@QAE@XZ ENDP		; CDatadescGeneratedNameHolder::~CDatadescGeneratedNameHolder
PUBLIC	?WriteAll@CSave@@QAEHPBXPAUdatamap_s@@@Z	; CSave::WriteAll
PUBLIC	?Save@CBaseEntity@@UAEHAAVCSave@@@Z		; CBaseEntity::Save
PUBLIC	??_C@_07BFFD@ENTVARS?$AA@			; `string'
EXTRN	?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z:NEAR ; CSave::WriteEntVars
;	COMDAT ??_C@_07BFFD@ENTVARS?$AA@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_07BFFD@ENTVARS?$AA@ DB 'ENTVARS', 00H		; `string'
CONST	ENDS
;	COMDAT ?Save@CBaseEntity@@UAEHAAVCSave@@@Z
_TEXT	SEGMENT
_save$ = 8
_this$ = -4
?Save@CBaseEntity@@UAEHAAVCSave@@@Z PROC NEAR		; CBaseEntity::Save, COMDAT

; 1415 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1416 : 	// here, we must force recomputation of all abs data so it gets saved correctly
; 1417 : 	// we can't leave the transform bits set because the loader can't cope with it.
; 1418 : 	CalcAbsolutePosition();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsolutePosition@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsolutePosition

; 1419 : 	CalcAbsoluteVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?CalcAbsoluteVelocity@CBaseEntity@@QAEXXZ ; CBaseEntity::CalcAbsoluteVelocity

; 1420 : 
; 1421 : 	if( m_iActorType != ACTOR_INVALID )

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1604]
	test	ecx, ecx
	je	SHORT $L39684

; 1422 : 		WorldPhysic->SaveBody( this );

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+52]
$L39684:

; 1423 : 
; 1424 : 	if( save.WriteEntVars( "ENTVARS", GetDataDescMap(), pev ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax]
	push	eax
	push	OFFSET FLAT:??_C@_07BFFD@ENTVARS?$AA@	; `string'
	mov	ecx, DWORD PTR _save$[ebp]
	call	?WriteEntVars@CSave@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ; CSave::WriteEntVars
	test	eax, eax
	je	SHORT $L39685

; 1425 : 		return save.WriteAll( this, GetDataDescMap());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _save$[ebp]
	call	?WriteAll@CSave@@QAEHPBXPAUdatamap_s@@@Z ; CSave::WriteAll
	jmp	SHORT $L39683
$L39685:

; 1426 : 
; 1427 : 	return 0;

	xor	eax, eax
$L39683:

; 1428 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Save@CBaseEntity@@UAEHAAVCSave@@@Z ENDP		; CBaseEntity::Save
_TEXT	ENDS
EXTRN	?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z:NEAR ; CSave::DoWriteAll
;	COMDAT ?WriteAll@CSave@@QAEHPBXPAUdatamap_s@@@Z
_TEXT	SEGMENT
_pLeafObject$ = 8
_pLeafMap$ = 12
_this$ = -4
?WriteAll@CSave@@QAEHPBXPAUdatamap_s@@@Z PROC NEAR	; CSave::WriteAll, COMDAT

; 53   : 	int	WriteAll( const void *pLeafObject, DATAMAP *pLeafMap ) { return DoWriteAll( pLeafObject, pLeafMap, pLeafMap ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafMap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLeafObject$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoWriteAll@CSave@@QAEHPBXPAUdatamap_s@@1@Z ; CSave::DoWriteAll
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?WriteAll@CSave@@QAEHPBXPAUdatamap_s@@@Z ENDP		; CSave::WriteAll
_TEXT	ENDS
PUBLIC	?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z	; CBaseEntity::Restore
PUBLIC	?ReadAll@CRestore@@QAEHPAXPAUdatamap_s@@@Z	; CRestore::ReadAll
PUBLIC	?IsGlobalMode@CRestore@@QAEHXZ			; CRestore::IsGlobalMode
EXTRN	?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z:NEAR ; CRestore::ReadEntVars
EXTRN	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z:NEAR ; UTIL_SetSize
;	COMDAT ?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z
_TEXT	SEGMENT
_restore$ = 8
_this$ = -4
_status$ = -8
_hParent$ = -16
_hChild$ = -24
_hNextChild$ = -32
_parentSpaceOffset$39698 = -44
_mins$39701 = -56
_maxs$39702 = -68
?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z PROC NEAR	; CBaseEntity::Restore, COMDAT

; 1431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1432 : 	int status;
; 1433 : 	EHANDLE hParent, hChild, hNextChild;
; 1434 : 
; 1435 : 	if( restore.IsGlobalMode() )

	mov	ecx, DWORD PTR _restore$[ebp]
	call	?IsGlobalMode@CRestore@@QAEHXZ		; CRestore::IsGlobalMode
	test	eax, eax
	je	SHORT $L39695

; 1437 : 		// we already have the valid chain.
; 1438 : 		// Don't break it with bad pointers from previous level
; 1439 : 		hParent = m_hParent;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [eax+152]
	mov	DWORD PTR _hParent$[ebp], ecx
	mov	DWORD PTR _hParent$[ebp+4], edx

; 1440 : 		hChild = m_hChild;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	mov	edx, DWORD PTR [eax+160]
	mov	DWORD PTR _hChild$[ebp], ecx
	mov	DWORD PTR _hChild$[ebp+4], edx

; 1441 : 		hNextChild = m_hNextChild;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+164]
	mov	edx, DWORD PTR [eax+168]
	mov	DWORD PTR _hNextChild$[ebp], ecx
	mov	DWORD PTR _hNextChild$[ebp+4], edx
$L39695:

; 1443 : 
; 1444 : 	status = restore.ReadEntVars( "ENTVARS", GetDataDescMap(), pev );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax]
	push	eax
	push	OFFSET FLAT:??_C@_07BFFD@ENTVARS?$AA@	; `string'
	mov	ecx, DWORD PTR _restore$[ebp]
	call	?ReadEntVars@CRestore@@QAEHPBDPAUdatamap_s@@PAUentvars_s@@@Z ; CRestore::ReadEntVars
	mov	DWORD PTR _status$[ebp], eax

; 1445 : 	if ( status )

	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $L39696

; 1446 : 		status = restore.ReadAll( this, GetDataDescMap());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _restore$[ebp]
	call	?ReadAll@CRestore@@QAEHPAXPAUdatamap_s@@@Z ; CRestore::ReadAll
	mov	DWORD PTR _status$[ebp], eax
$L39696:

; 1447 : 
; 1448 : 	if( restore.IsGlobalMode() )

	mov	ecx, DWORD PTR _restore$[ebp]
	call	?IsGlobalMode@CRestore@@QAEHXZ		; CRestore::IsGlobalMode
	test	eax, eax
	je	SHORT $L39697

; 1450 : 		// restore our chian here
; 1451 : 		m_hParent = hParent;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _hParent$[ebp]
	mov	DWORD PTR [ecx+148], edx
	mov	eax, DWORD PTR _hParent$[ebp+4]
	mov	DWORD PTR [ecx+152], eax

; 1452 : 		m_hChild = hChild;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _hChild$[ebp]
	mov	DWORD PTR [ecx+156], edx
	mov	eax, DWORD PTR _hChild$[ebp+4]
	mov	DWORD PTR [ecx+160], eax

; 1453 : 		m_hNextChild = hNextChild;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _hNextChild$[ebp]
	mov	DWORD PTR [ecx+164], edx
	mov	eax, DWORD PTR _hNextChild$[ebp+4]
	mov	DWORD PTR [ecx+168], eax
$L39697:

; 1461 : 		Vector parentSpaceOffset = restore.modelSpaceOffset;

	mov	ecx, DWORD PTR _restore$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _parentSpaceOffset$39698[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1462 : 
; 1463 : 		if( m_hParent == NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	call	??BEHANDLE@@QAEHXZ			; EHANDLE::operator int
	test	eax, eax
	jne	SHORT $L39699

; 1465 : 			// parent is the world, so parent space is worldspace
; 1466 : 			// so update with the worldspace leveltransition transform
; 1467 : 			parentSpaceOffset += gpGlobals->vecLandmarkOffset;

	mov	edx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	edx, 160				; 000000a0H
	push	edx
	lea	ecx, DWORD PTR _parentSpaceOffset$39698[ebp]
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=
$L39699:

; 1469 : 
; 1470 : 		m_local.SetOrigin( pev->origin );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 180				; 000000b4H
	call	?SetOrigin@matrix4x4@@QAEXABVVector@@@Z	; matrix4x4::SetOrigin

; 1471 : 		m_vecOrigin += parentSpaceOffset;

	lea	edx, DWORD PTR _parentSpaceOffset$39698[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 100				; 00000064H
	call	??YVector@@QAEAAV0@ABV0@@Z		; Vector::operator+=

; 1473 : 
; 1474 : 	if ( pev->modelindex != 0 && !FStringNull( pev->model ))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+180], 0
	je	SHORT $L39700
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+184]
	push	ecx
	call	?FStringNull@@YAHH@Z			; FStringNull
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39700

; 1476 : 		Vector mins = pev->mins; // Set model is about to destroy these

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 220				; 000000dcH
	push	eax
	lea	ecx, DWORD PTR _mins$39701[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1477 : 		Vector maxs = pev->maxs;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	lea	ecx, DWORD PTR _maxs$39702[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1478 : 
; 1479 : 
; 1480 : 		PRECACHE_MODEL( GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A
	add	esp, 4

; 1481 : 		SetModel( GetModel() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetModel@CBaseEntity@@QAEPBDXZ		; CBaseEntity::GetModel
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetModel@CBaseEntity@@QAEXPBD@Z	; CBaseEntity::SetModel

; 1482 : 		UTIL_SetSize( pev, mins, maxs ); // Reset them

	lea	eax, DWORD PTR _maxs$39702[ebp]
	push	eax
	lea	ecx, DWORD PTR _mins$39701[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UTIL_SetSize@@YAXPAUentvars_s@@ABVVector@@1@Z ; UTIL_SetSize
	add	esp, 12					; 0000000cH
$L39700:

; 1484 : 
; 1485 : 	if( m_iActorType != ACTOR_INVALID )

	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR [ecx+1604]
	test	edx, edx
	je	SHORT $L39703

; 1486 : 		m_pUserData = WorldPhysic->RestoreBody( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?WorldPhysic@@3PAVIPhysicLayer@@A ; WorldPhysic
	call	DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+244], eax
$L39703:

; 1487 : 
; 1488 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 1489 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Restore@CBaseEntity@@UAEHAAVCRestore@@@Z ENDP		; CBaseEntity::Restore
_TEXT	ENDS
EXTRN	?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z:NEAR ; CRestore::DoReadAll
;	COMDAT ?ReadAll@CRestore@@QAEHPAXPAUdatamap_s@@@Z
_TEXT	SEGMENT
_pLeafObject$ = 8
_pLeafMap$ = 12
_this$ = -4
?ReadAll@CRestore@@QAEHPAXPAUdatamap_s@@@Z PROC NEAR	; CRestore::ReadAll, COMDAT

; 91   : 	int	ReadAll( void *pLeafObject, DATAMAP *pLeafMap )	{ return DoReadAll( pLeafObject, pLeafMap, pLeafMap ); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pLeafMap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pLeafMap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pLeafObject$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoReadAll@CRestore@@QAEHPAXPAUdatamap_s@@1@Z ; CRestore::DoReadAll
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ReadAll@CRestore@@QAEHPAXPAUdatamap_s@@@Z ENDP		; CRestore::ReadAll
_TEXT	ENDS
;	COMDAT ?IsGlobalMode@CRestore@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsGlobalMode@CRestore@@QAEHXZ PROC NEAR		; CRestore::IsGlobalMode, COMDAT

; 105  : 	BOOL	IsGlobalMode( void ) { return m_global; }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsGlobalMode@CRestore@@QAEHXZ ENDP			; CRestore::IsGlobalMode
_TEXT	ENDS
PUBLIC	?SetObjectCollisionBox@CBaseEntity@@UAEXXZ	; CBaseEntity::SetObjectCollisionBox
EXTRN	?UTIL_CanRotateBModel@@YAHPAVCBaseEntity@@@Z:NEAR ; UTIL_CanRotateBModel
EXTRN	?TransformAABB@@YAXABVmatrix4x4@@ABVVector@@1AAV2@2@Z:NEAR ; TransformAABB
;	COMDAT ?SetObjectCollisionBox@CBaseEntity@@UAEXXZ
_TEXT	SEGMENT
$T41111 = -16
$T41112 = -28
_this$ = -4
?SetObjectCollisionBox@CBaseEntity@@UAEXXZ PROC NEAR	; CBaseEntity::SetObjectCollisionBox, COMDAT

; 1493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1494 : 	if( UTIL_CanRotateBModel( this ) && ( GetAbsAngles() != g_vecZero ))

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UTIL_CanRotateBModel@@YAHPAVCBaseEntity@@@Z ; UTIL_CanRotateBModel
	add	esp, 4
	test	eax, eax
	je	SHORT $L39708
	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, eax
	call	??9Vector@@QBEHABV0@@Z			; Vector::operator!=
	test	eax, eax
	je	SHORT $L39708

; 1496 : 		// expand for rotation
; 1497 : 		TransformAABB( EntityToWorldTransform(), pev->mins, pev->maxs, pev->absmin, pev->absmax );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 208				; 000000d0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 196				; 000000c4H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 232				; 000000e8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 220				; 000000dcH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QAEAAVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	call	?TransformAABB@@YAXABVmatrix4x4@@ABVVector@@1AAV2@2@Z ; TransformAABB
	add	esp, 20					; 00000014H

; 1499 : 	else

	jmp	SHORT $L39709
$L39708:

; 1501 : 		pev->absmin = GetAbsOrigin() + pev->mins;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 220				; 000000dcH
	push	ecx
	lea	edx, DWORD PTR $T41111[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 196				; 000000c4H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1502 : 		pev->absmax = GetAbsOrigin() + pev->maxs;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	lea	eax, DWORD PTR $T41112[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	mov	ecx, eax
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 208				; 000000d0H
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax
$L39709:

; 1504 : 
; 1505 : 	pev->absmin.x -= 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+196]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+196]

; 1506 : 	pev->absmin.y -= 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+200]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+200]

; 1507 : 	pev->absmin.z -= 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+204]
	fsub	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+204]

; 1508 : 	pev->absmax.x += 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+208]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx+208]

; 1509 : 	pev->absmax.y += 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+212]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fstp	DWORD PTR [edx+212]

; 1510 : 	pev->absmax.z += 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+216]
	fadd	DWORD PTR __real@4@3fff8000000000000000
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fstp	DWORD PTR [eax+216]

; 1511 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?SetObjectCollisionBox@CBaseEntity@@UAEXXZ ENDP		; CBaseEntity::SetObjectCollisionBox
_TEXT	ENDS
PUBLIC	?EntityAABBToWorldAABB@CBaseEntity@@QBEXABVVector@@0AAV2@1@Z ; CBaseEntity::EntityAABBToWorldAABB
;	COMDAT ?EntityAABBToWorldAABB@CBaseEntity@@QBEXABVVector@@0AAV2@1@Z
_TEXT	SEGMENT
$T41115 = -16
$T41116 = -28
_entityMins$ = 8
_entityMaxs$ = 12
_pWorldMins$ = 16
_pWorldMaxs$ = 20
_this$ = -4
?EntityAABBToWorldAABB@CBaseEntity@@QBEXABVVector@@0AAV2@1@Z PROC NEAR ; CBaseEntity::EntityAABBToWorldAABB, COMDAT

; 1517 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1518 : 	if( GetAbsAngles() == g_vecZero )

	push	OFFSET FLAT:?g_vecZero@@3VVector@@B	; g_vecZero
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsAngles@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsAngles
	mov	ecx, eax
	call	??8Vector@@QBEHABV0@@Z			; Vector::operator==
	test	eax, eax
	je	SHORT $L39719

; 1520 : 		pWorldMins = entityMins + GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T41115[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityMins$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pWorldMins$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1521 : 		pWorldMaxs = entityMaxs + GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T41116[ebp]
	push	ecx
	mov	ecx, DWORD PTR _entityMaxs$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _pWorldMaxs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1523 : 	else

	jmp	SHORT $L39722
$L39719:

; 1525 : 		TransformAABB( EntityToWorldTransform(), entityMins, entityMaxs, pWorldMins, pWorldMaxs );

	mov	ecx, DWORD PTR _pWorldMaxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pWorldMins$[ebp]
	push	edx
	mov	eax, DWORD PTR _entityMaxs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _entityMins$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	push	eax
	call	?TransformAABB@@YAXABVmatrix4x4@@ABVVector@@1AAV2@2@Z ; TransformAABB
	add	esp, 20					; 00000014H
$L39722:

; 1527 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?EntityAABBToWorldAABB@CBaseEntity@@QBEXABVVector@@0AAV2@1@Z ENDP ; CBaseEntity::EntityAABBToWorldAABB
_TEXT	ENDS
PUBLIC	?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z	; CBaseEntity::WorldSpaceAABB
;	COMDAT ?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z
_TEXT	SEGMENT
$T41119 = -16
$T41120 = -28
_pWorldMins$ = 8
_pWorldMaxs$ = 12
_this$ = -4
?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z PROC NEAR ; CBaseEntity::WorldSpaceAABB, COMDAT

; 1530 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1531 : 	if( UTIL_GetModelType( pev->modelindex ) != mod_brush )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	je	SHORT $L39728

; 1533 : 		pWorldMins = pev->mins + GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T41119[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	add	ecx, 220				; 000000dcH
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	edx, DWORD PTR _pWorldMins$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 1534 : 		pWorldMaxs = pev->maxs + GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR $T41120[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	add	ecx, 232				; 000000e8H
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pWorldMaxs$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 1536 : 	else

	jmp	SHORT $L39731
$L39728:

; 1538 : 		EntityAABBToWorldAABB( pev->mins, pev->maxs, pWorldMins, pWorldMaxs ); 

	mov	ecx, DWORD PTR _pWorldMaxs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pWorldMins$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 232				; 000000e8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 220				; 000000dcH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityAABBToWorldAABB@CBaseEntity@@QBEXABVVector@@0AAV2@1@Z ; CBaseEntity::EntityAABBToWorldAABB
$L39731:

; 1540 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?WorldSpaceAABB@CBaseEntity@@QBEXAAVVector@@0@Z ENDP	; CBaseEntity::WorldSpaceAABB
_TEXT	ENDS
PUBLIC	?CalcNearestPoint@CBaseEntity@@QBEXABVVector@@PAV2@@Z ; CBaseEntity::CalcNearestPoint
PUBLIC	?CollisionToWorldSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z ; CBaseEntity::CollisionToWorldSpace
PUBLIC	?WorldToCollisionSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z ; CBaseEntity::WorldToCollisionSpace
EXTRN	?CalcClosestPointOnAABB@@YAXABVVector@@00AAV1@@Z:NEAR ; CalcClosestPointOnAABB
;	COMDAT ?CalcNearestPoint@CBaseEntity@@QBEXABVVector@@PAV2@@Z
_TEXT	SEGMENT
_vecWorldPt$ = 8
_pVecNearestWorldPt$ = 12
_this$ = -4
_localPt$ = -16
_localClosestPt$ = -28
?CalcNearestPoint@CBaseEntity@@QBEXABVVector@@PAV2@@Z PROC NEAR ; CBaseEntity::CalcNearestPoint, COMDAT

; 1543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1544 : 	// calculate physics force
; 1545 : 	Vector localPt, localClosestPt;

	lea	ecx, DWORD PTR _localPt$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector
	lea	ecx, DWORD PTR _localClosestPt$[ebp]
	call	??0Vector@@QAE@XZ			; Vector::Vector

; 1546 : 
; 1547 : 	WorldToCollisionSpace( vecWorldPt, &localPt );

	lea	eax, DWORD PTR _localPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vecWorldPt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?WorldToCollisionSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z ; CBaseEntity::WorldToCollisionSpace

; 1548 : 	CalcClosestPointOnAABB( pev->mins, pev->maxs, localPt, localClosestPt );

	lea	edx, DWORD PTR _localClosestPt$[ebp]
	push	edx
	lea	eax, DWORD PTR _localPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 232				; 000000e8H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 220				; 000000dcH
	push	ecx
	call	?CalcClosestPointOnAABB@@YAXABVVector@@00AAV1@@Z ; CalcClosestPointOnAABB
	add	esp, 16					; 00000010H

; 1549 : 	CollisionToWorldSpace( localClosestPt, pVecNearestWorldPt );

	mov	edx, DWORD PTR _pVecNearestWorldPt$[ebp]
	push	edx
	lea	eax, DWORD PTR _localClosestPt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CollisionToWorldSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z ; CBaseEntity::CollisionToWorldSpace

; 1550 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CalcNearestPoint@CBaseEntity@@QBEXABVVector@@PAV2@@Z ENDP ; CBaseEntity::CalcNearestPoint
_TEXT	ENDS
EXTRN	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z:NEAR ; matrix4x4::VectorTransform
;	COMDAT ?CollisionToWorldSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z
_TEXT	SEGMENT
$T41125 = -16
$T41126 = -28
_in$ = 8
_pResult$ = 12
_this$ = -4
?CollisionToWorldSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z PROC NEAR ; CBaseEntity::CollisionToWorldSpace, COMDAT

; 758  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 759  : 	// Makes sure we don't re-use the same temp twice
; 760  : 	if( UTIL_GetModelType( pev->modelindex ) != mod_brush )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	je	SHORT $L35158

; 762  : 		// boxes can't rotate
; 763  : 		*pResult = in + GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T41125[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	??HVector@@QBE?AV0@ABV0@@Z		; Vector::operator+
	mov	ecx, DWORD PTR _pResult$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 765  : 	else

	jmp	SHORT $L35160
$L35158:

; 767  : 		*pResult = EntityToWorldTransform().VectorTransform( in );

	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41126[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?VectorTransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorTransform
	mov	ecx, DWORD PTR _pResult$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L35160:

; 769  : 
; 770  : 	return *pResult;

	mov	eax, DWORD PTR _pResult$[ebp]

; 771  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?CollisionToWorldSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z ENDP ; CBaseEntity::CollisionToWorldSpace
_TEXT	ENDS
;	COMDAT ?WorldToCollisionSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z
_TEXT	SEGMENT
$T41129 = -16
$T41130 = -28
_in$ = 8
_pResult$ = 12
_this$ = -4
?WorldToCollisionSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z PROC NEAR ; CBaseEntity::WorldToCollisionSpace, COMDAT

; 774  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 	if( UTIL_GetModelType( pev->modelindex ) != mod_brush )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	je	SHORT $L35167

; 777  : 		// boxes can't rotate
; 778  : 		*pResult = in - GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	eax, DWORD PTR $T41129[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	??GVector@@QBE?AV0@ABV0@@Z		; Vector::operator-
	mov	ecx, DWORD PTR _pResult$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 780  : 	else

	jmp	SHORT $L35169
$L35167:

; 782  : 		*pResult = EntityToWorldTransform().VectorITransform( in );

	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T41130[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EntityToWorldTransform@CBaseEntity@@QBEABVmatrix4x4@@XZ ; CBaseEntity::EntityToWorldTransform
	mov	ecx, eax
	call	?VectorITransform@matrix4x4@@QBE?AVVector@@ABV2@@Z ; matrix4x4::VectorITransform
	mov	ecx, DWORD PTR _pResult$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
$L35169:

; 784  : 	return *pResult;

	mov	eax, DWORD PTR _pResult$[ebp]

; 785  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?WorldToCollisionSpace@CBaseEntity@@QBEABVVector@@ABV2@PAV2@@Z ENDP ; CBaseEntity::WorldToCollisionSpace
_TEXT	ENDS
PUBLIC	?Intersects@CBaseEntity@@QAEHPAV1@@Z		; CBaseEntity::Intersects
;	COMDAT ?Intersects@CBaseEntity@@QAEHPAV1@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
?Intersects@CBaseEntity@@QAEHPAV1@@Z PROC NEAR		; CBaseEntity::Intersects, COMDAT

; 1553 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1555 : 	     pOther->pev->absmin.y > pev->absmax.y ||
; 1556 : 	     pOther->pev->absmin.z > pev->absmax.z ||
; 1557 : 	     pOther->pev->absmax.x < pev->absmin.x ||
; 1558 : 	     pOther->pev->absmax.y < pev->absmin.y ||
; 1559 : 	     pOther->pev->absmax.z < pev->absmin.z )

	mov	eax, DWORD PTR _pOther$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+196]
	fcomp	DWORD PTR [eax+208]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	$L39744
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+200]
	fcomp	DWORD PTR [ecx+212]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39744
	mov	edx, DWORD PTR _pOther$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+204]
	fcomp	DWORD PTR [edx+216]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39744
	mov	eax, DWORD PTR _pOther$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [ecx+208]
	fcomp	DWORD PTR [eax+196]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39744
	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [edx+212]
	fcomp	DWORD PTR [ecx+200]
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39744
	mov	edx, DWORD PTR _pOther$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [eax+216]
	fcomp	DWORD PTR [edx+204]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39743
$L39744:

; 1560 : 		 return 0;

	xor	eax, eax
	jmp	SHORT $L39742
$L39743:

; 1561 : 	return 1;

	mov	eax, 1
$L39742:

; 1562 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Intersects@CBaseEntity@@QAEHPAV1@@Z ENDP		; CBaseEntity::Intersects
_TEXT	ENDS
PUBLIC	?AreaIntersect@CBaseEntity@@QAEHVVector@@0@Z	; CBaseEntity::AreaIntersect
;	COMDAT ?AreaIntersect@CBaseEntity@@QAEHVVector@@0@Z
_TEXT	SEGMENT
_mins$ = 8
_maxs$ = 20
_this$ = -4
?AreaIntersect@CBaseEntity@@QAEHVVector@@0@Z PROC NEAR	; CBaseEntity::AreaIntersect, COMDAT

; 1565 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1567 : 	||  pev->absmin.y >= maxs.y
; 1568 : 	||  pev->absmin.z >= maxs.z
; 1569 : 	||  pev->absmax.x <= mins.x
; 1570 : 	||  pev->absmax.y <= mins.y
; 1571 : 	||  pev->absmax.z <= mins.z )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+196]
	fcomp	DWORD PTR _maxs$[ebp]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39751
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+200]
	fcomp	DWORD PTR _maxs$[ebp+4]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39751
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+204]
	fcomp	DWORD PTR _maxs$[ebp+8]
	fnstsw	ax
	test	ah, 1
	je	SHORT $L39751
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	fld	DWORD PTR [ecx+208]
	fcomp	DWORD PTR _mins$[ebp]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39751
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	fld	DWORD PTR [eax+212]
	fcomp	DWORD PTR _mins$[ebp+4]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $L39751
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	fld	DWORD PTR [edx+216]
	fcomp	DWORD PTR _mins$[ebp+8]
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39750
$L39751:

; 1572 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L39749
$L39750:

; 1573 : 	return TRUE;

	mov	eax, 1
$L39749:

; 1574 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?AreaIntersect@CBaseEntity@@QAEHVVector@@0@Z ENDP	; CBaseEntity::AreaIntersect
_TEXT	ENDS
PUBLIC	?TriggerIntersects@CBaseEntity@@QAEHPAV1@@Z	; CBaseEntity::TriggerIntersects
;	COMDAT ?TriggerIntersects@CBaseEntity@@QAEHPAV1@@Z
_TEXT	SEGMENT
_pOther$ = 8
_this$ = -4
_hullNumber$ = -8
_trace$ = -64
?TriggerIntersects@CBaseEntity@@QAEHPAV1@@Z PROC NEAR	; CBaseEntity::TriggerIntersects, COMDAT

; 1577 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1578 : 	if ( !Intersects( pOther ))

	mov	eax, DWORD PTR _pOther$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Intersects@CBaseEntity@@QAEHPAV1@@Z	; CBaseEntity::Intersects
	test	eax, eax
	jne	SHORT $L39756

; 1579 : 		 return 0;

	xor	eax, eax
	jmp	SHORT $L39755
$L39756:

; 1580 : 
; 1581 : 	int hullNumber = human_hull;

	mov	DWORD PTR _hullNumber$[ebp], 1

; 1582 : 	TraceResult trace;

	lea	ecx, DWORD PTR _trace$[ebp]
	call	??0gametrace_s@@QAE@XZ			; gametrace_s::gametrace_s

; 1583 : 
; 1584 : 	if( FBitSet( pOther->pev->flags, FL_DUCKING ))

	mov	ecx, DWORD PTR _pOther$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+420]
	and	eax, 16384				; 00004000H
	test	eax, eax
	je	SHORT $L39759

; 1585 : 		hullNumber = head_hull;

	mov	DWORD PTR _hullNumber$[ebp], 3
$L39759:

; 1586 : 
; 1587 : 	UTIL_TraceModel( pOther->GetAbsOrigin(), pOther->GetAbsOrigin(), hullNumber, edict(), &trace );

	lea	ecx, DWORD PTR _trace$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	mov	edx, DWORD PTR _hullNumber$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	mov	ecx, DWORD PTR _pOther$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	call	?UTIL_TraceModel@@YAXABVVector@@0HPAUedict_s@@PAUgametrace_s@@@Z ; UTIL_TraceModel
	add	esp, 20					; 00000014H

; 1588 : 
; 1589 : 	return trace.fStartSolid;

	mov	eax, DWORD PTR _trace$[ebp+4]
$L39755:

; 1590 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?TriggerIntersects@CBaseEntity@@QAEHPAV1@@Z ENDP	; CBaseEntity::TriggerIntersects
_TEXT	ENDS
PUBLIC	?IsWater@CBaseEntity@@QAEHXZ			; CBaseEntity::IsWater
;	COMDAT ?IsWater@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsWater@CBaseEntity@@QAEHXZ PROC NEAR			; CBaseEntity::IsWater, COMDAT

; 1593 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1594 : 	if( pev->solid == SOLID_NOT && pev->skin <= CONTENTS_WATER && pev->skin > CONTENTS_TRANSLUCENT )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+268], 0
	jne	SHORT $L39765
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+272], -3			; fffffffdH
	jg	SHORT $L39765
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+272], -15		; fffffff1H
	jle	SHORT $L39765

; 1596 : 		if( UTIL_GetModelType( pev->modelindex ) == mod_brush )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+180]
	push	edx
	call	?UTIL_GetModelType@@YA?AW4modtype_t@@H@Z ; UTIL_GetModelType
	add	esp, 4
	test	eax, eax
	jne	SHORT $L39765

; 1597 : 			return true;

	mov	eax, 1
	jmp	SHORT $L39763
$L39765:

; 1599 : 	return false;

	xor	eax, eax
$L39763:

; 1600 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsWater@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::IsWater
_TEXT	ENDS
PUBLIC	?MakeDormant@CBaseEntity@@QAEXXZ		; CBaseEntity::MakeDormant
;	COMDAT ?MakeDormant@CBaseEntity@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?MakeDormant@CBaseEntity@@QAEXXZ PROC NEAR		; CBaseEntity::MakeDormant, COMDAT

; 1603 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1604 : 	SetBits( pev->flags, FL_DORMANT );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+420]
	or	edx, -2147483648			; 80000000H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+420], edx

; 1605 : 	
; 1606 : 	// Don't touch
; 1607 : 	pev->solid = SOLID_NOT;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+268], 0

; 1608 : 	// Don't move
; 1609 : 	pev->movetype = MOVETYPE_NONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+264], 0

; 1610 : 	// Don't draw
; 1611 : 	SetBits( pev->effects, EF_NODRAW );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+280]
	or	dl, -128				; ffffff80H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+280], edx

; 1612 : 	// Don't think
; 1613 : 	DontThink();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?DontThink@CBaseEntity@@QAEXXZ		; CBaseEntity::DontThink

; 1614 : 	// Relink
; 1615 : 	RelinkEntity( FALSE );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RelinkEntity@CBaseEntity@@QAEXHPBVVector@@H@Z ; CBaseEntity::RelinkEntity

; 1616 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MakeDormant@CBaseEntity@@QAEXXZ ENDP			; CBaseEntity::MakeDormant
_TEXT	ENDS
PUBLIC	?IsDormant@CBaseEntity@@QAEHXZ			; CBaseEntity::IsDormant
;	COMDAT ?IsDormant@CBaseEntity@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4
?IsDormant@CBaseEntity@@QAEHXZ PROC NEAR		; CBaseEntity::IsDormant, COMDAT

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1620 : 	return FBitSet( pev->flags, FL_DORMANT );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+420]
	and	eax, -2147483648			; 80000000H

; 1621 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsDormant@CBaseEntity@@QAEHXZ ENDP			; CBaseEntity::IsDormant
_TEXT	ENDS
PUBLIC	__real@4@400d8000000000000000
PUBLIC	__real@4@c00d8000000000000000
PUBLIC	__real@4@4009fa00000000000000
PUBLIC	__real@4@c009fa00000000000000
PUBLIC	?IsInWorld@CBaseEntity@@UAEHH@Z			; CBaseEntity::IsInWorld
;	COMDAT __real@4@400d8000000000000000
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
__real@4@400d8000000000000000 DD 046800000r	; 16384
CONST	ENDS
;	COMDAT __real@4@c00d8000000000000000
CONST	SEGMENT
__real@4@c00d8000000000000000 DD 0c6800000r	; -16384
CONST	ENDS
;	COMDAT __real@4@4009fa00000000000000
CONST	SEGMENT
__real@4@4009fa00000000000000 DD 044fa0000r	; 2000
CONST	ENDS
;	COMDAT __real@4@c009fa00000000000000
CONST	SEGMENT
__real@4@c009fa00000000000000 DD 0c4fa0000r	; -2000
CONST	ENDS
;	COMDAT ?IsInWorld@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_checkVelocity$ = 8
_this$ = -4
_absOrigin$ = -16
_absVelocity$ = -28
?IsInWorld@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::IsInWorld, COMDAT

; 1624 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1625 : 	Vector absOrigin = GetAbsOrigin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsOrigin@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsOrigin
	push	eax
	lea	ecx, DWORD PTR _absOrigin$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1626 : 
; 1627 : 	// position 
; 1628 : 	if( absOrigin.x >= 16384 ) return FALSE;

	fld	DWORD PTR _absOrigin$[ebp]
	fcomp	DWORD PTR __real@4@400d8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39779
	xor	eax, eax
	jmp	$L39777
$L39779:

; 1629 : 	if( absOrigin.y >= 16384 ) return FALSE;

	fld	DWORD PTR _absOrigin$[ebp+4]
	fcomp	DWORD PTR __real@4@400d8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39780
	xor	eax, eax
	jmp	$L39777
$L39780:

; 1630 : 	if( absOrigin.z >= 16384 ) return FALSE;

	fld	DWORD PTR _absOrigin$[ebp+8]
	fcomp	DWORD PTR __real@4@400d8000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39781
	xor	eax, eax
	jmp	$L39777
$L39781:

; 1631 : 	if( absOrigin.x <= -16384 ) return FALSE;

	fld	DWORD PTR _absOrigin$[ebp]
	fcomp	DWORD PTR __real@4@c00d8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39782
	xor	eax, eax
	jmp	$L39777
$L39782:

; 1632 : 	if( absOrigin.y <= -16384 ) return FALSE;

	fld	DWORD PTR _absOrigin$[ebp+4]
	fcomp	DWORD PTR __real@4@c00d8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39783
	xor	eax, eax
	jmp	$L39777
$L39783:

; 1633 : 	if( absOrigin.z <= -16384 ) return FALSE;

	fld	DWORD PTR _absOrigin$[ebp+8]
	fcomp	DWORD PTR __real@4@c00d8000000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39784
	xor	eax, eax
	jmp	$L39777
$L39784:

; 1634 : 
; 1635 : 	if( !checkVelocity )

	cmp	DWORD PTR _checkVelocity$[ebp], 0
	jne	SHORT $L39785

; 1636 : 		return TRUE;

	mov	eax, 1
	jmp	$L39777
$L39785:

; 1637 : 
; 1638 : 	Vector absVelocity = GetAbsVelocity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetAbsVelocity@CBaseEntity@@QBEABVVector@@XZ ; CBaseEntity::GetAbsVelocity
	push	eax
	lea	ecx, DWORD PTR _absVelocity$[ebp]
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector

; 1639 : 
; 1640 : 	// speed
; 1641 : 	if( absVelocity.x >= 2000 ) return FALSE;

	fld	DWORD PTR _absVelocity$[ebp]
	fcomp	DWORD PTR __real@4@4009fa00000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39787
	xor	eax, eax
	jmp	SHORT $L39777
$L39787:

; 1642 : 	if( absVelocity.y >= 2000 ) return FALSE;

	fld	DWORD PTR _absVelocity$[ebp+4]
	fcomp	DWORD PTR __real@4@4009fa00000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39788
	xor	eax, eax
	jmp	SHORT $L39777
$L39788:

; 1643 : 	if( absVelocity.z >= 2000 ) return FALSE;

	fld	DWORD PTR _absVelocity$[ebp+8]
	fcomp	DWORD PTR __real@4@4009fa00000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $L39789
	xor	eax, eax
	jmp	SHORT $L39777
$L39789:

; 1644 : 	if( absVelocity.x <= -2000 ) return FALSE;

	fld	DWORD PTR _absVelocity$[ebp]
	fcomp	DWORD PTR __real@4@c009fa00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39790
	xor	eax, eax
	jmp	SHORT $L39777
$L39790:

; 1645 : 	if( absVelocity.y <= -2000 ) return FALSE;

	fld	DWORD PTR _absVelocity$[ebp+4]
	fcomp	DWORD PTR __real@4@c009fa00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39791
	xor	eax, eax
	jmp	SHORT $L39777
$L39791:

; 1646 : 	if( absVelocity.z <= -2000 ) return FALSE;

	fld	DWORD PTR _absVelocity$[ebp+8]
	fcomp	DWORD PTR __real@4@c009fa00000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $L39792
	xor	eax, eax
	jmp	SHORT $L39777
$L39792:

; 1647 : 
; 1648 : 	return TRUE;

	mov	eax, 1
$L39777:

; 1649 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsInWorld@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::IsInWorld
_TEXT	ENDS
PUBLIC	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z	; CBaseEntity::ShouldToggle
;	COMDAT ?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z
_TEXT	SEGMENT
_useType$ = 8
_currentState$ = 12
_this$ = -4
?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z PROC NEAR ; CBaseEntity::ShouldToggle, COMDAT

; 1652 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1653 : 	if ( useType != USE_TOGGLE && useType != USE_SET )

	cmp	DWORD PTR _useType$[ebp], 3
	je	SHORT $L39799
	cmp	DWORD PTR _useType$[ebp], 2
	je	SHORT $L39799

; 1655 : 		if ( (currentState && useType == USE_ON) || (!currentState && useType == USE_OFF) )

	cmp	DWORD PTR _currentState$[ebp], 0
	je	SHORT $L39801
	cmp	DWORD PTR _useType$[ebp], 1
	je	SHORT $L39800
$L39801:
	cmp	DWORD PTR _currentState$[ebp], 0
	jne	SHORT $L39799
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L39799
$L39800:

; 1656 : 			return 0;

	xor	eax, eax
	jmp	SHORT $L39797
$L39799:

; 1658 : 	return 1;

	mov	eax, 1
$L39797:

; 1659 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@H@Z ENDP	; CBaseEntity::ShouldToggle
_TEXT	ENDS
PUBLIC	?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z	; CBaseEntity::ShouldToggle
;	COMDAT ?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z
_TEXT	SEGMENT
_useType$ = 8
_this$ = -4
_curState$ = -8
?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z PROC NEAR	; CBaseEntity::ShouldToggle, COMDAT

; 1662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1663 : 	STATE curState = GetState();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+88]
	mov	DWORD PTR _curState$[ebp], eax

; 1664 : 
; 1665 : 	if( useType == USE_ON || useType == USE_OFF )

	cmp	DWORD PTR _useType$[ebp], 1
	je	SHORT $L39808
	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L39810
$L39808:

; 1668 : 		{

	mov	eax, DWORD PTR _curState$[ebp]
	mov	DWORD PTR -12+[ebp], eax
	cmp	DWORD PTR -12+[ebp], 3
	ja	SHORT $L39810
	mov	ecx, DWORD PTR -12+[ebp]
	jmp	DWORD PTR $L41157[ecx*4]
$L39813:

; 1669 : 		case STATE_ON:
; 1670 : 		case STATE_TURN_ON:
; 1671 : 			if( useType == USE_ON )

	cmp	DWORD PTR _useType$[ebp], 1
	jne	SHORT $L39814

; 1672 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $L39805
$L39814:

; 1673 : 			break;

	jmp	SHORT $L39810
$L39815:

; 1674 : 		case STATE_OFF:
; 1675 : 		case STATE_TURN_OFF:
; 1676 : 			if( useType == USE_OFF )

	cmp	DWORD PTR _useType$[ebp], 0
	jne	SHORT $L39816

; 1677 : 				return FALSE;

	xor	eax, eax
	jmp	SHORT $L39805
$L39816:
$L39810:

; 1681 : 	return TRUE;

	mov	eax, 1
$L39805:

; 1682 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L41157:
	DD	$L39815
	DD	$L39813
	DD	$L39813
	DD	$L39815
?ShouldToggle@CBaseEntity@@QAEHW4USE_TYPE@@@Z ENDP	; CBaseEntity::ShouldToggle
_TEXT	ENDS
PUBLIC	?DamageDecal@CBaseEntity@@UAEHH@Z		; CBaseEntity::DamageDecal
;	COMDAT ?DamageDecal@CBaseEntity@@UAEHH@Z
_TEXT	SEGMENT
_this$ = -4
?DamageDecal@CBaseEntity@@UAEHH@Z PROC NEAR		; CBaseEntity::DamageDecal, COMDAT

; 1685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 1686 : 	if ( pev->rendermode == kRenderTransAlpha )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+328], 4
	jne	SHORT $L39821

; 1687 : 		return -1;

	or	eax, -1
	jmp	SHORT $L39820
$L39821:

; 1688 : 
; 1689 : 	if ( pev->rendermode != kRenderNormal )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+328], 0
	je	SHORT $L39822

; 1690 : 		return DECAL_BPROOF1;

	mov	eax, 35					; 00000023H
	jmp	SHORT $L39820
$L39822:

; 1691 : 
; 1692 : 	return DECAL_GUNSHOT1 + RANDOM_LONG(0,4);

	push	4
	push	0
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+360
	add	esp, 8
$L39820:

; 1693 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?DamageDecal@CBaseEntity@@UAEHH@Z ENDP			; CBaseEntity::DamageDecal
_TEXT	ENDS
PUBLIC	??_C@_0BF@DLND@NULL?5Ent?5in?5Create?$CB?6?$AA@	; `string'
PUBLIC	?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ; CBaseEntity::Create
EXTRN	?DispatchSpawn@@YAHPAUedict_s@@@Z:NEAR		; DispatchSpawn
EXTRN	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z:NEAR ; CreateEntityByName
;	COMDAT ??_C@_0BF@DLND@NULL?5Ent?5in?5Create?$CB?6?$AA@
; File z:\xashxtsrc\server\cbase.cpp
CONST	SEGMENT
??_C@_0BF@DLND@NULL?5Ent?5in?5Create?$CB?6?$AA@ DB 'NULL Ent in Create!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z
_TEXT	SEGMENT
_szName$ = 8
_vecOrigin$ = 12
_vecAngles$ = 16
_pentOwner$ = 20
_pEntity$ = -4
?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z PROC NEAR ; CBaseEntity::Create, COMDAT

; 1698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi

; 1699 : 	CBaseEntity *pEntity = CreateEntityByName( szName );

	push	0
	mov	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	?CreateEntityByName@@YAPAVCBaseEntity@@PBDPAUentvars_s@@@Z ; CreateEntityByName
	add	esp, 8
	mov	DWORD PTR _pEntity$[ebp], eax

; 1700 : 
; 1701 : 	if( !pEntity )

	cmp	DWORD PTR _pEntity$[ebp], 0
	jne	SHORT $L39830

; 1703 : 		ALERT( at_console, "NULL Ent in Create!\n" );

	push	OFFSET FLAT:??_C@_0BF@DLND@NULL?5Ent?5in?5Create?$CB?6?$AA@ ; `string'
	push	1
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+244
	add	esp, 8

; 1704 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L39828
$L39830:

; 1706 : 
; 1707 : 	pEntity->pev->owner = pentOwner;

	mov	ecx, DWORD PTR _pEntity$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pentOwner$[ebp]
	mov	DWORD PTR [edx+408], eax

; 1708 : 	pEntity->SetAbsOrigin( vecOrigin );

	mov	ecx, DWORD PTR _vecOrigin$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsOrigin@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsOrigin

; 1709 : 	pEntity->SetAbsAngles( vecAngles );

	mov	edx, DWORD PTR _vecAngles$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?SetAbsAngles@CBaseEntity@@QAEXABVVector@@@Z ; CBaseEntity::SetAbsAngles

; 1710 : 	pEntity->m_fSetAngles = TRUE;

	mov	eax, DWORD PTR _pEntity$[ebp]
	mov	DWORD PTR [eax+72], 1

; 1711 : 
; 1712 : 	DispatchSpawn( pEntity->edict() );

	mov	ecx, DWORD PTR _pEntity$[ebp]
	call	?edict@CBaseEntity@@QAEPAUedict_s@@XZ	; CBaseEntity::edict
	push	eax
	call	?DispatchSpawn@@YAHPAUedict_s@@@Z	; DispatchSpawn
	add	esp, 4

; 1713 : 
; 1714 : 	return pEntity;

	mov	eax, DWORD PTR _pEntity$[ebp]
$L39828:

; 1715 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Create@CBaseEntity@@SAPAV1@PADABVVector@@1PAUedict_s@@@Z ENDP ; CBaseEntity::Create
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PADH@@QAE@HH@Z			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
PUBLIC	??1?$CUtlMemory@PADH@@QAE@XZ			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PADH@@QAE@HH@Z		; CUtlMemory<char *,int>::CUtlMemory<char *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@HH@Z ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PADH@@QAE@XZ		; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAE@XZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::~CUtlArray<char *,CUtlMemory<char *,int> >
PUBLIC	??A?$CUtlMemory@PADH@@QAEAAPADH@Z		; CUtlMemory<char *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
PUBLIC	??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
PUBLIC	??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT ??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlarray.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@
CONST	SEGMENT
??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ DB '('
	DB	'Base() == NULL) || (&src < Base()) || (&src >= (Base() + Coun'
	DB	't()) )', 00H				; `string'
CONST	ENDS
;	COMDAT ?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41186
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41186
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41186
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41186:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::AddToTail
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z	; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>
PUBLIC	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ	; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z ; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
	ret	0
__ehhandler$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@HH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
PUBLIC	?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
	ret	0
__ehhandler$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAE@XZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::~CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >
PUBLIC	??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]
;	COMDAT ??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::operator[]
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
PUBLIC	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
PUBLIC	?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHHABQAVCBaseEntity@@@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore
;	COMDAT ?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHABQAVCBaseEntity@@@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHABQAVCBaseEntity@@@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	test	eax, eax
	je	SHORT $L41209
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41209
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41209
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41209:

; 520  : 	return InsertBefore( m_Size, src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHHABQAVCBaseEntity@@@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHABQAVCBaseEntity@@@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::AddToTail
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEABQAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
;	COMDAT ?Find@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHABQAVCBaseEntity@@@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
_i$ = -8
?Find@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHABQAVCBaseEntity@@@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Find, COMDAT

; 659  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 660  : 	for ( int i = 0; i < Count(); ++i )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L39876
$L39877:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L39876:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
	cmp	DWORD PTR _i$[ebp], eax
	jge	SHORT $L39878

; 662  : 		if (Element(i) == src)

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEABQAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $L39879

; 663  : 			return i;

	mov	eax, DWORD PTR _i$[ebp]
	jmp	SHORT $L39874
$L39879:

; 664  : 	}

	jmp	SHORT $L39877
$L39878:

; 665  : 	return -1;

	or	eax, -1
$L39874:

; 666  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Find@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHABQAVCBaseEntity@@@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Find
_TEXT	ENDS
PUBLIC	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
PUBLIC	??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@	; `string'
PUBLIC	?Destruct@@YAXPAPAVCBaseEntity@@@Z		; Destruct
EXTRN	_memcpy:NEAR
;	COMDAT ??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ DB 'IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?FastRemove@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXH@Z
_TEXT	SEGMENT
_elem$ = 8
_this$ = -4
?FastRemove@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::FastRemove, COMDAT

; 680  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 681  : 	assert( IsValidIndex(elem) );

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41214
	push	681					; 000002a9H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0BD@FFFF@IsValidIndex?$CIelem?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41214:

; 682  : 
; 683  : 	Destruct( &Element(elem) );

	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAVCBaseEntity@@@Z	; Destruct
	add	esp, 4

; 684  : 	if (m_Size > 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jle	SHORT $L39890

; 686  : 		memcpy( &Element(elem), &Element(m_Size-1), sizeof(T) );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 687  : 		--m_Size;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$L39890:

; 689  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?FastRemove@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::FastRemove
_TEXT	ENDS
PUBLIC	??0?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@HH@Z ; CUtlMemory<TeleportListEntry_t,int>::CUtlMemory<TeleportListEntry_t,int>
PUBLIC	??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ	; CUtlMemory<TeleportListEntry_t,int>::~CUtlMemory<TeleportListEntry_t,int>
PUBLIC	?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ResetDbgInfo
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z$0
xdata$x	ENDS
;	COMDAT ??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z
_TEXT	SEGMENT
__$EHRec$ = -12
_growSize$ = 8
_initSize$ = 12
_this$ = -16
??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _initSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _growSize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@HH@Z ; CUtlMemory<TeleportListEntry_t,int>::CUtlMemory<TeleportListEntry_t,int>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 248  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ResetDbgInfo

; 249  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ ; CUtlMemory<TeleportListEntry_t,int>::~CUtlMemory<TeleportListEntry_t,int>
	ret	0
__ehhandler$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@HH@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >
PUBLIC	?Purge@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Purge
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlarray.h
xdata$x	SEGMENT
__ehfuncinfo$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT ??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::~CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >, COMDAT

; 260  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Purge

; 262  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ ; CUtlMemory<TeleportListEntry_t,int>::~CUtlMemory<TeleportListEntry_t,int>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ ; CUtlMemory<TeleportListEntry_t,int>::~CUtlMemory<TeleportListEntry_t,int>
	ret	0
__ehhandler$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ:
	mov	eax, OFFSET FLAT:__ehfuncinfo$??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAE@XZ ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::~CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >
PUBLIC	??A?$CUtlMemory@UTeleportListEntry_t@@H@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlMemory<TeleportListEntry_t,int>::operator[]
;	COMDAT ??A?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::operator[], COMDAT

; 282  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UTeleportListEntry_t@@H@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlMemory<TeleportListEntry_t,int>::operator[]

; 284  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::operator[]
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Count
_TEXT	ENDS
PUBLIC	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
PUBLIC	?InsertBefore@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHHABUTeleportListEntry_t@@@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::InsertBefore
;	COMDAT ?AddToTail@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHABUTeleportListEntry_t@@@Z
_TEXT	SEGMENT
_src$ = 8
_this$ = -4
?AddToTail@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHABUTeleportListEntry_t@@@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::AddToTail, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 518  : 	// Can't insert something that's in the list... reallocation may hose us
; 519  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
	test	eax, eax
	je	SHORT $L41239
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41239
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Count
	imul	eax, 28					; 0000001cH
	add	esi, eax
	cmp	DWORD PTR _src$[ebp], esi
	jae	SHORT $L41239
	push	519					; 00000207H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41239:

; 520  : 	return InsertBefore( m_Size, src );

	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InsertBefore@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHHABUTeleportListEntry_t@@@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::InsertBefore

; 521  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?AddToTail@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHABUTeleportListEntry_t@@@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::AddToTail
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ		; CUtlMemory<char *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PADH@@QAEPAPADXZ	; CUtlMemory<char *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ ; CUtlMemory<CBaseEntity *,int>::Base
;	COMDAT ?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ ; CUtlMemory<CBaseEntity *,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?Base@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEPAUTeleportListEntry_t@@XZ ; CUtlMemory<TeleportListEntry_t,int>::Base
;	COMDAT ?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base, COMDAT

; 60   : 	T* Base()								{ return m_Memory.Base(); }

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEPAUTeleportListEntry_t@@XZ ; CUtlMemory<TeleportListEntry_t,int>::Base
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
_TEXT	ENDS
;	COMDAT ?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ResetDbgInfo, COMDAT

; 160  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		m_pElements = Base();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 162  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ResetDbgInfo
_TEXT	ENDS
PUBLIC	?CopyConstruct@@YAXPAPADABQAD@Z			; CopyConstruct
PUBLIC	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
PUBLIC	??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
;	COMDAT ??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ DB '('
	DB	'elem == Count()) || IsValidIndex(elem)', 00H ; `string'
CONST	ENDS
;	COMDAT ?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	test	eax, eax
	je	SHORT $L41254
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41254
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEPAPADXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41254
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41254:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBEHXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L41255
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41255
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41255:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPADABQAD@Z		; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEHHABQAD@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PADH@@QAEXXZ		; CUtlMemory<char *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP	; CUtlArray<char *,CUtlMemory<char *,int> >::Purge
_TEXT	ENDS
PUBLIC	??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
PUBLIC	??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ	; CUtlMemory<char *,int>::ValidateGrowSize
EXTRN	_malloc:NEAR
;	COMDAT ??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ DB 'z:\xashxtsrc\gam'
	DB	'e_shared\utlmemory.h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ DB 'nGrowSize >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??0?$CUtlMemory@PADH@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PADH@@QAE@HH@Z PROC NEAR		; CUtlMemory<char *,int>::CUtlMemory<char *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ; CUtlMemory<char *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L41260
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41260:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L39948

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L39948:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PADH@@QAE@HH@Z ENDP			; CUtlMemory<char *,int>::CUtlMemory<char *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PADH@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PADH@@QAE@XZ PROC NEAR			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PADH@@QAEXXZ	; CUtlMemory<char *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PADH@@QAE@XZ ENDP			; CUtlMemory<char *,int>::~CUtlMemory<char *,int>
_TEXT	ENDS
PUBLIC	??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@		; `string'
PUBLIC	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z		; CUtlMemory<char *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ		; CUtlMemory<char *,int>::IsReadOnly
;	COMDAT ??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ DB '!IsReadOnly()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ DB 'IsIdxValid(i)', 00H ; `string'
CONST	ENDS
;	COMDAT ??A?$CUtlMemory@PADH@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z PROC NEAR		; CUtlMemory<char *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41265
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41265:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z	; CUtlMemory<char *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41266
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41266:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PADH@@QAEAAPADH@Z ENDP			; CUtlMemory<char *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PADH@@QAEPAPADXZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ PROC NEAR		; CUtlMemory<char *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ	; CUtlMemory<char *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41269
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41269:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PADH@@QAEPAPADXZ ENDP		; CUtlMemory<char *,int>::Base
_TEXT	ENDS
PUBLIC	??A?$CUtlMemory@PAVCBaseEntity@@H@@QBEABQAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]
;	COMDAT ?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEABQAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEABQAVCBaseEntity@@H@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element, COMDAT

; 300  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 301  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PAVCBaseEntity@@H@@QBEABQAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]

; 302  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEABQAVCBaseEntity@@H@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ; CUtlMemory<CBaseEntity *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
_TEXT	ENDS
;	COMDAT ?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count, COMDAT

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	return m_Size;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 346  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41278
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L41278
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41279
$L41278:
	mov	DWORD PTR -8+[ebp], 0
$L41279:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?CopyConstruct@@YAXPAPAVCBaseEntity@@ABQAV1@@Z	; CopyConstruct
PUBLIC	?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight
;	COMDAT ?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHHABQAVCBaseEntity@@@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHHABQAVCBaseEntity@@@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	test	eax, eax
	je	SHORT $L41282
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41282
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEPAPAVCBaseEntity@@XZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
	lea	eax, DWORD PTR [esi+eax*4]
	cmp	DWORD PTR _src$[ebp], eax
	jae	SHORT $L41282
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41282:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBEHXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L41283
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41283
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41283:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAPAVCBaseEntity@@ABQAV1@@Z ; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEHHABQAVCBaseEntity@@@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ	; CUtlMemory<CBaseEntity *,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ ; CUtlMemory<CBaseEntity *,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z PROC NEAR	; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L41288
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41288:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L40002

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L40002:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@PAVCBaseEntity@@H@@QAE@HH@Z ENDP	; CUtlMemory<CBaseEntity *,int>::CUtlMemory<CBaseEntity *,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ PROC NEAR	; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ ; CUtlMemory<CBaseEntity *,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@PAVCBaseEntity@@H@@QAE@XZ ENDP		; CUtlMemory<CBaseEntity *,int>::~CUtlMemory<CBaseEntity *,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z ; CUtlMemory<CBaseEntity *,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z PROC NEAR ; CUtlMemory<CBaseEntity *,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41293
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41293:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z ; CUtlMemory<CBaseEntity *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41294
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41294:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PAVCBaseEntity@@H@@QAEAAPAVCBaseEntity@@H@Z ENDP ; CUtlMemory<CBaseEntity *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41297
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41297:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@PAVCBaseEntity@@H@@QAEPAPAVCBaseEntity@@XZ ENDP ; CUtlMemory<CBaseEntity *,int>::Base
_TEXT	ENDS
EXTRN	_memset:NEAR
;	COMDAT ?Destruct@@YAXPAPAVCBaseEntity@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAVCBaseEntity@@@Z PROC NEAR		; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAVCBaseEntity@@@Z ENDP			; Destruct
_TEXT	ENDS
PUBLIC	?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z ; CopyConstruct
PUBLIC	?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Element
PUBLIC	?IsValidIndex@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBE_NH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::IsValidIndex
PUBLIC	?GrowVector@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::GrowVector
PUBLIC	?ShiftElementsRight@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXHH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ShiftElementsRight
;	COMDAT ?InsertBefore@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHHABUTeleportListEntry_t@@@Z
_TEXT	SEGMENT
_elem$ = 8
_src$ = 12
_this$ = -4
?InsertBefore@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHHABUTeleportListEntry_t@@@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::InsertBefore, COMDAT

; 533  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 534  : 	// Can't insert something that's in the list... reallocation may hose us
; 535  : 	assert( (Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count()) ) ); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
	test	eax, eax
	je	SHORT $L41302
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
	cmp	DWORD PTR _src$[ebp], eax
	jb	SHORT $L41302
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEPAUTeleportListEntry_t@@XZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Base
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Count
	imul	eax, 28					; 0000001cH
	add	esi, eax
	cmp	DWORD PTR _src$[ebp], esi
	jae	SHORT $L41302
	push	535					; 00000217H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0EF@KBFD@?$CIBase?$CI?$CJ?5?$DN?$DN?5NULL?$CJ?5?$HM?$HM?5?$CI?$CGsrc?5?$DM?5Base@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41302:

; 536  : 
; 537  : 	// Can insert at the end
; 538  : 	assert( (elem == Count()) || IsValidIndex(elem) );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Count@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBEHXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Count
	cmp	DWORD PTR _elem$[ebp], eax
	je	SHORT $L41303
	mov	ecx, DWORD PTR _elem$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBE_NH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41303
	push	538					; 0000021aH
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0CI@IOBG@?$CIelem?5?$DN?$DN?5Count?$CI?$CJ?$CJ?5?$HM?$HM?5IsValidInde@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41303:

; 539  : 
; 540  : 	GrowVector();

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GrowVector@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::GrowVector

; 541  : 	ShiftElementsRight(elem);

	push	1
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShiftElementsRight@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXHH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ShiftElementsRight

; 542  : 	CopyConstruct( &Element(elem), src );

	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	edx, DWORD PTR _elem$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Element
	push	eax
	call	?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z ; CopyConstruct
	add	esp, 8

; 543  : 	return elem;

	mov	eax, DWORD PTR _elem$[ebp]

; 544  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?InsertBefore@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEHHABUTeleportListEntry_t@@@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::InsertBefore
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::RemoveAll
PUBLIC	?Purge@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXXZ ; CUtlMemory<TeleportListEntry_t,int>::Purge
;	COMDAT ?Purge@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Purge, COMDAT

; 742  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 743  : 	RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::RemoveAll

; 744  : 	m_Memory.Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXXZ ; CUtlMemory<TeleportListEntry_t,int>::Purge

; 745  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ResetDbgInfo

; 746  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Purge
_TEXT	ENDS
PUBLIC	?ValidateGrowSize@?$CUtlMemory@UTeleportListEntry_t@@H@@IAEXXZ ; CUtlMemory<TeleportListEntry_t,int>::ValidateGrowSize
;	COMDAT ??0?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@HH@Z
_TEXT	SEGMENT
_nGrowSize$ = 8
_nInitAllocationCount$ = 12
_this$ = -4
??0?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@HH@Z PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::CUtlMemory<TeleportListEntry_t,int>, COMDAT

; 295  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitAllocationCount$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 296  : 	ValidateGrowSize();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ValidateGrowSize@?$CUtlMemory@UTeleportListEntry_t@@H@@IAEXXZ ; CUtlMemory<TeleportListEntry_t,int>::ValidateGrowSize

; 297  : 	assert( nGrowSize >= 0 );

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	jge	SHORT $L41308
	push	297					; 00000129H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0P@MOH@nGrowSize?5?$DO?$DN?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41308:

; 298  : 	if (m_nAllocationCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L40041

; 300  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 28					; 0000001cH
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L40041:

; 302  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@HH@Z ENDP	; CUtlMemory<TeleportListEntry_t,int>::CUtlMemory<TeleportListEntry_t,int>
_TEXT	ENDS
;	COMDAT ??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4
??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::~CUtlMemory<TeleportListEntry_t,int>, COMDAT

; 322  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 	Purge();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Purge@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXXZ ; CUtlMemory<TeleportListEntry_t,int>::Purge

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CUtlMemory@UTeleportListEntry_t@@H@@QAE@XZ ENDP	; CUtlMemory<TeleportListEntry_t,int>::~CUtlMemory<TeleportListEntry_t,int>
_TEXT	ENDS
PUBLIC	?IsIdxValid@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NH@Z ; CUtlMemory<TeleportListEntry_t,int>::IsIdxValid
PUBLIC	?IsReadOnly@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ; CUtlMemory<TeleportListEntry_t,int>::IsReadOnly
;	COMDAT ??A?$CUtlMemory@UTeleportListEntry_t@@H@@QAEAAUTeleportListEntry_t@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@UTeleportListEntry_t@@H@@QAEAAUTeleportListEntry_t@@H@Z PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::operator[], COMDAT

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 424  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ; CUtlMemory<TeleportListEntry_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41313
	push	424					; 000001a8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41313:

; 425  : 	assert( IsIdxValid(i) );

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NH@Z ; CUtlMemory<TeleportListEntry_t,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41314
	push	425					; 000001a9H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41314:

; 426  : 	return m_pMemory[i];

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	eax, edx

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@UTeleportListEntry_t@@H@@QAEAAUTeleportListEntry_t@@H@Z ENDP ; CUtlMemory<TeleportListEntry_t,int>::operator[]
_TEXT	ENDS
;	COMDAT ?Base@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEPAUTeleportListEntry_t@@XZ
_TEXT	SEGMENT
_this$ = -4
?Base@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEPAUTeleportListEntry_t@@XZ PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::Base, COMDAT

; 487  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 	assert( !IsReadOnly() );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsReadOnly@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ; CUtlMemory<TeleportListEntry_t,int>::IsReadOnly
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L41317
	push	488					; 000001e8H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@KBCN@?$CBIsReadOnly?$CI?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41317:

; 489  : 	return m_pMemory;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]

; 490  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Base@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEPAUTeleportListEntry_t@@XZ ENDP ; CUtlMemory<TeleportListEntry_t,int>::Base
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ PROC NEAR	; CUtlMemory<char *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PADH@@IAEXXZ ENDP	; CUtlMemory<char *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@PAVCBaseEntity@@H@@IAEXXZ ENDP ; CUtlMemory<CBaseEntity *,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?ValidateGrowSize@?$CUtlMemory@UTeleportListEntry_t@@H@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4
?ValidateGrowSize@?$CUtlMemory@UTeleportListEntry_t@@H@@IAEXXZ PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::ValidateGrowSize, COMDAT

; 148  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 149  : #ifdef _X360
; 150  : 		if ( m_nGrowSize && m_nGrowSize != EXTERNAL_BUFFER_MARKER )
; 151  : 		{
; 152  : 			// Max grow size at 128 bytes on XBOX
; 153  : 			const int MAX_GROW = 128;
; 154  : 			if ( m_nGrowSize * sizeof(T) > MAX_GROW )
; 155  : 			{
; 156  : 				m_nGrowSize = max( 1, MAX_GROW / sizeof(T) );
; 157  : 			}
; 158  : 		}
; 159  : #endif
; 160  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ValidateGrowSize@?$CUtlMemory@UTeleportListEntry_t@@H@@IAEXXZ ENDP ; CUtlMemory<TeleportListEntry_t,int>::ValidateGrowSize
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@PADH@@QAEAAPADH@Z	; CUtlMemory<char *,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41328
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L41328
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41329
$L41328:
	mov	DWORD PTR -8+[ebp], 0
$L41329:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAPAD@Z				; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40076:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40077

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAD@Z			; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40076
$L40077:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEXXZ ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ		; CUtlMemory<char *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PADH@@QAEXH@Z		; CUtlMemory<char *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40086

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ	; CUtlMemory<char *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PADH@@QAEXH@Z	; CUtlMemory<char *,int>::Grow
$L40086:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXXZ ; CUtlArray<char *,CUtlMemory<char *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::GrowVector
_TEXT	ENDS
PUBLIC	??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
EXTRN	_memmove:NEAR
;	COMDAT ??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@
; File z:\xashxtsrc\game_shared\utlarray.h
CONST	SEGMENT
??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ DB 'I'
	DB	'sValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 )', 00H ; `string'
CONST	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z PROC NEAR ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QBE_NH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41336
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L41336
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L41336
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41336:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40095
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40095

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@QAEAAPADH@Z ; CUtlArray<char *,CUtlMemory<char *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40095:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PADV?$CUtlMemory@PADH@@@@IAEXHH@Z ENDP ; CUtlArray<char *,CUtlMemory<char *,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT ?CopyConstruct@@YAXPAPADABQAD@Z
_TEXT	SEGMENT
$T41339 = -4
_pMemory$ = 8
_src$ = 12
?CopyConstruct@@YAXPAPADABQAD@Z PROC NEAR		; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T41339[ebp], eax
	cmp	DWORD PTR $T41339[ebp], 0
	je	SHORT $L41340
	mov	ecx, DWORD PTR $T41339[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T41339[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L41341
$L41340:
	mov	DWORD PTR -8+[ebp], 0
$L41341:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPADABQAD@Z ENDP			; CopyConstruct
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__P$ = 12
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 76   :         {return (_P); }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR __P$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z PROC NEAR	; CUtlMemory<char *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41346
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L41346
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41347
$L41346:
	mov	DWORD PTR -8+[ebp], 0
$L41347:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PADH@@QBE_NH@Z ENDP		; CUtlMemory<char *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
EXTRN	_free:NEAR
;	COMDAT ?Purge@?$CUtlMemory@PADH@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PADH@@QAEXXZ PROC NEAR		; CUtlMemory<char *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40109

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40110

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40110:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40109:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PADH@@QAEXXZ ENDP			; CUtlMemory<char *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR	; CUtlMemory<char *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PADH@@QBE_NXZ ENDP		; CUtlMemory<char *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40120:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40121

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	?Destruct@@YAXPAPAVCBaseEntity@@@Z	; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40120
$L40121:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEXXZ ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ; CUtlMemory<CBaseEntity *,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z	; CUtlMemory<CBaseEntity *,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ; CUtlMemory<CBaseEntity *,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40129

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ; CUtlMemory<CBaseEntity *,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z ; CUtlMemory<CBaseEntity *,int>::Grow
$L40129:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXXZ ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::GrowVector
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z PROC NEAR ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QBE_NH@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41358
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L41358
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L41358
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41358:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40137
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40137

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@QAEAAPAVCBaseEntity@@H@Z ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40137:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@PAVCBaseEntity@@V?$CUtlMemory@PAVCBaseEntity@@H@@@@IAEXHH@Z ENDP ; CUtlArray<CBaseEntity *,CUtlMemory<CBaseEntity *,int> >::ShiftElementsRight
_TEXT	ENDS
;	COMDAT ??A?$CUtlMemory@PAVCBaseEntity@@H@@QBEABQAVCBaseEntity@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
??A?$CUtlMemory@PAVCBaseEntity@@H@@QBEABQAVCBaseEntity@@H@Z PROC NEAR ; CUtlMemory<CBaseEntity *,int>::operator[], COMDAT

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 432  : 	assert( IsIdxValid(i) );

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z ; CUtlMemory<CBaseEntity *,int>::IsIdxValid
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41361
	push	432					; 000001b0H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_0O@MLLF@IsIdxValid?$CIi?$CJ?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41361:

; 433  : 	return m_pMemory[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 434  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CUtlMemory@PAVCBaseEntity@@H@@QBEABQAVCBaseEntity@@H@Z ENDP ; CUtlMemory<CBaseEntity *,int>::operator[]
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<CBaseEntity *,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41364
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L41364
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41365
$L41364:
	mov	DWORD PTR -8+[ebp], 0
$L41365:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NH@Z ENDP ; CUtlMemory<CBaseEntity *,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ PROC NEAR	; CUtlMemory<CBaseEntity *,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40153

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40154

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40154:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40153:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXXZ ENDP	; CUtlMemory<CBaseEntity *,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ENDP ; CUtlMemory<CBaseEntity *,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ?CopyConstruct@@YAXPAPAVCBaseEntity@@ABQAV1@@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T41372 = -4
?CopyConstruct@@YAXPAPAVCBaseEntity@@ABQAV1@@Z PROC NEAR ; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T41372[ebp], eax
	cmp	DWORD PTR $T41372[ebp], 0
	je	SHORT $L41373
	mov	ecx, DWORD PTR $T41372[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T41372[ebp]
	mov	DWORD PTR -8+[ebp], ecx
	jmp	SHORT $L41374
$L41373:
	mov	DWORD PTR -8+[ebp], 0
$L41374:

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?CopyConstruct@@YAXPAPAVCBaseEntity@@ABQAV1@@Z ENDP	; CopyConstruct
_TEXT	ENDS
;	COMDAT ?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Element, COMDAT

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 	return m_Memory[ i ];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$CUtlMemory@UTeleportListEntry_t@@H@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlMemory<TeleportListEntry_t,int>::operator[]

; 296  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Element
_TEXT	ENDS
;	COMDAT ?IsValidIndex@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsValidIndex@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBE_NH@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::IsValidIndex, COMDAT

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 	return (i >= 0) && (i < m_Size);

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41379
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $L41379
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41380
$L41379:
	mov	DWORD PTR -8+[ebp], 0
$L41380:
	mov	al, BYTE PTR -8+[ebp]

; 356  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsValidIndex@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBE_NH@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::IsValidIndex
_TEXT	ENDS
PUBLIC	?Destruct@@YAXPAUTeleportListEntry_t@@@Z	; Destruct
;	COMDAT ?RemoveAll@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
_i$ = -8
?RemoveAll@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::RemoveAll, COMDAT

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 727  : 	for (int i = m_Size; --i >= 0; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _i$[ebp], ecx
$L40175:
	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L40176

; 729  : 		Destruct(&Element(i));

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Element
	push	eax
	call	?Destruct@@YAXPAUTeleportListEntry_t@@@Z ; Destruct
	add	esp, 4

; 730  : 	}

	jmp	SHORT $L40175
$L40176:

; 731  : 
; 732  : 	m_Size = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 733  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEXXZ ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::RemoveAll
_TEXT	ENDS
PUBLIC	?NumAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBEHXZ ; CUtlMemory<TeleportListEntry_t,int>::NumAllocated
PUBLIC	?Grow@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXH@Z ; CUtlMemory<TeleportListEntry_t,int>::Grow
;	COMDAT ?GrowVector@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
?GrowVector@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXH@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::GrowVector, COMDAT

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 	if (m_Size + num > m_Memory.NumAllocated())

	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBEHXZ ; CUtlMemory<TeleportListEntry_t,int>::NumAllocated
	cmp	esi, eax
	jle	SHORT $L40185

; 377  : 		m_Memory.Grow( m_Size + num - m_Memory.NumAllocated() );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [ecx+12]
	add	esi, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NumAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBEHXZ ; CUtlMemory<TeleportListEntry_t,int>::NumAllocated
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Grow@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXH@Z ; CUtlMemory<TeleportListEntry_t,int>::Grow
$L40185:

; 379  : 
; 380  : 	m_Size += num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR _num$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 381  : 	ResetDbgInfo();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ResetDbgInfo@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXXZ ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ResetDbgInfo

; 382  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?GrowVector@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXH@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::GrowVector
_TEXT	ENDS
;	COMDAT ?ShiftElementsRight@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXHH@Z
_TEXT	SEGMENT
_elem$ = 8
_num$ = 12
_this$ = -4
_numToMove$ = -8
?ShiftElementsRight@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXHH@Z PROC NEAR ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ShiftElementsRight, COMDAT

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 448  : 	assert( IsValidIndex(elem) || ( m_Size == 0 ) || ( num == 0 ));

	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsValidIndex@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QBE_NH@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::IsValidIndex
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L41387
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L41387
	cmp	DWORD PTR _num$[ebp], 0
	je	SHORT $L41387
	push	448					; 000001c0H
	push	OFFSET FLAT:??_C@_0CE@EGBJ@z?3?2xashxtsrc?2game_shared?2utlarra@ ; `string'
	push	OFFSET FLAT:??_C@_0DG@DBGD@IsValidIndex?$CIelem?$CJ?5?$HM?$HM?5?$CI?5m_Size?5?$DN@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41387:

; 449  : 	int numToMove = m_Size - elem - num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, DWORD PTR _elem$[ebp]
	sub	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _numToMove$[ebp], ecx

; 450  : 	if ((numToMove > 0) && (num > 0))

	cmp	DWORD PTR _numToMove$[ebp], 0
	jle	SHORT $L40193
	cmp	DWORD PTR _num$[ebp], 0
	jle	SHORT $L40193

; 451  : 		memmove( &Element(elem+num), &Element(elem), numToMove * sizeof(T) );

	mov	edx, DWORD PTR _numToMove$[ebp]
	imul	edx, 28					; 0000001cH
	push	edx
	mov	eax, DWORD PTR _elem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Element
	push	eax
	mov	ecx, DWORD PTR _elem$[ebp]
	add	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Element@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@QAEAAUTeleportListEntry_t@@H@Z ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::Element
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$L40193:

; 452  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?ShiftElementsRight@?$CUtlArray@UTeleportListEntry_t@@V?$CUtlMemory@UTeleportListEntry_t@@H@@@@IAEXHH@Z ENDP ; CUtlArray<TeleportListEntry_t,CUtlMemory<TeleportListEntry_t,int> >::ShiftElementsRight
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0TeleportListEntry_t@@QAE@ABU0@@Z		; TeleportListEntry_t::TeleportListEntry_t
;	COMDAT xdata$x
; File z:\xashxtsrc\game_shared\utlmemory.h
xdata$x	SEGMENT
__ehfuncinfo$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z DD 019930520H
	DD	01H
	DD	FLAT:__unwindtable$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
__unwindtable$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z$0
xdata$x	ENDS
;	COMDAT ?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z
_TEXT	SEGMENT
_pMemory$ = 8
_src$ = 12
$T41390 = -16
$T41391 = -20
__$EHRec$ = -12
?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z PROC NEAR ; CopyConstruct, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 44   : 	new( pMemory ) T(src);

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	push	28					; 0000001cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T41391[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T41391[ebp], 0
	je	SHORT $L41392
	mov	ecx, DWORD PTR _src$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T41391[ebp]
	call	??0TeleportListEntry_t@@QAE@ABU0@@Z	; TeleportListEntry_t::TeleportListEntry_t
	mov	DWORD PTR -24+[ebp], eax
	jmp	SHORT $L41393
$L41392:
	mov	DWORD PTR -24+[ebp], 0
$L41393:
	mov	edx, DWORD PTR -24+[ebp]
	mov	DWORD PTR $T41390[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 45   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z$0:
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T41391[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z:
	mov	eax, OFFSET FLAT:__ehfuncinfo$?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z
	jmp	___CxxFrameHandler
text$x	ENDS
?CopyConstruct@@YAXPAUTeleportListEntry_t@@ABU1@@Z ENDP	; CopyConstruct
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 79   : 	{return; }

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
;	COMDAT ?IsIdxValid@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NH@Z
_TEXT	SEGMENT
_i$ = 8
_this$ = -4
?IsIdxValid@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NH@Z PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::IsIdxValid, COMDAT

; 520  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 	return ( ((int) i) >= 0 ) && ( ((int) i) < m_nAllocationCount );

	cmp	DWORD PTR _i$[ebp], 0
	jl	SHORT $L41405
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jge	SHORT $L41405
	mov	DWORD PTR -8+[ebp], 1
	jmp	SHORT $L41406
$L41405:
	mov	DWORD PTR -8+[ebp], 0
$L41406:
	mov	al, BYTE PTR -8+[ebp]

; 522  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?IsIdxValid@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NH@Z ENDP ; CUtlMemory<TeleportListEntry_t,int>::IsIdxValid
_TEXT	ENDS
PUBLIC	?IsExternallyAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ; CUtlMemory<TeleportListEntry_t,int>::IsExternallyAllocated
;	COMDAT ?Purge@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4
?Purge@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXXZ PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::Purge, COMDAT

; 645  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 	if ( !IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ; CUtlMemory<TeleportListEntry_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	jne	SHORT $L40210

; 648  : 		if (m_pMemory)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L40211

; 650  : 			free( (void*)m_pMemory );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 651  : 			m_pMemory = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L40211:

; 653  : 		m_nAllocationCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L40210:

; 655  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Purge@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXXZ ENDP ; CUtlMemory<TeleportListEntry_t,int>::Purge
_TEXT	ENDS
;	COMDAT ?IsReadOnly@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsReadOnly@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::IsReadOnly, COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], -2			; fffffffeH
	sete	cl
	mov	al, cl

; 469  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsReadOnly@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ENDP ; CUtlMemory<TeleportListEntry_t,int>::IsReadOnly
_TEXT	ENDS
;	COMDAT ??0TeleportListEntry_t@@QAE@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8
_this$ = -4
??0TeleportListEntry_t@@QAE@ABU0@@Z PROC NEAR		; TeleportListEntry_t::TeleportListEntry_t, COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0Vector@@QAE@ABV0@@Z			; Vector::Vector
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0TeleportListEntry_t@@QAE@ABU0@@Z ENDP		; TeleportListEntry_t::TeleportListEntry_t
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ PROC NEAR	; CUtlMemory<char *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PADH@@QBEHXZ ENDP		; CUtlMemory<char *,int>::NumAllocated
_TEXT	ENDS
PUBLIC	??_C@_07BGLK@num?5?$DO?50?$AA@			; `string'
PUBLIC	??_C@_01PLJA@0?$AA@				; `string'
PUBLIC	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z	; UtlMemory_CalcNewAllocationCount
PUBLIC	??_C@_09JCKE@m_pMemory?$AA@			; `string'
EXTRN	_realloc:NEAR
;	COMDAT ??_C@_07BGLK@num?5?$DO?50?$AA@
; File z:\xashxtsrc\game_shared\utlmemory.h
CONST	SEGMENT
??_C@_07BGLK@num?5?$DO?50?$AA@ DB 'num > 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01PLJA@0?$AA@
CONST	SEGMENT
??_C@_01PLJA@0?$AA@ DB '0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09JCKE@m_pMemory?$AA@
CONST	SEGMENT
??_C@_09JCKE@m_pMemory?$AA@ DB 'm_pMemory', 00H		; `string'
CONST	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PADH@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PADH@@QAEXH@Z PROC NEAR		; CUtlMemory<char *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L41417
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41417:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ; CUtlMemory<char *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40228

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L41418
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41418:

; 567  : 		return;

	jmp	$L40225
$L40228:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40248

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L40240
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L40240

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L40248
$L40240:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L40244

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L41419
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41419:

; 589  : 				return;

	jmp	$L40225
$L40244:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40248

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L40244
$L40248:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L40251

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41420
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41420:

; 603  : 	else

	jmp	SHORT $L41421
$L40251:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41421
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41421:
$L40225:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PADH@@QAEXH@Z ENDP			; CUtlMemory<char *,int>::Grow
_TEXT	ENDS
;	COMDAT ?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z
_TEXT	SEGMENT
_nAllocationCount$ = 8
_nGrowSize$ = 12
_nNewSize$ = 16
_nBytesItem$ = 20
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z PROC NEAR	; UtlMemory_CalcNewAllocationCount, COMDAT

; 528  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 529  : 	if ( nGrowSize )

	cmp	DWORD PTR _nGrowSize$[ebp], 0
	je	SHORT $L28985

; 531  : 		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);

	mov	eax, DWORD PTR _nNewSize$[ebp]
	sub	eax, 1
	cdq
	idiv	DWORD PTR _nGrowSize$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nGrowSize$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax

; 533  : 	else 

	jmp	SHORT $L28990
$L28985:

; 535  : 		if ( !nAllocationCount )

	cmp	DWORD PTR _nAllocationCount$[ebp], 0
	jne	SHORT $L28987

; 537  : 			// Compute an allocation which is at least as big as a cache line...
; 538  : 			nAllocationCount = (31 + nBytesItem) / nBytesItem;

	mov	eax, DWORD PTR _nBytesItem$[ebp]
	add	eax, 31					; 0000001fH
	cdq
	idiv	DWORD PTR _nBytesItem$[ebp]
	mov	DWORD PTR _nAllocationCount$[ebp], eax
$L28987:

; 540  : 
; 541  : 		while (nAllocationCount < nNewSize)

	mov	eax, DWORD PTR _nAllocationCount$[ebp]
	cmp	eax, DWORD PTR _nNewSize$[ebp]
	jge	SHORT $L28990

; 543  : #ifndef _X360
; 544  : 			nAllocationCount *= 2;

	mov	ecx, DWORD PTR _nAllocationCount$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _nAllocationCount$[ebp], ecx

; 545  : #else
; 546  : 			int nNewAllocationCount = ( nAllocationCount * 9) / 8; // 12.5 %
; 547  : 			if ( nNewAllocationCount > nAllocationCount )
; 548  : 				nAllocationCount = nNewAllocationCount;
; 549  : 			else
; 550  : 				nAllocationCount *= 2;
; 551  : #endif
; 552  : 		}

	jmp	SHORT $L28987
$L28990:

; 554  : 
; 555  : 	return nAllocationCount;

	mov	eax, DWORD PTR _nAllocationCount$[ebp]

; 556  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ENDP	; UtlMemory_CalcNewAllocationCount
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ PROC NEAR ; CUtlMemory<char *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PADH@@QBE_NXZ ENDP	; CUtlMemory<char *,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAPAD@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAPAD@Z PROC NEAR				; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	4
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAPAD@Z ENDP				; Destruct
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBEHXZ ENDP ; CUtlMemory<CBaseEntity *,int>::NumAllocated
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z PROC NEAR	; CUtlMemory<CBaseEntity *,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L41432
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41432:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40273

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L41433
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41433:

; 567  : 		return;

	jmp	$L40271
$L40273:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	4
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40292

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L40284
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L40284

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L40292
$L40284:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L40288

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L41434
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41434:

; 589  : 				return;

	jmp	$L40271
$L40288:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40292

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L40288
$L40292:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L40295

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41435
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41435:

; 603  : 	else

	jmp	SHORT $L41436
$L40295:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41436
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41436:
$L40271:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@PAVCBaseEntity@@H@@QAEXH@Z ENDP	; CUtlMemory<CBaseEntity *,int>::Grow
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@PAVCBaseEntity@@H@@QBE_NXZ ENDP ; CUtlMemory<CBaseEntity *,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?NumAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4
?NumAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBEHXZ PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::NumAllocated, COMDAT

; 504  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 505  : 	return m_nAllocationCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 506  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?NumAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBEHXZ ENDP ; CUtlMemory<TeleportListEntry_t,int>::NumAllocated
_TEXT	ENDS
;	COMDAT ?Grow@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXH@Z
_TEXT	SEGMENT
_num$ = 8
_this$ = -4
_nAllocationRequested$ = -8
?Grow@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXH@Z PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::Grow, COMDAT

; 560  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 561  : 	assert( num > 0 );

	cmp	DWORD PTR _num$[ebp], 0
	jg	SHORT $L41443
	push	561					; 00000231H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_07BGLK@num?5?$DO?50?$AA@ ; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41443:

; 562  : 
; 563  : 	if ( IsExternallyAllocated() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsExternallyAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ; CUtlMemory<TeleportListEntry_t,int>::IsExternallyAllocated
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L40314

; 565  : 		// Can't grow a buffer whose memory was externally allocated 
; 566  : 		assert(0);

	xor	ecx, ecx
	test	ecx, ecx
	jne	SHORT $L41444
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41444:

; 567  : 		return;

	jmp	$L40312
$L40314:

; 569  : 
; 570  : 	// Make sure we have at least numallocated + num allocations.
; 571  : 	// Use the grow rules specified for this memory (in m_nGrowSize)
; 572  : 	int nAllocationRequested = m_nAllocationCount + num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _num$[ebp]
	mov	DWORD PTR _nAllocationRequested$[ebp], ecx

; 573  : 
; 574  : 	m_nAllocationCount = UtlMemory_CalcNewAllocationCount( m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T) );

	push	28					; 0000001cH
	mov	edx, DWORD PTR _nAllocationRequested$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?UtlMemory_CalcNewAllocationCount@@YAHHHHH@Z ; UtlMemory_CalcNewAllocationCount
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 575  : 
; 576  : 	// if m_nAllocationRequested wraps index type I, recalculate
; 577  : 	if ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40333

; 579  : 		if ( ( int )( I )m_nAllocationCount == 0 && ( int )( I )( m_nAllocationCount - 1 ) >= nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L40325
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	eax, DWORD PTR _nAllocationRequested$[ebp]
	jl	SHORT $L40325

; 581  : 			--m_nAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx

; 583  : 		else

	jmp	SHORT $L40333
$L40325:

; 585  : 			if ( ( int )( I )nAllocationRequested != nAllocationRequested )

	mov	ecx, DWORD PTR _nAllocationRequested$[ebp]
	cmp	ecx, DWORD PTR _nAllocationRequested$[ebp]
	je	SHORT $L40329

; 587  : 				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
; 588  : 				assert( 0 );

	xor	edx, edx
	test	edx, edx
	jne	SHORT $L41445
	push	588					; 0000024cH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_01PLJA@0?$AA@		; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41445:

; 589  : 				return;

	jmp	$L40312
$L40329:

; 591  : 			while ( ( int )( I )m_nAllocationCount < nAllocationRequested )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _nAllocationRequested$[ebp]
	jge	SHORT $L40333

; 593  : 				m_nAllocationCount = ( m_nAllocationCount + nAllocationRequested ) / 2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]
	add	eax, DWORD PTR _nAllocationRequested$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 594  : 			}

	jmp	SHORT $L40329
$L40333:

; 597  : 
; 598  : 	if (m_pMemory)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L40336

; 600  : 		m_pMemory = (T*)realloc( m_pMemory, m_nAllocationCount * sizeof(T) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_realloc
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 601  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41446
	push	601					; 00000259H
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41446:

; 603  : 	else

	jmp	SHORT $L41447
$L40336:

; 605  : 		m_pMemory = (T*)malloc( m_nAllocationCount * sizeof(T) );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, 28					; 0000001cH
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 		assert( m_pMemory );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L41447
	push	606					; 0000025eH
	push	OFFSET FLAT:??_C@_0CF@KIKJ@z?3?2xashxtsrc?2game_shared?2utlmemo@ ; `string'
	push	OFFSET FLAT:??_C@_09JCKE@m_pMemory?$AA@	; `string'
	call	__assert
	add	esp, 12					; 0000000cH
$L41447:
$L40312:

; 608  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Grow@?$CUtlMemory@UTeleportListEntry_t@@H@@QAEXH@Z ENDP ; CUtlMemory<TeleportListEntry_t,int>::Grow
_TEXT	ENDS
;	COMDAT ?IsExternallyAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4
?IsExternallyAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ PROC NEAR ; CUtlMemory<TeleportListEntry_t,int>::IsExternallyAllocated, COMDAT

; 457  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 	return (m_nGrowSize < 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 0
	setl	cl
	mov	al, cl

; 459  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?IsExternallyAllocated@?$CUtlMemory@UTeleportListEntry_t@@H@@QBE_NXZ ENDP ; CUtlMemory<TeleportListEntry_t,int>::IsExternallyAllocated
_TEXT	ENDS
;	COMDAT ?Destruct@@YAXPAUTeleportListEntry_t@@@Z
_TEXT	SEGMENT
_pMemory$ = 8
?Destruct@@YAXPAUTeleportListEntry_t@@@Z PROC NEAR	; Destruct, COMDAT

; 49   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 50   : 	pMemory->~T();
; 51   : 
; 52   : #ifdef _DEBUG
; 53   : 	memset( pMemory, 0xDD, sizeof(T) );

	push	28					; 0000001cH
	push	221					; 000000ddH
	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 54   : #endif
; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?Destruct@@YAXPAUTeleportListEntry_t@@@Z ENDP		; Destruct
_TEXT	ENDS
END
